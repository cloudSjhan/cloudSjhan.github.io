<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="GO QCon 技术分享," />





  <link rel="alternate" href="/atom.xml" title="cloud world" type="application/atom+xml" />






<meta name="description" content="博客内容为GO专家David关于Go最佳实践的一些建议">
<meta name="keywords" content="GO QCon 技术分享">
<meta property="og:type" content="article">
<meta property="og:title" content="上海QCon之Go专家David Cheney关于GO最佳实践的演讲">
<meta property="og:url" content="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/index.html">
<meta property="og:site_name" content="cloud world">
<meta property="og:description" content="博客内容为GO专家David关于Go最佳实践的一些建议">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/index.html">
<meta property="og:updated_time" content="2018-10-21T14:17:36.133Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="上海QCon之Go专家David Cheney关于GO最佳实践的演讲">
<meta name="twitter:description" content="博客内容为GO专家David关于Go最佳实践的一些建议">
<meta name="twitter:image" content="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/index.html">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/"/>





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bf5b9806"
    });
  daovoice('update');
  </script>


  <title>上海QCon之Go专家David Cheney关于GO最佳实践的演讲 | cloud world</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/hantmac" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cloud world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To be A geek</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-top">
          <a href="/top" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br />
            
            阅读排行
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cloud sjhan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cloud world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">上海QCon之Go专家David Cheney关于GO最佳实践的演讲</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-21T22:07:15+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/" class="leancloud_visitors" data-flag-title="上海QCon之Go专家David Cheney关于GO最佳实践的演讲">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17,353
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  108
                </span>
              
            </div>
          

          
              <div class="post-description">
                  博客内容为GO专家David关于Go最佳实践的一些建议
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description"></p>

<p><img src="https://" alt="" style="width:100%"></p>
<a id="more"></a>
<p>本周六有幸参加了2018QCon上海的会议，听了David关于GO最佳实践的一些建议，下面贴出的就是David的演讲稿，内容相对来说比较基础，但是又是编程中不可避免的一些问题，希望可以给大家带来一些启发。</p>
<p>Table of Contents </p>
<p>Introduction<br> \1. Guiding principles </p>
<p>1.1. Simplicity 1.2. Readability 1.3. Productivity </p>
<p>\2. Identiers<br> 2.1. Choose identiers for clarity, not brevity 2.2. Identier length<br> 2.3. Don’t name your variables for their types 2.4. Use a consistent naming style<br> 2.5. Use a consistent declaration style<br> 2.6. Be a team player </p>
<p>\3. Comments<br> 3.1. Comments on variables and constants should describe their contents not their purpose 3.2. Always document public symbols </p>
<p>\4. Package Design<br> 4.1. A good package starts with its name<br> 4.2. Avoid package names like base , common , or util 4.3. Return early rather than nesting deeply<br> 4.4. Make the zero value useful<br> 4.5. Avoid package level state </p>
<p>\5. Project Structure<br> 5.1. Consider fewer, larger packages<br> 5.2. Keep package main small as small as possible </p>
<p>\6. API Design<br> 6.1. Design APIs that are hard to misuse.<br> 6.2. Design APIs for their default use case<br> 6.3. Let functions dene the behaviour they requires </p>
<p>\7. Error handling<br> 7.1. Eliminate error handling by eliminating errors 7.2. Only handle an error once </p>
<p>\8. Concurrency<br> 8.1. Keep yourself busy or do the work yourself<br> 8.2. Leave concurrency to the caller<br> 8.3. Never start a goroutine without when it will stop. </p>
<p>Introduction </p>
<p>Hello,<br> My goal over the next two sessions is to give you my advice for best practices writing Go code. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 1/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>This is a workshop style presentation, I’m going to dispense with the usual slide deck and we’ll work directly from the document which you can take away with you today. </p>
<p>TIP </p>
<p>You can find the latest version of this presentation at <a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>\1. Guiding principles </p>
<p>If I’m going to talk about best practices in any programming language I need some way to define what I mean by best. If you came to my keynote yesterday you would have seen this quote from the Go team lead, Russ Cox: </p>
<p>“Software engineering is what happens to programming when you add time and other programmers. </p>
<p>— Russ Cox </p>
<p>Russ is making the distinction between software programming and software engineering. The former is a program you write for yourself. The latter is a product that many people will work on over time. Engineers will come and go, teams will grow and shrink over time, requirements will change, features will be added and bugs fixed. This is the nature of software engineering. </p>
<p>I’m possibly one of the earliest users of Go in this room, but to argue that my seniority gives my views more weight is false. Instead, the advice I’m going to present today is informed by what I believe to be the guiding principles underlying Go itself. They are: </p>
<p>\1. Simplicity<br> \2. Readability 3. Productivity </p>
<p>NOTE </p>
<p>You’ll note that I didn’t say performance, or concurrency. There are languages which are a bit faster than Go, but they’re certainly not as simple as Go. There are languages which make concurrency their highest goal, but they are not as readable, nor as productive. </p>
<p>Performance and concurrency are important attributes, but not as important as simplicity, readability, and productivity. </p>
<p>1.1. Simplicity </p>
<p>Why should we strive for simplicity? Why is important that Go programs be simple? </p>
<p>We’ve all been in a situation where you say “I can’t understand this code”, yes? We’ve all worked on programs where you’re scared to make a change because you’re worried it’ll break another part of the program; a part you don’t understand and don’t know how to fix. </p>
<p>This is complexity. Complexity turns reliable software in unreliable software. Complexity is what kills software projects. </p>
<p>Simplicity is the highest goal of Go. Whatever programs we write, we should be able to agree that they are simple. </p>
<p>1.2. Readability </p>
<p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 2/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>“Readability is essential for maintainability. — Mark Reinhold </p>
<p>JVM language summit 2018 </p>
<p>Why is it important that Go code be readable? Why should we strive for readability? </p>
<p>“Programs must be written for people to read, and only incidentally for machines to execute. — Hal Abelson and Gerald Sussman </p>
<p>Structure and Interpretation of Computer Programs </p>
<p>Readability is important because all software, not just Go programs, is written by humans to be read by other humans. The fact that software is also consumed by machines is secondary. </p>
<p>Code is read many more times than it is written. A single piece of code will, over its lifetime, be read hundreds, maybe thousands of times. </p>
<p>“The most important skill for a programmer is the ability to effectively communicate ideas. — Gastón Jorquera [1] </p>
<p>Readability is key to being able to understand what the program is doing. If you can’t understand what a program is doing, how can you hope to maintain it? If software cannot be maintained, then it will be rewritten; and that could be the last time your company will invest in Go. </p>
<p>If you’re writing a program for yourself, maybe it only has to run once, or you’re the only person who’ll ever see it, then do what ever works for you. But if this is a piece of software that more than one person will contribute to, or that will be used by people over a long enough time that requirements, features, or the environment it runs in changes, then your goal must be for your program to be maintainable. </p>
<p>The first step towards writing maintainable code is making sure the code is readable. </p>
<p>“1.3. Productivity<br> Design is the art of arranging code to work today, and be changeable forever. </p>
<p>— Sandi Metz </p>
<p>The last underlying principle I want to highlight is productivity. Developer productivity is a sprawling topic but it boils down to this; how much time do you spend doing useful work verses waiting for your tools or hopelessly lost in a foreign code-base. Go programmers should feel that they can get a lot done with Go. </p>
<p>The joke goes that Go was designed while waiting for a C++ program to compile. Fast compilation is a key feature of Go and a key recruiting tool to attract new developers. While compilation speed remains a constant battleground, it is fair to say that compilations which take minutes in other languages, take seconds in Go. This helps Go developers feel as productive as their counterparts working in dynamic languages without the reliability issues inherent in those languages. </p>
<p>More fundamental to the question of developer productivity, Go programmers realise that code is written to be read and so place the act of reading code above the act of writing it. Go goes so far as to enforce, via tooling and custom, that all code be formatted in a specific style. This removes the friction of learning a project specific dialect and helps spot mistakes because they just look incorrect. </p>
<p>Go programmers don’t spend days debugging inscrutable compile errors. They don’t waste days with complicated build scripts or deploying code to production. And most importantly they don’t spend their time trying to understand what their coworker wrote. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 3/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Productivity is what the Go team talk about when they say the language must scale. 2. Identiers </p>
<p>The first topic we’re going to discuss is identifiers. An identifier is a fancy word for a name; the name of a variable, the name of a function, the name of a method, the name of a type, the name of a package, and so on. </p>
<p>“Poor naming is symptomatic of poor design. — Dave Cheney </p>
<p>Given the limited syntax of Go, the names we choose for things in our programs have an oversized impact on the readability of our programs. Readability is the defining quality of good code thus choosing good names is crucial to the readability of Go code. </p>
<p>“2.1. Choose identiers for clarity, not brevity<br> Obvious code is important. What you can do in one line you should do in three. </p>
<p>— Ukiah Smith </p>
<p>Go is not a language that optimises for clever one liners. Go is not a language which optimises for the least number of lines in a program. We’re not optimising for the size of the source code on disk, nor how long it takes to type. </p>
<p>“Good naming is like a good joke. If you have to explain it, it’s not funny. — Dave Cheney </p>
<p>Key to this clarity is the names we choose for identifies in Go programs. Let’s talk about the qualities of a good name: </p>
<p>A good name is concise. A good name need not be the shortest it can possibly be, but a good name should waste no space on things which are extraneous. Good names have a high signal to noise ratio. </p>
<p>A good name is descriptive. A good name should describe the application of a variable or constant, not their contents. A good name should describe the result of a function, or behaviour of a method, not their operation. A good name should describe the purpose of a package, not its contents. The more accurately a name describes the thing it identifies, the better the name. </p>
<p>A good name is should be predictable. You should be able to infer the way a name will be used from its name alone. This is a function of choosing descriptive names, but it also about following tradition. This is what Go programmers talk about when they say idiomatic. </p>
<p>Let’s talk about each of these properties in depth. </p>
<p>2.2. Identier length </p>
<p>Sometimes people criticise the Go style for recommending short variable names. As Rob Pike said, “Go programmers want the right length identifiers”. [1] </p>
<p>Andrew Gerrand suggests that by using longer identifies for some things we indicate to the reader that they are of higher importance. </p>
<p>“The greater the distance between a name’s declaration and its uses, the longer the name should be. </p>
<p>— Andrew Gerrand [2] </p>
<p>From this we can draw some guidelines: </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 4/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Short variable names work well when the distance between their declaration and last use is short.<br> Long variable names need to justify themselves; the longer they are the more value they need to provide. Lengthy </p>
<p>bureaucratic names carry a low amount of signal compared to their weight on the page. </p>
<p>Don’t include the name of your type in the name of your variable. </p>
<p>Constants should describe the value they hold, not how that value is used. </p>
<p>Single letter variables for loops and branches, single words for parameters and return values, multiple words for functions and package level declarations </p>
<p>Single words for methods, interfaces, and packages.<br> Remember that the name of a package is part of the name the caller uses to to refer to it, so make use of that. </p>
<p>Let’s look at an example to </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br></pre></td></tr></table></figure>
<p>Age int } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// AverageAge returns the average age of people.</span><br><span class="line">func AverageAge(people []Person) int &#123;</span><br><span class="line">    if len(people) == 0 &#123;</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count, sum int</span><br><span class="line">for _, p := range people &#123;</span><br></pre></td></tr></table></figure>
<p>sum += p.Age </p>
<p>count += 1 } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return sum / count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>In this example, the range variable p is declared on line 10 and only referenced on the following line. p lives for a very short time both on the page, and during the execution of the function. A reader who is interested in the effect values of p have on the program need only read two lines. </p>
<p>By comparison people is declared in the function parameters and lives for seven lines. The same is true for sum , and count , thus they justify their longer names. The reader has to scan a wider number of lines to locate them so they are </p>
<p>given more distinctive names. </p>
<p>I could have chosen s for sum and c (or possibly n ) for but this would have reduced all the variables in the program to the same level of importance. I could have chosen                              instead of                              but that would have left the problem of what to call the for … range iteration variable. The singular                              would look odd as the loop iteration variable which lives for little time has a longer name than the slice of values it was derived from. </p>
<p>count </p>
<p>TIP </p>
<p>Use blank lines to break up the flow of a function in the same way you use paragraphs to break up the flow of a document. In AverageAge we have three operations occurring in sequence. The first is the precondition, checking that we don’t divide by zero if people is empty, the second is the accumulation of the sum and count, and the final is the computation of the average. </p>
<p>2.2.1. Context is key </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 5/45 </p>
<p>p </p>
<p>people </p>
<p>person </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>It’s important to recognise that most advice on naming is contextual. I like to say it is a principle, not a rule. </p>
<p>What is the difference between two identifiers, i , and index . We cannot say conclusively that one is better than another, for example is </p>
<p>fundamentally more readable than </p>
<p>I argue it is not, because it is likely the scope of i , and index for that matter, is limited to the body of the for loop and the extra verbosity of the latter adds little to comprehension of the program. </p>
<p>However, which of these functions is more readable? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(oid []int, index int) (int, error)</span><br></pre></td></tr></table></figure>
<p>or </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(o []int, i int) (int, error)</span><br></pre></td></tr></table></figure>
<p>In this example, oid is an abbreviation for SNMP Object ID, so shortening it to o would mean programmers have to translate from the common notation that they read in documentation to the shorter notation in your code. Similarly, reducing index to i obscures what i stands for as in SNMP messages a sub value of each OID is called an Index. </p>
<p>TIP Don’t mix and match long and short formal parameters in the same declaration. 2.3. Don’t name your variables for their types </p>
<p>You shouldn’t name your variables after their types for the same reason you don’t name your pets “dog” and “cat”. You also probably shouldn’t include the name of your type in the name of your variable’s name for the same reason. </p>
<p>The name of the variable should describe its contents, not the type of the contents. Consider this example: var usersMap map[string]*User </p>
<p>What’s good about this declaration? We can see that its a map, and it has something to do with the *User type, that’s probably good. But usersMap is a map, and Go being a statically typed language won’t let us accidentally use it where a scalar variable is required, so the Map suffix is redundant. </p>
<p>Now, consider what happens if we were to declare other variables like: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for index := 0; index &lt; len(s); index++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure>
<p>} </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 6/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    companiesMap map[string]*Company</span><br><span class="line">    productsMap map[string]*Products</span><br></pre></td></tr></table></figure>
<p>) </p>
<p>Now we have three map type variables in scope, usersMap , companiesMap , and productsMap , all mapping strings to different types. We know they are maps, and we also know that their map declarations prevent us from using one in place of another—the compiler will throw an error if we try to use companiesMap where the code is expecting a </p>
<p>map[string]*User . In this situation it’s clear that the Map suffix does not improve the clarity of the code, its just extra boilerplate to type. </p>
<p>My suggestion is to avoid any suffix that resembles the type of the variable.<br> TIP If users isn’t descriptive enough, then usersMap won’t be either. </p>
<p>This advice also applies to function parameters. For example: </p>
<p>Naming the <em>Config parameter config is redundant. We know its a </em>Config , it says so right there. In this case consider conf or maybe c will do if the lifetime of the variable is short enough. </p>
<p>If there is more that one in scope at any one time then calling them conf1 and conf2 is less descriptive than calling them and as the latter are less likely to be mistaken for one another. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line">func WriteConfig(w io.Writer, config *Config)</span><br></pre></td></tr></table></figure>
<p>*Config </p>
<p>original </p>
<p>updated </p>
<p>Don’t let package names steal good variable names. </p>
<p>The name of an imported identifier includes its package name. For example the context package will be known as context.Context . This makes it impossible to use </p>
<p>a variable or type in your package. </p>
<p>type in the as </p>
<p>func WriteLog(context context.Context, message string)<br> Will not compile. This is why the local declaration for context.Context types is traditionally ctx . </p>
<p>eg. </p>
<p>func WriteLog(ctx context.Context, message string) </p>
<p>2.4. Use a consistent naming style </p>
<p>Another property of a good name is it should be predictable. The reader should be able to understand the use of a name when they encounter it for the first time. When they encounter a common name, they should be able to assume it has not changed meanings since the last time they saw it. </p>
<p>NOTE </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 7/45 </p>
<p>Context </p>
<p>context </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>For example, if your code passes around a database handle, make sure each time the parameter appears, it has the same name. Rather than a combination of d <em>sql.DB , dbase </em>sql.DB , DB <em>sql.DB , and database </em>sql.DB , instead consolidate on something like; </p>
<p>db <em>sql.DB<br> Doing so promotes familiarity; if you see a db , you know it’s a </em>sql.DB and that it has either been declared locally or </p>
<p>provided for you by the caller. </p>
<p>Similarly for method receivers; use the same receiver name every method on that type. This makes it easier for the reader to internalise the use of the receiver across the methods in this type. </p>
<p>The convention for short receiver names in Go is at odds with the advice provided so far. This is just NOTE one of the choices made early on that has become the preferred style, just like the use of CamelCase </p>
<p>TIP </p>
<p>rather than snake_case . </p>
<p>Go style dictates that receivers have a single letter name, or acronyms derived from their type. You may find that the name of your receiver sometimes conflicts with name of a parameter in a method. In this case, consider making the parameter name slightly longer, and don’t forget to use this new parameter name consistently. </p>
<p>Finally, certain single letter variables have traditionally been associated with loops and counting. For example, i , j , and k are commonly the loop induction variable for simple for loops. n is commonly associated with a counter or accumulator. v is a common shorthand for a value in a generic encoding function, k is commonly used for the key of a map, and s is often used as shorthand for parameters of type string . </p>
<p>As with the db example above programmers expect                              to be a loop induction variable. If you ensure that is always a loop variable, not used in other contexts outside a                              loop. When readers encounter a variable called , or j , they know that a loop is close by. </p>
<p>i </p>
<p>i </p>
<p>for </p>
<p>i </p>
<p>TIP </p>
<p>If you found yourself with so many nested loops that you exhaust your supply of i , j , and k variables, its probably time to break your function into smaller units. </p>
<p>2.5. Use a consistent declaration style </p>
<p>Go has at least six different ways to declare a variable </p>
<p>varxint=1 varx=1 varxint;x=1 var x = int(1) x:=1 </p>
<p>I’m sure there are more that I haven’t thought of. This is something that Go’s designers recognise was probably a mistake, but its too late to change it now. With all these different ways of declaring a variable, how do we avoid each Go programmer choosing their own style? </p>
<p>I want to present a suggestions for how I declare variables in my programs. This is the style I try to use where possible. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 8/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>When declaring, but not initialising, a variable, use var . When declaring a variable that will be explicitly initialised later in the function, use the var keyword. </p>
<p>The var acts as a clue to say that this variable has been deliberately declared as the zero value of the indicated type. This is also consistent with the requirement to declare variables at the package level using var as opposed to the short declaration syntax—although I’ll argue later that you shouldn’t be using package level variables at all. </p>
<p>When declaring and initialising, use := . When declaring and initialising the variable at the same time, that is to say we’re not letting the variable be implicitly initialised to its zero value, I recommend using the short variable declaration form. This makes it clear to the reader that the variable on the left hand side of the := is being deliberately initialised. </p>
<p>To explain why, Let’s look at the previous example, but this time deliberately initialising each variable: </p>
<p>In the first and third examples, because in Go there are no automatic conversions from one type to another; the type on the left hand side of the assignment operator must be identical to the type on the right hand side. The compiler can infer the type of the variable being declared from the type on the right hand side, to the example can be written more concisely like this: </p>
<p>This leaves us with explicitly initialising players to 0 which is redundant because 0 is `players’ zero value. So its better to make it clear that we’re going to use the zero value by instead writing </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var players int</span><br></pre></td></tr></table></figure>
<p>What about the second statement? We cannot elide the type and write </p>
<p>var things = nil<br> Because nil does not have a type. [2] Instead we have a choice, do we want the zero value for a slice? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var players int    // 0</span><br><span class="line">var things []Thing // an empty slice of Things</span><br><span class="line">var thing Thing    // empty Thing struct</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br><span class="line">var players int = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing *Thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br><span class="line">var players = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 9/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things []Thing</span><br></pre></td></tr></table></figure>
<p>or do we want to create a slice with zero elements? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things = make([]Thing, 0)</span><br></pre></td></tr></table></figure>
<p>If we wanted the latter then this is not the zero value for a slice so we should make it clear to the reader that we’re making this choice by using the short declaration form: </p>
<p>things := make([]Thing, 0)<br> Which tells the reader that we have chosen to initialise things explicitly. </p>
<p>This brings us to the third declaration, </p>
<p>var thing = new(Thing)<br> Which is both explicitly initialising a variable and introduces the uncommon use of the new keyword which some Go </p>
<p>programmer dislike. If we apply our short declaration syntax recommendation then the statement becomes </p>
<p>thing := new(Thing)<br> Which makes it clear that thing is explicitly initialised to the result of new(Thing) –a pointer to a Thing –but still </p>
<p>leaves us with the unusual use of new . We could address this by using the compact literal struct initialiser form, thing := &amp;Thing{} </p>
<p>Which does the same as<br> means we’re explicitly initialising </p>
<p>, hence why some Go programmers are upset by the duplication. However this with a pointer to a Thing{} , which is the zero value for a Thing . </p>
<p>new(Thing) </p>
<p>thing </p>
<p>Instead we should recognise that                              is being declared as its zero value and use the address of operator to pass the address of thing to </p>
<p>thing </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.Unmarshall</span><br><span class="line">var thing Thing</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 10/45 </p>
<p>2018/10/21 </p>
<p>Practical Go: Real world advice for writing maintainable Go programs </p>
<p>NOTE </p>
<p>Of course, with any rule of thumb, there are exceptions. For example, sometimes two variables are closely related so writing </p>
<p>Would be odd. The declaration may be more readable like this </p>
<p>min, max := 0, 1000 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var min int</span><br><span class="line">max := 1000</span><br></pre></td></tr></table></figure>
<p>In summary:<br> When declaring a variable without initialisation, use the var syntax. </p>
<p>When declaring and explicitly initialising a variable, use := . Make tricky declarations obvious. </p>
<p>When something is complicated, it should look complicated. var length uint32 = 0x80 </p>
<p>Here length may be being used with a library which requires a specific numeric type and is more TIP explicit that length is being explicitly chosen to be uint32 than the short declaration form: </p>
<p>length := uint32(0x80) </p>
<p>In the first example I’m deliberately breaking my rule of using the var declaration form with an explicit initialiser. This decision to vary from my usual form is a clue to the reader that something unusual is happening. </p>
<p>2.6. Be a team player </p>
<p>I talked about a goal of software engineering to produce readable, maintainable, code. Therefore you will likely spend most of your career working on projects of which you are not the sole author. My advice in this situation is to follow the local style. </p>
<p>Changing styles in the middle of a file is jarring. Uniformity, even if its not your preferred approach, is more valuable for maintenance than your personal preference. My rule of thumb is; if it fits through gofmt then its usually not worth holding up a code review for. </p>
<p>If you want to do a renaming across a code-base, do not mix this into another change. If someone is TIP using git bisect they don’t want to wade through thousands of lines of renaming to find the code you </p>
<p>changed as well. </p>
<p>\3. Comments </p>
<p>Before we move on to larger items I want to spend a few minutes talking about comments. </p>
<p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 11/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>“Good code has lots of comments, bad code requires lots of comments. — Dave Thomas and Andrew Hunt </p>
<p>The Pragmatic Programmer </p>
<p>Comments are very important to the readability of a Go program. A comments should do one of three things: </p>
<p>\1. The comment should explain what the thing does.<br> \2. The comment should explain how the thing does what it does. 3. The comment should explain why the thing is why it is. </p>
<p>The first form is ideal for commentary on public symbols: </p>
<p>The second form is ideal for commentary inside a method: </p>
<p>The third form, the why , is unique as it does not displace the first two, but at the same time it’s not a replacement for the what, or the how. The why style of commentary exists to explain the external factors that drove the code you read on the page. Frequently those factors rarely make sense taken out of context, the comment exists to provide that context. </p>
<p>In this example it may not be immediately clear what the effect of setting HealthyPanicThreshold to zero percent will do. The comment is needed to clarify that the value of 0 will disable the panic threshold behaviour. </p>
<p>3.1. Comments on variables and constants should describe their contents not their purpose </p>
<p>I talked earlier that the name of a variable, or a constant, should describe its purpose. When you add a comment to a variable or constant, that comment should describe the variables contents, not the variables purpose. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const randomNumber = 6 // determined from an unbiased die</span><br></pre></td></tr></table></figure>
<p>In this example the comment describes why                              is assigned the value six, and where the six was derived from. The comment does not describe where                              will be used. Here are some more examples: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Open opens the named file for reading.</span><br><span class="line">// If successful, methods on the returned file can be used for reading.</span><br><span class="line">// queue all dependant actions</span><br><span class="line">var results []chan error</span><br><span class="line">for _, dep := range a.Deps &#123;</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results = append(results, execute(seen, dep))</span><br><span class="line">return &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">    // Disable HealthyPanicThreshold</span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">            Value: 0,</span><br></pre></td></tr></table></figure>
<p>}, } </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>12/45 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randomNumber</span><br><span class="line">randomNumber</span><br></pre></td></tr></table></figure>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    StatusContinue           = 100 // RFC 7231, 6.2.1</span><br><span class="line">    StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2</span><br><span class="line">    StatusProcessing         = 102 // RFC 2518, 10.1</span><br><span class="line">    StatusOK                 = 200 // RFC 7231, 6.3.1</span><br></pre></td></tr></table></figure>
<p>In the context of HTTP the number 100 is known as StatusContinue , as defined in RFC 7231, section 6.2.1. For variables without an initial value, the comment should describe who is responsible for </p>
<p>// sizeCalculationDisabled indicates whether it is safe // to calculate Types’ widths and alignments. See dowidth. var sizeCalculationDisabled bool </p>
<p>TIP </p>
<p>initialising this variable. </p>
<p>Here the comment lets the reader know that the dowidth function is responsible for maintaining the state of sizeCalculationDisabled . </p>
<p>Hiding in plain sight </p>
<p>This is a tip from Kate Gregory. [3] Sometimes you’ll find a better name for a variable hiding in a comment. </p>
<p>The comment was added by the author because registry doesn’t explain enough about its purpose —it’s a registry, but a registry of what? </p>
<p>By renaming the variable to sqlDrivers its now clear that the purpose of this variable is to hold SQL drivers. </p>
<p>var sqlDrivers = make(map[string]*sql.Driver) </p>
<p>Now the comment is redundant and can be removed. </p>
<p>// registry of SQL drivers<br> var registry = make(map[string]*sql.Driver) </p>
<p>TIP </p>
<p>3.2. Always document public symbols </p>
<p>Because godoc is the documentation for your package, you should always add a comment for every public symbol— variable, constant, function, and method—declared in your package. </p>
<p>Here are two rules from the Google Style guide </p>
<p>Any public function that is not both obvious and short must be commented.<br> Any function in a library must be commented regardless of length or complexity </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 13/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package ioutil</span><br><span class="line">// ReadAll reads from r until an error or EOF and returns the data it read.</span><br><span class="line">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><br><span class="line">// defined to read from src until EOF, it does not treat an EOF from Read</span><br><span class="line">// as an error to be reported.</span><br><span class="line">func ReadAll(r io.Reader) ([]byte, error)</span><br></pre></td></tr></table></figure>
<p>There is one exception to this rule; you don’t need to document methods that implement an interface. Specifically don’t do this: </p>
<p>This comment says nothing. It doesn’t tell you what the method does, in fact it’s worse, it tells you to go look somewhere else for the documentation. In this situation I suggest removing the comment entirely. </p>
<p>Here is an example from the io package </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Read implements the io.Reader interface</span><br><span class="line">func (r *FileReader) Read(buf []byte) (int, error)</span><br><span class="line">// LimitReader returns a Reader that reads from r</span><br><span class="line">// but stops with EOF after n bytes.</span><br><span class="line">// The underlying implementation is a *LimitedReader.</span><br><span class="line">func LimitReader(r Reader, n int64) Reader &#123; return &amp;LimitedReader&#123;r, n&#125; &#125;</span><br><span class="line">// A LimitedReader reads from R but limits the amount of</span><br><span class="line">// data returned to just N bytes. Each call to Read</span><br><span class="line">// updates N to reflect the new amount remaining.</span><br><span class="line">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span><br><span class="line">type LimitedReader struct &#123;</span><br><span class="line">    R Reader // underlying reader</span><br><span class="line">    N int64  // max bytes remaining</span><br><span class="line">&#125;</span><br><span class="line">func (l *LimitedReader) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">    if l.N &lt;= 0 &#123;</span><br><span class="line">        return 0, EOF</span><br><span class="line">    &#125;</span><br><span class="line">    if int64(len(p)) &gt; l.N &#123;</span><br><span class="line">        p = p[0:l.N]</span><br><span class="line">    &#125;</span><br><span class="line">    n, err = l.R.Read(p)</span><br><span class="line">    l.N -= int64(n)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>Note that the                              declaration is directly preceded by the function that uses it, and the declaration of follows the declaration of LimitedReader itself. Even though LimitedReader.Read has no </p>
<p>documentation itself, its clear from that it is an implementation of io.Reader . </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LimitedReader</span><br><span class="line">LimitedReader.Read</span><br></pre></td></tr></table></figure>
<p>TIP </p>
<p>Before you write the function, write the comment describing the function. If you find it hard to write the comment, then it’s a sign that the code you’re about to write is going to be hard to understand. </p>
<p>3.2.1. Don’t comment bad code, rewrite it </p>
<p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 14/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>“ Don’t comment bad code — rewrite it — Brian Kernighan </p>
<p>Comments highlighting the grossness of a particular piece of code are not sufficient. If you encounter one of these comments, you should raise an issue as a reminder to refactor it later. It is okay to live with technical debt, as long as the amount of debt is known. </p>
<p>The tradition in the standard library is to annotate a TODO style comment with the username of the person who noticed it. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO(dfc) this is O(N^2), find a faster way to do this.</span><br></pre></td></tr></table></figure>
<p>The username is not a promise that that person has committed to fixing the issue, but they may be the best person to ask when the time comes to address it. Other projects annotate TODOs with a date or an issue number. </p>
<p>“3.2.2. Rather than commenting a block of code, refactor it </p>
<p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer. </p>
<p>— Steve McConnell </p>
<p>Functions should do one thing only. If you find yourself commenting a piece of code because it is unrelated to the rest of the function, consider extracting it into a function of its own. </p>
<p>In addition to be easier to comprehend, smaller functions are easier to test in isolation, and now you’ve isolated the orthogonal code into its own function, its name may be all the documentation required. </p>
<p>“4. Package Design<br> Write shy code - modules that don’t reveal anything unnecessary to other modules and that </p>
<p>don’t rely on other modules’ implementations. </p>
<p>— Dave Thomas </p>
<p>Each Go package is in effect it’s own small Go program. Just as the implementation of a function or method is unimportant to the caller, the implementation of the functions and methods and types that make your package’s public API—its behaviour—is unimportant for the caller. </p>
<p>A good Go package should strive to have a low degree of source level coupling such that, as the project grows, changes to one package do not cascade across the code-base. These stop-the-world refactorings place a hard limit on the rate of change in a code base and thus the productivity of the members working in that code-base. </p>
<p>In this section we’ll talk about designing a package including the package’s name, naming types, and tips for writing methods and functions. </p>
<p>4.1. A good package starts with its name </p>
<p>Writing a good Go package starts with the package’s name. Think of your package’s name as an elevator pitch to describe what it does using just one word. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>15/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Just as I talked about names for variables in the previous section, the name of a package is very important. The rule of thumb I follow is not, “what types should I put in this package?”. Instead the question I ask “what does service does package provide?” Normally the answer to that question is not “this package provides the X type”, but “this package let’s you speak HTTP”. </p>
<p>TIP Name your package after what is provides, not what it contains. 4.1.1. Good package names should be unique. </p>
<p>Within your project, each package name should be unique. This advice is pretty easy to follow if the advice that a package’s name should derive from its purpose—if you find you have two packages which need the same name, it is likely either; </p>
<p>a. The name of the package is too generic. </p>
<p>b. The package overlaps another package of a similar name. In this case either you should review your design, or consider merging the packages. </p>
<p>4.2. Avoid package names like base , common , or util </p>
<p>A common cause of poor package names is what call utility packages. These are packages where common helpers and utility code congeals over time. As these packages contain an assortment of unrelated functions, their utility is hard to describe in terms of what the package provides. This often leads to the package’s name being derived from what the package contains–utilities. </p>
<p>Package names like utils or helpers are commonly found in larger projects which have developed deep package hierarchies and want to share helper functions without encountering import loops. By extracting utility functions to new package the import loop is broken, but because the package stems from a design problem in the project, its name doesn’t reflect its purpose, only its function of breaking the import cycle. </p>
<p>My recommendation to improve the name of utils or helpers packages is to analyse where they are called and if possible move the relevant functions into their caller’s package. Even if this involves duplicating some helper code this is better than introducing an import dependency between two packages. </p>
<p>“[A little] duplication is far cheaper than the wrong abstraction. — Sandy Metz </p>
<p>In the case where utility functions are used in many places prefer multiple packages, each focused on a single aspect, to a single monolithic package. </p>
<p>TIP Use plurals for naming utility packages. For example the strings for string handling utilities. </p>
<p>Packages with names like base or common are often found when functionality common to two or more implementations, or common types for a client and server, has been refactored into a separate package. I believe the solution to this is to reduce the number of packages, to combine the client, server, and common code into a single package named after the function of the package. </p>
<p>For example, the net/http package does not have client and                              sub packages, instead it has a client.go and server.go file, each holding their respective types, and a                              file for the common message transport code. </p>
<p>server </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>16/45 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport.go</span><br></pre></td></tr></table></figure>
<p>2018/10/21 </p>
<p>Practical Go: Real world advice for writing maintainable Go programs </p>
<p>TIP </p>
<p>An identifier’s name includes its package name. </p>
<p>It’s important to remember that the name of an identifier includes the name of its package. </p>
<p>The Get function from the net/http package becomes http.Get when referenced by another package. </p>
<p>The Reader type from the strings package becomes strings.Reader when imported into other packages. </p>
<p>The Error interface from the net package is clearly related to network errors. 4.3. Return early rather than nesting deeply </p>
<p>As Go does not use exceptions for control flow there is no requirement to deeply indent your code just to provide a top level structure for the try and catch blocks. Rather than the successful path nesting deeper and deeper to the right, Go code is written in a style where the success path continues down the screen as the function progresses. My friend Mat Ryer calls this practice ‘line of sight’ coding. [4] </p>
<p>This is achieved by using guard clauses; conditional blocks with assert preconditions upon entering a function. Here is an example from the bytes package, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &lt;= opInvalid &#123;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">        b.off -= int(b.lastRead)</span><br><span class="line">    &#125;</span><br><span class="line">    b.lastRead = opInvalid</span><br></pre></td></tr></table></figure>
<p>return nil } </p>
<p>Upon entering UnreadRune the state of b.lastRead is checked and if the previous operation was not an error is returned immediately. From there the rest of the function proceeds with the assertion that is greater that opInvalid . </p>
<p>Compare this to the same function written without a guard clause, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &gt; opInvalid &#123;</span><br><span class="line">        if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">            b.off -= int(b.lastRead)</span><br><span class="line">        &#125;</span><br><span class="line">        b.lastRead = opInvalid</span><br><span class="line">        return nil</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<p>The body of the successful case, the most common, is nested inside the first if condition and the successful exit condition, return nil , has to be discovered by careful matching of closing braces. The final line of the function now returns an error, and the called must trace the execution of the function back to the matching opening brace to know </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 17/45 </p>
<p>ReadRune </p>
<p>b.lastRead </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>when control will reach this point. </p>
<p>This is more error prone for the reader, and the maintenance programmer, hence why Go prefer to use guard clauses and returning early on errors. </p>
<p>4.4. Make the zero value useful </p>
<p>Every variable declaration, assuming no explicit initialiser is provided, will be automatically initialised to a value that matches the contents of zeroed memory. This is the values zero value. The type of the value determines its zero value; for numeric types it is zero, for pointer types nil, the same for slices, maps, and channels. </p>
<p>This property of always setting a value to a known default is important for safety and correctness of your program and can make your Go programs simpler and more compact. This is what Go programmers talk about when they say “give your structs a useful zero value”. </p>
<p>Consider the sync.Mutex type. sync.Mutex contains two unexported integer fields, representing the mutex’s internal state. Thanks to the zero value those fields will be set to will be set to 0 whenever a sync.Mutex is declared. </p>
<p>sync.Mutex has been deliberately coded to take advantage of this property, making the type usable without explicit initialisation. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type MyInt struct &#123;</span><br><span class="line">    mu  sync.Mutex</span><br></pre></td></tr></table></figure>
<p>val int } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var i MyInt</span><br><span class="line">    // i.mu is usable without explicit initialisation.</span><br><span class="line">    i.mu.Lock()</span><br><span class="line">    i.val++</span><br><span class="line">    i.mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<p>Another example of a type with a useful zero value is bytes.Buffer . You can declare a bytes.Buffer and start writing to it without explicit initialisation. </p>
<p>A useful property of slices is their zero value is nil . This makes sense if we look at the runtime’s definition of a slice header. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    b.WriteString(&quot;Hello, world!\n&quot;)</span><br><span class="line">    io.Copy(os.Stdout, &amp;b)</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">        array *[...]T // pointer to the underlying array</span><br><span class="line">        len   int</span><br><span class="line">        cap   int</span><br></pre></td></tr></table></figure>
<p>} </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 18/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>The zero value of this struct would imply len and cap have the value 0 , and array , the pointer to memory holding the contents of the slice’s backing array, would be nil . This means you don’t need to explicitly make a slice, you can just declare it. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // s := make([]string, 0)</span><br><span class="line">    // s := []string&#123;&#125;</span><br><span class="line">    var s []string</span><br><span class="line">    s = append(s, &quot;Hello&quot;)</span><br><span class="line">    s = append(s, &quot;world&quot;)</span><br><span class="line">    fmt.Println(strings.Join(s, &quot; &quot;))</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<p>var s []string is similar to the two commented lines above it, but not identical. It is possible to detect the difference between a slice value that is nil and a slice value that has zero length. The following code will output false. </p>
<p>NOTE </p>
<p>A surprising, but useful, property of uninitialised pointer variables—nil pointers—is you can call methods on types that have a nil value. This can be used to provide default values simply. </p>
<p>func main() {<br> var s1 = []string{}<br> var s2 []string fmt.Println(reflect.DeepEqual(s1, s2)) </p>
<p>} </p>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    path string</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *Config) Path() string &#123;</span><br><span class="line">    if c == nil &#123;</span><br><span class="line">        return &quot;/usr/home&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return c.path</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var c1 *Config</span><br><span class="line">    var c2 = &amp;Config&#123;</span><br><span class="line">        path: &quot;/export&quot;,</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>4.5. Avoid package level state </p>
<p>The key to writing maintainable programs is that they should be loosely coupled—a change to one package should have a low probability of affecting another package that does not directly depend on the first. </p>
<p>There are two excellent ways to achieve loose coupling in Go </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>19/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>\1. Use interfaces to describe the behaviour your functions or methods require. 2. Avoid the use of global state. </p>
<p>In Go we can declare variables at the function or method scope, and also at the package scope. When the variable is public, given a identifier starting with a capital letter, then its scope is effectively global to the entire program—any package may observe the type and contents of that variable at any time. </p>
<p>Mutable global state introduces tight coupling between independent parts of your program as global variables become an invisible parameter to every function in your program! Any function that relies on a global variable can be broken if that variable’s type changes. Any function that relies on the state of a global variable can be broken if another part of the program changes that variable. </p>
<p>If you want to reduce the coupling a global variable creates, </p>
<p>\1. Move the relevant variables as fields on structs that need them.<br> \2. Use interfaces to reduce the coupling between the behaviour and the implementation of that behaviour. </p>
<p>\5. Project Structure </p>
<p>Let’s talk about combining packages together into a project. Commonly this will be a single git repository, but in the future Go developers will use module and project interchangeably. </p>
<p>Just like a package, each project should have a clear purpose. If your project is a library, it should provide one thing, say XML parsing, or logging. You should avoid combining multiple purposes into a single package, this will help avoid the dreaded common library. </p>
<p>In my experience, the common repo ends up tightly coupled to its biggest consumer and that makes TIP it hard to back-port fixes without upgrading both common and consumer in lock step, bringing in a </p>
<p>lot of unrelated changes and API breakage along the way. </p>
<p>If your project is an application, like your web application, Kubernetes controller, and so on, then you might have one or more                              packages inside your project. For example, the Kubernetes controller I work on has a single </p>
<p>package which serves as both the server deployed to a Kubernetes cluster, and a client for debugging </p>
<p>purposes. </p>
<p>5.1. Consider fewer, larger packages </p>
<p>One of the things I tend to pick up in code review for programmers who are transitioning from other languages to Go is they tend to overuse packages. </p>
<p>Go does not provide elaborate ways of establishing visibility; thing Java’s public , protected , private , and implicit default access modifiers. There is no equivalent of C++’s notion of friend classes. </p>
<p>In Go we have only two access modifiers, public and private, indicated by the capitalisation of the first letter of the identifier. If an identifier is public, it’s name starts with a capital letter, that identifier can be referenced by any other Go package. </p>
<p>NOTE You may hear people say exported and not exported as synonyms for public and private.<br> Given the limited controls available to control access to a package’s symbols, what practices should Go programmers </p>
<p>follow to avoid creating over-complicated package hierarchies? </p>
<p>main </p>
<p>cmd/contour </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 20/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>TIP Every package, with the exception of cmd/ and internal/ , should contain some source code. </p>
<p>The advice I find myself repeating is to prefer fewer, larger packages. Your default position should be to not create a new package. That will lead to too many types being made public creating a wide, shallow, API surface for your package.. </p>
<p>The sections below explores this suggestion in more detail. </p>
<p>TIP </p>
<p>Coming from Java? </p>
<p>If you’re coming from a Java or C# background, consider this rule of thumb. - A Java package is equivalent to a single .go source file. - A Go package is equivalent to a whole Maven module or .NET assembly. </p>
<p>5.1.1. Arrange code into les by import statements </p>
<p>If you’re arranging your packages by what they provide to callers, should you do the same for files within a Go package? How do you know when you should break up a .go file into multiple ones? How do you know when you’ve gone to far and should consider consolidating .go file? </p>
<p>Here are the rules of thumb I use:<br> Start each package with one file. Give that file the same name as the name of the folder. eg. package http </p>
<p>should be placed in a file called in a directory named http . </p>
<p>As your package grows you may decide to split apart the various responsibilities into different files. eg,<br> contains the `Request and Response types, client.go contains the Client type, server.go </p>
<p>contains the type. </p>
<p>If you find your files have similar import declarations, consider combining them. Alternatively, identify the differences between the import sets and move those </p>
<p>Different files should be responsible for different areas of the package.                              may be responsible for marshalling of HTTP requests and responses on and off the network,                              may contain the low level network handling logic, client.go and server.go implement the HTTP business logic of request construction or routing, and so on. </p>
<p>TIP Prefer nouns for source file names. </p>
<p>The Go compiler compiles each package in parallel. Within a package the compiler compiles each NOTE function (methods are just fancy functions in Go) in parallel. Changing the layout of your code within </p>
<p>a package does not affect compilation time. </p>
<p>5.1.2. Prefer internal tests to external tests </p>
<p>The go tool supports writing your testing package tests in two places. Assuming your package is called http2 , you can write a file and use the declaration. Doing so will compile the code in </p>
<p>as if it were part of the package. This is known colloquially as an internal test. </p>
<p>The go tool also supports a special package declaration, ending in test , ie., package http_test . This allows your test files to live alongside your code in the same package, however when those tests are compiled they are not part of your package’s code, they live in their own package. This allows you to write your tests as if you were another package calling into your code. This is known as an _external test. </p>
<p>.go </p>
<p>http.go </p>
<p>messages.go </p>
<p>Server </p>
<p>messages.go </p>
<p>http.go </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure>
<p>package http2 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure>
<p>http2 </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 21/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>I recommend using internal tests when writing unit tests for your package. This allows you to test each function or method directly, avoiding the bureaucracy of external testing. </p>
<p>However, you should place your Example test functions in an external test file. This ensures that when viewed in godoc, the examples have the appropriate package prefix and can be easily copy pasted. </p>
<p>TIP </p>
<p>Avoid elaborate package hierarchies, resist the desire to apply taxonomy </p>
<p>With one exception, which we’ll talk about next, the hierarchy of Go packages has no meaning to the go tool. For example, the net/http package is not a child or sub-package of the net package. </p>
<p>If you find you have created intermediate directories in your project which contain no .go files, you may have failed to follow this advice. </p>
<p>5.1.3. Use internal packages to reduce your public API surface </p>
<p>If your project contains multiple packages you may have some exported functions which are intended to be used by other packages in your project, but are not intended to be part of your project’s public API. If you find yourself in this situation the go tool recognises a special folder name—not package name–, internal/ which can be used to place code which is public to your project, but private to other projects. </p>
<p>To create such a package, place it in a directory named internal/ or in a sub-directory of a directory named internal/ . When the go command sees an import of a package with                              in its path, it verifies that the </p>
<p>package doing the import is within the tree rooted at the parent of the                              directory.<br> For example, a package can be imported only by code in the directory tree rooted at … </p>
<p>/a/b/c . It cannot be imported by code in                              or in any other repository. [5] 5.2. Keep package main small as small as possible </p>
<p>Your main function, and                              package should do as little as possible. This is because main.main acts as a singleton; there can only be one                              function in a program, including tests. </p>
<p>Because main.main is a singleton there are a lot of assumptions built into the things that main.main will call that they will only be called during main.main or main.init, and only called once. This makes it hard to write tests for code written in main.main , thus you should aim to move as much of your business logic out of your main function and ideally out of your main package. </p>
<p>TIP </p>
<p>main should parse flags, open connections to databases, loggers, and such, then hand off execution to a high level object. </p>
<p>\6. API Design </p>
<p>The last piece of design advice I’m going to give today I feel is the most important. </p>
<p>All of the suggestions I’ve made so far are just that, suggestions. These are the way I try to write my Go, but I’m not going to push them hard in code review. </p>
<p>However when it comes to reviewing APIs during code review, I am less forgiving. This is because everything I’ve talked about so far can be fixed without breaking backward compatibility; they are, for the most part, implementation details. </p>
<p>When it comes to the public API of a package, it pays to put considerable thought into the initial design, because changing that design later is going to be disruptive for people who are already using your API. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 22/45 </p>
<p>internal </p>
<p>main </p>
<p>…/a/b/g </p>
<p>internal </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.../a/b/c/internal/d/e/f</span><br></pre></td></tr></table></figure>
<p>main </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>“6.1. Design APIs that are hard to misuse.<br> APIs should be easy to use and hard to misuse. </p>
<p>— Josh Bloch [3] </p>
<p>If you take anything away from this presentation, it should be this advice from Josh Bloch. If an API is hard to use for simple things, then every invocation of the API will look complicated. When the actual invocation of the API is complicated it will be less obvious and more likely to be overlooked. </p>
<p>6.1.1. Be wary of functions which take several parameters of the same type </p>
<p>A good example of a simple looking, but hard to use correctly API is one which takes two or more parameters of the same type. Let’s compare two function signatures: </p>
<p>What’s the difference between these two functions? Obviously one returns the maximum of two numbers, the other copies a file, but that’s not the important thing. </p>
<p>Max is commutative; the order of the parameters does not matter. The maximum of eight and ten is ten regardless of if I compare eight to ten or ten two eight. </p>
<p>However, this property does not hold true for CopyFile . </p>
<p>Which one of these statements made a backup of your presentation and which one overwrite your presentation with last week’s version? You can’t tell without consulting the documentation. A code reviewer cannot know if you’ve got the order correct without consulting the documentation. </p>
<p>One possible solution to this is to introduce a helper type which will be responsible for calling CopyFile correctly. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Max(a, b int) int</span><br><span class="line">func CopyFile(to, from string) error</span><br><span class="line">Max(8, 10) // 10</span><br><span class="line">Max(10, 8) // 10</span><br><span class="line">CopyFile(&quot;/tmp/backup&quot;, &quot;presentation.md&quot;)</span><br><span class="line">CopyFile(&quot;presentation.md&quot;, &quot;/tmp/backup&quot;)</span><br><span class="line">type Source string</span><br><span class="line">func (src Source) CopyTo(dest string) error &#123;</span><br><span class="line">    return CopyFile(dest, string(src))</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var from Source = &quot;presentation.md&quot;</span><br><span class="line">    from.CopyTo(&quot;/tmp/backup&quot;)</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<p>In this way CopyFile is always called correctly—this can be asserted with a unit test—and can possibly be made private, further reducing the likelihood of misuse. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 23/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>TIP APIs with multiple parameters of the same type are hard to use correctly. 6.2. Design APIs for their default use case </p>
<p>A few years ago I gave a talk [6] about using functional options [7] to make APIs easier to use for their default case. </p>
<p>The gist of this talk was you should design your APIs for the common use case. Sad another way, your API should not require the caller to provide parameters which they don’t care about. </p>
<p>6.2.1. Discourage the use of nil as a parameter </p>
<p>I opened this chapter with the suggestion that you shouldn’t force the caller of your API into providing you parameters when they don’t really care what those parameters mean. This is what I mean when I say design APIs for their default use case. </p>
<p>Here’s an example from the net/http package </p>
<p>package http </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ListenAndServe listens on the TCP network address addr and then calls</span><br><span class="line">// Serve with handler to handle requests on incoming connections.</span><br><span class="line">// Accepted connections are configured to enable TCP keep-alives.</span><br><span class="line">//</span><br><span class="line">// The handler is typically nil, in which case the DefaultServeMux is used.</span><br><span class="line">//</span><br><span class="line">// ListenAndServe always returns a non-nil error.</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br></pre></td></tr></table></figure>
<p>ListenAndServe takes two parameters, a TCP address to listen for incoming connections, and http.Handler to handle the incoming HTTP request. Serve allows the second parameter to be nil , and notes that usually the caller will pass nil indicating that they want to use http.DefaultServeMux as the implicit parameter. </p>
<p>Now the caller of Serve has two ways to do the same thing. </p>
<p>Both do exactly the same thing. </p>
<p>This                              behaviour is viral. The http package also has a http.Serve helper, which you can reasonably imagine that builds upon like this </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>nil </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">    l, err := net.Listen(&quot;tcp&quot;, addr)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure>
<p>return err } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    defer l.Close()</span><br><span class="line">    return Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 24/45 </p>
<p>http.Serve </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br></pre></td></tr></table></figure>
<p>nil<br> handler </p>
<p>DefaultServeMux`” logic. </p>
<p>http.Serve </p>
<p>Accepting `nil </p>
<p>nil </p>
<p>Serve </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.Serve(nil, nil)</span><br><span class="line">          http.ListenAndServe</span><br><span class="line">DefaultServeMux</span><br></pre></td></tr></table></figure>
<p>nil </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br></pre></td></tr></table></figure>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br></pre></td></tr></table></figure>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ShutdownVMs(ids []string) error</span><br></pre></td></tr></table></figure>
<p>2018/10/21 </p>
<p>Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Because behaviour. In fact, </p>
<p>permits the caller to pass for the second parameter, also supports this is the one that implements the “if is nil , use </p>
<p>for one parameter may lead the caller into thinking they can pass for both parameters. However calling like this, </p>
<p>results in an ugly panic.<br> TIP Don’t mix nil and non nil-able parameters in the same function signature. </p>
<p>The author of was trying to make the API user’s life easier in the common case, but possibly made the package harder to use safely. </p>
<p>There is no difference in line count between using explicitly, or implicitly via . </p>
<p>verses </p>
<p>and a was this confusion really worth saving one line? </p>
<p>TIP </p>
<p>Give serious consideration to how much time helper functions will save the programmer. Clear is better than concise. </p>
<p>Avoid public APIs with test only parameters </p>
<p>TIP Avoid exposing APIs with values who only differ in test scope. Instead, use Public wrappers to hide those parameters, use test scoped helpers to set the property in test scope. </p>
<p>6.2.2. Prefer var args to []T parameters </p>
<p>It’s very common to write a function or method that takes a slice of values. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p>
<p>25/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>This is just an example I made up, but its common to a lot of code I’ve worked on. The problem with signatures like these is they presume that they will be called with more than one entry. However, what I have found is many times these type of functions are called with only one argument, which has to be “boxed” inside a slice just to meet the requirements of the functions signature. </p>
<p>Additionally, because the ids parameter is a slice, you can pass an empty slice or nil to the function and the compiler will be happy. This adds extra testing load because you should cover these cases in your testing. </p>
<p>To give an example of this class of API, recently I was refactoring a piece of logic that required me to set some extra fields if at least one of a set of parameters was non zero. The logic looked like this: </p>
<p>As the if statement was getting very long I wanted to pull the logic of the check out into its own function. This is what I came up with: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if svc.MaxConnections &gt; 0 || svc.MaxPendingRequests &gt; 0 || svc.MaxRequests &gt; 0 ||</span><br><span class="line">svc.MaxRetries &gt; 0 &#123;</span><br><span class="line">    // apply the non zero parameters</span><br><span class="line">&#125;</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(values ...int) bool &#123;</span><br><span class="line">    for _, v := range values &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br></pre></td></tr></table></figure>
<p>return true } </p>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>This enabled me to make the condition where the inner block will be executed clear to the reader: </p>
<p>However there is a problem with anyPositive , someone could accidentally invoke it like this if anyPositive() { … } </p>
<p>In this case anyPositive would return false because it would execute zero iterations and immediately return false . This isn’t the worst thing in the world — that would be if anyPositive returned true when passed no </p>
<p>arguments. </p>
<p>Nevertheless it would be be better if we could change the signature of anyPositive to enforce that the caller should pass at least one argument. We can do that by combining normal and vararg parameters like this: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        // apply the non zero parameters</span><br></pre></td></tr></table></figure>
<p>} </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 26/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Now anyPositive cannot be called with less than one argument. 6.3. Let functions dene the behaviour they requires </p>
<p>Let’s say I’ve been given a task to write a function that persists a Document structure to disk. </p>
<p>I could specify this function, Save, which takes an *os.File as the destination to write the Document . But this has a few problems </p>
<p>The signature of Save precludes the option to write the data to a network location. Assuming that network storage is likely to become requirement later, the signature of this function would have to change, impacting all its callers. </p>
<p>Save is also unpleasant to test, because it operates directly with files on disk. So, to verify its operation, the test would have to read the contents of the file after being written. </p>
<p>And I would have to ensure that f was written to a temporary location and always removed afterwards. </p>
<p><em>os.File also defines a lot of methods which are not relevant to , like reading directories and checking to see if a path is a symlink. It would be useful if the signature of the function could describe only the parts of </em>os.File that were relevant. </p>
<p>What can we do ? </p>
<p>Using io.ReadWriteCloser we can apply the interface segregation principle to redefine Save to take an interface that describes more general file shaped things. </p>
<p>With this change, any type that implements the io.ReadWriteCloser interface can be substituted for the previous *os.File . </p>
<p>This makes Save both broader in its application, and clarifies to the caller of Save which methods of the *os.File type are relevant to its operation. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the file f.</span><br><span class="line">func Save(f *os.File, doc *Document) error</span><br></pre></td></tr></table></figure>
<p>Save </p>
<p>Save </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// ReadWriterCloser.</span><br><span class="line">func Save(rwc io.ReadWriteCloser, doc *Document) error</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(first int, rest ...int) bool &#123;</span><br><span class="line">    if first &gt; 0 &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    for _, v := range rest &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br><span class="line">            return true</span><br></pre></td></tr></table></figure>
<p>} } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 27/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>And as the author of I no longer have the option to call those unrelated methods on as it is hidden behind the interface. </p>
<p>But we can take the interface segregation principle a bit further. </p>
<p>Firstly, it is unlikely that if Save follows the single responsibility principle, it will read the file it just wrote to verify its contents—that should be responsibility of another piece of code. </p>
<p>So we can narrow the specification for the interface we pass to Save to just writing and closing.<br> Secondly, by providing Save with a mechanism to close its stream, which we inherited in this desire to make it still </p>
<p>look like a file, this raises the question of under what circumstances will wc be closed.<br> Possibly Save will call Close unconditionally, or perhaps Close will be called in the case of success. </p>
<p>This presents a problem for the caller of Save as it may want to write additional data to the stream after the document is written. </p>
<p>A better solution would be to redefine Save to take only an io.Writer , stripping it completely of the responsibility to do anything but write data to a stream. </p>
<p>By applying the interface segregation principle to our Save function, the results has simultaneously been a function which is the most specific in terms of its requirements—it only needs a thing that is writable—and the most general in its function, we can now use Save to save our data to anything which implements io.Writer. </p>
<p>\7. Error handling </p>
<p>I’ve given several presentations about error handling [8] and written a lot about error handling on my blog. I also spoke a lot about error handling in yesterday’s session so I won’t repeat what I’ve said. </p>
<p><a href="https://dave.cheney.net/2014/12/24/inspecting-errors" target="_blank" rel="noopener">https://dave.cheney.net/2014/12/24/inspecting-errors</a> <a href="https://dave.cheney.net/2016/04/07/constant-errors" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/07/constant-errors</a> </p>
<p>Instead I want to cover two other areas related to error handling. </p>
<p>7.1. Eliminate error handling by eliminating errors </p>
<p>If you were in my presentation yesterday I talked about the draft proposals for improving error handling. But do you know what is better than an improved syntax for handling errors? Not needing to handle errors at all. </p>
<p>Save </p>
<p>*os.File </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// WriteCloser.</span><br><span class="line">func Save(wc io.WriteCloser, doc *Document) error</span><br><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// Writer.</span><br><span class="line">func Save(w io.Writer, doc *Document) error</span><br></pre></td></tr></table></figure>
<p>NOTE </p>
<p>I’m not saying “remove your error handling”. What I am suggesting is, change your code so you do not have errors to handle. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ReadWriteCloser</span><br></pre></td></tr></table></figure>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 28/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>This section draws inspiration from John Ousterhout’s recently book, A philosophy of Software Design [9]. One of the chapters in that book is called “Define Errors Out of Existence”. We’re going to try to apply this advice to Go. </p>
<p>7.1.1. Counting lines </p>
<p>Let’s write a function to count the number of lines in a file. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    var (</span><br><span class="line">        br    = bufio.NewReader(r)</span><br><span class="line">        lines int</span><br><span class="line">        err   error</span><br></pre></td></tr></table></figure>
<p>) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    _, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">    lines++</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure>
<p>break } </p>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if err != io.EOF &#123;</span><br><span class="line">    return 0, err</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>Because we’re following our advice from previous sections, CountLines takes an io.Reader, not a *File; its the job of the caller to provide the io.Reader who’s contents we want to count. </p>
<p>We construct a bufio.Reader , and then sit in a loop calling the ReadString method, incrementing a counter until we reach the end of the file, then we return the number of lines read. </p>
<p>At least that’s the code we want to write, but instead this function is made more complicated by error handling. For example, there is this strange construction, </p>
<p>We increment the count of lines before checking the error—that looks odd.<br> The reason we have to write it this way is ReadString will return an error if it encounters and end-of-file before </p>
<p>hitting a newline character. This can happen if there is no final newline in the file.<br> To try to fix this, we rearrange the logic to increment the line count, then see if we need to exit the loop. </p>
<p>NOTE this logic still isn’t perfect, can you spot the bug? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">lines++</span><br><span class="line">if err != nil &#123;</span><br></pre></td></tr></table></figure>
<p>break } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 29/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>But we’re not done checking errors yet. will return when it hits the end of the file. This is expected,                                  needs some way of saying stop, there is nothing more to read. So before we return the error to the caller of                                  , we need to check if the error was not io.EOF , and in that case propagate it up, otherwise we return nil to say that everything worked fine. </p>
<p>I think this is a good example of Russ Cox’s observation that error handling can obscure the operation of the function. Let’s look at an improved version. </p>
<p>ReadString </p>
<p>io.EOF </p>
<p>ReadString </p>
<p>CountLine </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    sc := bufio.NewScanner(r)</span><br><span class="line">    lines := 0</span><br><span class="line">    for sc.Scan() &#123;</span><br><span class="line">        lines++</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>This improved version switches from using bufio.Reader to bufio.Scanner . </p>
<p>Under the hood bufio.Scanner uses , but it adds a nice layer of abstraction which helps remove the error handling with obscured the operation of                                  . </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Reader</span><br></pre></td></tr></table></figure>
<p>CountLines </p>
<p>NOTE </p>
<p>The method, the body of our </p>
<p>bufio.Scanner can scan for any pattern, but by default it looks for newlines. </p>
<p>returns true if the scanner has matched a line of text and has not encountered an error. So, loop will be called only when there is a line of text in the scanner’s buffer. This means our revised </p>
<p>sc.Scan() </p>
<p>for </p>
<p>CountLines correctly handles the case where there is no trailing newline, and also handles the case where the file was empty. </p>
<p>Secondly, as sc.Scan returns false once an error is encountered, our for loop will exit when the end-of-file is reached or an error is encountered. The type memoises the first error it encountered and we can recover that error once we’ve exited the loop using the method. </p>
<p>Lastly, sc.Err() takes care of handling io.EOF and will convert it to a nil if the end of file was reached without encountering another error. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Scanner</span><br></pre></td></tr></table></figure>
<p>sc.Err() </p>
<p>TIP </p>
<p>When you find yourself faced with overbearing error handling, try to extract some of the operations into a helper type. </p>
<p>7.1.2. WriteResponse </p>
<p>My second example is inspired from the Errors are values blog post [10]. </p>
<p>Earlier in this presentation We’ve seen examples dealing with opening, writing and closing files. The error handling is present, but not overwhelming as the operations can be encapsulated in helpers like ioutil.ReadFile and </p>
<p>ioutil.WriteFile . However when dealing with low level network protocols it becomes necessary to build the response directly using I/O primitives the error handling can become repetitive. Consider this fragment of a HTTP server which is constructing the HTTP response. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 30/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>First we construct the status line using fmt.Fprintf , and check the error. Then for each header we write the header key and value, checking the error each time. Lastly we terminate the header section with an additional \r\n , check the error, and copy the response body to the client. Finally, although we don’t need to check the error from io.Copy , we need to translate it from the two return value form that io.Copy returns into the single return value that </p>
<p>WriteResponse returns.<br> That’s a lot of repetitive work. But we can make it easier on ourselves by introducing a small wrapper type, </p>
<p>errWriter . </p>
<p>errWriter fulfils the io.Writer contract so it can be used to wrap an existing io.Writer . errWriter passes writes through to its underlying writer until an error is detected. From that point on, it discards any writes and returns the previous error. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Header struct &#123;</span><br><span class="line">    Key, Value string</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status struct &#123;</span><br><span class="line">    Code   int</span><br><span class="line">    Reason string</span><br><span class="line">&#125;</span><br><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure>
<p>return err } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, h := range headers &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure>
<p>return err } </p>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if _, err := fmt.Fprint(w, &quot;\r\n&quot;); err != nil &#123;</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(w, body)</span><br></pre></td></tr></table></figure>
<p>return err } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 31/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Applying errWriter to WriteResponse dramatically improves the clarity of the code. Each of the operations no longer needs to bracket itself with an error check. Reporting the error is moved to the end of the function by inspecting the ew.err field, avoiding the annoying translation from `io.Copy’s return values. </p>
<p>7.2. Only handle an error once </p>
<p>Lastly, I want to mention that you should only handle errors once. Handling an error means inspecting the error value, and making a single decision. </p>
<p>If you make less than one decision, you’re ignoring the error. As we see here, the error from w.WriteAll is being discarded. </p>
<p>But making more than one decision in response to a single error is also problematic. The following is code that I come across frequently. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// WriteAll writes the contents of buf to the supplied writer.</span><br><span class="line">func WriteAll(w io.Writer, buf []byte) &#123;</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.Write(buf)</span><br><span class="line">type errWriter struct &#123;</span><br><span class="line">    io.Writer</span><br></pre></td></tr></table></figure>
<p>err error } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (e *errWriter) Write(buf []byte) (int, error) &#123;</span><br><span class="line">    if e.err != nil &#123;</span><br><span class="line">        return 0, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    var n int</span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    return n, nil</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    for _, h := range headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Fprint(ew, &quot;\r\n&quot;)</span><br><span class="line">io.Copy(ew, body)</span><br><span class="line">return ew.err</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Println(&quot;unable to write:&quot;, err) // annotated error goes to log file</span><br><span class="line">        return err                           // unannotated error returned to caller</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>return nil } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 32/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>In this example if an error occurs during , a line will be written to a log file, noting the file and line that the error occurred, and the error is also returned to the caller, who possibly will log it, and return it, all the way back up to the top of the program. </p>
<p>The caller is probably doing the same </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br></pre></td></tr></table></figure>
<p>return err } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">    log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>return nil } </p>
<p>GO </p>
<p>So you get a stack of duplicate lines in your log file, </p>
<p>but at the top of the program you get the original error without any context. </p>
<p>I want to dig into this a little further because I don’t see the problems with logging and returning as just a matter of personal preference. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br><span class="line">err := WriteConfig(f, &amp;conf)</span><br><span class="line">fmt.Println(err) // io.EOF</span><br><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">        // oops, forgot to return</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">        return err</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>return nil } </p>
<p>GO </p>
<p>The problem I see a lot is programmers forgetting to return from an error. As we talked about earlier, Go style is to use guard clauses, checking preconditions as the function progresses and returning early. </p>
<p>In this example the author checked the error, logged it, but forgot to return. This has caused a subtle bug. </p>
<p>w.Write </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 33/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>The contract for error handling in Go says that you cannot make any assumptions about the contents of other return values in the presence of an error. As the JSON marshalling failed, the contents of buf are unknown, maybe it contains nothing, but worse it could contain a 1/2 written JSON fragment. </p>
<p>Because the programmer forgot to return after checking and logging the error, the corrupt buffer will be passed to WriteAll , which will probably succeed and so the config file will be written incorrectly. However the function will </p>
<p>return just fine, and the only indication that a problem happened will be a single log line complaining about marshalling JSON, not a failure to write the config. </p>
<p>7.2.1. Adding context to errors </p>
<p>The bug occurred because the author was trying to add context to the error message. They were trying to leave themselves a breadcrumb to point them back to the source of the error. </p>
<p>Let’s look at another way to do the same thing using fmt.Errorf . </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not write config: %v&quot;, err)</span><br></pre></td></tr></table></figure>
<p>} </p>
<p>return nil } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;write failed: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>return nil } </p>
<p>GO </p>
<p>By combining the annotation of the error with returning onto one line there it is harder to forget to return an error and avoid continuing accidentally. </p>
<p>If an I/O error occurs writing the file, the error’s `Error() method will report something like this; could not write config: write failed: input/output error </p>
<p>7.2.2. Wrapping errors with github.com/pkg/errors </p>
<p>The fmt.Errorf pattern works well for annotating the error message, but it does so at the cost of obscuring the type of the original error. I’ve argued that treating errors as opaque values is important to producing software which is loosely coupled, so the face that the type of the original error should not matter if the only thing you do with an error value is </p>
<p>\1. Check that it is not nil . 2. Print or log it. </p>
<p>However there are some cases, I believe they are infrequent, where you do need to recover the original error. In that case you can use something like my errors package to annotate errors like this </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 34/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Now the error reported will be the nice K&amp;D [11] style error, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>
<p>and the error value retains a reference to the original cause. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;original error: %T %v\n&quot;, errors.Cause(err), errors.Cause(err))</span><br><span class="line">        fmt.Printf(&quot;stack trace:\n%+v\n&quot;, err)</span><br><span class="line">        os.Exit(1)</span><br></pre></td></tr></table></figure>
<p>} } </p>
<p>GO </p>
<p>Thus you can recover the original error and print a stack trace; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadFile(path string) ([]byte, error) &#123;</span><br><span class="line">    f, err := os.Open(path)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;open failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close()</span><br><span class="line">    buf, err := ioutil.ReadAll(f)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;read failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return buf, nil</span><br><span class="line">&#125;</span><br><span class="line">func ReadConfig() ([]byte, error) &#123;</span><br><span class="line">    home := os.Getenv(&quot;HOME&quot;)</span><br><span class="line">    config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;))</span><br><span class="line">    return config, errors.WithMessage(err, &quot;could not read config&quot;)</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br></pre></td></tr></table></figure>
<p>os.Exit(1) } </p>
<p>} </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 35/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Using the errors package gives you the ability to add context to error values, in a way that is inspectable by both a human and a machine. If you came to my presentation yesterday you’ll know that wrapping is moving into the standard library in an upcoming Go release. </p>
<p>\8. Concurrency </p>
<p>Often Go is chosen for a project because of its concurrency features. The Go team have gone to great lengths to make concurrency in Go cheap (in terms of hardware resources) and performant, however it is possible to use Go’s concurrency features to write code which is neither performent or reliable. With the time I have left I want to leave you with some advice for avoid some of the pitfalls that come with Go’s concurrency features. </p>
<p>Go features first class support for concurrency with channels, and the select and go statements. If you’ve learnt Go formally from a book or training course, you might have noticed that the concurrency section is always one of the last you’ll cover. This workshop is no different, I have chosen to cover concurrency last, as if it is somehow additional to the regular the skills a Go programmer should master. </p>
<p>There is a dichotomy here; Go’s headline feature is our simple, lightweight concurrency model. As a product, our language almost sells itself on this on feature alone. On the other hand, there is a narrative that concurrency isn’t actually that easy to use, otherwise authors wouldn’t make it the last chapter in their book and we wouldn’t look back on our formative efforts with regret. </p>
<p>This section discusses some pitfalls of naive usage of Go’s concurrency features. </p>
<p>8.1. Keep yourself busy or do the work yourself </p>
<p>What is the problem with this program? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 36/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>The program does what we intended, it serves a simple web server. However it also does something else at the same time, it wastes CPU in an infinite loop. This is because the for{} on the last line of main is going to block the main goroutine because it doesn’t do any IO, wait on a lock, send or receive on a channel, or otherwise communicate with the scheduler. </p>
<p>As the Go runtime is mostly cooperatively scheduled, this program is going to spin fruitlessly on a single CPU, and may eventually end up live-locked. </p>
<p>How could we fix this? Here’s one suggestion. </p>
<p>package main </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure>
<p>“net/http” </p>
<p>“runtime” ) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>}() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    runtime.Gosched()</span><br></pre></td></tr></table></figure>
<p>} } </p>
<p>GO </p>
<p>package main </p>
<p>GO </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure>
<p>“net/http” ) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>}() </p>
<p>for { </p>
<p>} } </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 37/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>This might look silly, but it’s a common common solution I see in the wild. It’s symptomatic of not understanding the underlying problem. </p>
<p>Now, if you’re a little more experienced with go, you might instead write something like this. </p>
<p>package main </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure>
<p>“net/http” ) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>}() </p>
<p>select {} } </p>
<p>GO </p>
<p>An empty select statement will block forever. This is a useful property because now we’re not spinning a whole CPU just to call runtime.GoSched() . However, we’re only treating the symptom, not the cause. </p>
<p>I want to present to you another solution, one which has hopefully already occurred to you. Rather than run<br> in a goroutine, leaving us with the problem of what to do with the main goroutine, simply run </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe</span><br><span class="line">http.ListenAndServe</span><br></pre></td></tr></table></figure>
<p>TIP </p>
<p>on the main goroutine itself. </p>
<p>If the main.main function of a Go program returns then the Go program will unconditionally exit no matter what other goroutines started by the program over time are doing. </p>
<p>package main </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure>
<p>“net/http” ) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure>
<p>} } </p>
<p>GO </p>
<p>So this is my first piece of advice: if your goroutine cannot make progress until it gets the result from another, oftentimes it is simpler to just do the work yourself rather than to delegate it. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 38/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>This often eliminates a lot of state tracking and channel manipulation required to plumb a result back from a goroutine to its initiator. </p>
<p>TIP </p>
<p>Many Go programmers overuse goroutines, especially when they are starting out. As with all things in life, moderation is the key the key to success. </p>
<p>8.2. Leave concurrency to the caller </p>
<p>What is the difference between these two APIs? </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ListDirectory returns the contents of dir.</span><br><span class="line">func ListDirectory(dir string) ([]string, error)</span><br><span class="line">// ListDirectory returns a channel over which</span><br><span class="line">// directory entries will be published. When the list</span><br><span class="line">// of entries is exhausted, the channel will be closed.</span><br><span class="line">func ListDirectory(dir string) chan string</span><br></pre></td></tr></table></figure>
<p>Firstly, the obvious differences; the first example reads a directory into a slice then returns the whole slice, or an error if something went wrong. This happens synchronously, the caller of ListDirectory blocks until all directory entries have been read. Depending on how large the directory, this could take a long time, and could potentially allocate a lot of memory building up the slide of directory entry names. </p>
<p>Lets look at the second example. This is a little more Go like, ListDirectory returns a channel over which directory entries will be passed. When the channel is closed, that is your indication that there are no more directory entries. As the population of the channel happens after ListDirectory returns, ListDirectory is probably starting a goroutine to populate the channel. </p>
<p>NOTE </p>
<p>Its not necessary for the second version to actually use a Go routine; it could allocate a channel sufficient to hold all the directory entries without blocking, fill the channel, close it, then return the channel to the caller. But this is unlikely, as this would have the same problems with consuming a large amount of memory to buffer all the results in a channel. </p>
<p>The channel version of ListDirectory has two further problems: </p>
<p>By using a closed channel as the signal that there are no more items to process there is no way for ListDirectory to tell the caller that the set of items returned over the channel is incomplete because an error was encountered partway through. There is no way for the caller to tell the difference between an empty directory and an error to read from the directory entirely. Both result in a channel returned from ListDirectory which appears to be closed immediately. </p>
<p>The caller must continue to read from the channel until it is closed because that is the only way the caller can know that the goroutine which was started to fill the channel has stopped. This is a serious limitation on the use of </p>
<p>ListDirectory , the caller has to spend time reading from the channel even though it may have received the answer it wanted. It is probably more efficient in terms of memory usage for medium to large directories, but this method is no faster than the original slice based method. </p>
<p>The solution to the problems of both implementations is to use a callback, a function that is called in the context of each directory entry as it is executed. </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 39/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Not surprisingly this is how the filepath.WalkDir function works. </p>
<p>If your function starts a goroutine you must provide the caller with a way to explicitly stop that TIP goroutine. It is often easier to leave decision to execute a function asynchronously to the caller of </p>
<p>that function. </p>
<p>8.3. Never start a goroutine without when it will stop. </p>
<p>The previous example showed using a goroutine when one wasn’t really necessary. But one of the driving reasons for using Go is the first class concurrency features the language offers. Indeed there are many instances where you want to exploit the parallelism available in your hardware. To do so, you must use goroutines. </p>
<p>This simple application serves http traffic on two different ports, port 8080 for application traffic and port 8001 for access to the /debug/pprof endpoint. </p>
<p>package main </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br></pre></td></tr></table></figure>
<p>“net/http” </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    _ &quot;net/http/pprof&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux) // debug</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)                       // app traffic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GO </p>
<p>Although this program isn’t very complicated, it represents the basis of a real application. </p>
<p>There are a few problems with the application as it stands which will reveal themselves as the application grows, so lets address a few of them now. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ListDirectory(dir string, fn func(string))</span><br></pre></td></tr></table></figure>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 40/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>By breaking the serveApp and serveDebug handlers out into their own functions we’ve decoupled them from main.main . We’ve also followed the advice from above and make sure that serveApp and serveDebug leave their </p>
<p>concurrency to the caller. </p>
<p>But there are some operability problems with this program. If serveApp returns then main.main will return causing the program to shutdown and be restarted by whatever process manager you’re using. </p>
<p>TIP </p>
<p>Just as functions in Go leave concurrency to the caller, applications should leave the job of monitoring their status and restarting them if they fail to the program that invoked them. Do not make your applications responsible for restarting themselves, this is a procedure best handled from outside the application. </p>
<p>However, serveDebug is run in a separate goroutine and if it returns just that goroutine will exit while the rest of the program continues on. Your operations staff will not be happy to find that they cannot get the statistics out of your application when they want too because the /debug handler stopped working a long time ago. </p>
<p>What we want to ensure is that if any of the goroutines responsible for serving this application stop, we shut down the application. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() &#123;</span><br><span class="line">    http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br></pre></td></tr></table></figure>
<p>serveApp() } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 41/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Now serverApp and serveDebug check the error returned from ListenAndServe and call if required. Because both handlers are running in goroutines, we park the main goroutine in a . </p>
<p>This approach has a number of problems: </p>
<p>\1. If ListenAndServer returns with a nil error, log.Fatal won’t be called and the HTTP service on that port will shut down without stopping the application. </p>
<p>\2. log.Fatal calls os.Exit which will unconditionally exit the program; defers won’t be called, other goroutines won’t be notified to shut down, the program will just stop. This makes it difficult to write tests for those functions. </p>
<p>TIP Only use log.Fatal from main.main or init functions. </p>
<p>What we’d really like is to pass any error that occurs back to the originator of the goroutine so that it can know why the goroutine stopped, can shut down the process cleanly. </p>
<p>log.Fatal </p>
<p>select{} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure>
<p>} } </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func serveDebug() &#123;</span><br><span class="line">    if err := http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br><span class="line">    go serveApp()</span><br></pre></td></tr></table></figure>
<p>select {} } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 42/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>We can use a channel to collect the return status of the goroutine. The size of the channel is equal to the number of goroutines we want to manage so that sending to the done channel will not block, as this will block the shutdown the of goroutine, causing it to leak. </p>
<p>As there is no way to safely close the done channel we cannot use the for range idiom to loop of the channel until all goroutines have reported in, instead we loop for as many goroutines we started, which is equal to the capacity of the channel. </p>
<p>Now we have a way to wait for each goroutine to exit cleanly and log any error they encounter. All that is needed is a way to forward the shutdown signal from the first goroutine that exits to the others. </p>
<p>It turns out that asking a http.Server to shut down is a little involved, so I’ve spun that logic out into a helper function. The serve helper takes an address and http.Handler , similar to http.ListenAndServe , and also a stop channel which we use to trigger the Shutdown method. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() error &#123;</span><br><span class="line">    return http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug()</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp()</span><br></pre></td></tr></table></figure>
<p>}() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>} } </p>
<p>GO </p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 43/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<p>Now, each time we receive a value on the channel, we close the stop channel which causes all the goroutines waiting on that channel to shut down their . This in turn will cause all the remaining ListenAndServe goroutines to return. Once all the goroutines we started have stopped, main.main returns and the process stops cleanly. </p>
<p>done </p>
<p>http.Server </p>
<p>TIP </p>
<p>Writing this logic yourself is repetitive and subtle. Consider something like this package, <a href="https://github.com/heptio/workgroup" target="_blank" rel="noopener">https://github.com/heptio/workgroup</a> which will do most of the work for you. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func serve(addr string, handler http.Handler, stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    s := http.Server&#123;</span><br></pre></td></tr></table></figure>
<p>Addr: addr, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Handler: handler,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">    &lt;-stop // wait for stop signal</span><br><span class="line">    s.Shutdown(context.Background())</span><br></pre></td></tr></table></figure>
<p>}() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">func serveApp(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return serve(&quot;0.0.0.0:8080&quot;, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    return serve(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux, stop)</span><br></pre></td></tr></table></figure>
<p>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    stop := make(chan struct&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug(stop)</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp(stop)</span><br></pre></td></tr></table></figure>
<p>}() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stopped bool</span><br><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if !stopped &#123;</span><br><span class="line">        stopped = true</span><br><span class="line">        close(stop)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>} } </p>
<p>GO </p>
<ul>
<li>下面是David给出的一下关于go的学习参考资料的链接：</li>
</ul>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 44/45 </p>
<p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p>
<ol>
<li><p><a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">https://gaston.life/books/effective-programming/</a></p>
</li>
<li><p><a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">https://talks.golang.org/2014/names.slide#4</a></p>
</li>
<li><p><a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p>
</li>
<li><p><a href="https://www.lysator.liu.se/c/pikestyle.html" target="_blank" rel="noopener">https://www.lysator.liu.se/c/pikestyle.html</a></p>
</li>
<li><p><a href="https://speakerdeck.com/campoy/understanding-nil" target="_blank" rel="noopener">https://speakerdeck.com/campoy/understanding-nil</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=Ic2y6w8lMPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p>
</li>
<li><p><a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p>
</li>
<li><p><a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="noopener">https://golang.org/doc/go1.4#internalpackages</a></p>
</li>
<li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p>
</li>
<li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p>
</li>
<li><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
</li>
<li><p><a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p>
</li>
<li><p><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a></p>
</li>
<li><p><a href="http://www.gopl.io/" target="_blank" rel="noopener">http://www.gopl.io/</a></p>
</li>
</ol>
<hr>

      
    </div>
    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #555;font-size:14px;">-------------The End-------------</div>
    
</div>

  
</div>

<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/">上海QCon之Go专家David Cheney关于GO最佳实践的演讲</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 cloud sjhan 的个人博客">cloud sjhan</a></p>
  <p><span>发布时间:</span>2018年10月21日 - 22:10</p>
  <p><span>最后更新:</span>2018年10月21日 - 22:10</p>
  <p><span>原始链接:</span><a href="/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/" title="上海QCon之Go专家David Cheney关于GO最佳实践的演讲">https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
	});
    });  
</script>


      
</div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="cloud sjhan 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="cloud sjhan 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/GO-QCon-技术分享/" rel="tag"><i class="fa fa-tag"></i> GO QCon 技术分享</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
                <div style="color: rgba(0, 0, 0, 0.75); font-size:13px; letter-spacing:3px">(&gt;给这篇博客打个分吧&lt;)</div>
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/21/技术周刊之改善-Python-程序的-91-个建议（转载/" rel="next" title="技术周刊之改善 Python 程序的 91 个建议（转载)">
                <i class="fa fa-chevron-left"></i> 技术周刊之改善 Python 程序的 91 个建议（转载)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/25/golang中string-rune-byte的关系/" rel="prev" title="golang中string,rune,byte的关系">
                golang中string,rune,byte的关系 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTAyOS8xNTU1Ng=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="cloud sjhan" />
            
              <p class="site-author-name" itemprop="name">cloud sjhan</p>
              <p class="site-description motion-element" itemprop="description">关于技术，关于生活</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hantmac" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hantmac@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/韩山杰" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/u012421976" title="CSDN" target="_blank">CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.w3school.com.cn/" title="w3school" target="_blank">w3school</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://search.chongbuluo.com/" title="快搜" target="_blank">快搜</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cloud sjhan</span>

  
</div>








  <div class="footer-custom">stay hungry,stay foolish</div>
<div class="theme-info">
  <span class="post-count">Total Words:121.9k</span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("pJYxhylrFRaJscWTtFKMbPF7-gzGzoHsz", "SEOPiaT1ePi7gsc6bgpATqHB");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: 13320,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>;
<script>
$("body").backstretch("http://img18.3lian.com/d/file/201712/22/825586b224a321673396fa65620548e6.png");
</script>
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>

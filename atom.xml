<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cloud world</title>
  
  <subtitle>To be A geek</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cloudsjhan.github.io/"/>
  <updated>2024-06-08T15:58:31.649Z</updated>
  <id>https://cloudsjhan.github.io/</id>
  
  <author>
    <name>cloud sjhan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速吃透 Golang Channels</title>
    <link href="https://cloudsjhan.github.io/2024/06/08/%E5%BF%AB%E9%80%9F%E5%90%83%E9%80%8F-Golang-Channels/"/>
    <id>https://cloudsjhan.github.io/2024/06/08/快速吃透-Golang-Channels/</id>
    <published>2024-06-08T15:57:11.000Z</published>
    <updated>2024-06-08T15:58:31.649Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>Golang 可以通过启动 goroutines 来并发执行任务。它们可以通过一种名为 “通道”的通信媒介相互通信。话不多说，下面我列举了几种不同情况下 channel 的使用以及其适用条件，最后总结出一张 channel table，能够帮助你快速吃透 channel 的所有要点。Let’t go!</p><h3 id="Nil-Channels"><a href="#Nil-Channels" class="headerlink" title="Nil Channels"></a>Nil Channels</h3><p>如果你像创建普通变量一样创建一个通道，通道将被初始化为零值。这里要提到的另一个重要细节是，通道的发送方和接收方都必须做好通信准备，否则我们将收到一个死锁错误。这可以通过缓冲通道来避免，我们将在后面讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: Deadlock</span><br><span class="line">func nilChannel() &#123;</span><br><span class="line"> var ch chan int</span><br><span class="line"></span><br><span class="line">// creating a goroutine and sending value on the channel</span><br><span class="line"> go func() &#123;</span><br><span class="line">  ch &lt;- 1</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在 main 中调用这个函数，你会得到以下错误和一些其他信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure></p><p>这是因为我们试图在往 nil channel上发送一个值，这是坚决不允许的操作。</p><h3 id="Empty-Channel"><a href="#Empty-Channel" class="headerlink" title="Empty Channel"></a>Empty Channel</h3><p>在以下代码中，我们将收到同样的死锁错误，因为我们正试图在 channel receiver 尚未准备好的通道上发送值。从下面的代码中可以看到，在接收器创建之前，值就已经在通道上发送了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: Deadlock</span><br><span class="line">func emptyChannel() &#123;</span><br><span class="line"> var ch = make(chan int)</span><br><span class="line"></span><br><span class="line"> ch &lt;- 1</span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UN-Buffered-Channel"><a href="#UN-Buffered-Channel" class="headerlink" title="UN Buffered Channel"></a>UN Buffered Channel</h3><p>错误的代码已经够多了。这次让我给出一个有效的代码。在下面的代码中，我们编写了与上一个示例相同的代码，但不是创建一个 nil 通道，而是使用 make 函数创建了一个用默认值初始化的通道。 不过，如果在这种情况下没有接收器，就会错过结果，但不会产生死锁错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: send single value through goroutine</span><br><span class="line">func simpleChannel() &#123;</span><br><span class="line"> var ch = make(chan int)</span><br><span class="line"></span><br><span class="line"> go func() &#123;</span><br><span class="line">  ch &lt;- 1</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line">// NOTE: if you comment this line. You will not be able to receive the result but code will not crash</span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Channel-方向"><a href="#Channel-方向" class="headerlink" title="Channel 方向"></a>Channel 方向</h3><p>默认情况下通道是双向的。下面的代码显示了一个只能用于发送值的通道。如果我们试图从中获取值，就会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func uniDirectionalChannel() &#123;</span><br><span class="line">// Bidirectional [outside goroutine]</span><br><span class="line"> var ch = make(chan int)</span><br><span class="line"></span><br><span class="line"> go func(ch chan&lt;- int) &#123;</span><br><span class="line"> // unidirectinal [within goroutine]</span><br><span class="line">  ch &lt;- 1</span><br><span class="line"> &#125;(ch)</span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Buffered-Channel"><a href="#Buffered-Channel" class="headerlink" title="Buffered Channel"></a>Buffered Channel</h3><p>这些通道可以像数组一样容纳多个值，因此在非缓冲通道中，如果我们尝试在没有接收器的情况下向其写入数据，就会出错，但在缓冲通道中，我们可以向其写入数据，直到缓冲区满为止。当缓冲区已满时，如果我们尝试向其中写入新值，就会出错。<br>如果我们这里不注释该函数的最后一行，就会出现死锁错误，因为这里将从空通道读取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// using buffered channel</span><br><span class="line">func bufferdChannelWithoutLoop() &#123;</span><br><span class="line"> var ch = make(chan int, 2)</span><br><span class="line"></span><br><span class="line"> ch &lt;- 1</span><br><span class="line"> ch &lt;- 2</span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line"> fmt.Println(&lt;-ch)</span><br><span class="line"> // fmt.Println(&lt;-ch) // NOTE: Deadlock, Reading from empty channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从通道读取数值还有另一种方法，即使用循环。在前面的示例中，我们逐个读取数值，但我们也可以通过循环读取接收通道中的数值，因此每当通道中发送一个新数值时，循环就会迭代，执行完正文中的代码后，就会等待下一个数值。如果接收器试图读取，但通道上已没有其他值，则会出现同样的死锁错误。</p><p>开发人员的职责是在通道使用后将其关闭，因为如果接收器试图读取已经关闭的通道，就会出现上述死锁问题。</p><h3 id="Channels-Table"><a href="#Channels-Table" class="headerlink" title="Channels Table"></a>Channels Table</h3><p>我们已经讨论了通道的所有情况，但怎么才能快速记住它们呢？ 别紧张😎，有我在，下表可以作为快速指南，对照着表盘一下我们写的 channel 就能避免出现死锁，并显示它们在不同情况下的行为。</p><p><img src="https://files.mdnice.com/user/4760/36cd608c-5f74-4aae-8baa-e0924b74f31b.png" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang GC 基础: 三色标记清除和 STW</title>
    <link href="https://cloudsjhan.github.io/2024/06/06/Golang-GC-%E5%9F%BA%E7%A1%80-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%92%8C-STW/"/>
    <id>https://cloudsjhan.github.io/2024/06/06/Golang-GC-基础-三色标记清除和-STW/</id>
    <published>2024-06-06T08:54:11.000Z</published>
    <updated>2024-06-06T08:54:34.697Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>今天大家讨论一下 Golang 中垃圾回收的一些基础知识，这些知识往往让人难以理解。要知道，在垃圾回收过程中，Go 会首先:<br>（1）将根对象标记为灰色，<br>（2）然后将它们自己标记为黑色，将它们的后代标记为灰色，<br>（3）最后删除剩余的（白色）对象。<br>这就是所谓的标记和清除。但为什么我们需要三种颜色呢？为什么不是两种呢？让我们在下文中进一步讨论这个问题，并确定 STW (stop the world)的实际开销。</p><h3 id="标记和清除"><a href="#标记和清除" class="headerlink" title="标记和清除"></a>标记和清除</h3><p>如果 GC 的全部任务都归结为标记不能删除的对象和删除未标记的对象，那么为什么不使用双色算法呢？事实上，我们可以简单地用黑色标记所有可到达的对象，然后删除白色的对象。</p><p><img src="https://files.mdnice.com/user/4760/c0fc2f94-81fc-439a-ade4-8c3da5ec3970.png" alt=""></p><p>这一切似乎都合乎逻辑，但现在我们决定让垃圾回收器增量运行，也就是说，我们赋予它将标记阶段分成几个低延迟阶段的能力。</p><p><img src="https://files.mdnice.com/user/4760/18b600b8-5659-4511-9b50-83a3bbc46e52.png" alt=""><br>如图所示，在第一阶段，我们首先将节点 1 标记为黑色，然后查找该节点的连接，找到节点 2，并将其也标记为黑色。然后，标记暂停，给应用程序一点 CPU 时间来执行其主要任务。最后，我们进入第二阶段标记。由于没有灰色/黑色之分，我们不知道节点 1 的引用是否已被检查过，因此必须再次检查。算法最终很可能会完成，但不能保证它会在程序本身完成之前完成（导致 OOM）。</p><p>为了解决这个问题，我们增加了一个不变量：黑色物体应被视为扫描对象。</p><p>这个算法似乎是有效的，即使在增量垃圾回收的情况下也能正确终止。但有一个问题却打破了一切：在这种天真版本的标记和清扫算法的整个运行过程中，我们必须保持程序处于 “STW”状态。</p><h3 id="如果在没有-STW-的情况下进行标记和清扫，会发生什么情况？"><a href="#如果在没有-STW-的情况下进行标记和清扫，会发生什么情况？" class="headerlink" title="如果在没有 STW 的情况下进行标记和清扫，会发生什么情况？"></a>如果在没有 STW 的情况下进行标记和清扫，会发生什么情况？</h3><p><img src="https://files.mdnice.com/user/4760/5f390365-4631-4d39-8daf-7464b6d4500c.png" alt=""></p><p>正如你所看到的，在这两个标记阶段之间，已经添加了许多新对象，但我们并没有标记表明需要对它们进行扫描。这就导致了内存泄漏。唯一的解决办法就是禁止我们的程序（突变器）在垃圾回收器运行时进行任何更改。</p><h3 id="三色标记和清扫是如何实现并发垃圾回收的？"><a href="#三色标记和清扫是如何实现并发垃圾回收的？" class="headerlink" title="三色标记和清扫是如何实现并发垃圾回收的？"></a>三色标记和清扫是如何实现并发垃圾回收的？</h3><p>正如我们之前所发现的，在标记和扫描算法中，我们遇到了 “世界停止”（STW）的问题。不过，如果我们引入一个额外的标记 “未扫描但不符合删除条件”（灰色），STW 问题就会自动解决！</p><p>需要注意的是，在 Golang 中，GC 不仅是增量式的，而且是并发式的。其逻辑与增量方法相同–GC 工作被分为不同的部分，但它们不是按顺序执行，而是由后台工作者并发执行。</p><p>下面是 Golang 中的三色标记：<br><img src="https://files.mdnice.com/user/4760/8fd19e35-2603-4ff2-ae18-30aead44df37.png" alt=""></p><p>我们将黑色节点引用但尚未扫描的对象标记为灰色节点。让我们看看这如何帮助我们消除 STW。</p><p><img src="https://files.mdnice.com/user/4760/ba5d3b17-d581-494a-bea0-2289bb201056.png" alt=""></p><p>新添加的对象会被标记为灰色，并由 gcBgMarkWorker2 或其他可用的工作程序进行扫描。这并不能完全消除对 STW 的需求，但会大大减少花费在 STW 上的时间。至少在标记阶段，我们不需要让世界停止运行，以防止堆发生变化。接下来，我们将深入探讨 Golang 中仍会出现的特定 STW。</p><h3 id="“Stop-the-world”-in-Go-is-not-a-problem"><a href="#“Stop-the-world”-in-Go-is-not-a-problem" class="headerlink" title="“Stop the world” in Go is not a problem"></a>“Stop the world” in Go is not a problem</h3><p>其实，仔细想想，在 99% 的情况下，这都与你无关。垃圾回收器的主要工作与程序的执行同时进行，而 STW 在两个阶段之间发生的时间很短：</p><ul><li>从扫频过渡到标记（扫频终止）。</li><li>从标记过渡到扫描（标记终止）。</li></ul><p>在这两种情况下，世界的停顿都是为了下一阶段做准备：启动 Worker、清除 P 缓存（用 Go 调度器术语来说就是处理器）、等待清扫阶段完成（对于在运行时启动垃圾回收的同时从程序代码中触发 runtime.GC()的情况）、设置/取消写入障碍–而这一切都与已分配对象的数量无关。</p><p>如果你分配了 1 兆字节，然后开始分配千兆字节的对象，这并不意味着 STW 会按比例增长，因为 STW 只在下一个标记或扫描阶段的初始化过程中短暂需要。该数据数组的实际标记和扫描是在后台进行的。</p><p>STW 的持续时间取决于所涉及的 P 的数量和 goroutines 的数量，并与管理其状态的需要有关。STW 不受堆上分配数量的影响。</p><p>世界只在两个短时间内停止：标记终止和扫描终止。标记和扫描在后台进行，不会阻塞应用程序。</p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>这里做一个简单的测试，测试两种分配小对象的情况。我使用 env GOGC=off 禁用了垃圾回收器，并在每次测试结束时直接调用 runtime.GC() 来触发垃圾回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func Test1000Allocs(t *testing.T) &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">       for &#123;</span><br><span class="line">          i := 123</span><br><span class="line">          reader(&amp;i)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 1000; i++ &#123;</span><br><span class="line">       ii := i</span><br><span class="line">       i = *reader(&amp;ii)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test10000000000Allocs(t *testing.T) &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">       for &#123;</span><br><span class="line">          i := 123</span><br><span class="line">          reader(&amp;i)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10000000000; i++ &#123;</span><br><span class="line">       ii := i</span><br><span class="line">       i = *reader(&amp;ii)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func reader(i *int) *int &#123;</span><br><span class="line">    ii := i</span><br><span class="line">    return ii</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行每个测试时都启用了跟踪信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GOGC=off go test -run=Test1000Allocs -trace=trace1.out</span><br><span class="line">GOGC=off go test -run=Test10000000000Allocs -trace=trace2.out</span><br><span class="line">go tool trace trace1.out</span><br><span class="line">go tool trace trace2.out</span><br></pre></td></tr></table></figure><p>Test1000Allocs</p><p><img src="https://files.mdnice.com/user/4760/36f28032-0aea-4d2d-90ab-9c5fdcb04cc8.png" alt=""></p><p>Test10000000000Allocs</p><p><img src="https://files.mdnice.com/user/4760/50d734c8-f479-4514-8d8d-323309f6c1e2.png" alt=""></p><p>Test10000000000Allocs<br><img src="https://files.mdnice.com/user/4760/fd736e5e-ee33-4e58-a116-a9980657d45b.png" alt=""></p><p>在 Test1000Allocs 测试的扫描终止阶段，STW 为 80384 ns。测试 10000000000Allocs 时为 88384 ns。有区别吗？我也没发现。</p><p>在 Test1000Allocs 测试的标记终止阶段，STW 为 87616 ns。测试 10000000000Allocs 时为 120128 毫微秒。这里的差异更为明显，但我们谈论的还是毫秒级的微小差异。在 GC 运行的大部分时间里，我们的程序成功并行运行。</p><p>在分配数量多、GOGC 值低的情况下，这些带有小 STW 阶段的短 GC 循环可能会频繁出现，并可能被视为一个问题。由于我禁用了 GC，并且只通过直接调用触发了一次，所以测试有点像是合成的。但这恰恰说明，有时值得考虑所选的 GOGC 值。</p><p>总之，Golang 中的垃圾回收器显然是并发运行的，在大多数情况下，STW 时的停顿都是可以忽略不计的问题。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 Golang 构建你的第一个 k8s Operator</title>
    <link href="https://cloudsjhan.github.io/2024/06/03/%E4%BD%BF%E7%94%A8-Golang-%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-k8s-Operator/"/>
    <id>https://cloudsjhan.github.io/2024/06/03/使用-Golang-构建你的第一个-k8s-Operator/</id>
    <published>2024-06-03T14:09:30.000Z</published>
    <updated>2024-06-03T14:10:30.865Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>使用 Golang 构建你的第一个 k8s Operator</p><p>本文将展示如何使用 <a href="https://github.com/operator-framework/operator-sdk" title="operator sdk" target="_blank" rel="noopener">Operator SDK</a> 搭建一个基本的 k8s Operator。在本文中，您将了解如何创建一个新项目，并通过创建自定义资源定义 (CRD) 和基本控制器来添加 API。</p><p>我们将在 CRD 中添加字段，以包含一些有关期望状态和实际状态的信息，修改控制器以调和新资源的实例，然后将 operator 部署到 Kubernetes 集群。</p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul><li>安装 Operator-sdk v1.5.0+</li><li>安装 Kubectl v1.17.0+</li><li>一个 Kubernetes 集群以及其管理访问权限</li><li>安装 Docker v3.2.2+ 版本</li><li>安装 Golang v1.16.0+ 版本</li></ul><h3 id="Step-1-Create-a-project"><a href="#Step-1-Create-a-project" class="headerlink" title="Step 1: Create a project"></a>Step 1: Create a project</h3><p>建一个目录，并初始化一个 operator 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir memcached-operator</span><br><span class="line">$ cd memcached-operator</span><br><span class="line">$ operator-sdk init --domain=example.com --repo=github.com/example/memcached-operator</span><br><span class="line">Writing scaffold for you to edit...</span><br><span class="line">Get controller runtime:</span><br><span class="line">$ go get sigs.k8s.io/controller-runtime@v0.7.0</span><br><span class="line">Update go.mod:</span><br><span class="line">$ go mod tidy</span><br><span class="line"></span><br><span class="line">Running make:</span><br><span class="line">$ make</span><br><span class="line">go: creating new go.mod: module tmp</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.4.1</span><br><span class="line">go: found sigs.k8s.io/controller-tools/cmd/controller-gen in sigs.k8s.io/controller-tools v0.4.1</span><br><span class="line">/Users/username/workspace/projects/memcached-operator/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go build -o bin/manager main.go</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator-sdk init — domain=example.com — repo=github.com/example/memcached-operator</span><br></pre></td></tr></table></figure><ul><li>domin 用于 operator 创建的任何 API Group，因此这里的 API Group 是 *.example.com。</li></ul><p>大家可能熟悉的一个 API Group 是 rbac.authorization.k8s.io，创建 RBAC 资源（如 ClusterRoles 和 ClusterBindings）的功能通常就设置在 Kubernetes 集群上。operator-sdk 允许您指定一个自定义域，将其附加到您定义的任何 API 组，以帮助避免名称冲突。</p><p>这里使用的 –repo 值只是一个示例。如果你想提交项目并保留它，可以将其设置为你可以访问的 Git 仓库。</p><p>项目初始化后会生生一个 Operator 项目的壳子，我们剩下的工作就是在这个框架之上，实现 operator 的功能。</p><h3 id="Step-2-Create-an-API"><a href="#Step-2-Create-an-API" class="headerlink" title="Step 2: Create an API"></a>Step 2: Create an API</h3><p>使用 <code>create</code> 命令生成 CRD 和控制器：</p><blockquote><p>注意：–version 标志针对的是操作符的 Kubernetes API 版本，而不是语义版本。因此，请勿在 –version 中使用 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ operator-sdk create api --group cache --version v1alpha1 --kind Memcached --resource=true --controller=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writing scaffold for you to edit...</span><br><span class="line">api/v1alpha1/memcached_types.go</span><br><span class="line">controllers/memcached_controller.go</span><br><span class="line">Running make:</span><br><span class="line"></span><br><span class="line">$ make</span><br><span class="line">/Users/username/workspace/projects/memcached-operator/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;</span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go build -o bin/manager main.go</span><br></pre></td></tr></table></figure><p><code>--group</code> 是自定义资源所在的组，因此它最终会出现在 API Group “cache.example.com “中。</p><p><code>--version</code> 决定 API Group 的版本。可以使用不同的版本连续升级自定义资源。</p><p><code>-resource</code> 和 <code>--controller</code> 标志设置为 “true”，以便为这两样东西生成脚手架。</p><p>现在我们已经有了组件的轮廓，让我们开始用实际功能来填充它们。<br>首先是 CRD。在 <code>api/v1alpha1/memcached_types.go</code> 中，您应该能看到一些定义自定义资源类型规格和状态的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!</span><br><span class="line">// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.</span><br><span class="line">// MemcachedSpec defines the desired state of Memcached</span><br><span class="line">type MemcachedSpec struct &#123;</span><br><span class="line">    // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span><br><span class="line">    // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line">    // Foo is an example field of Memcached. Edit Memcached_types.go to remove/update</span><br><span class="line">    Foo string `json:&quot;foo,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line">// MemcachedStatus defines the observed state of Memcached</span><br><span class="line">type MemcachedStatus struct &#123;</span><br><span class="line">    // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span><br><span class="line">    // Important: Run &quot;make&quot; to regenerate code after modifying this file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意文件顶部的信息。该文件是由 Operator-SDK 搭建的脚手架，我们可以根据自己的项目需求去修改。<br><code>Spec</code> 包含指定资源所需状态的信息，而 Status 则包含系统的可观测状态，尤其是其他资源可能想要使用的信息。这些 Golang 结构与 Kubernetes 用户为创建自定义资源类型实例而编写的 YAML 直接对应。</p><p>让我们为类型添加一些基本字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// MemcachedSpec defines the desired state of Memcached</span><br><span class="line">type MemcachedSpec struct &#123;</span><br><span class="line">    // +kubebuilder:validation:Minimum=0</span><br><span class="line">    // Size is the size of the memcached deployment</span><br><span class="line">    Size int32 `json:&quot;size&quot;`</span><br><span class="line">&#125;</span><br><span class="line">// MemcachedStatus defines the observed state of Memcached</span><br><span class="line">type MemcachedStatus struct &#123;</span><br><span class="line">    // Nodes are the names of the memcached pods</span><br><span class="line">    Nodes []string `json:&quot;nodes&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Size</code> 是一个整数，用于确定 Memcached 集群中的节点数量。我们在 Status 中添加了一个字符串数组，用于存储集群中包含的节点的 IP 地址。需要注意的是，这个特定的实现方式只是一个示例。<br>注意父 Memcached 结构 Status 字段的 Kubebuilder 子资源标记。这将在生成的 CRD 清单中添加 Kubernetes 状态子资源。这样，控制器就可以只更新状态字段，而无需更新整个对象，从而提高性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Memcached is the Schema for the memcacheds API</span><br><span class="line">// +kubebuilder:subresource:status</span><br><span class="line">type Memcached struct &#123;</span><br><span class="line">    metav1.TypeMeta   `json:&quot;,inline&quot;`</span><br><span class="line">    metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`</span><br><span class="line">    Spec   MemcachedSpec   `json:&quot;spec,omitempty&quot;`</span><br><span class="line">    Status MemcachedStatus `json:&quot;status,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改 types.go 文件后，应始终在项目根目录下运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make generate</span><br></pre></td></tr></table></figure></p><p>此 make target 会调用 controller-gen 更新 api/v1alpha1/zz_generated.deepcopy.go，使其包含您刚刚添加的字段的必要实现。完成更新后，我们应运行以下命令为 CRD 生成 YAML 清单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make manifests</span><br></pre></td></tr></table></figure><p>会生成以下文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">New:</span><br><span class="line">        config/crd/bases/cache.example.com_memcacheds.yaml</span><br><span class="line">        config/rbac/role.yaml</span><br></pre></td></tr></table></figure><p>config/crd/bases/cache.example.com_memcacheds.yaml 是 memcached CRD 的清单。config/rbac/role.yaml 是 RBAC 清单，其中包含控制器所需的管理 memcached 类型的权限。</p><h3 id="Step-3-Create-a-controller"><a href="#Step-3-Create-a-controller" class="headerlink" title="Step 3: Create a controller"></a>Step 3: Create a controller</h3><p>让我们看看 controllers/memcached_controller.go 中目前包含的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span><br><span class="line">// move the current state of the cluster closer to the desired state.</span><br><span class="line">// TODO(user): Modify the Reconcile function to compare the state specified by</span><br><span class="line">// the Memcached object against the actual cluster state, and then</span><br><span class="line">// perform operations to make the cluster state reflect the state specified by</span><br><span class="line">// the user.</span><br><span class="line">//// For more details, check Reconcile and its Result here:</span><br><span class="line">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.7.0/pkg/reconcile</span><br><span class="line">func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) &#123;</span><br><span class="line">    _ = r.Log.WithValues(&quot;memcached&quot;, req.NamespacedName)</span><br><span class="line">    // your logic here</span><br><span class="line">    return ctrl.Result&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Reconcile</code> 方法负责将自定义资源状态中包含的期望状态与系统上运行的实际状态进行核对，也是实现控制器逻辑的主要部分。实现调和循环的具体细节超出了本教程的范围，将在进阶的文章中介绍。现在，请用此参考实现替换 controllers/memcached_controller.go。注意，如果你在初始化项目时指定了不同的 repo，可能需要更改 github.com/example/memcached-operator/api/v1alpha1 的导入路径，以便正确指向你定义 memcached_types.goin 的目录。粘贴后，确保重新生成清单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make manifests</span><br></pre></td></tr></table></figure><h3 id="Step-4-Build-and-deploy-your-operator"><a href="#Step-4-Build-and-deploy-your-operator" class="headerlink" title="Step 4: Build and deploy your operator"></a>Step 4: Build and deploy your operator</h3><p>现在您已经填写了所有需要的组件，是时候部署 operator 了！一般来说，有三种不同的方法来部署：</p><ul><li>作为在 Kubernetes 集群外执行的程序。这样做可能是出于开发目的，也可能是出于集群中数据的安全考虑。Makefile 包含目标 make install run，用于在本地运行运算符，但这种方法不是这里的重点。</li><li><p>作为 Kubernetes 集群内的部署运行。这就是我现在要向你展示的内容。</p></li><li><p>由 operator 生命周期管理器部署和管理。建议在生产中使用，因为 OLM 具有管理和升级运行中的 operator 的附加功能。</p></li></ul><p>现在，先构建并推送控制器的 Docker image。本示例使用了基础 Dockerfile，但你也可以根据自己的需要进行修改。我使用 Docker Hub 作为镜像仓库，但你能推/拉访问的任何仓库都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export USERNAME=&lt;docker-username&gt;</span><br><span class="line">$ make docker-build docker-push IMG=docker.io/$USERNAME/memcached-operator:v1.0.0</span><br></pre></td></tr></table></figure><p>如果出现如下错误，则可能需要获取其他依赖项。运行建议的命令下载依赖项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/controllers: package k8s.io/api/apps/v1 imported from implicitly required module; to add missing requirements, run:</span><br><span class="line">    go get k8s.io/api/apps/v1@v0.19.2</span><br></pre></td></tr></table></figure></p><p>我们还可以在 Makefile 中设置镜像的默认名称和标签。镜像构建完成后，就可以部署 operator 了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make deploy IMG=docker.io/$USERNAME/memcached-operator:v1.0.0</span><br></pre></td></tr></table></figure></p><p>它使用 config/ 中的清单创建 CRD，在 Pod 中部署控制器，创建控制器管理 CRD 所需的 RBAC 角色，并将其分配给控制器。让我们来看看。<br>我们的 CRD 类型为 memcacheds.cache.example.com：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get crds</span><br><span class="line">NAME                                          CREATED AT</span><br><span class="line">catalogsources.operators.coreos.com           2021-01-22T00:13:22Z</span><br><span class="line">clusterserviceversions.operators.coreos.com   2021-01-22T00:13:22Z</span><br><span class="line">installplans.operators.coreos.com             2021-01-22T00:13:22Z</span><br><span class="line">memcacheds.cache.example.com                   2021-02-06T00:52:38Z</span><br><span class="line">operatorgroups.operators.coreos.com           2021-01-22T00:13:22Z</span><br><span class="line">rbacsyncs.ibm.com                             2021-01-22T00:08:59Z</span><br><span class="line">subscriptions.operators.coreos.com            2021-01-22T00:13:22Z</span><br></pre></td></tr></table></figure></p><p>运行控制器的部署和 Pod：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --namespace memcached-operator-system get deployments</span><br><span class="line">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">memcached-operator-controller-manager   1/1     1            1           2m18s</span><br><span class="line"></span><br><span class="line">$ kubectl --namespace memcached-operator-system get pods </span><br><span class="line">NAME                                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">memcached-operator-controller-manager-76b588bbb5-wvl7b   2/2     Running   0          2m44s</span><br></pre></td></tr></table></figure><p>当 pod 开始运行，我们的 Operator 就可以使用了。编辑 config/samples/cache_v1alpha1_memcached.yaml 中的示例 YAML，加入一个大小整数，就像在自定义资源规范中定义的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: cache.example.com/v1alpha1</span><br><span class="line">kind: Memcached</span><br><span class="line">metadata:</span><br><span class="line">  name: memcached-sample</span><br><span class="line">spec:</span><br><span class="line">  size: 1</span><br></pre></td></tr></table></figure><p>然后创建一个自定义资源的新实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml </span><br><span class="line">memcached.cache.example.com/memcached-sample created</span><br></pre></td></tr></table></figure></p><p>再看看新的自定义资源和控制器在后台创建的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get memcached</span><br><span class="line">NAME               AGE</span><br><span class="line">memcached-sample   18s</span><br><span class="line"></span><br><span class="line">$ kubectl get deployments</span><br><span class="line">NAME               READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">memcached-sample   1/1     1            1           33s</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">memcached-sample-9b765dfc8-2hvf8   1/1     Running   0          44s</span><br></pre></td></tr></table></figure></p><p>如果查看一下 Memcached 对象，就会发现状态已用运行节点的名称更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get memcached memcached-sample -o yaml</span><br><span class="line">apiVersion: cache.example.com/v1alpha1</span><br><span class="line">kind: Memcached</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;&quot;apiVersion&quot;:&quot;cache.example.com/v1alpha1&quot;,&quot;kind&quot;:&quot;Memcached&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;memcached-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;size&quot;:1&#125;&#125;</span><br><span class="line">  creationTimestamp: &quot;2021-03-29T19:22:53Z&quot;</span><br><span class="line">  generation: 1</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: cache.example.com/v1alpha1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:kubectl.kubernetes.io/last-applied-configuration: &#123;&#125;</span><br><span class="line">      f:spec:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:size: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-03-29T19:22:53Z&quot;</span><br><span class="line">  - apiVersion: cache.example.com/v1alpha1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:status:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:nodes: &#123;&#125;</span><br><span class="line">    manager: manager</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-03-29T19:22:58Z&quot;</span><br><span class="line">  name: memcached-sample</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;1374&quot;</span><br><span class="line">  uid: 63c7b1b1-1a75-49e6-8132-2164807a1b78</span><br><span class="line">spec:</span><br><span class="line">  size: 1</span><br><span class="line">status:</span><br><span class="line">  nodes:</span><br><span class="line">- memcached-sample-9b765dfc8-2hvf8</span><br></pre></td></tr></table></figure><p>要查看控制器的运行情况，可以在集群中添加另一个节点。将 config/samples/cache_v1alpha1_memcached.yaml 中的大小改为 2，然后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml</span><br><span class="line">memcached.cache.example.com/memcached-sample configured</span><br></pre></td></tr></table></figure></p><p>查看创建的新 pod：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class="line">memcached-sample-9b765dfc8-2hvf8   1/1     Running   0          50s</span><br><span class="line">memcached-sample-9b765dfc8-jdhlq   1/1     Running   0          3s</span><br></pre></td></tr></table></figure></p><p>然后看到 Memcached 对象再次更新为新 pod 的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get memcached memcached-sample -o yaml</span><br><span class="line">apiVersion: cache.example.com/v1alpha1</span><br><span class="line">kind: Memcached</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;&quot;apiVersion&quot;:&quot;cache.example.com/v1alpha1&quot;,&quot;kind&quot;:&quot;Memcached&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;memcached-sample&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;size&quot;:1&#125;&#125;</span><br><span class="line">  creationTimestamp: &quot;2021-03-29T19:22:53Z&quot;</span><br><span class="line">  generation: 2</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: cache.example.com/v1alpha1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:kubectl.kubernetes.io/last-applied-configuration: &#123;&#125;</span><br><span class="line">      f:spec:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:size: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-03-29T19:22:53Z&quot;</span><br><span class="line">  - apiVersion: cache.example.com/v1alpha1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:status:</span><br><span class="line">        .: &#123;&#125;</span><br><span class="line">        f:nodes: &#123;&#125;</span><br><span class="line">    manager: manager</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-03-29T19:22:58Z&quot;</span><br><span class="line">  name: memcached-sample</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;1712&quot;</span><br><span class="line">  uid: 63c7b1b1-1a75-49e6-8132-2164807a1b78</span><br><span class="line">spec:</span><br><span class="line">  size: 2</span><br><span class="line">status:</span><br><span class="line">  nodes:</span><br><span class="line">  - memcached-sample-9b765dfc8-2hvf8</span><br><span class="line">  - memcached-sample-9b765dfc8-jdhlq</span><br></pre></td></tr></table></figure><h3 id="Step-5-Cleanup"><a href="#Step-5-Cleanup" class="headerlink" title="Step 5: Cleanup"></a>Step 5: Cleanup</h3><p>完成后，可以通过运行这些命令来清理已部署的 operator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete memcached memcached-sample</span><br><span class="line"></span><br><span class="line">$ make undeploy</span><br></pre></td></tr></table></figure></p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>查看操作员管理器日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs deployment.apps/memcached-operator-controller-manager -n memcached-operator-system -c manager</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="https://cloudsjhan.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://cloudsjhan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>如何用 golang 从 OpenAI,Ollama 和 Claude 获取可靠的结构化输出?</title>
    <link href="https://cloudsjhan.github.io/2024/06/03/%E5%A6%82%E4%BD%95%E7%94%A8-golang-%E4%BB%8E-OpenAI-Ollama-%E5%92%8C-Claude-%E8%8E%B7%E5%8F%96%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA/"/>
    <id>https://cloudsjhan.github.io/2024/06/03/如何用-golang-从-OpenAI-Ollama-和-Claude-获取可靠的结构化输出/</id>
    <published>2024-06-03T00:53:23.000Z</published>
    <updated>2024-06-03T01:50:28.688Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>OpenAI 大火后有许多开发者正在活想要基于 OpenAI 做很多上层应用的开发，这方面在 Python 的生态确实比较完善，但对于 Gopher 来说要获得结构化的结果还需要额外的工作，没有既定的最佳实践。<br>在 golang 世界中，还没有这样的协议。但有一种非常成熟、稳定、广泛使用的协议可以实现我们想要的大部分功能：protobufs 和 protojson（用于将结构化内存中的结构转换为 JSON）。</p><p>在本文中，我们将通过代码来实现这种组合：OpenAI（包括 ollama + open weights）+ protobufs + golang。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们希望创建一个 POC，对输入和输出进行稳健的类型化验证：<br>输入应为国家名称，输出应为国家名称和其他统计数据。</p><h4 id="如何在-Golang-中使用-OpenAI"><a href="#如何在-Golang-中使用-OpenAI" class="headerlink" title="如何在 Golang 中使用 OpenAI"></a>如何在 Golang 中使用 OpenAI</h4><p>这里我们使用 <a href="https://github.com/sashabaranov" title="Baranov" target="_blank" rel="noopener">Sasha Baranov</a> 开发的非官方 <a href="https://github.com/sashabaranov/go-openai" title="go-openai" target="_blank" rel="noopener">Golang OpenAI 客户端</a>。</p><p><img src="https://files.mdnice.com/user/4760/c6d0405e-5091-4418-93f7-97577d130dd4.png" alt=""></p><h4 id="设计协议"><a href="#设计协议" class="headerlink" title="设计协议"></a>设计协议</h4><p>创建 protobuf 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package countryinfo;</span><br><span class="line">option go_package = &quot;./protobuf&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message CountryRequest &#123;</span><br><span class="line">  string country = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CountryResponse &#123;</span><br><span class="line">  string country = 1;</span><br><span class="line">  int32 country_population = 2;</span><br><span class="line">  string capital = 3;</span><br><span class="line">  int32 capital_population = 4;</span><br><span class="line">  int64 gdp_usd = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在创建 go 对应程序（需要安装 <a href="https://grpc.io/docs/protoc-installation/" title="protoc installation" target="_blank" rel="noopener">protoc</a> 才能使用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. countryinfo.proto</span><br></pre></td></tr></table></figure></p><p>这将为我们在 main.go 文件中使用的内容创建一个 go 原生类型验证。我们的包含文件需要包含 protobuf，我们还需要 protojson 来解析 LLM 的输入和输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;countryinfo/protobuf&quot;</span><br><span class="line"> &quot;google.golang.org/protobuf/encoding/protojson&quot;</span><br></pre></td></tr></table></figure><h4 id="system-prompt"><a href="#system-prompt" class="headerlink" title="system prompt"></a>system prompt</h4><p>我们需要让 OpenAI 与 protobuf 对话。我们可以通过系统提示完成这项工作:</p><ul><li>我们验证输出（以及输入）</li><li>在系统提示中包含了一份原生数据库的文本副本，显然每次重新生成原生数据库时都需要手动同步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">systemPrompt := `You are a programmatic country information API used software applications. </span><br><span class="line">All input messages provided MUST adhere to the CountryRequest schema: validate them and throw an error if not. </span><br><span class="line">Your responses MUST adhere to the CountryResponse schema ONLY with no additional narrative or markup, backquotes or anything.</span><br><span class="line">message CountryRequest &#123;</span><br><span class="line"> string country = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  message CountryResponse &#123;</span><br><span class="line"> string country = 1;</span><br><span class="line"> int32 country_population = 2;</span><br><span class="line"> string capital = 3;</span><br><span class="line"> int32 capital_population = 4;</span><br><span class="line"> int64 gdp_usd = 5;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="创建类型安全请求"><a href="#创建类型安全请求" class="headerlink" title="创建类型安全请求"></a>创建类型安全请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">req := openai.ChatCompletionRequest&#123;</span><br><span class="line">  Model:     openai.GPT3Dot5Turbo,</span><br><span class="line">  MaxTokens: 1000, // Increased max tokens to 1000</span><br><span class="line">  Messages: []openai.ChatCompletionMessage&#123;</span><br><span class="line">   &#123;</span><br><span class="line">    Role:    openai.ChatMessageRoleSystem,</span><br><span class="line">    Content: systemPrompt,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    Role:    openai.ChatMessageRoleUser,</span><br><span class="line">    Content: encodeCountryRequest(*country),</span><br><span class="line">   &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是方法定义。看一下我们是如何使用自动生成的 protobuf 来验证内容的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func encodeCountryRequest(country string) string &#123;</span><br><span class="line"> req := &amp;protobuf.CountryRequest&#123;</span><br><span class="line">  Country: country,</span><br><span class="line"> &#125;</span><br><span class="line"> data, err := protojson.Marshal(req)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  log.Fatalf(&quot;Protobuf JSON encoding error: %v\n&quot;, err)</span><br><span class="line"> &#125;</span><br><span class="line"> resultStr := string(data)</span><br><span class="line"> fmt.Println(&quot;Encoded Protobuf JSON Message: &quot;, resultStr)</span><br><span class="line"> return resultStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-response"><a href="#处理-response" class="headerlink" title="处理 response"></a>处理 response</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func decodeCountryResponse(data string) (*protobuf.CountryResponse, error) &#123;</span><br><span class="line"> resp := &amp;protobuf.CountryResponse&#123;&#125;</span><br><span class="line"> err := protojson.Unmarshal([]byte(data), resp)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  return nil, err</span><br><span class="line"> &#125;</span><br><span class="line"> return resp, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>上面的代码默认使用 GPT 3.5，但如果你有足够的预算，也可以重写模型使用 GPT 4，还可以重写主机网址指向 ollama（因为它与 OpenAI-API 兼容）。</p><p>下面是成功测试过的模型：</p><ul><li>GPT 3.5</li><li>GPT 4</li><li>本地安装的 llama3-instruct </li><li>Claude Haiku claude-3-haiku-20240307 （最便宜的型号）</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
      <category term="OpenAI" scheme="https://cloudsjhan.github.io/tags/OpenAI/"/>
    
  </entry>
  
  <entry>
    <title>go1.23: 对 //go:linkname 的修改及其对开发人员的影响</title>
    <link href="https://cloudsjhan.github.io/2024/05/30/go1-23-%E5%AF%B9-go-linkname-%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://cloudsjhan.github.io/2024/05/30/go1-23-对-go-linkname-的修改及其对开发人员的影响/</id>
    <published>2024-05-30T08:46:35.000Z</published>
    <updated>2024-05-30T08:47:38.734Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>上周，Go 1.23 进入冻结期，这意味着不会添加任何新功能，已经添加的功能也不太可能被删除。今天，我们将讨论 Go 1.23 中 //go:linkname 指令的变化。<br>相关的 issue 是：<a href="https://github.com/golang/go/issues/67401" title="linkname issue" target="_blank" rel="noopener">cmd/link: lock down future uses of linkname · Issue #67401 · golang/go</a></p><blockquote><p>注：//go:linkname 指令不是官方推荐使用的指令，不能保证向前或向后的兼容性。明智的做法是尽可能避免使用该指令。</p></blockquote><p>有鉴于此，让我们深入了解这些新变化。</p><h3 id="linkname-的作用是什么"><a href="#linkname-的作用是什么" class="headerlink" title="linkname 的作用是什么"></a>linkname 的作用是什么</h3><p>简单来说，链接名指令用于向编译器和链接器传递信息。根据使用情况，可将其分为三类：</p><h4 id="1-Pull"><a href="#1-Pull" class="headerlink" title="1. Pull"></a>1. Pull</h4><p><code>pull</code> 的用法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;unsafe&quot; // Required to use linkname</span><br><span class="line"> ​</span><br><span class="line"> import _ &quot;fmt&quot; // The pulled package must be explicitly imported (except the runtime package)</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname my_func fmt.Println</span><br><span class="line"> func my_func(...any) (n int, err error)</span><br></pre></td></tr></table></figure><p>该指令格式为 //go:linkname &lt;本地函数或包级变量&gt; &lt;本包或其他包中完全定义的函数或变量&gt;。它告诉编译器和链接器 my_func 应直接使用 fmt.Println，使 my_func 成为 fmt.Println 的别名。</p><p>这种用法可以忽略函数或变量是否被导出，甚至可以使用包私有元素。不过，这种方法有风险，如果出现类型不匹配，可能会引起 panic。</p><h4 id="2-Push"><a href="#2-Push" class="headerlink" title="2. Push"></a>2. Push</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;unsafe&quot; // Required to use linkname</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname main.fastHandle</span><br><span class="line"> func fastHandle(input io.Writer) error &#123;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> // package main</span><br><span class="line"> func fastHandle(input io.Writer) error</span><br><span class="line"> ​</span><br><span class="line"> // The main package can directly use fastHandle</span><br></pre></td></tr></table></figure><p>在这里，只需将函数或变量名作为第一个参数传递给指令，并指定使用该函数或变量的软件包名称。这种用法表示函数或变量将被命名为 xxx.yyy。</p><h4 id="3-HandShake"><a href="#3-HandShake" class="headerlink" title="3. HandShake"></a>3. HandShake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package mypkg</span><br><span class="line"> ​</span><br><span class="line"> import _ &quot;unsafe&quot; // Required to use linkname</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname fastHandle</span><br><span class="line"> func fastHandle(input io.Writer) error &#123;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> package main</span><br><span class="line"> ​</span><br><span class="line"> import _ &quot;unsafe&quot; // Required to use linkname</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname fastHandle mypkg.fastHandle</span><br><span class="line"> func fastHandle(input io.Writer) error</span><br></pre></td></tr></table></figure><p>这种用法意味着两端要握手，明确标记哪个函数或变量应被链接。</p><h3 id="使用-linkname-的风险"><a href="#使用-linkname-的风险" class="headerlink" title="使用 linkname 的风险"></a>使用 linkname 的风险</h3><p>主要风险是在软件包不知情的情况下使用软件包私有函数或变量的能力。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// pkg/mymath/mymath.go</span><br><span class="line"> package mymath</span><br><span class="line"> ​</span><br><span class="line"> func uintPow(n uint) uint &#123;</span><br><span class="line">     return n * n</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> // main.go</span><br><span class="line"> package main</span><br><span class="line"> ​</span><br><span class="line"> import (</span><br><span class="line">     &quot;fmt&quot;</span><br><span class="line">     _ &quot;linkname/pkg/mymath&quot;</span><br><span class="line">     _ &quot;unsafe&quot;</span><br><span class="line"> )</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname pow linkname/pkg/mymath.uintPow</span><br><span class="line"> func pow(n uint) uint</span><br><span class="line"> ​</span><br><span class="line"> func main() &#123;</span><br><span class="line">     fmt.Println(pow(6)) // 36</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通常，uintPow 不应在其软件包之外被访问。但 linkname 绕过了这一限制，可能导致严重的类型相关内存错误或运行时 panic。</p><h3 id="linkname-也有有用的时候"><a href="#linkname-也有有用的时候" class="headerlink" title="linkname 也有有用的时候"></a>linkname 也有有用的时候</h3><p>尽管存在风险，但 linkname 的存在还是有其合理的原因，例如在 Go 程序启动时。例如，在 Go 的运行时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// runtime/proc.go</span><br><span class="line"> ​</span><br><span class="line"> //go:linkname main_main main.main</span><br><span class="line"> func main_main()</span><br><span class="line"> ​</span><br><span class="line"> // runtime.main</span><br><span class="line"> func main() &#123;</span><br><span class="line">     fn := main_main</span><br><span class="line">     fn()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里，linkname 允许运行时调用用户定义的主函数。</p><h3 id="Go-1-23-中对-linkname-的更改"><a href="#Go-1-23-中对-linkname-的更改" class="headerlink" title="Go 1.23 中对 linkname 的更改"></a>Go 1.23 中对 linkname 的更改</h3><p>考虑到上述风险，Go 核心团队决定限制链接名的使用： </p><ul><li>新的标准库软件包将禁止 linkname。</li><li>新增了一个 ldflag -checklinkname=1 来执行限制。默认值为 0，但在 1.23 的最终版本中将设置为 1。</li><li>标准库将禁止只拉链接名，只允许握手模式。</li></ul><p>例如，以下代码在 1.23 版中就无法编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> import _ &quot;unsafe&quot;</span><br><span class="line"> //go:linkname corostart runtime.corostart</span><br><span class="line"> func corostart()</span><br><span class="line"> ​</span><br><span class="line"> func main() &#123;</span><br><span class="line">     corostart()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="linkname-的未来"><a href="#linkname-的未来" class="headerlink" title="linkname 的未来"></a>linkname 的未来</h3><p>长期目标是只允许使用握手模式。作为开发者，我们应该:</p><ul><li>使用 -checklinkname=1 审核并删除不必要的链接名使用。</li><li>建议在必要时公开私有 API。</li><li>最后，使用 -ldflags=-checklinkname=0 禁用限制。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，我们还是应避免使用 <code>//go:linkname</code> 以防止出现不可预见的问题。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>掌握 Golang Mutex：安全并发的最佳实践</title>
    <link href="https://cloudsjhan.github.io/2024/05/29/%E6%8E%8C%E6%8F%A1-Golang-Mutex%EF%BC%9A%E5%AE%89%E5%85%A8%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://cloudsjhan.github.io/2024/05/29/掌握-Golang-Mutex：安全并发的最佳实践/</id>
    <published>2024-05-29T01:59:12.000Z</published>
    <updated>2024-05-29T02:12:04.979Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>掌握 Golang Mutex：安全并发的最佳实践</p><p>并发是 Go 的核心功能之一，它使开发人员能够高效地同时执行多个进程。然而，管理并发性需要谨慎的同步，以避免常见的隐患，如竞赛条件，即两个或多个进程试图同时修改共享数据。Mutex（互斥锁）是 Go 程序员并发工具包中的一个重要工具。本文将探讨 Golang Mutex 的复杂性，说明何时以及如何正确使用它，以确保数据完整性和程序稳定性。</p><h3 id="Understanding-Golang-Mutex"><a href="#Understanding-Golang-Mutex" class="headerlink" title="Understanding Golang Mutex"></a>Understanding Golang Mutex</h3><p>Mutex 是一种同步原语，可用于确保每次只有一个 goroutine 访问代码的关键部分。它用于保护并发程序（由 Go 运行时管理的轻量级线程）对数据和其他资源的访问。</p><p>在 Go 中，互斥由 sync 包提供，主要类型是 sync.Mutex 和 sync.RWMutex：</p><ul><li>sync.Mutex 提供了一种基本的锁定机制；当一个 goroutine 锁定一个 Mutex 时，任何其他试图锁定它的 goroutine 都会阻塞，直到它被解锁。</li><li>sync.RWMutex 是一种读/写互斥器，允许多个读取器或一个写入器，但不能同时读写。</li></ul><h3 id="When-to-Use-a-Mutex"><a href="#When-to-Use-a-Mutex" class="headerlink" title="When to Use a Mutex"></a>When to Use a Mutex</h3><p>在下列情况下应使用 mutex:</p><ul><li>代码中有一些关键部分需要访问共享数据，而这些数据可能会被多个程序同时访问。</li><li>需要确保在任何给定时间内只有一个 goroutine 可以访问或修改共享数据，以防止数据竞争。</li><li>要处理的是并发环境中的有状态组件或资源。</li></ul><h3 id="How-to-Use-a-Mutex-Guidelines-and-Best-Practices"><a href="#How-to-Use-a-Mutex-Guidelines-and-Best-Practices" class="headerlink" title="How to Use a Mutex: Guidelines and Best Practices"></a>How to Use a Mutex: Guidelines and Best Practices</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>下面是一个使用 sync.Mutex 保护共享数据结构的简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SafeCounter struct &#123;</span><br><span class="line">    val  int</span><br><span class="line">    mux  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Inc increments the counter safely.</span><br><span class="line">func (c *SafeCounter) Inc() &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    c.val++</span><br><span class="line">    c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Value returns the current value of the counter safely.</span><br><span class="line">func (c *SafeCounter) Value() int &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    defer c.mux.Unlock()</span><br><span class="line">    return c.val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    c := SafeCounter&#123;&#125;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // Start 100 goroutines to increment the counter.</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            c.Inc()</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(c.Value())  // Output: 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock 和Unlock 要靠近：尽可能缩小锁定的部分，并在最近的机会解锁互斥，可以明确使用 Unlock() 或在锁定后使用 defer（如果函数有多个退出点）。</p><h4 id="使用-defer-来-Unlock"><a href="#使用-defer-来-Unlock" class="headerlink" title="使用 defer 来 Unlock"></a>使用 defer 来 Unlock</h4><p>要确保始终解锁互斥项，即使发生 panic，也要在锁定后立即使用延迟。</p><h4 id="避免嵌套锁"><a href="#避免嵌套锁" class="headerlink" title="避免嵌套锁"></a>避免嵌套锁</h4><p>嵌套锁可能导致死锁，即两个或多个程序互相等待对方释放锁。请谨慎设计并发模型，以防止出现这种情况。</p><h4 id="使用-RWMutex-处理读取繁重的工作负载"><a href="#使用-RWMutex-处理读取繁重的工作负载" class="headerlink" title="使用 RWMutex 处理读取繁重的工作负载"></a>使用 RWMutex 处理读取繁重的工作负载</h4><p>当共享资源的读取次数多于写入次数时，可以考虑使用 sync.RWMutex。它允许多个程序同时读取资源，只在写入时锁定，从而提高了效率。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 Go 的并发领域，mutex 就像一个哨兵，保护着共享数据。要避免并发编程中的危险陷阱（如竞争条件），正确使用互斥是至关重要的。通过遵守本文概述的原则和实践，开发人员可以利用 Go 并发模型的强大功能，同时确保数据完整性和程序可靠性</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 中 JSON 操作的 5 个常见陷阱</title>
    <link href="https://cloudsjhan.github.io/2024/05/25/Golang-%E4%B8%AD-JSON-%E6%93%8D%E4%BD%9C%E7%9A%84-5-%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
    <id>https://cloudsjhan.github.io/2024/05/25/Golang-中-JSON-操作的-5-个常见陷阱/</id>
    <published>2024-05-25T10:06:53.000Z</published>
    <updated>2024-05-25T10:07:36.089Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>JSON 是许多开发人员在工作中经常使用的一种数据格式。它一般用于配置文件或网络数据传输等场景。由于其简单、易懂、可读性好，JSON 已成为整个 IT 界最常用的格式之一。对于这种情况，Golang 和许多其他语言一样，也提供了标准库级别的支持, <a href="https://pkg.go.dev/encoding/json" title="encoding/json" target="_blank" rel="noopener">encoding/json</a>。</p><p>就像 JSON 本身很容易理解一样，用于操作 JSON 的编码/JSON 库也非常容易使用。但我相信，很多开发者可能会像我第一次使用这个库时一样，遇到各种奇怪的问题或 bug。本文总结了我个人在使用 Golang 操作 JSON 时遇到的问题和错误。希望能帮助更多阅读本文的开发者掌握 Golang 的使用技巧，更正确地操作 JSON，避免调用不必要的”坑”。</p><p>本文内容基于 Go 1.22。不同版本之间可能存在细微差别。读者在阅读和使用时请注意。同时，本文列出的所有案例均使用 <code>encoding/json</code>，不涉及任何第三方 JSON 库。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>先来看下 <code>encoding/json</code> 的基本用法。<br>作为一种数据格式，JSON 的核心操作只有两个：序列化和反序列化。序列化是将 Go 对象转换为 JSON 格式的字符串（或字节序列）。反序列化则相反，是将 JSON 格式的数据转换成 Go 对象。</p><p>这里提到的对象是一个宽泛的概念。它不仅指结构对象，还包括切片和映射类型的数据。它们也支持 JSON 序列化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> ID   <span class="keyword">uint</span></span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPerson</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := Person&#123;</span><br><span class="line">  ID:   <span class="number">1</span>,</span><br><span class="line">  Name: <span class="string">"Bruce"</span>,</span><br><span class="line">  Age:  <span class="number">18</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> output, err := json.Marshal(p)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">println</span>(<span class="keyword">string</span>(output))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnmarshalPerson</span><span class="params">()</span></span> &#123;</span><br><span class="line"> str := <span class="string">`&#123;"ID":1,"Name":"Bruce","Age":18&#125;`</span></span><br><span class="line"> <span class="keyword">var</span> p Person</span><br><span class="line"> err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;p)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">"%+v\n"</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是两个函数 <code>json.Marshal</code> 和 <code>json.Unmarshal</code>，分别用于序列化和反序列化。这两个函数都会返回错误，在这里我只是简单地 panic 一下。<br>使用过 <code>encoding/json</code> 的读者可能知道，还有另一对工具会经常用到：NewEncoder 和 NewDecoder。简单看一下源代码就会发现，这两个工具的底层核心逻辑调用与 Marshal 是一样的，所以我就不在这里举例说明了。</p><h3 id="常见的-‘坑’"><a href="#常见的-‘坑’" class="headerlink" title="常见的 ‘坑’"></a>常见的 ‘坑’</h3><h4 id="1-public-or-private-字段处理"><a href="#1-public-or-private-字段处理" class="headerlink" title="1. public or private 字段处理"></a>1. public or private 字段处理</h4><p>这可能是刚接触 Go 的开发人员最容易犯的错误。也就是说，如果我们使用结构体处理 JSON，那么结构体的成员字段必须是公有的，即首字母大写的，而私有成员是无法解析的。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID   uint</span><br><span class="line">  Name string</span><br><span class="line">  age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MarshalPerson() &#123;</span><br><span class="line"> p := Person&#123;</span><br><span class="line">  ID:   1,</span><br><span class="line">  Name: &quot;Bruce&quot;,</span><br><span class="line">  age:  18,</span><br><span class="line"> &#125;</span><br><span class="line"> output, err := json.Marshal(p)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"> println(string(output))</span><br><span class="line">&#125;</span><br><span class="line">func UnmarshalPerson() &#123;</span><br><span class="line"> str := `&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;age&quot;:18&#125;`</span><br><span class="line"> var p Person</span><br><span class="line"> err := json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  panic(err)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line">&#125;</span><br><span class="line">// Output Marshal:</span><br><span class="line">&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;&#125;</span><br><span class="line">// Output Unmarshal:</span><br><span class="line">&#123;ID:1 Name:Bruce age:0&#125;</span><br></pre></td></tr></table></figure><p>在这里，age 被设置为私有变量，因此序列化的 JSON 字符串中没有 age 字段。同样，在将 JSON 字符串反序列化为 Person 时，也无法正确读取 age 的值。<br>原因很简单。如果我们深入研究 Marshal 下的源代码，就会发现它实际上使用了 <code>reflect</code> 来动态解析 <code>struct</code> 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// .../src/encoding/json/encode.go</span><br><span class="line"></span><br><span class="line">func (e *encodeState) marshal(v any, opts encOpts) (err error) &#123;</span><br><span class="line"> // ...skip</span><br><span class="line"> e.reflectValue(reflect.ValueOf(v), opts)</span><br><span class="line"> return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 Golang 在语言设计层面禁止对结构的私有成员进行反射式访问，因此这种反射式解析自然会失败，反序列化也是如此。</p><h4 id="2-警惕结构体组合"><a href="#2-警惕结构体组合" class="headerlink" title="2. 警惕结构体组合"></a>2. 警惕结构体组合</h4><p>Go 是面向对象的，但它没有类，只有结构，而结构没有继承性。因此，Go 使用一种组合来重用不同的结构。在许多情况下，这种组合非常方便，因为我们可以像操作结构本身的成员一样操作组合中的其他成员，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID   uint</span><br><span class="line">  Name string</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type address struct &#123;</span><br><span class="line"> Code   int</span><br><span class="line"> Street string</span><br><span class="line">&#125;</span><br><span class="line">func (a address) PrintAddr() &#123;</span><br><span class="line"> fmt.Println(a.Code, a.Street)</span><br><span class="line">&#125;</span><br><span class="line">func Group() &#123;</span><br><span class="line"> p := Person&#123;</span><br><span class="line">  ID:   1,</span><br><span class="line">  Name: &quot;Bruce&quot;,</span><br><span class="line">  address: address&#123;</span><br><span class="line">   Code:   100,</span><br><span class="line">   Street: &quot;Main St&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> // Access all address&apos;s fields and methods directly</span><br><span class="line"> fmt.Println(p.Code, p.Street)</span><br><span class="line"> p.PrintAddr()</span><br><span class="line">&#125;</span><br><span class="line">// Output</span><br><span class="line">100 Main St</span><br><span class="line">100 Main St</span><br></pre></td></tr></table></figure><p>结构体组合使用起来确实挺方便。不过，在使用 JSON 解析时，我们需要注意一个小问题。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// The structure used here is the same as the previous one, </span><br><span class="line">// so I won&apos;t repeat it. error is also not captured to save space.</span><br><span class="line"></span><br><span class="line">func MarshalPerson() &#123;</span><br><span class="line"> p := Person&#123;</span><br><span class="line">  ID:   1,</span><br><span class="line">  Name: &quot;Bruce&quot;,</span><br><span class="line">  address: address&#123;</span><br><span class="line">   Code:   100,</span><br><span class="line">   Street: &quot;Main St&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> // It would be more pretty by MarshalIndent</span><br><span class="line"> output, _ := json.MarshalIndent(p, &quot;&quot;, &quot;  &quot;)</span><br><span class="line"> println(string(output))</span><br><span class="line">&#125;</span><br><span class="line">func UnmarshalPerson() &#123;</span><br><span class="line"> str := `&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;,&quot;address&quot;:&#123;&quot;Code&quot;:100,&quot;Street&quot;:&quot;Main St&quot;&#125;&#125;`</span><br><span class="line"> var p Person</span><br><span class="line"> _ = json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line">&#125;</span><br><span class="line">// Output MarshalPerson:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ID&quot;: 1,</span><br><span class="line">  &quot;Name&quot;: &quot;Bruce&quot;,</span><br><span class="line">  &quot;Code&quot;: 100,</span><br><span class="line">  &quot;Street&quot;: &quot;Main St&quot;</span><br><span class="line">&#125;</span><br><span class="line">// Ouptput UnmarshalPerson:</span><br><span class="line">&#123;ID:1 Name:Bruce address:&#123;Code:0 Street:&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里先声明一个 Person 对象，然后使用 MarshalIndent 美化序列化结果并打印出来。从打印输出中我们可以看到，整个 Person 对象都被扁平化了。就 Person 结构而言，尽管进行了组合，但它看起来仍有一个地址成员字段。因此，有时我们会想当然地认为 Person 的序列化 JSON 看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// The imagine of JSON serialization result</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ID&quot;: 1,</span><br><span class="line">  &quot;Name&quot;: &quot;Bruce&quot;,</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;Code&quot;: 100,</span><br><span class="line">    &quot;Street&quot;: &quot;Main St&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但事实并非如此，它被扁平化了。这更符合我们之前直接通过 Person 访问地址成员时的感觉，即地址成员似乎直接成为了 Person 的成员。这一点需要注意，因为这种组合会使序列化后的 JSON 结果扁平化。</p><p>另一个有点违反直觉的问题是，地址结构是一个私有结构，而私有成员似乎不应该被序列化？没错，这也是这种组合结构体做 JSON 解析的缺点之一：它暴露了私有组合对象的公共成员。<br>如果没有特殊需要（例如，原始 JSON 数据已被扁平化，并且有多个结构体的重复字段需要重复使用），从我个人的角度来看，建议这样编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID      int</span><br><span class="line">  Name    string</span><br><span class="line">  Address address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-反序列化部分成员字段"><a href="#3-反序列化部分成员字段" class="headerlink" title="3. 反序列化部分成员字段"></a>3. 反序列化部分成员字段</h4><p>直接查看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID   uint</span><br><span class="line">  Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// PartUpdateIssue simulates parsing two different </span><br><span class="line">// JSON strings with the same structure</span><br><span class="line">func PartUpdateIssue() &#123;</span><br><span class="line"> var p Person</span><br><span class="line"> // The first data has the ID field and is not 0</span><br><span class="line"> str := `&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;&#125;`</span><br><span class="line"> _ = json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line"> // The second data does not have an ID field, </span><br><span class="line"> // deserializing it again with p preserves the last value</span><br><span class="line"> str = `&#123;&quot;Name&quot;:&quot;Jim&quot;&#125;`</span><br><span class="line"> _ = json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> // Notice the output ID is still 1</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line">&#125;</span><br><span class="line">// Output</span><br><span class="line">&#123;ID:1 Name:Bruce&#125;</span><br><span class="line">&#123;ID:1 Name:Jim&#125;</span><br></pre></td></tr></table></figure><p>从代码注释中可以知道，当我们重复使用同一结构来反序列化不同的 JSON 数据时，一旦某个 JSON 数据的值只包含部分成员字段，那么未包含的成员就会使用最后一次反序列化的值，会产生脏数据污染问题。</p><h4 id="4-处理指针字段"><a href="#4-处理指针字段" class="headerlink" title="4. 处理指针字段"></a>4. 处理指针字段</h4><p>许多开发人员一听到指针这个词就头疼不已，其实大可不必。但 Go 中的指针确实给开发人员带来了 Go 程序中最常见的 panic 之一：空指针异常。当指针与 JSON 结合时会发生什么呢？</p><p>看下面的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID      uint</span><br><span class="line">  Name    string</span><br><span class="line">  Address *Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func UnmarshalPtr() &#123;</span><br><span class="line"> str := `&#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Bruce&quot;&#125;`</span><br><span class="line"> var p Person</span><br><span class="line"> _ = json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line"> // It would panic this line</span><br><span class="line"> // fmt.Printf(&quot;%+v\n&quot;, p.Address.Street)</span><br><span class="line">&#125;</span><br><span class="line">// Output</span><br><span class="line">&#123;ID:1 Name:Bruce Address:&lt;nil&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>我们将 Address 成员定义为指针，当我们反序列化一段不包含 Address 的 JSON 数据时，指针字段会被设置为 nil，因为它没有对应的数据。如果我们直接调用 p.Address.xxx，程序会因为 p.Address 为空而崩溃。</p><p>因此，如果有一个指针指向我们结构中的一个成员，请记住在使用它之前先确定指针是否为 nil。这有点繁琐，但也没办法。毕竟，编写几行代码与生产环境中的 panic 所造成的损失相比可能并不算什么。</p><p>此外，在创建带有指针字段的结构时，指针字段的赋值也会相对繁琐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  ID   int    </span><br><span class="line">  Name string </span><br><span class="line">  Age  *int   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Foo() &#123;</span><br><span class="line"> p := Person&#123;</span><br><span class="line">  ID:   1,</span><br><span class="line">  Name: &quot;Bruce&quot;,</span><br><span class="line">  Age:  new(int),</span><br><span class="line"> &#125;</span><br><span class="line"> *p.Age = 20</span><br><span class="line"> // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-零值（默认值）可能造成的问题"><a href="#5-零值（默认值）可能造成的问题" class="headerlink" title="5. 零值（默认值）可能造成的问题"></a>5. 零值（默认值）可能造成的问题</h4><p>零值是 Golang 变量的一个特性，我们可以简单地将其视为默认值。也就是说，如果我们没有显式地给变量赋值，Golang 就会给它赋一个默认值。例如，我们在前面的例子中看到，int 的默认值为 0，string 的默认值为空字符串，指针的零值为 nil，等等。</p><p>处理带有零值的 JSON 有哪些隐患？<br>请看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  Name        string</span><br><span class="line">  ChildrenCnt int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ZeroValueConfusion() &#123;</span><br><span class="line"> str := `&#123;&quot;Name&quot;:&quot;Bruce&quot;&#125;`</span><br><span class="line"> var p Person</span><br><span class="line"> _ = json.Unmarshal([]byte(str), &amp;p)</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p)</span><br><span class="line"> str2 := `&#123;&quot;Name&quot;:&quot;Jim&quot;,&quot;ChildrenCnt&quot;:0&#125;`</span><br><span class="line"> var p2 Person</span><br><span class="line"> _ = json.Unmarshal([]byte(str2), &amp;p2)</span><br><span class="line"> fmt.Printf(&quot;%+v\n&quot;, p2)</span><br><span class="line">&#125;</span><br><span class="line">// Output</span><br><span class="line">&#123;Name:Bruce ChildrenCnt:0&#125;</span><br><span class="line">&#123;Name:Jim ChildrenCnt:0&#125;</span><br></pre></td></tr></table></figure></p><p>我们在 <code>Person</code> 结构中添加了一个 ChildrenCnt 字段，用于计算该人的子女数量。由于该字段的值为零，当 p 加载的 JSON 数据中没有 ChildrenCnt 数据时，该字段的赋值为 0。在 Bruce 和 Jim 的例子中，由于数据缺失，其中一个的子女数为 0，而另一个的子女数为 0。而实际上布鲁斯的子女数应该是 “未知”，如果我们真的将其视为 0，可能会在业务上造成问题。<br>在一些对数据有严格要求的场景中，这种混淆是非常致命的。那么，有没有办法避免这种零值干扰呢？<br>让我们将 Person 的 ChildrenCnt 类型改为 *int 并看看会发生什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">  Name        string</span><br><span class="line">  ChildrenCnt *int</span><br><span class="line">&#125;</span><br><span class="line">// Output</span><br><span class="line">&#123;Name:Bruce ChildrenCnt:&lt;nil&gt;&#125;</span><br><span class="line">&#123;Name:Jim ChildrenCnt:0xc0000124c8&#125;</span><br></pre></td></tr></table></figure><p>不同之处在于 Bruce 没有数据，因此 ChildrenCnt 为零，而 Jim 是一个非零指针。这样就很明显了，Bruc 的孩子数量是未知的。 从本质上讲，这种方法仍然使用零值，即指针的零值，有点像以毒攻毒（笑）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  在这篇文章中，我列举了自己在使用编码/json 库时犯过的 7 个错误，其中大部分都是我在工作中遇到的。如果你还没有遇到过，那么恭喜你！这也提醒我们今后在使用 JSON 时要小心谨慎；如果你遇到过这些问题，并为此感到困惑，希望本文能对你有所帮助。</p><hr>]]></content>
    
    <summary type="html">
    
      Golang 中 JSON 操作的 5 个常见陷阱
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用 Golang 创建反向代理</title>
    <link href="https://cloudsjhan.github.io/2024/05/17/%E4%BD%BF%E7%94%A8-Golang-%E5%88%9B%E5%BB%BA%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://cloudsjhan.github.io/2024/05/17/使用-Golang-创建反向代理/</id>
    <published>2024-05-17T14:12:45.000Z</published>
    <updated>2024-05-17T14:13:30.150Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>为了让 API 连接正常工作，我需要在请求头中提供客户端 ID，基于用户名或客户端证书，然后将流量重定向到它。听起来像是专用反向代理软件 Nginx 或 Traefik 要执行的任务。现在我们来探索用 Golang 来实现反向代理的功能。</p><h3 id="单主机反向代理"><a href="#单主机反向代理" class="headerlink" title="单主机反向代理"></a>单主机反向代理</h3><p>得益于 Golang 标准库，一个开箱即用的单主机反向代理可以很容易地实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rp := httputil.NewSingleHostReverseProxy(targetUrl)</span><br><span class="line">rp.ServeHTTP(w, r)</span><br></pre></td></tr></table></figure><p>这段代码应该插入标准的 HTTP 处理程序中。这里的“单一主机”更多指的是反向代理功能，没有提供负载均衡功能。</p><h3 id="携带-header-的反向代理"><a href="#携带-header-的反向代理" class="headerlink" title="携带 header 的反向代理"></a>携带 header 的反向代理</h3><p>这里会实现一个 HTTP 处理程序，读取客户端证书，并根据 CN 名称选择一个客户端 ID 值，在 HTTP 头部中更新它，并将流量重定向到目标 URL。</p><p>给出以下示例配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mapping:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">client1-app1</span></span><br><span class="line"><span class="attr">  certCN:</span> <span class="string">user1</span></span><br><span class="line"><span class="attr">  clientID:</span> <span class="number">2</span><span class="string">a3977e9c4dd4631c9233f2e9387a103</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">client2-app1</span></span><br><span class="line"><span class="attr">  certCN:</span> <span class="string">user2</span></span><br><span class="line"><span class="attr">  clientID:</span> <span class="number">939</span><span class="string">f15e518e75d3c251a1245141c1c48</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">  certFile:</span> <span class="string">../certs/server.pem</span></span><br><span class="line"><span class="attr">  keyFile:</span> <span class="string">../certs/server-key.pem</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reverseProxy:</span></span><br><span class="line"><span class="attr">  targetUrl:</span> <span class="attr">https://apis-gw-gateway-apic.apps.dev-ocp414.ibmcloud.io.cpak/porg/mycat/myapi</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> config.WithOptions(config.ParseEnv, <span class="function"><span class="keyword">func</span><span class="params">(opt *config.Options)</span></span> &#123;</span><br><span class="line">  opt.DecoderConfig.TagName = <span class="string">"yaml"</span></span><br><span class="line"> &#125;)</span><br><span class="line"> config.AddDriver(yaml.Driver)</span><br><span class="line"> try.E(config.LoadFiles(<span class="string">"config.yaml"</span>))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> mapping []CnToClientID</span><br><span class="line"> try.E(config.BindStruct(<span class="string">"mapping"</span>, &amp;mapping))</span><br><span class="line"></span><br><span class="line"> targetUrl := try.E1(url.Parse(config.String(<span class="string">"reverseProxy.targetUrl"</span>)))</span><br><span class="line"></span><br><span class="line"> http.HandleFunc(<span class="string">"/"</span>, rpHandler(mapping, targetUrl))</span><br><span class="line"></span><br><span class="line"> srv := &amp;http.Server&#123;</span><br><span class="line">  Addr: fmt.Sprintf(<span class="string">":%d"</span>, config.Int(<span class="string">"server.port"</span>)),</span><br><span class="line">  TLSConfig: &amp;tls.Config&#123;</span><br><span class="line">   ClientAuth: tls.RequireAnyClientCert,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> try.E(srv.ListenAndServeTLS(config.String(<span class="string">"server.certFile"</span>), config.String(<span class="string">"server.keyFile"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用带有证书和密钥的基 于HTTPs 的服务器。请注意 TLS 选项，我们将要求客户端提供其证书以提取其 CN 名称，尽管我们不执行mTLS。</p><p>可以通过以下方式实现http处理程序:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rpHandler</span><span class="params">(mapping []CnToClientID, targetUrl *url.URL)</span> <span class="title">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  dump, _ := httputil.DumpRequest(r, <span class="literal">true</span>)</span><br><span class="line">  log.Printf(<span class="string">"request: %s"</span>, dump)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> r.TLS == <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Printf(<span class="string">"Request must be over TLS"</span>)</span><br><span class="line">   http.Error(w, <span class="string">"Request must be over TLS"</span>, http.StatusForbidden)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(r.TLS.PeerCertificates) == <span class="number">0</span> &#123;</span><br><span class="line">   log.Printf(<span class="string">"Request must contain a client certificate"</span>)</span><br><span class="line">   http.Error(w, <span class="string">"Request must contain a client certificate"</span>, http.StatusForbidden)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cnName := r.TLS.PeerCertificates[<span class="number">0</span>].Subject.CommonName</span><br><span class="line">  log.Printf(<span class="string">"Client CN: %s"</span>, cnName)</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">   <span class="keyword">if</span> v.CertCN == cnName &#123;</span><br><span class="line">    rp := httputil.NewSingleHostReverseProxy(targetUrl)</span><br><span class="line"></span><br><span class="line">    r.Header.Set(<span class="string">"X-IBM-Client-Id"</span>, v.ClientID)</span><br><span class="line">    rp.ServeHTTP(w, r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if no match found</span></span><br><span class="line">  http.Error(w, <span class="string">"client id not found"</span>, http.StatusForbidden)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理程序中，首先我们读取客户端证书以获取其 CN 名称，然后循环遍历配置以找到客户端 ID 值，将其添加到请求头中，然后创建一个反向代理对象，目标 URL 是让它处理该请求。</p><h3 id="自定义-Round-Trip"><a href="#自定义-Round-Trip" class="headerlink" title="自定义 Round Trip"></a>自定义 Round Trip</h3><p>我们需要一些自定义来解决反向代理的问题，可能需要跳过证书验证，因为目标端可能使用自签名证书。</p><p>这些可以通过 RoundTrip 的接口实现。</p><blockquote><p>RoundTripper是一个接口，代表着执行单个HTTP事务的能力，获取给定请求的响应。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyRoundTripper <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(MyRoundTripper)</span> <span class="title">RoundTrip</span><span class="params">(r *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line"> dump, _ := httputil.DumpRequest(r, <span class="literal">true</span>)</span><br><span class="line"> log.Printf(<span class="string">"request to proxy: %s"</span>, dump)</span><br><span class="line"></span><br><span class="line"> insecureTransport := http.DefaultTransport.(*http.Transport).Clone()</span><br><span class="line"> insecureTransport.TLSClientConfig = &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> insecureTransport.RoundTrip(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Roundtrip()</code> 中，我们调用 <code>httputil.DumpRequest</code> 来为了调试目的而转储请求。</p><p>然后重置其 <code>TLS</code> 配置以跳过证书验证，以允许自签名证书通过。然后我们调用原始的 <code>RoundTrip()</code> 来处理请求。</p><p>然后可以使用自定义的 <code>roundtrip</code> 更新 <code>http</code> 处理程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">rp := httputil.NewSingleHostReverseProxy(targetUrl)</span><br><span class="line">rp.Transport = &amp;MyRoundTripper&#123;&#125;</span><br><span class="line"></span><br><span class="line">r.Header.Set(<span class="string">"X-IBM-Client-Id"</span>, v.ClientID)</span><br><span class="line">rp.ServeHTTP(w, r)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      使用 Golang 创建反向代理
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Observability with OpenTelemetry and Go</title>
    <link href="https://cloudsjhan.github.io/2024/05/13/Observability-with-OpenTelemetry-and-Go/"/>
    <id>https://cloudsjhan.github.io/2024/05/13/Observability-with-OpenTelemetry-and-Go/</id>
    <published>2024-05-13T03:08:11.000Z</published>
    <updated>2024-05-13T03:09:07.272Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>这篇文章中我们会讨论可观测性概念，并了解了有关 OpenTelemetry 的一些细节，然后会在 Golang 服务中对接 OpenTelemetry 实现分布式系统可观测性。</p><p><img src="https://files.mdnice.com/user/4760/4db44fe3-81d7-4d08-9f96-bfd51bccad08.png" alt=""></p><h3 id="Test-Project"><a href="#Test-Project" class="headerlink" title="Test Project"></a>Test Project</h3><p>我们将使用 Go 1.22 开发我们的测试服务。我们将构建一个 API，返回服务的名称及其版本。</p><p>我们将把我们的项目分成两个简单的文件（main.go 和 info.go）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> portNum <span class="keyword">string</span> = <span class="string">":8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"Starting http server."</span>)</span><br><span class="line"></span><br><span class="line">   mux := http.NewServeMux()</span><br><span class="line">   mux.HandleFunc(<span class="string">"/info"</span>, info)</span><br><span class="line"></span><br><span class="line">   srv := &amp;http.Server&#123;</span><br><span class="line">      Addr:    portNum,</span><br><span class="line">      Handler: mux,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">"Started on port"</span>, portNum)</span><br><span class="line">   err := srv.ListenAndServe()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Fail start http server."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: info.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"encoding/json"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InfoResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">   Version     <span class="keyword">string</span> <span class="string">`json:"version"`</span></span><br><span class="line">   ServiceName <span class="keyword">string</span> <span class="string">`json:"service-name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">   response := InfoResponse&#123;Version: <span class="string">"0.1.0"</span>, ServiceName: <span class="string">"otlp-sample"</span>&#125;</span><br><span class="line">   json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>go run .</code> 运行后，应该在 console 中输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting http server.</span><br><span class="line">Started on port :8080</span><br></pre></td></tr></table></figure><p>访问 <code>localhost:8080</code> 会显示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/info</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="string">"service-name"</span>: <span class="string">"otlp-sample"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的服务已经可以运行了，现在要以对其进行监控（或者配置我们的流水线）。在这里，我们将执行手动监控以理解一些观测细节。</p><h3 id="First-Steps"><a href="#First-Steps" class="headerlink" title="First Steps"></a>First Steps</h3><p>第一步是安装 Open Telemetry 的依赖。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get <span class="string">"go.opentelemetry.io/otel"</span> \</span><br><span class="line">       <span class="string">"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"</span> \</span><br><span class="line">       <span class="string">"go.opentelemetry.io/otel/metric"</span> \</span><br><span class="line">       <span class="string">"go.opentelemetry.io/otel/sdk"</span> \</span><br><span class="line">       <span class="string">"go.opentelemetry.io/otel/trace"</span> \</span><br><span class="line">       <span class="string">"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"</span></span><br></pre></td></tr></table></figure><p>目前，我们只会安装项目的初始依赖。这里我们将 OpenTelemetry 配置 otel.go文件。</p><p>在我们开始之前，先看下配置的流水线：</p><p><img src="https://files.mdnice.com/user/4760/cadc0aa0-acaf-47bd-9c84-a6f7d0584700.png" alt=""></p><h3 id="定义-Exporter"><a href="#定义-Exporter" class="headerlink" title="定义 Exporter"></a>定义 Exporter</h3><p>为了演示简单，我们将在这里使用 console Exporter 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: otel.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"context"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel/sdk/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTraceExporter</span><span class="params">()</span> <span class="params">(trace.SpanExporter, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> stdouttrace.New(stdouttrace.WithPrettyPrint())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go 的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"context"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> portNum <span class="keyword">string</span> = <span class="string">":8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"Starting http server."</span>)</span><br><span class="line"></span><br><span class="line">   mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">   _, err := newTraceExporter()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Failed to get console exporter."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mux.HandleFunc(<span class="string">"/info"</span>, info)</span><br><span class="line"></span><br><span class="line">   srv := &amp;http.Server&#123;</span><br><span class="line">      Addr:    portNum,</span><br><span class="line">      Handler: mux,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">"Started on port"</span>, portNum)</span><br><span class="line">   err := srv.ListenAndServe()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Fail start http server."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>我们的首个信号将是 Trace。为了与这个信号互动，我们必须创建一个 provider，如下所示。作为一个参数，我们将拥有一个 Exporter，它将接收收集到的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: otel.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"context"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel/sdk/trace"</span></span><br><span class="line">   <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTraceExporter</span><span class="params">()</span> <span class="params">(trace.SpanExporter, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> stdouttrace.New(stdouttrace.WithPrettyPrint())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTraceProvider</span><span class="params">(traceExporter trace.SpanExporter)</span> *<span class="title">trace</span>.<span class="title">TracerProvider</span></span> &#123;</span><br><span class="line">   traceProvider := trace.NewTracerProvider(</span><br><span class="line">      trace.WithBatcher(traceExporter,</span><br><span class="line">         trace.WithBatchTimeout(time.Second)),</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">return</span> traceProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.go 文件中，我们将使用创建跟踪提供程序的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"context"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> portNum <span class="keyword">string</span> = <span class="string">":8080"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"Starting http server."</span>)</span><br><span class="line"></span><br><span class="line">   mux := http.NewServeMux()</span><br><span class="line">   ctx := context.Background()</span><br><span class="line"></span><br><span class="line">   consoleTraceExporter, err := newTraceExporter()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Failed get console exporter."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   tracerProvider := newTraceProvider(consoleTraceExporter)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> tracerProvider.Shutdown(ctx)</span><br><span class="line">   otel.SetTracerProvider(tracerProvider)</span><br><span class="line"></span><br><span class="line">   mux.HandleFunc(<span class="string">"/info"</span>, info)</span><br><span class="line"></span><br><span class="line">   srv := &amp;http.Server&#123;</span><br><span class="line">      Addr:    portNum,</span><br><span class="line">      Handler: mux,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">"Started on port"</span>, portNum)</span><br><span class="line">   err = srv.ListenAndServe()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Fail start http server."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在实例化一个 provider 时，我们必须保证它会“关闭”。这样可以避免内存泄露。</p><p>现在我们的服务已经配置了一个 trace provider，我们准备好收集数据了。让我们调用 “/info” 接口来产生数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: info.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"encoding/json"</span></span><br><span class="line">   <span class="string">"go.opentelemetry.io/otel"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InfoResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">   Version     <span class="keyword">string</span> <span class="string">`json:"version"`</span></span><br><span class="line">   ServiceName <span class="keyword">string</span> <span class="string">`json:"service-name"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   tracer = otel.Tracer(<span class="string">"info-service"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   _, span := tracer.Start(r.Context(), <span class="string">"info"</span>)</span><br><span class="line">   <span class="keyword">defer</span> span.End()</span><br><span class="line"></span><br><span class="line">   w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">   response := InfoResponse&#123;Version: <span class="string">"0.1.0"</span>, ServiceName: <span class="string">"otlp-sample"</span>&#125;</span><br><span class="line">   json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tracer = otel.Tracer(“info-service”)</code> 将在我们已经在<code>main.go</code> 中注册的全局 trace provider 中创建一个命名的跟踪器。如果未提供名称，则将使用默认名称。</p><p><code>tracer.Start(r.Context(), “info”)</code> 创建一个 <code>Span</code> 和一个包含新创建的 <code>span</code> 的 <code>context.Context</code>。如果 “ctx” 中提供的 <code>context.Context</code> 包含一个 <code>Span</code>，那么新创建的 <code>Span</code> 将是该 <code>Span</code> 的子<code>Span</code>，否则它将是根 <code>Span</code>。</p><p>Span 对我们来说是一个新的概念。Span 代表一个工作单元或操作。Span 是跟踪（Traces）的构建块。</p><p>同样地，正如提供程序一样，我们必须始终关闭 Spans 以避免“内存泄漏”。</p><p>现在，我们的端点已经被监控，我们可以在控制台中查看我们的观测数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"Name"</span>:<span class="string">"info"</span>,</span><br><span class="line"> <span class="attr">"SpanContext"</span>:&#123;</span><br><span class="line">   <span class="attr">"TraceID"</span>:<span class="string">"6216cbe99bfd1165974dc2bda24e0d5c"</span>,</span><br><span class="line">   <span class="attr">"SpanID"</span>:<span class="string">"728454ee6b9a72e3"</span>,</span><br><span class="line">   <span class="attr">"TraceFlags"</span>:<span class="string">"01"</span>,</span><br><span class="line">   <span class="attr">"TraceState"</span>:<span class="string">""</span>,</span><br><span class="line">   <span class="attr">"Remote"</span>:<span class="literal">false</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"Parent"</span>:&#123;</span><br><span class="line">   <span class="attr">"TraceID"</span>:<span class="string">"00000000000000000000000000000000"</span>,</span><br><span class="line">   <span class="attr">"SpanID"</span>:<span class="string">"0000000000000000"</span>,</span><br><span class="line">   <span class="attr">"TraceFlags"</span>:<span class="string">"00"</span>,</span><br><span class="line">   <span class="attr">"TraceState"</span>:<span class="string">""</span>,</span><br><span class="line">   <span class="attr">"Remote"</span>:<span class="literal">false</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"SpanKind"</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">"StartTime"</span>:<span class="string">"2024-03-02T23:39:51.791979-03:00"</span>,</span><br><span class="line"> <span class="attr">"EndTime"</span>:<span class="string">"2024-03-02T23:39:51.792140908-03:00"</span>,</span><br><span class="line"> <span class="attr">"Attributes"</span>:<span class="literal">null</span>,</span><br><span class="line"> <span class="attr">"Events"</span>:<span class="literal">null</span>,</span><br><span class="line"> <span class="attr">"Links"</span>:<span class="literal">null</span>,</span><br><span class="line"> <span class="attr">"Status"</span>:&#123;</span><br><span class="line">   <span class="attr">"Code"</span>:<span class="string">"Unset"</span>,</span><br><span class="line">   <span class="attr">"Description"</span>:<span class="string">""</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">"DroppedAttributes"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"DroppedEvents"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"DroppedLinks"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"ChildSpanCount"</span>:<span class="number">0</span>,</span><br><span class="line"> <span class="attr">"Resource"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"service.name"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"unknown_service:otlp-golang"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.language"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"go"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.name"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"opentelemetry"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.version"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"1.24.0"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">"InstrumentationLibrary"</span>:&#123;</span><br><span class="line">   <span class="attr">"Name"</span>:<span class="string">"info-service"</span>,</span><br><span class="line">   <span class="attr">"Version"</span>:<span class="string">""</span>,</span><br><span class="line">   <span class="attr">"SchemaURL"</span>:<span class="string">""</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-Metrics"><a href="#添加-Metrics" class="headerlink" title="添加 Metrics"></a>添加 Metrics</h3><p>我们已经有了我们的 tracing 配置。现在来添加我们的第一个指标。</p><p>首先，安装并配置一个专门用于指标的导出器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get <span class="string">"go.opentelemetry.io/otel/exporters/stdout/stdoutmetric"</span></span><br></pre></td></tr></table></figure><p>通过修改我们的 otel.go 文件，我们将有两个导出器：一个专门用于 tracing，另一个用于 metrics。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: otel.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTraceExporter</span><span class="params">()</span> <span class="params">(trace.SpanExporter, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> stdouttrace.New(stdouttrace.WithPrettyPrint())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMetricExporter</span><span class="params">()</span> <span class="params">(metric.Exporter, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> stdoutmetric.New()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在添加我们的 metrics Provider 实例化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: otel.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMeterProvider</span><span class="params">(meterExporter metric.Exporter)</span> *<span class="title">metric</span>.<span class="title">MeterProvider</span></span> &#123;</span><br><span class="line">   meterProvider := metric.NewMeterProvider(</span><br><span class="line">      metric.WithReader(metric.NewPeriodicReader(meterExporter,</span><br><span class="line">         metric.WithInterval(<span class="number">10</span>*time.Second))),</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">return</span> meterProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将提供商的行为更改为每10秒进行一次定期读取（默认为1分钟）。</p><p>在实例化一个 MeterProvide r时，我们将创建一个Meter。Meters 允许您创建您可以使用的仪器，以创建不同类型的指标（计数器、异步计数器、直方图、异步仪表、增减计数器、异步增减计数器……）。</p><p>现在我们可以在 main.go 中配置我们的新 exporter 和 provider。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   log.Println(<span class="string">"Starting http server."</span>)</span><br><span class="line"></span><br><span class="line">   mux := http.NewServeMux()</span><br><span class="line">   ctx := context.Background()</span><br><span class="line"></span><br><span class="line">   consoleTraceExporter, err := newTraceExporter()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Failed get console exporter (trace)."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   consoleMetricExporter, err := newMetricExporter()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Failed get console exporter (metric)."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   tracerProvider := newTraceProvider(consoleTraceExporter)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> tracerProvider.Shutdown(ctx)</span><br><span class="line">   otel.SetTracerProvider(tracerProvider)</span><br><span class="line"></span><br><span class="line">   meterProvider := newMeterProvider(consoleMetricExporter)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">defer</span> meterProvider.Shutdown(ctx)</span><br><span class="line">   otel.SetMeterProvider(meterProvider)</span><br><span class="line"></span><br><span class="line">   mux.HandleFunc(<span class="string">"/info"</span>, info)</span><br><span class="line"></span><br><span class="line">   srv := &amp;http.Server&#123;</span><br><span class="line">      Addr:    portNum,</span><br><span class="line">      Handler: mux,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   log.Println(<span class="string">"Started on port"</span>, portNum)</span><br><span class="line">   err = srv.ListenAndServe()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"Fail start http server."</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，让我们测量我们想要的数据。我们将在 info.go 中做这件事，这与我们之前在 trace 中所做的非常相似。</p><p>我们将使用 <code>otel.Meter(&quot;info-service&quot;)</code> 在已经注册的全局提供者上创建一个命名的计量器。我们还将通过 <code>metric.Int64Counter</code> 定义我们的测量工具。Int64Counter 是一种记录递增的 int64 值的工具。</p><p>然而，与 trace不同，我们需要初始化我们的测量工具。我们将为我们的度量配置名称、描述和单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: info.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   tracer      = otel.Tracer(<span class="string">"info-service"</span>)</span><br><span class="line">   meter       = otel.Meter(<span class="string">"info-service"</span>)</span><br><span class="line">   viewCounter metric.Int64Counter</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> err error</span><br><span class="line">   viewCounter, err = meter.Int64Counter(<span class="string">"user.views"</span>,</span><br><span class="line">      metric.WithDescription(<span class="string">"The number of views"</span>),</span><br><span class="line">      metric.WithUnit(<span class="string">"&#123;views&#125;"</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦完成这个步骤，我们就可以开始测量了。最终代码看起来会像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// file: info.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   "encoding/json"</span><br><span class="line">   "go.opentelemetry.io/otel"</span><br><span class="line">   "go.opentelemetry.io/otel/metric"</span><br><span class="line">   "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type InfoResponse struct &#123;</span><br><span class="line">   Version     string `json:"version"`</span><br><span class="line">   ServiceName string `json:"service-name"`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">   tracer      = otel.Tracer("info-service")</span><br><span class="line">   meter       = otel.Meter("info-service")</span><br><span class="line">   viewCounter metric.Int64Counter</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">   var err error</span><br><span class="line">   viewCounter, err = meter.Int64Counter("user.views",</span><br><span class="line">      metric.WithDescription("The number of views"),</span><br><span class="line">      metric.WithUnit("&#123;views&#125;"))</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func info(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">   ctx, span := tracer.Start(r.Context(), "info")</span><br><span class="line">   defer span.End()</span><br><span class="line"></span><br><span class="line">   viewCounter.Add(ctx, 1)</span><br><span class="line"></span><br><span class="line">   w.Header().Set("Content-Type", "application/json")</span><br><span class="line">   response := InfoResponse&#123;Version: "0.1.0", ServiceName: "otlp-sample"&#125;</span><br><span class="line">   json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行我们的服务时，每10秒系统将在控制台显示我们的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"Resource"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"service.name"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"unknown_service:otlp-golang"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.language"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"go"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.name"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"opentelemetry"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Key"</span>:<span class="string">"telemetry.sdk.version"</span>,</span><br><span class="line">     <span class="attr">"Value"</span>:&#123;</span><br><span class="line">       <span class="attr">"Type"</span>:<span class="string">"STRING"</span>,</span><br><span class="line">       <span class="attr">"Value"</span>:<span class="string">"1.24.0"</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">"ScopeMetrics"</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">"Scope"</span>:&#123;</span><br><span class="line">       <span class="attr">"Name"</span>:<span class="string">"info-service"</span>,</span><br><span class="line">       <span class="attr">"Version"</span>:<span class="string">""</span>,</span><br><span class="line">       <span class="attr">"SchemaURL"</span>:<span class="string">""</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">"Metrics"</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="attr">"Name"</span>:<span class="string">"user.views"</span>,</span><br><span class="line">         <span class="attr">"Description"</span>:<span class="string">"The number of views"</span>,</span><br><span class="line">         <span class="attr">"Unit"</span>:<span class="string">"&#123;views&#125;"</span>,</span><br><span class="line">         <span class="attr">"Data"</span>:&#123;</span><br><span class="line">           <span class="attr">"DataPoints"</span>:[</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="attr">"Attributes"</span>:[</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               ],</span><br><span class="line">               <span class="attr">"StartTime"</span>:<span class="string">"2024-03-03T08:50:39.07383-03:00"</span>,</span><br><span class="line">               <span class="attr">"Time"</span>:<span class="string">"2024-03-03T08:51:45.075332-03:00"</span>,</span><br><span class="line">               <span class="attr">"Value"</span>:<span class="number">1</span></span><br><span class="line">             &#125;</span><br><span class="line">           ],</span><br><span class="line">           <span class="attr">"Temporality"</span>:<span class="string">"CumulativeTemporality"</span>,</span><br><span class="line">           <span class="attr">"IsMonotonic"</span>:<span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>为了将追踪信息发送出去，我们需要传播上下文。为了做到这一点，我们必须注册一个传播器。我们将在 otel.go和main.go 中实现，跟追 Tracing 和 metric 的实现差不多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: otel.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPropagator</span><span class="params">()</span> <span class="title">propagation</span>.<span class="title">TextMapPropagator</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> propagation.NewCompositeTextMapPropagator(</span><br><span class="line">      propagation.TraceContext&#123;&#125;,</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go </span></span><br><span class="line"></span><br><span class="line">prop := newPropagator()</span><br><span class="line">otel.SetTextMapPropagator(prop)</span><br></pre></td></tr></table></figure><h3 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h3><p>我们将通过观测数据来丰富我们的 HTTP 服务器以完成我们的监控。为此我们将使用带有 OTel 的 http handler 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handleFunc := <span class="function"><span class="keyword">func</span><span class="params">(pattern <span class="keyword">string</span>, handlerFunc <span class="keyword">func</span>(http.ResponseWriter, *http.Request)</span>)</span> &#123;</span><br><span class="line">   handler := otelhttp.WithRouteTag(pattern, http.HandlerFunc(handlerFunc))</span><br><span class="line">   mux.Handle(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handleFunc(<span class="string">"/info"</span>, info)</span><br><span class="line">newHandler := otelhttp.NewHandler(mux, <span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">srv := &amp;http.Server&#123;</span><br><span class="line">   Addr:    portNum,</span><br><span class="line">   Handler: newHandler,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们将在我们的收集到的数据中获得来自 HTTP 服务器的额外信息（用户代理、HTTP方法、协议、路由等）。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>这篇文章我们详细展示了如何使用 Go 来对接 OpenTelemetry 以实现完整的可观测系统，这里使用 console Exporter 仅作演示使用 ，在实际的开发中我们可能需要使用更加强大的 Exporter 将数据可视化，比如可以使用 <a href="github.com/GoogleCloudPlatform/opentelemetry-operations-go/exporter/trace" title="google cloud opentelementry">Google Cloud Trace</a> 来将数据直接导出到 Goole Cloud Monitoring 。</p><p><img src="https://files.mdnice.com/user/4760/c02d850b-e181-4e10-b16b-a0708ca394aa.png" alt=""></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://opentelemetry.io/" title="OpenTelementry" target="_blank" rel="noopener">OpenTelemetry</a><br><a href="https://learning.oreilly.com/library/view/the-future-of/9781098118433/" title="The furure of observability" target="_blank" rel="noopener">The Future of Observability with OpenTelemetry</a><br><a href="https://learning.oreilly.com/library/view/cloud-native-observability-with/9781801077705/" title="Cloud-Native Observisability with Opentelementry" target="_blank" rel="noopener">Cloud-Native Observability with OpenTelemetry</a><br><a href="https://learning.oreilly.com/library/view/learning-opentelemetry/9781098147174/" title="Learning OpenTelementry" target="_blank" rel="noopener">Learning OpenTelemetry</a></p><hr>]]></content>
    
    <summary type="html">
    
      Observability with OpenTelemetry and Go
    
    </summary>
    
      <category term="GO" scheme="https://cloudsjhan.github.io/categories/GO/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>什么情况下使用 ErrGroup VS waitGroup？</title>
    <link href="https://cloudsjhan.github.io/2024/05/11/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-ErrGroup-VS-waitGroup%EF%BC%9F/"/>
    <id>https://cloudsjhan.github.io/2024/05/11/什么情况下使用-ErrGroup-VS-waitGroup？/</id>
    <published>2024-05-11T12:43:56.000Z</published>
    <updated>2024-05-11T12:46:03.738Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>Goroutine 是编写 Go 语言并发程序的强大工具。然而管理协程，特别是在处理协程的错误时，可能会变得繁琐。这时，x/sync 包中的 errgroup 就派上用场了。它提供了一种简化的方法来处理并发任务及其错误。</p><h3 id="Example-for-ErrGroup"><a href="#Example-for-ErrGroup" class="headerlink" title="Example for ErrGroup"></a>Example for ErrGroup</h3><p>下面是一个使用 errorGroup 的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"context"</span></span><br><span class="line"> <span class="string">"errors"</span></span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task1</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"Task 1 started successfully"</span>)</span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">  fmt.Println(<span class="string">"Task 1 completed successfully"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">  fmt.Println(<span class="string">"Task 1 canceled"</span>)</span><br><span class="line">  <span class="keyword">return</span> ctx.Err()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task2</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"Task 2 started successfully"</span>)</span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">  fmt.Println(<span class="string">"Task 2 processed failed"</span>)</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"Task 2 processed failed due to error"</span>)</span><br><span class="line"> <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">  fmt.Println(<span class="string">"Task 2 canceled"</span>)</span><br><span class="line">  <span class="keyword">return</span> ctx.Err()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task3</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"Task 3 started successfully"</span>)</span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">  fmt.Println(<span class="string">"Task 3 completed successfully"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">  fmt.Println(<span class="string">"Task 3 canceled"</span>)</span><br><span class="line">  <span class="keyword">return</span> ctx.Err()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"> <span class="keyword">defer</span> cancel() <span class="comment">// Ensure cancellation happens when main() exits</span></span><br><span class="line"></span><br><span class="line"> g, ctx := errgroup.WithContext(ctx)</span><br><span class="line"></span><br><span class="line"> g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> task1(ctx)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> task2(ctx)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> task3(ctx)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Encountered error:"</span>, err)</span><br><span class="line">  cancel()</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"All tasks completed successfully"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序的输出是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Task <span class="number">1</span> started successfully</span><br><span class="line">Task <span class="number">2</span> started successfully</span><br><span class="line">Task <span class="number">3</span> started successfully</span><br><span class="line">Task <span class="number">1</span> completed successfully</span><br><span class="line">Task <span class="number">2</span> processed failed</span><br><span class="line">Encountered error: Task <span class="number">2</span> processed failed due to error</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>我们创建了一个带有可取消上下文的 <code>errgroup</code>。</li><li>定义了3个任务，task1 和 task3 在一定时间后模拟成功完成，而 task2 在更长的时间后通过返回错误来模拟失败。</li><li>使用 g.Go 在单独的 goroutine 中启动每个任务。</li><li>调用 g.Wait 等待所有任务完成。如果任何任务遇到错误，g.Wait() 会立即返回该错误。<br>在主执行之后，task1 成功完成，task2 遇到了处理失败，而 task3 由于 task2 中的上述失败而被取消。</li></ul><h3 id="ErrGroup-vs-WaitGroup"><a href="#ErrGroup-vs-WaitGroup" class="headerlink" title="ErrGroup vs WaitGroup"></a>ErrGroup vs WaitGroup</h3><h4 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="ErrGroup:"></a>ErrGroup:</h4><ul><li>使用 ErrGroup 来管理并发任务中的错误。它聚合了所有协程中的错误，并返回遇到的第一个错误。</li><li>需要管理多个可能产生错误的并发任务。</li><li>想要利用上下文取消功能来优雅地关闭程序。</li><li>不想手动检查多个 WaitGroup 调用的错误</li><li>它与 Go 的上下文包无缝集成。任何来自协程的错误都会取消上下文，自动停止其他正在运行的任务。</li></ul><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><ul><li>使用 WaitGroup 进行基本同步。它简单地等待指定数量的 goroutine 完成后再继续。</li><li>]当你只关心任务完成而不预期错误时，它是理想的选择。</li><li>它不直接处理错误。你需要在每个 goroutine 中检查错误并单独处理它们。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用 WaitGroup 进行简单的同步</li><li>使用 ErrGroup 进行错误管理，并希望在优雅关闭时有上下文感知的取消。</li><li>也可以同时使用它们，WaitGroup 用于基本同步，ErrGroup 用于一组任务中的详细错误处理。</li></ul><p>相关的 <a href="https://github.com/golang/go/issues/23595" title="x/sync/errgroup: get all errors" target="_blank" rel="noopener">issue</a></p><hr>]]></content>
    
    <summary type="html">
    
      什么情况下使用 ErrGroup VS waitGroup？
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 实现枚举的各种方法及最佳实践</title>
    <link href="https://cloudsjhan.github.io/2024/05/07/Golang-%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://cloudsjhan.github.io/2024/05/07/Golang-实现枚举的各种方法及最佳实践/</id>
    <published>2024-05-07T14:24:01.000Z</published>
    <updated>2024-05-07T14:24:48.865Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>枚举提供了一种表示一组命名常量的方式。虽然 Go 语言没有内置的枚举类型，但开发者可以通过常量/自定义类型来模拟类似枚举的行为。</p><p>枚举在编程语言中扮演着至关重要的角色，提供了一种简洁而富有表现力的方式来定义一组命名常量。虽然像Java或C#这样的语言提供了对枚举的内置支持，但Go采用了不同的方法。在 Go 中，枚举并不是一种原生的语言特性，但开发者有几种技术可供使用，以实现类似的功能。<br>本文深入探讨了 Go 语言中的枚举，探索了定义和有效使用它们的各种技术。通过代码示例、比较和实际用例，我们的目标是掌握枚举并在 Go 项目中高效使用它们。</p><h3 id="Understanding-Enum"><a href="#Understanding-Enum" class="headerlink" title="Understanding Enum"></a>Understanding Enum</h3><p>在 Go 语言中，枚举（enumerations 的缩写）提供了一种表示一组命名常量的方式。虽然 Go 语言没有像其他一些语言那样内建的枚举类型，但开发者可以使用常量或自定义类型来模拟类似枚举的行为。让我们深入了解 Go 中枚举的目的和语法：</p><p>目的<br>可读性和可维护性：通过给特定值分配有意义的名称，枚举使代码更具可读性和自解释性。这增强了代码的可维护性，因为更容易理解每个常量的目的。<br>类型安全性：枚举有助于通过将变量限制为预定义的一组值来强化类型安全性。这减少了因使用错误值而引起的运行时错误的可能性。</p><h3 id="实现语法"><a href="#实现语法" class="headerlink" title="实现语法"></a>实现语法</h3><ul><li>使用常量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum defining colors using constants</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Red   = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    Green        <span class="comment">// 1</span></span><br><span class="line">    Blue         <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Red, Green, Blue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用自定义类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum defining colors using custom types</span></span><br><span class="line"><span class="keyword">type</span> CardType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    VISA CardType = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    MASTER            <span class="comment">// 1</span></span><br><span class="line">    JCB             <span class="comment">// 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(VISA, MASTER, BlueJCB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中：</p><ul><li><p>我们使用常量和自定义类型定义颜色枚举。</p></li><li><p>iota 用于自动生成从 0 开始递增的值。</p></li><li><p>常量被分配给每个枚举值，而在自定义类型的情况下，会指定一个底层类型（通常是 int）。</p></li></ul><p>  Go 语言中的枚举提供了一种灵活的方式来表示一组固定值，提高了代码的清晰度和类型安全性。然而，根据你项目的具体需求，选择适当的方法（常量或自定义类型）至关重要。</p><h3 id="在-Go-中使用-Enum-类型的优缺点"><a href="#在-Go-中使用-Enum-类型的优缺点" class="headerlink" title="在 Go 中使用 Enum 类型的优缺点"></a>在 Go 中使用 Enum 类型的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高可读性：枚举通过为特定值提供有意义的名称来增强代码的可读性。这使得代码更加自解释，更易于开发人员理解。</li><li>类型安全性：枚举有助于通过限制变量为预定义的一组值来强化类型安全性。这减少了使用不正确或意外值的风险，从而减少了运行时错误。</li><li>明确定义常量：枚举允许开发人员明确定义一组常量，明确指出哪些值对于特定变量或参数是有效的。</li><li>增强可维护性：通过使用枚举，开发人员可以轻松地在单一位置更新或修改允许的值集，减少代码库中不一致或错误的可能性。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有内置枚举类型：与其他一些编程语言不同，Go语言没有内置的枚举类型。开发者必须使用诸如常量或自定义类型之类的解决方法来模拟类似枚举的行为。</li><li>冗长语法：使用常量或自定义类型在 Go 中实现枚举有时会导致冗长的语法，特别是当定义了一组大型的枚举值时。</li><li>表达力有限：Go 中的枚举缺乏其他语言枚举中的一些高级特性，例如将值或行为与个别枚举常量关联的能力。</li><li>潜在冲突：当使用常量作为枚举时，如果在同一代码库的不同上下文中使用了相同的常量名称，存在冲突的风险。这可能导致意外的行为或错误。</li><li>额外开销：使用自定义类型实现枚举可能会引入额外的开销，特别是如果为每个枚举常量定义了关联的方法或行为。</li></ul><p>尽管存在这些限制，Go 语言中的枚举类型仍然是提高代码清晰度、可维护性和类型安全性的有价值工具，开发者可以通过理解它们的优点和局限性来有效地利用它们。</p><h3 id="第三方类库"><a href="#第三方类库" class="headerlink" title="第三方类库"></a>第三方类库</h3><p>几个第三方库在 Go 语言中提供了类似枚举的功能：</p><p>go-enum：它可以从简单的定义格式生成 Go 语言的枚举代码。（点击 <a href="https://github.com/abice/go-enum" title="go-enum" target="_blank" rel="noopener">go-enum GitHub</a> 以获取更多信息）。<br>stringer：它为在 Go 源代码中定义的枚举自动生成字符串方法。（点击 <a href="https://golang.org/x/tools/cmd/stringer" title="stinger" target="_blank" rel="noopener">stringer</a> 工具以获取更多详情）。</p><h3 id="上述三种方式该如何选择？"><a href="#上述三种方式该如何选择？" class="headerlink" title="上述三种方式该如何选择？"></a>上述三种方式该如何选择？</h3><ul><li>如果希望实现简单，并且枚举集较小且不需要额外特性，使用 Iota 常量即可。</li><li>如果需要更好的类型安全性、灵活性，以及需要与枚举关联的额外方法，使用自定义类型。</li><li>如果需要自动化枚举生成或需要额外特性（如字符串表示），考虑使用库，但要谨慎处理依赖性和兼容性问题。</li></ul><h3 id="一些-Use-Cases"><a href="#一些-Use-Cases" class="headerlink" title="一些 Use Cases"></a>一些 Use Cases</h3><ul><li>表示星期</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum for days of the week using custom types</span></span><br><span class="line"><span class="keyword">type</span> DayOfWeek <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday DayOfWeek = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Days of the week:"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Sunday:"</span>, Sunday)</span><br><span class="line">    fmt.Println(<span class="string">"Monday:"</span>, Monday)</span><br><span class="line">    fmt.Println(<span class="string">"Tuesday:"</span>, Tuesday)</span><br><span class="line">    fmt.Println(<span class="string">"Wednesday:"</span>, Wednesday)</span><br><span class="line">    fmt.Println(<span class="string">"Thursday:"</span>, Thursday)</span><br><span class="line">    fmt.Println(<span class="string">"Friday:"</span>, Friday)</span><br><span class="line">    fmt.Println(<span class="string">"Saturday:"</span>, Saturday)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表示访问级别</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AccessLevel <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Guest AccessLevel = <span class="literal">iota</span></span><br><span class="line">    User</span><br><span class="line">    Moderator</span><br><span class="line">    Admin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>在 Go 语言中，枚举提供了一种强大的机制，用于提高代码的清晰度、可维护性和类型安全性。通过遵循最佳实践并有效利用枚举，开发者可以在他们的 Go 项目中编写更加健壮和可读的代码。</p></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本指南中，我们探讨了在 Go 语言中实现枚举的各种方法，并讨论了它们各自的优势、局限性和最佳实践。</p><p>本质上，Go 语言中的枚举通过提供一种结构化的方式来表示一组固定值，赋予开发者编写更清洁、更易于维护的代码的能力。通过理解本指南中概述的不同技术和最佳实践，开发者可以有效地利用枚举来增强他们的 Go 项目。</p><hr>]]></content>
    
    <summary type="html">
    
      Golang 实现枚举的各种方法及最佳实践
    
    </summary>
    
      <category term="Golang" scheme="https://cloudsjhan.github.io/categories/Golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="enum" scheme="https://cloudsjhan.github.io/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>一些在 Golang 中高效处理 Collection 类型的库</title>
    <link href="https://cloudsjhan.github.io/2024/05/05/%E4%B8%80%E4%BA%9B%E5%9C%A8-Golang-%E4%B8%AD%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86-Collection-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%93/"/>
    <id>https://cloudsjhan.github.io/2024/05/05/一些在-Golang-中高效处理-Collection-类型的库/</id>
    <published>2024-05-05T09:40:44.000Z</published>
    <updated>2024-05-05T09:41:31.210Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>处理集合是构建任何应用程序的重要部分。通常，您需要以下几类操作：</p><ul><li>转换：将某个函数应用于集合中的每个元素，以创建一个新类型的新集合；</li><li>过滤：选择满足特定条件的集合中的元素；</li><li>聚合：从集合中计算出单个结果，通常用于汇总；</li><li>排序/排序：根据某些标准重新排列集合的元素；</li><li>访问：根据其属性或位置检索元素的操作；</li><li>实用程序：与集合一起工作的通用操作，但不一定完全适合上述分类。</li></ul><p>尽管Go具有许多优点，但对于高级集合操作的内置支持相对有限，因此如果需要，您需要使用第三方包。在本文中，我将探讨几个流行的Go库，这些库可以增强语言的能力，以有效地处理集合，涵盖它们的功能和功能。这篇评论将帮助您选择合适的工具，以简化Go项目中的数据处理任务。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>让我们从上面的每个集合操作类中回顾一些流行的方法。</p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>Map — 对集合中的每个元素应用一个函数，并返回结果集合；<br>FlatMap — 将每个元素处理为一个元素列表，然后将这些列表展平为一个列表。</p><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>Filter — 删除不匹配谓词函数的元素；<br>Distinct — 从集合中删除重复的元素；<br>TakeWhile — 返回满足给定条件的元素，直到遇到不满足条件的元素为止；<br>DropWhile — 删除满足给定条件的元素，然后返回剩余的元素。</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>Reduce — 使用给定的函数组合集合的所有元素，并返回组合结果；<br>Count — 返回满足特定条件的元素数量；<br>Sum — 计算集合中每个元素的数字属性之和；<br>Max/Min — 确定元素属性中的最大值或最小值；<br>Average — 计算集合中元素的数字属性的平均值。</p><h4 id="排序-排序"><a href="#排序-排序" class="headerlink" title="排序/排序"></a>排序/排序</h4><p>Sort — 根据比较器规则对集合的元素进行排序；<br>Reverse — 颠倒集合中元素的顺序。</p><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>Find — 返回匹配给定谓词的第一个元素；<br>AtIndex — 检索特定索引处的元素。</p><h4 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h4><p>GroupBy — 根据键生成器函数将元素分类为组；<br>Partition — 根据谓词将集合分成两个集合：一个用于满足谓词的元素，另一个用于不满足谓词的元素；<br>Slice Operations — 修改集合视图或划分的操作，如切片或分块。</p><h3 id="Go-内置的能力"><a href="#Go-内置的能力" class="headerlink" title="Go 内置的能力"></a>Go 内置的能力</h3><p>在Go语言中，有几种类型可用于处理数据集合：</p><p>数组（Arrays） — 固定大小的元素集合。数组大小在声明时定义，例如 <code>var myArray [5]int</code>；<br>切片（Slices） — 动态大小的元素集合。切片建立在数组之上，但与数组不同的是，它们可以增长或缩小。声明方式：<code>mySlice := []int{1, 2, 3}</code>；<br>映射（Maps） — 键-值对的集合。映射可以动态增长，且键的顺序不受保证。例如 <code>myMap := map[string]int{&quot;first&quot;: 1, &quot;second&quot;: 2}</code> 创建了一个字符串键和整数值的映射；<br>通道（Channels） — 类型化的通信原语，允许在goroutine之间共享数据。例如 <code>myChan := make(chan int)</code> 创建了一个传输整数的通道。</p><p>Go标准库提供了其他结构和实用程序，可以作为集合或增强集合的功能，例如：</p><p>堆（Heap） — container/heap包为任何sort.Interface提供了堆操作。堆是具有以下特性的树：每个节点都是其子树中值最小的节点；<br>链表（List） — container/list包实现了双向链表；<br>环形链表（Ring） — container/ring包实现了环形链表的操作。</p><p>此外，作为Go标准库的一部分，还有用于处理切片和映射的包：</p><p>slices — 该包定义了与任何类型的切片一起使用的各种有用的函数；<br>maps — 该包定义了与任何类型的映射一起使用的各种有用的函数。</p><p>通过内置功能，您可以对集合执行一些操作：</p><p>获取数组/切片/映射的长度；<br>通过索引/键访问元素，对切片进行“切片”；<br>遍历项目。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>, <span class="number">3</span>: <span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"len(s)=%d\n"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"> fmt.Printf(<span class="string">"len(m)=%d\n"</span>, <span class="built_in">len</span>(m))</span><br><span class="line"> fmt.Printf(<span class="string">"cap(s)=%d\n"</span>, <span class="built_in">cap</span>(s))</span><br><span class="line"> <span class="comment">// fmt.Printf("cap(m)=%d\n", cap(m)) // error: invalid argument m (type map[int]string) for cap</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// panic: runtime error: index out of range [5] with length 5</span></span><br><span class="line"> <span class="comment">// fmt.Printf("s[5]=%d\n", s[5])</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// panic: runtime error: index out of range [5] with length 5</span></span><br><span class="line"> <span class="comment">// s[5] = 6</span></span><br><span class="line"></span><br><span class="line"> s = <span class="built_in">append</span>(s, <span class="number">6</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"s=%v\n"</span>, s)</span><br><span class="line"> fmt.Printf(<span class="string">"len(s)=%d\n"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"> fmt.Printf(<span class="string">"cap(s)=%d\n"</span>, <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line"> m[<span class="number">4</span>] = <span class="string">"four"</span></span><br><span class="line"> fmt.Printf(<span class="string">"m=%v\n"</span>, m)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"s[2:4]=%v\n"</span>, s[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line"> fmt.Printf(<span class="string">"s[2:]=%v\n"</span>, s[<span class="number">2</span>:])</span><br><span class="line"> fmt.Printf(<span class="string">"s[:2]=%v\n"</span>, s[:<span class="number">2</span>])</span><br><span class="line"> fmt.Printf(<span class="string">"s[:]=%v\n"</span>, s[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会打印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">len(s)=5</span><br><span class="line">len(m)=3</span><br><span class="line">cap(s)=5</span><br><span class="line">s=[1 2 3 4 5 6]</span><br><span class="line">len(s)=6</span><br><span class="line">cap(s)=10</span><br><span class="line">m=map[1:one 2:two 3:three 4:four]</span><br><span class="line">s[2:4]=[3 4]</span><br><span class="line">s[2:]=[3 4 5 6]</span><br><span class="line">s[:2]=[1 2]</span><br><span class="line">s[:]=[1 2 3 4 5 6]</span><br></pre></td></tr></table></figure><p>让我们逐个看下 Go 内置的 Package。</p><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p>切片 slices包最近才出现在Go标准库中，从Go 1.21版本开始。这是语言中的一个重大进步，但我仍然更喜欢使用外部库来处理集合（您很快就会明白原因）。让我们来看看这个库如何支持所有的集合操作类别。</p><h4 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h4><p>slices 能够快速在切片中找到最小/最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"slices"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Min: %d\n"</span>, slices.Min(s))</span><br><span class="line"> fmt.Printf(<span class="string">"Max: %d\n"</span>, slices.Max(s))</span><br><span class="line"></span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Min: %v\n"</span>, slices.MinFunc(</span><br><span class="line">  e,</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(i, j Example)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> i.Number - j.Number</span><br><span class="line">  &#125;),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Max: %v\n"</span>, slices.MaxFunc(</span><br><span class="line">  e,</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(i, j Example)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> i.Number - j.Number</span><br><span class="line">  &#125;),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码打印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Min: 1</span><br><span class="line">Max: 5</span><br><span class="line">Min: &#123;A 1&#125;</span><br><span class="line">Max: &#123;D 4&#125;</span><br></pre></td></tr></table></figure><h4 id="Sorting-Ordering"><a href="#Sorting-Ordering" class="headerlink" title="Sorting/Ordering"></a>Sorting/Ordering</h4><p>slices 能够使用比较函数对切片进行排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"slices"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"> slices.Sort(s)</span><br><span class="line"> fmt.Printf(<span class="string">"Sorted: %v\n"</span>, s)</span><br><span class="line"></span><br><span class="line"> slices.Reverse(s)</span><br><span class="line"> fmt.Printf(<span class="string">"Reversed: %v\n"</span>, s)</span><br><span class="line"></span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slices.SortFunc(e, <span class="function"><span class="keyword">func</span><span class="params">(a, b Example)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.Number - b.Number</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Sorted: %v\n"</span>, e)</span><br><span class="line"></span><br><span class="line"> slices.Reverse(e)</span><br><span class="line"> fmt.Printf(<span class="string">"Reversed: %v\n"</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sorted: [1 2 3 4 5]</span><br><span class="line">Reversed: [5 4 3 2 1]</span><br><span class="line">Sorted: [&#123;A 1&#125; &#123;B 2&#125; &#123;C 3&#125; &#123;D 4&#125;]</span><br><span class="line">Reversed: [&#123;D 4&#125; &#123;C 3&#125; &#123;B 2&#125; &#123;A 1&#125;]</span><br></pre></td></tr></table></figure><p>不过这个方法有个缺点，就是排序是原地进行的，修改了原始切片。如果该方法返回一个新的排序后的切片，从而保留原始数组会更好一点。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p><code>slices</code>暴露了一些方法，允许用户在切片中查找元素的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"slices"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"> i := slices.Index(s, <span class="number">3</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"Index of 3: %d\n"</span>, i)</span><br><span class="line"></span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> i = slices.IndexFunc(e, <span class="function"><span class="keyword">func</span><span class="params">(a Example)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.Number == <span class="number">3</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Index of 3: %d\n"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index of 3: 4</span><br><span class="line">Index of 3: 0</span><br></pre></td></tr></table></figure><p>如果你正在处理已排序的切片，你可以使用 BinarySearch 或 BinarySearchFunc 在排序的切片中搜索目标，并返回目标被找到的位置或目标将出现在排序顺序中的位置；它还返回一个布尔值，指示目标是否在切片中被找到。切片必须按递增顺序排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"slices"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"> slices.Sort(s)</span><br><span class="line"></span><br><span class="line"> i, found := slices.BinarySearch(s, <span class="number">3</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"Position of 3: %d. Found: %t\n"</span>, i, found)</span><br><span class="line"></span><br><span class="line"> i, found = slices.BinarySearch(s, <span class="number">6</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"Position of 6: %d. Found: %t\n"</span>, i, found)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Position of 3: 2. Found: true</span><br><span class="line">Position of 6: 5. Found: false</span><br></pre></td></tr></table></figure><h4 id="实用函数"><a href="#实用函数" class="headerlink" title="实用函数"></a>实用函数</h4><p>slices提供了许多实用函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> "fmt"</span><br><span class="line"> "slices"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Example struct &#123;</span><br><span class="line"> Name   string</span><br><span class="line"> Number int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> e1 := []Example&#123;</span><br><span class="line">  &#123;"C", 3&#125;,</span><br><span class="line">  &#123;"A", 1&#125;,</span><br><span class="line">  &#123;"D", 4&#125;,</span><br><span class="line">  &#123;"B", 2&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> e2 := []Example&#123;</span><br><span class="line">  &#123;"A", 1&#125;,</span><br><span class="line">  &#123;"B", 2&#125;,</span><br><span class="line">  &#123;"C", 3&#125;,</span><br><span class="line">  &#123;"D", 4&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Compare: %v\n", slices.CompareFunc(e1, e2, func(a, b Example) int &#123;</span><br><span class="line">  return a.Number - b.Number</span><br><span class="line"> &#125;))</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Contains: %v\n", slices.ContainsFunc(e1, func(a Example) bool &#123;</span><br><span class="line">  return a.Number == 2</span><br><span class="line"> &#125;))</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Delete: %v\n", slices.Delete(e1, 2, 3))</span><br><span class="line"> fmt.Printf("Equal: %v\n", slices.Equal(e1, e2))</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Is Sorted: %v\n", slices.IsSortedFunc(e1, func(a, b Example) int &#123;</span><br><span class="line">  return a.Number - b.Number</span><br><span class="line"> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Compare: 2</span><br><span class="line">Contains: true</span><br><span class="line">Delete: [&#123;C 3&#125; &#123;A 1&#125; &#123;B 2&#125;]</span><br><span class="line">Equal: false</span><br><span class="line">Is Sorted: false</span><br></pre></td></tr></table></figure><p><code>slices</code> 包的官方文档<a href="https://pkg.go.dev/slices?source=post_page-----8387cecdb8a4--------------------------------" title="slices" target="_blank" rel="noopener">地址</a></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>类似于slices，maps也是从Go 1.21开始出现在Go标准库中的。它定义了各种方法来操作 maps。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"maps"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">"one"</span>, <span class="number">2</span>: <span class="string">"two"</span>, <span class="number">3</span>: <span class="string">"three"</span>&#125;</span><br><span class="line"> c := maps.Clone(m)</span><br><span class="line"></span><br><span class="line"> c[<span class="number">4</span>] = <span class="string">"four"</span></span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Original: %v\n"</span>, m)</span><br><span class="line"> fmt.Printf(<span class="string">"Clone: %v\n"</span>, c)</span><br><span class="line"></span><br><span class="line"> maps.DeleteFunc(c, <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>, v <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> k%<span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"> fmt.Printf(<span class="string">"DeleteFunc: %v\n"</span>, c)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Equal: %v\n"</span>, maps.Equal(m, c))</span><br><span class="line"> fmt.Printf(<span class="string">"EqualFunc: %v\n"</span>, maps.EqualFunc(m, c, <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> v1 == v2 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Original: <span class="keyword">map</span>[<span class="number">1</span>:one <span class="number">2</span>:two <span class="number">3</span>:three]</span><br><span class="line">Clone: <span class="keyword">map</span>[<span class="number">1</span>:one <span class="number">2</span>:two <span class="number">3</span>:three <span class="number">4</span>:four]</span><br><span class="line">DeleteFunc: <span class="keyword">map</span>[<span class="number">1</span>:one <span class="number">3</span>:three]</span><br><span class="line">Equal: <span class="literal">false</span></span><br><span class="line">EqualFunc: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>maps 包的官方文档<a href="https://pkg.go.dev/maps?source=post_page-----8387cecdb8a4--------------------------------" title="maps" target="_blank" rel="noopener">地址</a></p><h3 id="github-com-elliotchance-pie"><a href="#github-com-elliotchance-pie" class="headerlink" title="github.com/elliotchance/pie"></a>github.com/elliotchance/pie</h3><p>这是我个人最喜欢的用来操作切片和映射的包。它提供了一种独特的语法，使您能够无缝地链接操作，提高了代码的可读性和效率。</p><p>使用库方法有四种方式：</p><ol><li>纯调用 — 只需调用库方法并提供所需的参数；</li><li>pie.Of — 链接多个操作，支持任何元素类型；</li><li>pie.OfOrdered — 链接多个操作，支持数字和字符串类型；</li><li>pie.OfNumeric — 链接多个操作，仅支持数字类型。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map 1: %v\n"</span>,</span><br><span class="line">  pie.Sort(</span><br><span class="line">   pie.Map(</span><br><span class="line">    e,</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(e Example)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> e.Name</span><br><span class="line">    &#125;,</span><br><span class="line">   ),</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map 2: %v\n"</span>,</span><br><span class="line">  pie.Of(e).</span><br><span class="line">   Map(<span class="function"><span class="keyword">func</span><span class="params">(e Example)</span> <span class="title">Example</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Example&#123;</span><br><span class="line">     Name:   e.Name,</span><br><span class="line">     Number: e.Number * <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;).</span><br><span class="line">   SortUsing(<span class="function"><span class="keyword">func</span><span class="params">(a, b Example)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.Number &lt; b.Number</span><br><span class="line">   &#125;),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map 3: %v\n"</span>,</span><br><span class="line">  pie.OfOrdered([]<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>&#125;).</span><br><span class="line">   Map(<span class="function"><span class="keyword">func</span><span class="params">(e <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.ToLower(e)</span><br><span class="line">   &#125;).</span><br><span class="line">   Sort(),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map 4: %v\n"</span>,</span><br><span class="line">  pie.OfNumeric([]<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;).</span><br><span class="line">   Map(<span class="function"><span class="keyword">func</span><span class="params">(e <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e * <span class="number">2</span></span><br><span class="line">   &#125;).</span><br><span class="line">   Sort(),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map 1: [A B C D]</span><br><span class="line">Map 2: &#123;[&#123;A 2&#125; &#123;B 4&#125; &#123;C 6&#125; &#123;D 8&#125;]&#125;</span><br><span class="line">Map 3: &#123;[a a b c]&#125;</span><br><span class="line">Map 4: &#123;[2 4 6 8]&#125;</span><br></pre></td></tr></table></figure><p>由于诸如 Map 等函数应该返回相同类型的集合，因此这个库的链式操作相当受限。因此，我认为纯方法调用是使用这个库的最佳方式。</p><p>该库提供了 Map 方法，允许将每个元素从一种类型转换为另一种类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map: %v\n"</span>,</span><br><span class="line">  pie.Map(</span><br><span class="line">   e,</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(e Example)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Name</span><br><span class="line">   &#125;,</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还提供了 Flat 方法，它将二维切片转换为一维切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Tags []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := []Person&#123;</span><br><span class="line">  &#123;<span class="string">"Alice"</span>, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"Bob"</span>, []<span class="keyword">string</span>&#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"Charlie"</span>, []<span class="keyword">string</span>&#123;<span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>&#125;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Unique Tags: %v\n"</span>,</span><br><span class="line">  pie.Unique(</span><br><span class="line">   pie.Flat(</span><br><span class="line">    pie.Map(</span><br><span class="line">     p,</span><br><span class="line">     <span class="function"><span class="keyword">func</span><span class="params">(e Person)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> e.Tags</span><br><span class="line">     &#125;,</span><br><span class="line">    ),</span><br><span class="line">   ),</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unique Tags: [b c d e a]</span><br></pre></td></tr></table></figure><p>使用 Keys 或 Values 方法可以仅获取 Map 的键或值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Keys: %v\n"</span>, pie.Keys(m))</span><br><span class="line"> fmt.Printf(<span class="string">"Values: %v\n"</span>, pie.Values(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keys: [3 1 2]</span><br><span class="line">Values: [one two three]</span><br></pre></td></tr></table></figure><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>该库提供了几种过滤原始集合的方法：Bottom、DropTop、DropWhile、Filter、FilterNot、Unique 等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bottom 3: [4 4 4]</span><br><span class="line">Drop top 3: [3 3 3 4 4 4 4]</span><br><span class="line">Drop while 3: [3 3 3 4 4 4 4]</span><br><span class="line">Filter even: [2 2 4 4 4 4]</span><br><span class="line">Filter not even: [1 3 3 3]</span><br><span class="line">Unique values: [1 2 3 4]</span><br></pre></td></tr></table></figure><h3 id="Aggregation-1"><a href="#Aggregation-1" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>有一个通用的聚合方法 Reduce。让我们来计算标准差：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;</span><br><span class="line"></span><br><span class="line"> avg := pie.Average(v)</span><br><span class="line"> count := <span class="built_in">len</span>(v)</span><br><span class="line"></span><br><span class="line"> sum2 := pie.Reduce(</span><br><span class="line">  v,</span><br><span class="line">  <span class="function"><span class="keyword">func</span><span class="params">(acc, value <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> acc + (value-avg)*(value-avg)</span><br><span class="line">  &#125;,</span><br><span class="line"> ) - v[<span class="number">0</span>] + (v[<span class="number">0</span>]-avg)*(v[<span class="number">0</span>]-avg)</span><br><span class="line"></span><br><span class="line"> d := math.Sqrt(sum2 / <span class="keyword">float64</span>(count))</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Standard deviation: %f\n"</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Standard deviation: 1.555635</span><br></pre></td></tr></table></figure><p>Reduce 方法首先将第一个切片元素作为累积值，将第二个元素作为值参数调用 reducer。这就是为什么公式看起来很奇怪。</p><p>从下面的示例中，可以找到另一个内置的聚合方法 Average。此外，您还可以找到 Min、Max、Product 等方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Average: %f\n"</span>, pie.Average(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Stddev: %f\n"</span>, pie.Stddev(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Max: %f\n"</span>, pie.Max(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Min: %f\n"</span>, pie.Min(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Sum: %f\n"</span>, pie.Sum(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Product: %f\n"</span>, pie.Product(v))</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"All &gt;0: %t\n"</span>, pie.Of(v).All(<span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> value &gt; <span class="number">0</span> &#125;))</span><br><span class="line"> fmt.Printf(<span class="string">"Any &gt;5: %t\n"</span>, pie.Of(v).Any(<span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> value &gt; <span class="number">5</span> &#125;))</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"First: %f\n"</span>, pie.First(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Last: %f\n"</span>, pie.Last(v))</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Are Unique: %t\n"</span>, pie.AreUnique(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Are Sorted: %t\n"</span>, pie.AreSorted(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Contains 3.3: %t\n"</span>, pie.Contains(v, <span class="number">3.3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Average: 3.300000</span><br><span class="line">Stddev: 1.555635</span><br><span class="line">Max: 5.500000</span><br><span class="line">Min: 1.100000</span><br><span class="line">Sum: 16.500000</span><br><span class="line">Product: 193.261200</span><br><span class="line">All &gt;0: true</span><br><span class="line">Any &gt;5: true</span><br><span class="line">First: 1.100000</span><br><span class="line">Last: 5.500000</span><br><span class="line">Are Unique: true</span><br><span class="line">Are Sorted: true</span><br><span class="line">Contains 3.3: true</span><br></pre></td></tr></table></figure><h4 id="Sorting-Ordering-1"><a href="#Sorting-Ordering-1" class="headerlink" title="Sorting/Ordering"></a>Sorting/Ordering</h4><p>有三种不同的方法可以使用 pie 对切片进行排序：</p><p>Sort — 类似于 sort.Slice。但与 sort.Slice 不同的是，返回的切片将被重新分配，以不修改输入切片；<br>SortStableUsing — 类似于 sort.SliceStable。但与 sort.SliceStable 不同的是，返回的切片将被重新分配，以不修改输入切片；<br>SortUsing — 类似于 sort.Slice。但与 sort.Slice 不同的是，返回的切片将被重新分配，以不修改输入切片。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> "fmt"</span><br><span class="line"></span><br><span class="line"> "github.com/elliotchance/pie/v2"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> v := []int&#123;3, 5, 1, 4, 2&#125;</span><br><span class="line"></span><br><span class="line"> less := func(a, b int) bool &#123;</span><br><span class="line">  return a &lt; b</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Sort: %v\n", pie.Sort(v))</span><br><span class="line"> fmt.Printf("SortStableUsing: %v\n", pie.SortStableUsing(v, less))</span><br><span class="line"> fmt.Printf("SortUsing: %v\n", pie.SortUsing(v, less))</span><br><span class="line"> fmt.Printf("Original: %v\n", v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sort: [1 2 3 4 5]</span><br><span class="line">SortStableUsing: [1 2 3 4 5]</span><br><span class="line">SortUsing: [1 2 3 4 5]</span><br><span class="line">Original: [3 5 1 4 2]</span><br></pre></td></tr></table></figure><h4 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h4><p>pie 提供了 FindFirstUsing 方法，用于获取切片中第一个与谓词匹配的元素的索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := []Person&#123;</span><br><span class="line">  &#123;<span class="string">"Alice"</span>, <span class="number">25</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Bob"</span>, <span class="number">30</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Charlie"</span>, <span class="number">35</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"FindFirstUsing: %v\n"</span>,</span><br><span class="line">  pie.FindFirstUsing(</span><br><span class="line">   p,</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(p Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.Age &gt;= <span class="number">30</span></span><br><span class="line">   &#125;,</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FindFirstUsing: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>pie 包含许多用于处理切片的实用方法。举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"math/rand"</span></span><br><span class="line"> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/elliotchance/pie/v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := []Person&#123;</span><br><span class="line">  &#123;<span class="string">"Alice"</span>, <span class="number">25</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Bob"</span>, <span class="number">30</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Charlie"</span>, <span class="number">35</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"David"</span>, <span class="number">25</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Eve"</span>, <span class="number">40</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Frank"</span>, <span class="number">35</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Chunk: %v\n"</span>, pie.Chunk(p, <span class="number">2</span>))</span><br><span class="line"> fmt.Printf(<span class="string">"GroupBy: %v\n"</span>, pie.GroupBy(p, <span class="function"><span class="keyword">func</span><span class="params">(p Person)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> p.Age &#125;))</span><br><span class="line"> fmt.Printf(<span class="string">"Shuffle: %v\n"</span>, pie.Shuffle(p, rand.New(rand.NewSource(time.Now().UnixNano()))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chunk: [[&#123;Alice <span class="number">25</span>&#125; &#123;Bob <span class="number">30</span>&#125;] [&#123;Charlie <span class="number">35</span>&#125; &#123;David <span class="number">25</span>&#125;] [&#123;Eve <span class="number">40</span>&#125; &#123;Frank <span class="number">35</span>&#125;]]</span><br><span class="line">GroupBy: <span class="keyword">map</span>[<span class="number">25</span>:[&#123;Alice <span class="number">25</span>&#125; &#123;David <span class="number">25</span>&#125;] <span class="number">30</span>:[&#123;Bob <span class="number">30</span>&#125;] <span class="number">35</span>:[&#123;Charlie <span class="number">35</span>&#125; &#123;Frank <span class="number">35</span>&#125;] <span class="number">40</span>:[&#123;Eve <span class="number">40</span>&#125;]]</span><br><span class="line">Shuffle: [&#123;Frank <span class="number">35</span>&#125; &#123;Bob <span class="number">30</span>&#125; &#123;David <span class="number">25</span>&#125; &#123;Eve <span class="number">40</span>&#125; &#123;Alice <span class="number">25</span>&#125; &#123;Charlie <span class="number">35</span>&#125;]</span><br></pre></td></tr></table></figure><p>下面是 pie 包的<a href="https://github.com/elliotchance/pie?source=post_page-----8387cecdb8a4--------------------------------" title="pie" target="_blank" rel="noopener">地址</a></p><p>elliotchance/pie/v2 库提供了一套非常完整的的处理集合的能力，极大地简化了在 Go 中处理切片的工作。其强大的方法用于操作和查询切片数据，为开发人员提供了一个强大的工具，增强了代码的可读性和效率。我强烈建议任何 Go 开发人员在下一个项目中尝试使用这个库。</p><h3 id="github-com-samber-lo"><a href="#github-com-samber-lo" class="headerlink" title="github.com/samber/lo"></a>github.com/samber/lo</h3><p>另一个在 Go 中操作集合的流行库。在某些方面，它可能类似于流行的 JavaScript 库 Lodash。它在内部使用泛型，而不是反射。</p><h4 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h4><p>该库支持默认的 <code>Map</code> 和 <code>FlatMap</code> 方法用于切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name   <span class="keyword">string</span></span><br><span class="line"> Number <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> e := []Example&#123;</span><br><span class="line">  &#123;<span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"A"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"D"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"B"</span>, <span class="number">2</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Map: %v\n"</span>,</span><br><span class="line">  lo.Map(</span><br><span class="line">   e,</span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">(e Example, index <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Name</span><br><span class="line">   &#125;,</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map: [C A D B]</span><br></pre></td></tr></table></figure><p>下面的代码演示如何操作 FlatMap:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Tags []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := []Person&#123;</span><br><span class="line">  &#123;<span class="string">"Alice"</span>, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"Bob"</span>, []<span class="keyword">string</span>&#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">"Charlie"</span>, []<span class="keyword">string</span>&#123;<span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>&#125;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(</span><br><span class="line">  <span class="string">"Unique Tags: %v\n"</span>,</span><br><span class="line">  lo.Uniq(</span><br><span class="line">   lo.FlatMap(</span><br><span class="line">    p,</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(e Person, index <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> e.Tags</span><br><span class="line">    &#125;,</span><br><span class="line">   ),</span><br><span class="line">  ),</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以获取映射键、值或将映射对转换为某些切片等操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">"one"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"two"</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">"three"</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Keys: %v\n"</span>, lo.Keys(m))</span><br><span class="line"> fmt.Printf(<span class="string">"Values: %v\n"</span>, lo.Values(m))</span><br><span class="line"> fmt.Printf(<span class="string">"MapKeys: %v\n"</span>, lo.MapKeys(m, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">string</span>, num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> num * <span class="number">2</span> &#125;))</span><br><span class="line"> fmt.Printf(<span class="string">"MapValues: %v\n"</span>, lo.MapValues(m, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">string</span>, num <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> strings.ToUpper(value) &#125;))</span><br><span class="line"> fmt.Printf(<span class="string">"MapToSlice: %v\n"</span>, lo.MapToSlice(m, <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>, value <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> value + <span class="string">":"</span> + fmt.Sprint(num) &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Keys: [2 3 1]</span><br><span class="line">Values: [one two three]</span><br><span class="line">MapKeys: map[2:one 4:two 6:three]</span><br><span class="line">MapValues: map[1:ONE 2:TWO 3:THREE]</span><br><span class="line">MapToSlice: [three:3 one:1 two:2]</span><br></pre></td></tr></table></figure><h4 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h4><p>在 lo 库中有许多 Drop 方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> "fmt"</span><br><span class="line"></span><br><span class="line"> "github.com/samber/lo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> v := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf("Drop: %v\n", lo.Drop(v, 2))</span><br><span class="line"> fmt.Printf("DropRight: %v\n", lo.DropRight(v, 2))</span><br><span class="line"> fmt.Printf("DropWhile: %v\n", lo.DropWhile(v, func(i int) bool &#123; return i &lt; 3 &#125;))</span><br><span class="line"> fmt.Printf("DropRightWhile: %v\n", lo.DropRightWhile(v, func(i int) bool &#123; return i &gt; 3 &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Drop: [3 4 5]</span><br><span class="line">DropRight: [1 2 3]</span><br><span class="line">DropWhile: [3 4 5]</span><br><span class="line">DropRightWhile: [1 2 3]</span><br></pre></td></tr></table></figure><p>此外，还可以通过 predicate 过滤切片和映射：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>, <span class="string">"c"</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Filter: %v\n"</span>, lo.Filter(v, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i &gt; <span class="number">2</span> &#125;))</span><br><span class="line"> fmt.Printf(<span class="string">"PickBy: %v\n"</span>, lo.PickBy(m, <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> value &gt; <span class="number">2</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filter: [3 4 5]</span><br><span class="line">PickBy: map[c:3]</span><br></pre></td></tr></table></figure><h4 id="Aggregation-2"><a href="#Aggregation-2" class="headerlink" title="Aggregation"></a>Aggregation</h4><p><code>lo</code> package 提供了 reduce 的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;</span><br><span class="line"></span><br><span class="line"> count := <span class="built_in">len</span>(v)</span><br><span class="line"></span><br><span class="line"> avg := lo.Reduce(v, <span class="function"><span class="keyword">func</span><span class="params">(acc, val <span class="keyword">float64</span>, index <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc + val</span><br><span class="line"> &#125;, <span class="number">0.0</span>) / <span class="keyword">float64</span>(count)</span><br><span class="line"></span><br><span class="line"> sum2 := lo.Reduce(v, <span class="function"><span class="keyword">func</span><span class="params">(acc, val <span class="keyword">float64</span>, index <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc + (val-avg)*(val-avg)</span><br><span class="line"> &#125;, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"> d := math.Sqrt(sum2 / <span class="keyword">float64</span>(count))</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Standard deviation: %f\n"</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Standard deviation: 1.555635</span><br></pre></td></tr></table></figure><p>此外，它支持一些通用的聚合方法，如 Sum、Min、Max：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Sum: %v\n"</span>, lo.Sum(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Min: %v\n"</span>, lo.Min(v))</span><br><span class="line"> fmt.Printf(<span class="string">"Max: %v\n"</span>, lo.Max(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些有用的方法用于处理 channel：FanIn 和 FanOut</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"> ch := lo.FanIn(<span class="number">10</span>, ch1, ch2, ch3)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">   ch1 &lt;- i</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line">   ch2 &lt;- i</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ch3 &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">close</span>(ch1)</span><br><span class="line"> <span class="built_in">close</span>(ch2)</span><br><span class="line"> <span class="built_in">close</span>(ch3)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以这样处理 channel:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> chs := lo.FanOut(<span class="number">3</span>, <span class="number">10</span>, ch)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">  ch &lt;- i</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> _, ch := <span class="keyword">range</span> chs &#123;</span><br><span class="line">  <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">   fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Sorting-Ordering-2"><a href="#Sorting-Ordering-2" class="headerlink" title="Sorting/Ordering"></a>Sorting/Ordering</h4><p><code>lo</code> 还提供 <code>Reverse</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> v := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Reverse: %v\n"</span>, lo.Reverse(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Access-1"><a href="#Access-1" class="headerlink" title="Access"></a>Access</h4><p><code>lo</code> 库提供了 find 方法来访问元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> Name <span class="keyword">string</span></span><br><span class="line"> Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := []Person&#123;</span><br><span class="line">  &#123;<span class="string">"Alice"</span>, <span class="number">25</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Bob"</span>, <span class="number">30</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Charlie"</span>, <span class="number">35</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"David"</span>, <span class="number">25</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"Edward"</span>, <span class="number">40</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> item, found := lo.Find(p, <span class="function"><span class="keyword">func</span><span class="params">(p Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.Name == <span class="string">"Charlie"</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Item: %+v, Found: %v\n"</span>, item, found)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"FindDuplicatesBy: %v\n"</span>, lo.FindDuplicatesBy(p, <span class="function"><span class="keyword">func</span><span class="params">(p Person)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.Age</span><br><span class="line"> &#125;))</span><br><span class="line"></span><br><span class="line"> item, index, found := lo.FindIndexOf(p, <span class="function"><span class="keyword">func</span><span class="params">(p Person)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.Name == <span class="string">"Charlie"</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">"Item: %+v, Index: %v, Found: %v\n"</span>, item, index, found)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Outputs:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Item: &#123;Name:Charlie Age:<span class="number">35</span>&#125;, Found: <span class="literal">true</span></span><br><span class="line">FindDuplicatesBy: [&#123;Alice <span class="number">25</span>&#125;]</span><br><span class="line">Item: &#123;Name:Charlie Age:<span class="number">35</span>&#125;, Index: <span class="number">2</span>, Found: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Find 方法同样支持 map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"github.com/samber/lo"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"Alice"</span>:   <span class="number">34</span>,</span><br><span class="line">  <span class="string">"Bob"</span>:     <span class="number">24</span>,</span><br><span class="line">  <span class="string">"Charlie"</span>: <span class="number">34</span>,</span><br><span class="line">  <span class="string">"David"</span>:   <span class="number">29</span>,</span><br><span class="line">  <span class="string">"Eve"</span>:     <span class="number">34</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> key, found := lo.FindKey(p, <span class="number">34</span>)</span><br><span class="line"> fmt.Printf(<span class="string">"Key: %v, Found: %v\n"</span>, key, found)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lo</code> 的文档<a href="https://github.com/samber/lo?source=post_page-----8387cecdb8a4--------------------------------" title="lo" target="_blank" rel="noopener">地址</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里只展示了 github.com/samber/lo 库约 10% 的方法。这个库提供了许多简化函数处理的实用工具。对于 Go 开发人员来说，这个库是一个非常全面的工具包。</p><p>本文展示了一些在 Go 中处理集合时推荐的库，希望对大家的开发工作有帮助。</p><hr>]]></content>
    
    <summary type="html">
    
      一些在 Golang 中高效处理 Collection 类型的库
    
    </summary>
    
      <category term="Golang" scheme="https://cloudsjhan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://cloudsjhan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 如何实现自定义 CDC 工具？</title>
    <link href="https://cloudsjhan.github.io/2024/05/04/Golang-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89-CDC-%E5%B7%A5%E5%85%B7%EF%BC%9F/"/>
    <id>https://cloudsjhan.github.io/2024/05/04/Golang-如何实现自定义-CDC-工具？/</id>
    <published>2024-05-04T13:28:00.000Z</published>
    <updated>2024-05-04T13:29:04.816Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="CDC"><a href="#CDC" class="headerlink" title="CDC"></a>CDC</h3><p>变更数据捕获（CDC）是一种跟踪数据库更改的技术，允许开发人员捕获应用于行的插入、更新和删除。它是数据集成和实时处理任务的重要组成部分。在本文中，我们将讨论如何在 Golang 中为 PostgreSQL、Oracle、MySQL、MongoDB 和 SQL Server 等多个数据库开发自定义 CDC 工具。</p><p>通常在 CDC 领域或者说大数据领域都是 java 的生态比较繁荣，比如 Flink, Spark, 最近大火的 <a href="https://paimon.apache.org/" title="paimon" target="_blank" rel="noopener">paimon</a> 都是 java 写的。Java 在数据生态的繁荣为对应数据工具的开发提供了土壤。那么我们 Gopher 如果也想开发 CDC 工具怎么办？今天介绍的是一些 golang 的 Lib，基于这些 lib 我们也可以实现自定义的 CDC 工具。</p><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><p>对于 PostgreSQL，我们可以使用 <a href="github.com/jackc/pglogrepl" title="pglogrepl">pglogrepl</a> 库（github.com/jackc/pglogrepl）。该库提供了 PostgreSQL 中的逻辑解码和流复制协议的低级 API。它允许您读取 PostgreSQL 的预写式日志（WAL），这些日志是存储所有对数据库的更改的地方。通过读取和解码这些日志，我们可以跟踪数据库中的更改。解码可以在插件级别或消费者级别进行，这取决于 PostgreSQL 中使用的解码插件。</p><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><p>为 Oracle 创建 CDC 工具要复杂一些。Oracle 有一个名为 “LogMiner” 的内置工具，它允许您通过 SQL 接口查询在线和归档的重做日志文件。数据的主要来源将是 V$LOGMNR_CONTENTS 视图，这是 LogMiner 在对其进行挖掘后的重做日志数据的视图。</p><p>我们的 CDC 工具需要定期查询此视图，并解析 SQL_REDO 和 SQL_UNDO 字段，以了解对数据库所做的更改。这需要理解 Oracle 的 SQL 语法，并可能处理不同版本的 Oracle，因为语法可能会发生变化。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>可以使用 <a href="https://github.com/go-mysql-org/go-mysql" title="go-mysql" target="_blank" rel="noopener">go-mysql</a> 库（github.com/go-mysql-org/go-mysql/canal）处理 MySQL。该软件包提供了一个框架，用于将 MySQL 的 binlog 同步到其他系统。它支持将 MySQL 的 binlog 同步到用户定义的处理程序，例如 stdout 和 Kafka 消息队列。通过使用该库，我们可以相对简单地跟踪数据库中的更改。</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>对于 MongoDB，我们可以使用 <a href="go.mongodb.org/mongo-driver/mongo" title="mongo-driver">mongo-driver/mongo</a> 包（go.mongodb.org/mongo-driver/mongo）。该软件包为 Go 提供了 MongoDB 驱动程序 API。MongoDB 驱动程序支持 “Change Streams”，它允许应用程序访问实时数据更改，而无需尾随 oplog 的复杂性和风险。应用程序可以使用更改流订阅单个集合、数据库或整个部署上的所有数据更改，并立即对其进行响应。</p><h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><p>对于 SQL Server，我们可以利用 <a href="github.com/denisenkom/go-mssqldb" title="go-mssqldb">go-mssqldb</a> 包（github.com/denisenkom/go-mssqldb）。SQL Server 支持变更跟踪，它跟踪表上的 DML 更改（插入、更新、删除）。通过查询这些变更表，我们可以获取有关更改的信息。请注意，这只会告诉我们更改行的键，而不是数据本身。要获取更改的数据，我们需要对实际数据表进行另一个查询。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 Golang 中创建自定义 CDC 工具涉及理解每个数据库用于记录更改的基础机制。通过利用现有软件包的功能，我们可以构建一个强大的工具，可以跟踪多种类型数据库的更改。然而，要实现高效和有效的 CDC 工具，需要对每个数据库的日志机制有透彻的了解，以及对 Golang 有扎实的掌握。</p><hr>]]></content>
    
    <summary type="html">
    
      Golang 如何实现自定义 CDC 工具
    
    </summary>
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/categories/CDC/"/>
    
    
      <category term="Golang" scheme="https://cloudsjhan.github.io/tags/Golang/"/>
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/tags/CDC/"/>
    
  </entry>
  
  <entry>
    <title>基于 langchaingo 对接大模型 ollama 实现本地知识库问答系统</title>
    <link href="https://cloudsjhan.github.io/2024/05/03/%E5%9F%BA%E4%BA%8E-langchaingo-%E5%AF%B9%E6%8E%A5%E5%A4%A7%E6%A8%A1%E5%9E%8B-ollama-%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E7%9F%A5%E8%AF%86%E5%BA%93%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F/"/>
    <id>https://cloudsjhan.github.io/2024/05/03/基于-langchaingo-对接大模型-ollama-实现本地知识库问答系统/</id>
    <published>2024-05-03T02:14:02.000Z</published>
    <updated>2024-05-03T02:32:35.552Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://github.com/ollama/ollama" title="ollama" target="_blank" rel="noopener">Ollama</a> 是一个基于 Go 语言开发的简单易用的本地大语言模型运行框架。在管理模型的同时，它还基于 Go 语言中的 Web 框架 <a href="https://github.com/gin-gonic/gin" title="gin" target="_blank" rel="noopener">gin</a>提供了一些 Api 接口，让你能够像跟 OpenAI 提供的接口那样进行交互。</p><p>Ollama 官方还提供了跟 docker hub 一样的模型 hub，用于存放各种大语言模型，开发者也可以上传自己训练好的模型供其他人使用。</p><h3 id="安装-ollama"><a href="#安装-ollama" class="headerlink" title="安装 ollama"></a>安装 ollama</h3><p>可以在 ollama 的 github  <a href="https://github.com/ollama/ollama/releases" title="ollama release" target="_blank" rel="noopener">release </a> 页面直接下载对应平台的二进制包进行安装，也可以 docker 一键部署。这里演示的机器是 macOS M1 PRO 版本，直接下载安装包，安装即可，安装之后，运行软件。</p><p>运行之后，项目默认监听 <code>11434</code> 端口，在终端执行如下命令可验证是否正常运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:11434</span></span><br><span class="line">Ollama is running</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/4760/83011ecd-e86e-4932-9d5c-841a929599b0.png" alt=""></p><h3 id="大模型管理"><a href="#大模型管理" class="headerlink" title="大模型管理"></a>大模型管理</h3><p>ollama 安装后，就可以对大模型进项安装使用了。Ollama 还会携带一个命令行工具，通过它可以与模型进行交互。</p><ul><li><code>ollama list</code>：显示模型列表。</li><li><code>ollama show</code>：显示模型的信息</li><li><code>ollama pull</code>：拉取模型</li><li><code>ollama push</code>：推送模型</li><li><code>ollama cp</code>：拷贝一个模型</li><li><code>ollama rm</code>：删除一个模型</li><li><code>ollama run</code>：运行一个模型</li></ul><p>在官方提供的模型仓库中可以找到你想要的模型：<a href="https://ollama.com/library" target="_blank" rel="noopener">https://ollama.com/library</a></p><blockquote><p>注意：应该至少有 8 GB 可用 RAM 来运行 7 B 型号，16 GB 来运行 13 B 型号，32 GB 来运行 33 B 型号。</p></blockquote><p>比如我们可以选择  <a href="https://github.com/QwenLM/Qwen1.5" title="Qwen" target="_blank" rel="noopener">Qwen</a> 做个演示，这里用 1.8B 的模型(本地电脑比较可怜，只有 16G😭)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ollama run qwen:1.8b</span></span><br></pre></td></tr></table></figure><p>是不是觉得这个命令似曾相识，是的，跟 docker run image 一样，如果本地没有该模型，则会先下载模型再运行。</p><p><img src="https://files.mdnice.com/user/4760/5aec9be5-52dc-4078-8780-d8fa0bcc4c3f.png" alt=""></p><p>既然跟 docker 如此一致，那么是不是也会有跟 Dockerfile 一样的东西，是的，叫做 Modelfile :</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> qwen:<span class="number">14</span>b</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the temperature to 1 [higher is more creative, lower is more coherent]</span></span><br><span class="line">PARAMETER temperature <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the system message</span></span><br><span class="line">SYSTEM <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">You are Mario from super mario bros, acting as an assistant.</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>保存上面的代码为 Modelfile，运行 <code>llama create choose-a-model-name -f Modelfile</code> 就可以定制你的模型，<code>ollama run choose-a-model-name</code> 就可以使用刚刚定制的模型。</p><p><img src="https://files.mdnice.com/user/4760/9d52c8ff-abb0-4af9-811d-38944b63989e.png" alt=""></p><h3 id="对接-ollama-实现本地知识库问答系统"><a href="#对接-ollama-实现本地知识库问答系统" class="headerlink" title="对接 ollama 实现本地知识库问答系统"></a>对接 ollama 实现本地知识库问答系统</h3><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>模型都在本地安装好了，我们可以对接这个模型，开发一些好玩的上层 AI 应用。下面我们基于 langchaningo 开发一个问答系统。</p><p>下面的系统会用到的模型有 ollama qwen1.8B，nomic-embed-text，先来安装这两个模型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ollama run qwen:1.8b</span><br><span class="line">ollama run nomic-embed-text:latest</span><br></pre></td></tr></table></figure><p>我们还需要一个向量数据库来存储拆分后的知识库内容，这里我们使用 <code>qdrant</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull qdrant/qdrant</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -itd --name qdrant -p 6333:6333 qdrant/qdrant</span></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/4760/e55f492c-c783-4086-b02f-35f540568076.png" alt=""></p><p>启动 qdrant 后我们先创建一个 Collection 用于存储文档拆分块:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://localhost:6333/collections/langchaingo-ollama-rag \</span><br><span class="line">  -H 'Content-Type: application/json' \</span><br><span class="line">  --data-raw '&#123;</span><br><span class="line">    "vectors": &#123;</span><br><span class="line">      "size": 768,</span><br><span class="line">      "distance": "Dot"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;'</span><br></pre></td></tr></table></figure><h4 id="知识库内容切分"><a href="#知识库内容切分" class="headerlink" title="知识库内容切分"></a>知识库内容切分</h4><p>这里提供一篇<a href="https://baijiahao.baidu.com/s?id=1770104977332994833&amp;wfr=spider&amp;for=pc" title="样例文章" target="_blank" rel="noopener">文章</a>供大模型学习，下面的代码将文章拆分成小的文档块：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TextToChunks</span><span class="params">(dirFile <span class="keyword">string</span>, chunkSize, chunkOverlap <span class="keyword">int</span>)</span> <span class="params">([]schema.Document, error)</span></span> &#123;</span><br><span class="line">file, err := os.Open(dirFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// create a doc loader</span></span><br><span class="line">docLoaded := documentloaders.NewText(file)</span><br><span class="line"><span class="comment">// create a doc spliter</span></span><br><span class="line">split := textsplitter.NewRecursiveCharacter()</span><br><span class="line"><span class="comment">// set doc chunk size</span></span><br><span class="line">split.ChunkSize = chunkSize</span><br><span class="line"><span class="comment">// set chunk overlap size</span></span><br><span class="line">split.ChunkOverlap = chunkOverlap</span><br><span class="line"><span class="comment">// load and split doc</span></span><br><span class="line">docs, err := docLoaded.LoadAndSplit(context.Background(), split)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> docs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文档存储到向量数据库"><a href="#文档存储到向量数据库" class="headerlink" title="文档存储到向量数据库"></a>文档存储到向量数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeDocs</span><span class="params">(docs []schema.Document, store *qdrant.Store)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(docs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">_, err := store.AddDocuments(context.Background(), docs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取用户输入并查询数据库"><a href="#读取用户输入并查询数据库" class="headerlink" title="读取用户输入并查询数据库"></a>读取用户输入并查询数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useRetriaver</span><span class="params">(store *qdrant.Store, prompt <span class="keyword">string</span>, topk <span class="keyword">int</span>)</span> <span class="params">([]schema.Document, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置选项向量</span></span><br><span class="line">optionsVector := []vectorstores.Option&#123;</span><br><span class="line">vectorstores.WithScoreThreshold(<span class="number">0.80</span>), <span class="comment">// 设置分数阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建检索器</span></span><br><span class="line">retriever := vectorstores.ToRetriever(store, topk, optionsVector...)</span><br><span class="line"><span class="comment">// 搜索</span></span><br><span class="line">docRetrieved, err := retriever.GetRelevantDocuments(context.Background(), prompt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"检索文档失败: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回检索到的文档</span></span><br><span class="line"><span class="keyword">return</span> docRetrieved, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建并加载大模型"><a href="#创建并加载大模型" class="headerlink" title="创建并加载大模型"></a>创建并加载大模型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOllamaQwen</span><span class="params">()</span> *<span class="title">ollama</span>.<span class="title">LLM</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新的ollama模型，模型名为"qwena:1.8b"</span></span><br><span class="line">llm, err := ollama.New(</span><br><span class="line">ollama.WithModel(<span class="string">"qwen:1.8b"</span>),</span><br><span class="line">ollama.WithServerURL(ollamaServer))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatal(<span class="string">"创建ollama模型失败: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> llm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大模型处理"><a href="#大模型处理" class="headerlink" title="大模型处理"></a>大模型处理</h4><p>将检索到的内容，交给大语言模型处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetAnswer 获取答案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAnswer</span><span class="params">(ctx context.Context, llm llms.Model, docRetrieved []schema.Document, prompt <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新的聊天消息历史记录</span></span><br><span class="line">history := memory.NewChatMessageHistory()</span><br><span class="line"><span class="comment">// 将检索到的文档添加到历史记录中</span></span><br><span class="line"><span class="keyword">for</span> _, doc := <span class="keyword">range</span> docRetrieved &#123;</span><br><span class="line">history.AddAIMessage(ctx, doc.PageContent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用历史记录创建一个新的对话缓冲区</span></span><br><span class="line">conversation := memory.NewConversationBuffer(memory.WithChatHistory(history))</span><br><span class="line"></span><br><span class="line">executor := agents.NewExecutor(</span><br><span class="line">agents.NewConversationalAgent(llm, <span class="literal">nil</span>),</span><br><span class="line"><span class="literal">nil</span>,</span><br><span class="line">agents.WithMemory(conversation),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 设置链调用选项</span></span><br><span class="line">options := []chains.ChainCallOption&#123;</span><br><span class="line">chains.WithTemperature(<span class="number">0.8</span>),</span><br><span class="line">&#125;</span><br><span class="line">res, err := chains.Run(ctx, executor, prompt, options...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go getanswer</span><br></pre></td></tr></table></figure><p>输入你想要咨询的问题</p><p><img src="https://files.mdnice.com/user/4760/4e989a5d-f7f8-4191-87f9-adff732d8d5a.png" alt=""></p><p>系统输出结果：</p><p><img src="https://files.mdnice.com/user/4760/9d7d30bc-1f71-4e79-9783-2bb3f2d4277f.png" alt=""></p><p>输出的结果可能会因为学习资料的不足或者模型的大小存在区别，有很多结果都不是很准确，这就需要提供更多的语料进行训练。而且还要对代码里的各个参数进行调优，并结合文档的内容，大小，格式等进行参数的设定。</p><p>项目的源码可以参考：<a href="https://github.com/hantmac/langchaingo-ollama-rag.git" target="_blank" rel="noopener">https://github.com/hantmac/langchaingo-ollama-rag.git</a></p><hr>]]></content>
    
    <summary type="html">
    
      基于 langchaingo 对接大模型 ollama 实现本地知识库问答系统
    
    </summary>
    
      <category term="ollama" scheme="https://cloudsjhan.github.io/categories/ollama/"/>
    
    
      <category term="langchaingo" scheme="https://cloudsjhan.github.io/tags/langchaingo/"/>
    
      <category term="ollama" scheme="https://cloudsjhan.github.io/tags/ollama/"/>
    
  </entry>
  
  <entry>
    <title>数据同步工具考古</title>
    <link href="https://cloudsjhan.github.io/2024/02/07/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E8%80%83%E5%8F%A4/"/>
    <id>https://cloudsjhan.github.io/2024/02/07/数据同步工具考古/</id>
    <published>2024-02-07T07:21:03.000Z</published>
    <updated>2024-02-07T11:14:23.847Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去的一年里，我除了日常的 <a href="https://app.databend.com/" title="Databend Cloud" target="_blank" rel="noopener">Databend Cloud </a>开发工作之外，还围绕着 Databend 做了大量的数据生态工作。这包括在 <a href="https://docs.databend.com/developer/apis/http" title="Databend REST API" target="_blank" rel="noopener">Databend Native</a> 协议的基础上提供了多语言的 SDK，并在 SDK 基础上增加了对诸如 <a href="https://github.com/databendcloud/databend-tableau-connector-jdbc" title="databend tableau connector" target="_blank" rel="noopener">Tableau</a>、<a href="https://github.com/databendcloud/metabase-databend-driver" title="metabase databend driver" target="_blank" rel="noopener">Metabase</a>、<a href="https://github.com/apache/superset/pull/23308" title="support databend in superset" target="_blank" rel="noopener">SuperSet</a>、<a href="https://github.com/getredash/redash/pull/5902" title="support databend in redash" target="_blank" rel="noopener">Redash</a>等BI工具的支持。此外，我还完善了关于数据传输和实时同步领域的生态，涉及到 Debezium Engine、Flink CDC、Kafka Connect、Airbyte、Datax Plugin、TapData 等工具。</p><p>在这一系列的工作中，数据同步是一个非常关键的环节，它构建了用户从外部数据、数据库到 <a href="https://github.com/datafuselabs/databend" title="Databend Github" target="_blank" rel="noopener">Databend</a> 的桥梁。起初我对于一些流行的数据同步工具只是略有耳闻，有些甚至从未听说过，更不了解它们的内部原理。通过一段时间的摸索和开发，成功实现了几个工具的整合之后，我对这些工具和平台有了更深入的了解。</p><p>所以在本文中，我将对几个目前广泛使用、比较流行的数据同步工具进行考古。这包括它们的发展历史、技术特点以及在实际应用中的使用情况。通过对这些工具的分析介绍，在给自己做笔记的同时希望能够为其他读者提供对数据同步领域的全面认识。</p><h2 id="数据同步工具"><a href="#数据同步工具" class="headerlink" title="数据同步工具"></a>数据同步工具</h2><h3 id="Debezium"><a href="#Debezium" class="headerlink" title="Debezium"></a>Debezium</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debezium is an open source distributed platform for change data capture. Start it up, point it at your databases, and your apps can start responding to all of the inserts, updates, and deletes that other apps commit to your databases. Debezium is durable and fast, so your apps can respond quickly and never miss an event, even when things go wrong.</span><br></pre></td></tr></table></figure><p><a href="https://debezium.io/documentation/reference/stable/tutorial.html#introduction-debezium" title="Debezium" target="_blank" rel="noopener">Debezium</a> 是一种 CDC（Change Data Capture）工具，工作原理类似大家所熟知的 Canal, DataBus, Maxwell 等，是通过抽取数据库日志来获取变更事件。Debezium 最初设计成一个 Kafka Connect 的 Source Plugin，目前开发者虽致力于将其与 Kafka Connect 解耦。下图引自 Debeizum 官方文档，可以看到一个 Debezium 在一个完整 CDC 系统中的位置。</p><p><img src="https://files.mdnice.com/user/4760/c669a06b-6008-453c-8ebd-da8616138173.png" alt=""></p><p>Kafka Connect 为 Source Plugin 提供了一系列的编程接口，最主要的就是要实现 SourceTask 的 poll 方法，其返回 List 将会被以最少一次语义(At Least Once)的方式投递至 Kafka。</p><h4 id="Debezium-抽取原理"><a href="#Debezium-抽取原理" class="headerlink" title="Debezium 抽取原理"></a>Debezium 抽取原理</h4><p>下图是 Debezium 从 PG 中抽取数据到 kafka topic 的流程，对于 PG 连接器来说是从逻辑复制流读取到变更日志，经由 kafka 发送到下游的数据处理服务以及相应的 writer plugin。</p><p><img src="https://files.mdnice.com/user/4760/f8e39d1f-97c6-4070-bf51-9a85422e806d.png" alt=""></p><p>再来看下 Debezium MySQL Reader 的代码，Reader体系构成了 MySQL 模块中代码的主线。</p><p>Reader 的继承关系如下图所示：</p><p><img src="https://files.mdnice.com/user/4760/6453c7da-801f-4429-b081-41800f82b14e.png" alt=""></p><p>SnapshotReader 和 BinlogReader 分别实现了对 MySQL 数据的全量读取和增量读取，他们继承于 AbstractReader，里面封装了一些共用的逻辑代码。AbstractReader 的流程如下图所示：</p><p><img src="https://files.mdnice.com/user/4760/8c680d75-6f14-4275-bad7-a67403956e61.png" alt=""></p><p>从图中可以看到 AbstractReader 在实现时，并没有直接将 enqueue 进来的 event record 直接写到 Kafka，而是通过一个内存阻塞队列BlockingQueue进行了解耦，这样写的好处是：</p><ol><li>职责解耦</li></ol><p>Event Record 在进入 BlockingQueue之前，要根据条件判断是否接受该 record；在向 Kafka 投递 record 之前，判断 task 的 running 状态。</p><ol start="2"><li>线程隔离</li></ol><p>BlockingQueue 是一个线程安全的阻塞队列，通过 BlockingQueue 实现的生产者消费者模型，是可以跑在不同的线程里的，这样避免局部的阻塞带来的整体的干扰。如上图所示，系统会定期判断 running 标志位，若 running 被stop信号置为了false，可以立刻停止整个task,而不会因 MySQL IO 阻塞延迟响应。</p><ol start="3"><li>单条与Batch的互相转化</li></ol><p>Enqueue record 是单条的投递 record，drain_to 是批量的消费 records。这个用法也可以反过来，实现 batch 到 single 的转化。</p><p>而 MySQL Connector 每日次获取 snapshot 的时候基本上是沿用了 MySQL 官方从库搭建的方案，详细步骤是：</p><ol><li>获取一个全局读锁，从而阻塞住其他数据库客户端的写操作。</li><li>开启一个可重复读语义的事务，来保证后续的在同一个事务内读操作都是在一个一致性快照中完成的。</li><li>读取binlog的当前位置。</li><li>读取连接器中配置的数据库和表的模式（schema）信息。</li><li>释放全局读锁，允许其他的数据库客户端对数据库进行写操作。</li><li>（可选）把DDL改变事件写入模式改变 topic（schema change topic），包括所有的必要的DROP和CREATEDDL语句。</li><li>扫描所有数据库的表，并且为每一个表产生一个和特定表相关的kafka topic创建事件（即为每一个表创建一个kafka topic）。</li><li>提交事务。</li><li>记录连接器成功完成快照任务时的连接器偏移量。</li></ol><h4 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h4><h5 id="基于-Kafka-Connect"><a href="#基于-Kafka-Connect" class="headerlink" title="基于 Kafka Connect"></a><strong>基于 Kafka Connect</strong></h5><p>最常见的架构是通过 <a href="https://kafka.apache.org/documentation/#connect" title="Apache Kafka Connect" target="_blank" rel="noopener">Apache Kafka Connect</a> 部署 Debezium。Kafka Connect 为在 Kafka 和外部存储系统之间系统数据提供了一种可靠且可伸缩性的方式。它为 Connector 插件提供了一组 API 和一个运行时：Connect 负责运行这些插件，它们则负责移动数据。通过 Kafka Connect 可以快速实现 Source Connector 和 Sink Connector 进行交互构造一个低延迟的数据 Pipeline：</p><ul><li>Source Connector（例如，Debezium）：将记录发送到 Kafka</li><li>Sink Connector：将 Kafka Topic 中的记录发送到其他系统</li></ul><p><img src="https://files.mdnice.com/user/4760/69863bd6-8eff-433b-b63e-a6ae3b0fb546.png" alt=""></p><p>如上图所示，部署了 MySQL 和 PostgresSQL 的 Debezium Connector 以捕获这两种类型数据库的变更。每个 Debezium Connector 都会与其源数据库建立连接：</p><ul><li>MySQL Connector 使用客户端库来访问 binlog。</li><li>PostgreSQL Connector 从逻辑副本流中读取数据。</li></ul><p>除了 Kafka Broker 之外，Kafka Connect 也作为一个单独的服务运行。默认情况下，数据库表的变更会写入名称与表名称对应的 Kafka Topic 中。如果需要，您可以通过配置 Debezium 的 Topic 路由转换来调整目标 Topic 名称。例如，您可以：</p><ul><li>将记录路由到名称与表名不同的 Topic 中</li><li>将多个表的变更事件记录流式传输到一个 Topic 中</li></ul><p>变更事件记录在 Apache Kafka 中后，Kafka Connect 生态系统中的不同 Sink Connector 可以将记录流式传输到其他系统、数据库，例如 Elasticsearch、Databend、分析系统或者缓存。</p><h5 id="基于Debezium-Server"><a href="#基于Debezium-Server" class="headerlink" title="基于Debezium Server"></a>基于<strong>Debezium Server</strong></h5><p>第二种部署 Debezium 的方法是使用 <a href="https://debezium.io/documentation/reference/stable/operations/debezium-server.html" title="Debezium Server" target="_blank" rel="noopener">Debezium Server</a>。Debezium Server 是一个可配置的、随时可用的应用程序，可以将变更事件从源数据库流式传输到各种消息中间件上。</p><p>下图展示了基于 Debezium Server 的变更数据捕获 Pipeline 架构：</p><p><img src="https://files.mdnice.com/user/4760/2181099d-622b-4376-a1c8-b5c86097ce4c.png" alt=""></p><p>Debezium Server 配置使用 Debezium Source Connector 来捕获源数据库中的变更。变更事件可以序列化为不同的格式，例如 JSON 或 Apache Avro，然后发送到各种消息中间件，例如 Amazon Kinesis、Apache Pulsar。</p><h5 id="基于-Debezium-Engine"><a href="#基于-Debezium-Engine" class="headerlink" title="基于 Debezium Engine"></a><strong>基于 Debezium Engine</strong></h5><p>使用 Debezium Connector 的另一种方法是基于 <a href="https://debezium.io/documentation/reference/stable/development/engine.html" title="Debezium Engine" target="_blank" rel="noopener">Debezium Engine</a>。在这种情况下，Debezium 不会通过 Kafka Connect 运行，而是作为嵌入到用户自定义 Java 应用程序中的库运行。这对于在应用程序本身获取变更事件非常有帮助，无需部署完整的 Kafka 和 Kafka Connect 集群，也不用将变更流式传输到消息中间件上。这篇文章展示了如何使用 Debezium Databend Server 实现从 MySQL 的数据全增量同步。</p><h5 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a><strong>特性总结</strong></h5><p>Debezium 是一组用于 Apache Kafka Connect 的 Source Connector。每个 Connector 都通过使用该数据库的变更数据捕获 (CDC) 功能从不同的数据库中获取变更。与其他方法（例如轮询或双重写入）不同，Debezium 的实现基于日志的 CDC：</p><ul><li>确保捕获所有的数据变更。</li><li>以极低的延迟生成变更事件，同时避免因为频繁轮询导致 CPU 使用率增加。例如，对于 MySQL 或 PostgreSQL，延迟在毫秒范围内。</li><li>不需要更改数据模型，例如增加 ‘Last Updated’ 列。</li><li>可以捕获删除操作。</li><li>可以捕获旧记录状态以及其他元数据，例如，事务 ID，具体取决于数据库的功能和配置。</li></ul><h3 id="Flink-CDC"><a href="#Flink-CDC" class="headerlink" title="Flink CDC"></a>Flink CDC</h3><p><a href="https://github.com/ververica/flink-cdc-connectors" title="Flink CDC" target="_blank" rel="noopener">Flink CDC</a> 是基于数据库日志 CDC（Change Data Capture）技术的实时数据集成框架，支持了全增量一体化、无锁读取、并行读取、表结构变更自动同步、分布式架构等高级特性。Flink CDC 发展了三年多的时间。2020 年，从作为个人的 Side project 出发，后来被越来越多人认识到。</p><p><img src="https://files.mdnice.com/user/4760/02390bc5-e50e-4816-853c-8788f157364f.png" alt=""></p><h4 id="Flink-CDC-迭代历程"><a href="#Flink-CDC-迭代历程" class="headerlink" title="Flink CDC 迭代历程"></a>Flink CDC 迭代历程</h4><h5 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a><strong>1.0</strong></h5><p>Flink CDC 1.0 比简单，直接就是底层封装了 Debezium， 而 Debezium 同步一张表分为两个阶段：</p><ul><li>全量阶段：查询当前表中所有记录；</li><li>增量阶段：从 binlog 消费变更数据。</li></ul><p>大部分用户使用的场景都是全量 + 增量同步，加锁是发生在全量阶段，目的是为了确定全量阶段的初始位点，保证增量 + 全量实现一条不多，一条不少，从而保证数据一致性。从下图中我们可以分析全局锁和表锁的一些加锁流程，左边红色线条是锁的生命周期，右边是 MySQL 开启可重复读事务的生命周期。</p><p><img src="https://files.mdnice.com/user/4760/482a5dcf-825a-4261-9d0c-3d2ff3885c0b.png" alt=""></p><p>以全局锁为例，首先是获取一个锁，然后再去开启可重复读的事务。这里锁住操作是读取 binlog 的起始位置和当前表的 schema。这样做的目的是保证 binlog 的起始位置和读取到的当前 schema 是可以对应上的，因为表的 schema 是会改变的，比如如删除列或者增加列。在读取这两个信息后，SnapshotReader 会在可重复读事务里读取全量数据，在全量数据读取完成后，会启动 BinlogReader 从读取的 binlog 起始位置开始增量读取，从而保证全量数据 + 增量数据的无缝衔接。</p><p>表锁是全局锁的退化版，因为全局锁的权限会比较高，因此在某些场景，用户只有表锁。表锁锁的时间会更长，因为表锁有个特征：锁提前释放了可重复读的事务默认会提交，所以锁需要等到全量数据读完后才能释放。而 FLUSH TABLE WITH READ LOCK 的操作会存在以下问题：</p><ol><li>该命令等待所有正在进行的 update 完成，同时阻止所有新来的 update;</li><li>执行成功之前必须等待所有正在运行的 select 完成，等待执行的 update 就会等待的更久。</li><li>会阻止其他的事务 commit。</li></ol><p>所以对于加锁来说在时间上是不确定的，严重的可能会 hang 住数据库。</p><p>当然，Flink CDC 1.x 版本也可以不加锁，但是会丢失一定的数据准确性。总的来说 1.x 存在的问题是：</p><ul><li>全量 + 增量读取的过程需要保证所有数据的一致性，因此需要通过加锁保证，但是加锁在数据库层面上是一个十分高危的操作。底层 Debezium 在保证数据一致性时，需要对读取的库或表加锁，全局锁可能导致数据库锁住，表级锁会锁住表的读，DBA 一般不给锁权限。</li><li>不支持水平扩展，因为 Flink CDC 底层是基于 Debezium，起架构是单节点，所以Flink CDC 只支持单并发。在全量阶段读取阶段，如果表非常大 (亿级别)，读取时间在小时甚至天级别，用户不能通过增加资源去提升作业速度。</li><li>全量读取阶段不支持 checkpoint：CDC 读取分为两个阶段，全量读取和增量读取，目前全量读取阶段是不支持 checkpoint 的，因此会存在一个问题：当我们同步全量数据时，假设需要 5 个小时，当我们同步了 4 小时的时候作业失败，这时候就需要重新开始，再读取 5 个小时。</li></ul><h5 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a><strong>2.0</strong></h5><p>了解了 1.0 的痛点之后，2.0 主要解决的问题有三个：支持无锁、水平扩展、checkpoint。</p><p><img src="https://files.mdnice.com/user/4760/136b100a-8e5f-445d-bc44-bb3a1d4d51de.png" alt=""></p><p>Flink CDC 2.0 在借鉴了 <a href="https://arxiv.org/pdf/2010.12597.pdf" title="DBLog: A Watermark Based Change-Data-Capture Framework" target="_blank" rel="noopener">Netflix 这篇论文</a> 之后可以做到全程无锁和并发读取。</p><h5 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a><strong>3.0</strong></h5><p><img src="https://files.mdnice.com/user/4760/c272b48a-5f53-477b-b781-df87dfe093d8.png" alt=""></p><p>Flink CDC 3.0 拥有了更多数据同步过程中的实用特性，成为了一个端到端的数据集成框架：</p><ul><li>上游 schema 变更自动同步到下游，已有作业支持动态加表</li><li>空闲资源自动回收，一个 sink 实例支持写入多表</li><li>API 设计直接面向数据集成场景，帮助用户轻松构建同步作业</li></ul><p>Databend 也提供了 <a href="https://github.com/databendcloud/flink-connector-databend" title="Flink Databend Connector" target="_blank" rel="noopener">Flink-Databend-Connector</a>，这篇文章展示了如何使用 databend connector 实现从 MySQL 的数据同步。</p><h3 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h3><p>canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。</p><p>早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p><p>基于日志增量订阅和消费的业务包括：</p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护(拆分异构索引、倒排索引等)</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul><p>当前的canal支持源端MySQL版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x。</p><h4 id="canal-工作原理"><a href="#canal-工作原理" class="headerlink" title="canal 工作原理"></a><strong>canal 工作原理</strong></h4><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为MySQL slave,向MySQL master发送dump协议</li><li>MySQL master收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li></ul><h4 id="Binlog获取详解"><a href="#Binlog获取详解" class="headerlink" title="Binlog获取详解"></a>Binlog获取详解</h4><p>Binlog发送接收流程，流程如下图所示:</p><p><img src="https://files.mdnice.com/user/4760/c7a8e181-958f-4650-8954-2680899c6ad0.png" alt=""></p><p>首先，我们需要伪造一个slave，向master注册，这样master才会发送binlog event。注册很简单，就是向master发送COM_REGISTER_SLAVE命令，带上slave相关信息。这里需要注意，因为在MySQL的replication topology中，都需要使用一个唯一的server id来区别标示不同的server实例，所以这里我们伪造的slave也需要一个唯一的server id。</p><p>接着实现binlog的dump。MySQL只支持一种 binlog dump方式，也就是指定binlog filename + position，向master发送COM_BINLOG_DUMP命令。在发送dump命令的时候，我们可以指定flag为BINLOG_DUMP_NON_BLOCK，这样master在没有可发送的binlog event之后，就会返回一个EOF package。不过通常对于slave来说，一直把连接挂着可能更好，这样能更及时收到新产生的binlog event。</p><h4 id="Canal-架构"><a href="#Canal-架构" class="headerlink" title="Canal 架构"></a>Canal 架构</h4><p><img src="https://files.mdnice.com/user/4760/4b3cacd5-a60b-44e6-b22f-b6fe23f9ccd0.png" alt=""></p><ul><li>server代表一个canal运行实例，对应于一个jvm，也可以理解为一个进程</li><li>instance对应于一个数据队列 （1个server对应1..n个instance)，每一个数据队列可以理解为一个数据库实例。</li></ul><p>instance代表了一个实际运行的数据队列，包括了EventPaser,EventSink,EventStore等组件。</p><p>抽象了CanalInstanceGenerator，主要是考虑配置的管理方式：</p><p>manager方式：和你自己的内部web console/manager系统进行对接。(目前主要是公司内部使用，Otter采用这种方式) spring方式：基于spring xml + properties进行定义，构建spring配置.</p><p>下面是 canalServer 和 instance 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">canalServer.setCanalInstanceGenerator(<span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">                Canal canal = canalConfigClient.findCanal(destination);</span><br><span class="line">                <span class="comment">// 此处省略部分代码 大致逻辑是设置canal一些属性</span></span><br><span class="line"></span><br><span class="line">                CanalInstanceWithManager instance = <span class="keyword">new</span> CanalInstanceWithManager(canal, filter) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> CanalHAController <span class="title">initHaController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        HAMode haMode = parameters.getHaMode();</span><br><span class="line">                        <span class="keyword">if</span> (haMode.isMedia()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> MediaHAController(parameters.getMediaGroup(),</span><br><span class="line">                                parameters.getDbUsername(),</span><br><span class="line">                                parameters.getDbPassword(),</span><br><span class="line">                                parameters.getDefaultDatabaseName());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">super</span>.initHaController();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startEventParserInternal</span><span class="params">(CanalEventParser parser, <span class="keyword">boolean</span> isGroup)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//大致逻辑是 设置支持的类型</span></span><br><span class="line">                        <span class="comment">//初始化设置MysqlEventParser的主库信息，这处抽象不好，目前只支持mysql</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        canalServer.start(); <span class="comment">//启动canalServer</span></span><br><span class="line"></span><br><span class="line">        canalServer.start(destination);<span class="comment">//启动对应instance</span></span><br><span class="line">        <span class="keyword">this</span>.clientIdentity = <span class="keyword">new</span> ClientIdentity(destination, pipeline.getParameters().getMainstemClientId(), filter);</span><br><span class="line">        canalServer.subscribe(clientIdentity);<span class="comment">// 发起一次订阅，当监听到instance配置时，调用generate方法注入新的instance</span></span><br></pre></td></tr></table></figure><p>instance模块：</p><ul><li>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</li><li>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</li><li>eventStore (数据存储)</li><li>metaManager (增量订阅&amp;消费信息管理器)</li></ul><p>基于 Canal 的实现原理来看，Canal 并不支持全量+增量的同步模式。</p><h3 id="Airbyte"><a href="#Airbyte" class="headerlink" title="Airbyte"></a>Airbyte</h3><p><a href="https://github.com/airbytehq/airbyte" title="Airbyte" target="_blank" rel="noopener">Airbyte</a> 是一个比较新的数据集成平台，提供了非常多的 connector，号称支持上千种数据源。Databend 也提供了<a href="https://docs.airbyte.com/integrations/destinations/databend" target="_blank" rel="noopener">Airbyte Destination Connecto</a>，用户可以从 Airbyte 支持的上百个 source connector 比如 mysql, es, pg 等同步数据到 Databend。</p><p><img src="https://files.mdnice.com/user/4760/8ce29be6-9407-485c-9313-18f2589266a6.png" alt=""></p><p>Airbyte 的优势是支持的数据源非常多，甚至像 Google Docs, Facebook 都支持。 Airbyte 是 ELT 模式，先抽取数据到目标表后，再进行清洗。但是缺点也非常明显，Airbyte 是一个打包的平台，所有的数据源都要被集成到里面，所以使用起来非常地重。并且Airbyte 同步过来的数据是一张大宽表，依赖 dbt Normalization 或者一些 ELT 工作才能够表展开。所以适合的是数据源多，并且需要统一管理的场景。</p><h3 id="DataX"><a href="#DataX" class="headerlink" title="DataX"></a>DataX</h3><p><a href="https://github.com/alibaba/DataX" title="Datax" target="_blank" rel="noopener">DataX</a> 是阿里开源的一个异构数据源离线同步工具，能够实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive等各种异构数据源之间稳定高效的数据同步功能。DataX 本身作为数据同步框架，将不同数据源的同步, 抽象为从 source 端读取数据的 Reader 插件，以及向目标端写入数据的Writer插件，理论上DataX框架可以支持任意数据源的数据同步工作。</p><p>Databend 提供了 <a href="https://github.com/alibaba/DataX/tree/master/databendwriter" title="Datax Databend Writer" target="_blank" rel="noopener">Databend Writer 的 Datax Plugin</a> , 可以支持从任意具有 Datax Reader 插件的数据库同步数据到 Databend，并且支持全量insert 和 upsert 两种同步模式。Datax 最适合的场景是 T+1 的离线数据同步。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CDC 的技术方案非常多，目前业界主流的实现机制可以分为两种：</p><h4 id="基于查询的-CDC："><a href="#基于查询的-CDC：" class="headerlink" title="基于查询的 CDC："></a>基于查询的 CDC：</h4><ul><li>离线调度查询作业，批处理。把一张表同步到其他系统，每次通过查询去获取表中最新的数据；</li><li>无法保障数据一致性，查的过程中有可能数据已经发生了多次变更；</li><li>不保障实时性，基于离线调度存在天然的延迟。</li></ul><h4 id="基于日志的-CDC："><a href="#基于日志的-CDC：" class="headerlink" title="基于日志的 CDC："></a>基于日志的 CDC：</h4><ul><li>实时消费日志，流处理，例如 MySQL 的 binlog 日志完整记录了数据库中的变更，可以把 binlog 文件当作流的数据源；</li><li>保障数据一致性，因为 binlog 文件包含了所有历史变更明细；</li><li>保障实时性，因为类似 binlog 的日志文件是可以流式消费的，提供的是实时数据。</li></ul><p>对比常见的开源 CDC 方案，我们可以发现，对比增量同步能力:</p><blockquote><ul><li>基于日志的方式，可以很好的做到增量同步；</li><li>而基于查询的方式是很难做到增量同步的。</li></ul></blockquote><ul><li>对比全量同步能力，基于查询或者日志的 CDC 方案基本都支持，除了 Canal。</li><li>而对比全量 + 增量同步的能力，只有 Flink CDC、Debezium 支持较好。</li><li><p>从架构角度去看，该表将架构分为单机和分布式，这里的分布式架构不单纯体现在数据读取能力的水平扩展上，更重要的是在大数据场景下分布式系统接入能力。例如 Flink CDC 的数据入湖或者入仓的时候，下游通常是分布式的系统，如 Hive、HDFS、Iceberg、Hudi 等，那么从对接入分布式系统能力上看，Flink CDC 的架构能够很好地接入此类系统。</p></li><li><p>在数据转换 / 数据清洗能力上，当数据进入到 CDC 工具的时候是否能较方便的对数据做一些过滤或者清洗</p></li></ul><blockquote><ul><li>在 Flink CDC 上操作很简单，可以通过 Flink SQL 去操作；</li><li>但是像 DataX、Debezium 等则需要通过脚本或者模板去做，所以用户的使用门槛会比较高。</li></ul></blockquote><p>另外，在生态方面，这里指的是下游的一些数据库或者数据源的支持。Flink CDC 下游有丰富的 Connector，例如写入到 Databend、MySQL、Pg、ClickHouse 等常见的一些系统，也支持各种自定义 connector。</p><hr>]]></content>
    
    <summary type="html">
    
      数据同步工具考古
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/tags/CDC/"/>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/tags/Databend/"/>
    
  </entry>
  
  <entry>
    <title>databend debezium server support  auto schema evolution</title>
    <link href="https://cloudsjhan.github.io/2024/01/25/databend-debezium-server-support-auto-schema-evolution/"/>
    <id>https://cloudsjhan.github.io/2024/01/25/databend-debezium-server-support-auto-schema-evolution/</id>
    <published>2024-01-25T09:29:12.000Z</published>
    <updated>2024-01-27T15:49:04.579Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://github.com/databendcloud/debezium-server-databend" target="_blank" rel="noopener">Debezium Server Databend</a> 是一个基于 Debezium Engine 自研的轻量级 CDC 项目，用于实时捕获数据库更改并将其作为事件流传递最终将数据写入目标数据库 Databend。它提供了一种简单的方式来监视和捕获关系型数据库的变化，并支持将这些变化转换为可消费事件。使用 Debezium server databend 实现 CDC 无须依赖大型的 Data Infra 比如 Flink, Kafka, Spark 等，只需一个启动脚本即可开启实时数据同步。</p><p>CDC 过程中的 Schema 变更处理是上游数据库中十分常见的用户场景，也是数据同步框架实现的难点。针对该场景，Databend-debezium-server 0.3.0 引入了 Auto Schema Evolution 的能力，在每一批次的数据中协调并控制作业拓扑中的 schema 变更事件处理。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>Debezium  Server Databend 实现 Schema Auto Evolution 功能的原理大致是：</p><p>在配置文件中新增 <code>debezium.sink.databend.schema.evolution</code> 的配置，默认为 false 不开启该功能。</p><p>当上游数据源发生 schema 变更时，先将流水线中已经读出的的数据全部刷出以保证进入数据流的这一批 schema 的一致性：</p><p>然后先将该类 schemachangekey 事件暂存到 schemaEvolutionEvents 的 ArrayList 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;DatabendChangeEvent&gt; schemaEvolutionEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (DatabendChangeEvent event : events) &#123;</span><br><span class="line">   <span class="keyword">if</span> (DatabendUtil.isSchemaChanged(event.schema()) &amp;&amp; isSchemaEvolutionEnabled) &#123;</span><br><span class="line">             schemaEvolutionEvents.add(event);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先将上面刷出的数据执行写入操作，写入这批数据之后且解析 schema 变更的事件之前的时间里不会有新的数据进来。数据处理完后再去解析 schema change events，如果事件类型属于 DDL 并且为 alter table 语句，就对目标 database.table 执行该 DDL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle schema evolution</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          schemaEvolution(table, schemaEvolutionEvents);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schemaEvolution</span><span class="params">(RelationalTable table, List&lt;DatabendChangeEvent&gt; events)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (DatabendChangeEvent event : events) &#123;</span><br><span class="line">         Map&lt;String, Object&gt; values = event.valueAsMap();</span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (entry.getKey().contains(<span class="string">"ddl"</span>) &amp;&amp; entry.getValue().toString().toLowerCase().contains(<span class="string">"alter table"</span>)) &#123;</span><br><span class="line">                 String tableName = getFirstWordAfterAlterTable(entry.getValue().toString());</span><br><span class="line">                 String ddlSql = replaceFirstWordAfterTable(entry.getValue().toString(), table.databaseName + <span class="string">"."</span> + tableName);</span><br><span class="line">                 <span class="keyword">try</span> (PreparedStatement statement = connection.prepareStatement(ddlSql)) &#123;</span><br><span class="line">                     System.out.println(ddlSql);</span><br><span class="line">                     statement.execute(ddlSql);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当 schema 变更事件处理成功后，会继续新的数据同步流程。</p><p>基本的处理流程如下图所示：</p><p><img src="https://files.mdnice.com/user/4760/21ddf1f4-e2e5-4f07-8d9a-ea7fe08b7771.png" alt=""></p><h3 id="实践-amp-演示"><a href="#实践-amp-演示" class="headerlink" title="实践&amp;演示"></a>实践&amp;演示</h3><h4 id="Debezium-Server-Databend"><a href="#Debezium-Server-Databend" class="headerlink" title="Debezium Server Databend"></a>Debezium Server Databend</h4><ul><li><p>Clone 项目: <code>git clone `</code><a href="https://github.com/databendcloud/debezium-server-databend.git`" target="_blank" rel="noopener">https://github.com/databendcloud/debezium-server-databend.git`</a></p></li><li><p>从项目根目录开始:</p><ul><li>构建和打包 debezium server: <code>mvn -Passembly -Dmaven.test.skip package</code></li><li>构建完成后，解压服务器分发包: <code>unzip debezium-server-databend-dist/target/debezium-server-databend-dist*.zip -d databendDist</code></li><li>进入解压后的文件夹: <code>cd databendDist</code></li><li>创建 <code>application.properties</code> 文件并修改: <code>nano conf/application.properties</code>，将下面的 application.properties 拷贝进去，根据用户实际情况修改相应的配置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">debezium.sink.type=databend</span><br><span class="line">debezium.sink.databend.upsert=<span class="keyword">true</span></span><br><span class="line">debezium.sink.databend.upsert-keep-deletes=<span class="keyword">false</span></span><br><span class="line">debezium.sink.databend.database.databaseName=debezium</span><br><span class="line">debezium.sink.databend.database.url=jdbc:databend:<span class="comment">//tnf34b0rm--xxxxxx.default.databend.cn:443</span></span><br><span class="line">debezium.sink.databend.database.username=cloudapp</span><br><span class="line">debezium.sink.databend.database.password=password</span><br><span class="line">debezium.sink.databend.database.primaryKey=id</span><br><span class="line">debezium.sink.databend.database.tableName=products</span><br><span class="line">debezium.sink.databend.database.param.ssl=<span class="keyword">true</span></span><br><span class="line">debezium.sink.databend.schema.evolution=<span class="keyword">true</span> <span class="comment">// Enable Auto Schema Evolution</span></span><br><span class="line"></span><br><span class="line"># enable event schemas</span><br><span class="line">debezium.format.value.schemas.enable=<span class="keyword">true</span></span><br><span class="line">debezium.format.key.schemas.enable=<span class="keyword">true</span></span><br><span class="line">debezium.format.value=json</span><br><span class="line">debezium.format.key=json</span><br><span class="line"></span><br><span class="line"># mysql source</span><br><span class="line">debezium.source.connector.class=io.debezium.connector.mysql.MySqlConnector</span><br><span class="line">debezium.source.offset.storage.file.filename=data/offsets.dat</span><br><span class="line">debezium.source.offset.flush.interval.ms=<span class="number">60000</span></span><br><span class="line"></span><br><span class="line">debezium.source.database.hostname=<span class="number">127.0</span>.0.1</span><br><span class="line">debezium.source.database.port=<span class="number">3306</span></span><br><span class="line">debezium.source.database.user=root</span><br><span class="line">debezium.source.database.password=<span class="number">123456</span></span><br><span class="line">debezium.source.database.dbname=mydb</span><br><span class="line">debezium.source.database.server.name=from_mysql</span><br><span class="line">debezium.source.include.schema.changes=<span class="keyword">false</span></span><br><span class="line">debezium.source.table.include.list=mydb.products</span><br><span class="line"># debezium.source.database.ssl.mode=required</span><br><span class="line"># Run without Kafka, use local file to store checkpoints</span><br><span class="line">debezium.source.database.history=io.debezium.relational.history.FileDatabaseHistory</span><br><span class="line">debezium.source.database.history.file.filename=data/status.dat</span><br><span class="line"># do event flattening. unwrap message!</span><br><span class="line">debezium.transforms=unwrap</span><br><span class="line">debezium.transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState</span><br><span class="line">debezium.transforms.unwrap.delete.handling.mode=rewrite</span><br><span class="line">debezium.transforms.unwrap.drop.tombstones=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># ############ SET LOG LEVELS ############</span><br><span class="line">quarkus.log.level=INFO</span><br><span class="line"># Ignore messages below warning level from Jetty, because it's a bit verbose</span><br><span class="line">quarkus.log.category.<span class="string">"org.eclipse.jetty"</span>.level=WARN</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用提供的脚本运行服务: <code>bash run.sh</code></li><li>Debezium Server with Databend 将会启动</li></ul><h4 id="Mysql-中准备表和数据"><a href="#Mysql-中准备表和数据" class="headerlink" title="Mysql 中准备表和数据"></a>Mysql 中准备表和数据</h4><p>创建数据库 mydb 和表 <code>products</code>，并插入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mydb;</span><br><span class="line"><span class="keyword">USE</span> mydb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (<span class="keyword">id</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,description <span class="built_in">VARCHAR</span>(<span class="number">512</span>));</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products AUTO_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span> (<span class="keyword">default</span>,<span class="string">"scooter"</span>,<span class="string">"Small 2-wheel scooter"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"car battery"</span>,<span class="string">"12V car battery"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"12-pack drill bits"</span>,<span class="string">"12-pack of drill bits with sizes ranging from #40 to #3"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"12oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"14oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"16oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"rocks"</span>,<span class="string">"box of assorted rocks"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"jacket"</span>,<span class="string">"water resistent black wind breaker"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"cloud"</span>,<span class="string">"test for databend"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"spare tire"</span>,<span class="string">"24 inch spare tire"</span>);</span><br></pre></td></tr></table></figure><h4 id="Databend-Cloud-中创建-Database"><a href="#Databend-Cloud-中创建-Database" class="headerlink" title="Databend Cloud 中创建 Database"></a>Databend Cloud 中创建 Database</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> debezium</span><br></pre></td></tr></table></figure><p>NOTE: 用户可以不必先在 Databend 中创建表，系统检测到后会自动为用户建表。</p><h4 id="启动-Debezium-Server-Databend"><a href="#启动-Debezium-Server-Databend" class="headerlink" title="启动 Debezium Server Databend"></a>启动 Debezium Server Databend</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash run.sh</span><br></pre></td></tr></table></figure><p>首次启动会进入 init snapshot 模式，通过配置的 Batch Size 全量将 MySQL 中的数据同步到 Databend，所以在 Databend 中可以看到 MySQL 中的数据已经同步过来了：</p><h4 id="改变-Mysql-表结构"><a href="#改变-Mysql-表结构" class="headerlink" title="改变 Mysql 表结构"></a>改变 Mysql 表结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> products <span class="keyword">add</span> columm a <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><p>在 products 表中新增一列 <code>a int</code></p><p>同时在 Databend Cloud 中也可以看到目标同步表的结构也随之变更了：</p><p><img src="https://files.mdnice.com/user/4760/37999730-dc82-4073-a9cb-fe6e318e6b1a.png" alt=""></p><p>此时在 mysql 中插入数据，新的数据就会以新的 Schema 形式写入目标表：</p><p><img src="https://files.mdnice.com/user/4760/18336d1a-8df3-46cf-8051-6013e3ff4256.png" alt=""></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Debezium Server Databend 在支持 Auto Schema Evolution 之后，用户无需在数据源发生 schema 变更时手动介入，大大降低用户的运维成本；只需对同步任务进行简单配置即可将多表、多个数据库同步至下游，提高了数据同步的效率并且降低了用户的开发难度。</p><hr>]]></content>
    
    <summary type="html">
    
      Databend debezium server support auto schema evolution
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/tags/CDC/"/>
    
      <category term="databend" scheme="https://cloudsjhan.github.io/tags/databend/"/>
    
  </entry>
  
  <entry>
    <title>(持续更新)Databend SDK 接入最佳实践&amp;常见问题</title>
    <link href="https://cloudsjhan.github.io/2024/01/06/Databend-SDK-%E6%8E%A5%E5%85%A5%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://cloudsjhan.github.io/2024/01/06/Databend-SDK-接入最佳实践-常见问题/</id>
    <published>2024-01-06T09:45:41.000Z</published>
    <updated>2024-01-06T12:38:43.804Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:80%"></p><a id="more"></a><p>本文档包含 Databend 支持的所有 SDK 接入的最佳实践以及在使用过程中可能会出现的问题以及对应的解决方案。希望可以成为用户接入 Databend 的一把金钥匙，打开通向 Databend 的大门。</p><h3 id="Databend-JDBC"><a href="#Databend-JDBC" class="headerlink" title="Databend JDBC"></a>Databend JDBC</h3><ul><li>Github: <a href="https://github.com/datafuselabs/databend-jdbc" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-jdbc</a></li><li>入门示例：<a href="https://github.com/datafuselabs/databend-jdbc/blob/main/databend-jdbc/src/main/java/com/databend/jdbc/examples/Examples.java" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-jdbc/blob/main/databend-jdbc/src/main/java/com/databend/jdbc/examples/Examples.java</a></li></ul><h4 id="创建-JDBC-Connection"><a href="#创建-JDBC-Connection" class="headerlink" title="创建 JDBC Connection"></a>创建 JDBC Connection</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">createConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String url = <span class="string">"jdbc:databend://localhost:8000"</span>;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url, <span class="string">"databend"</span>, <span class="string">"databend"</span>); <span class="comment">// user, password</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection c = createConnection();</span><br><span class="line">c.createStatement().execute(<span class="string">"create table test_basic_driver.table1(i int)"</span>);</span><br></pre></td></tr></table></figure><h4 id="单条插入数据"><a href="#单条插入数据" class="headerlink" title="单条插入数据"></a>单条插入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection c = createConnection();</span><br><span class="line">c.createStatement().execute(<span class="string">"create table test_basic_driver.table1(i int, j varchar)"</span>);</span><br><span class="line">c.createStatement().execute(<span class="string">"insert into test_basic_driver.table1 values(1,'j')"</span>);</span><br></pre></td></tr></table></figure><p>单条插入无法发挥 databend 的性能，写入性能较差，只能作为测试使用。推荐使用批量插入（Batch Insert）</p><h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BatchInsert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection c = createConnection();</span><br><span class="line">    c.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    c.createStatement().execute(<span class="string">"create table test_basic_driver.test_prepare_statement(i int, j varchar)"</span>);</span><br><span class="line"></span><br><span class="line">    PreparedStatement ps = c.prepareStatement(<span class="string">"insert into test_prepare_statement values"</span>);</span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    ps.setString(<span class="number">2</span>, <span class="string">"a"</span>);</span><br><span class="line">    ps.addBatch();</span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    ps.setString(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    ps.addBatch();</span><br><span class="line">    System.out.println(<span class="string">"execute batch insert"</span>);</span><br><span class="line">    <span class="keyword">int</span>[] ans = ps.executeBatch();</span><br><span class="line">    ps.close();</span><br><span class="line">    Statement statement = c.createStatement();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"execute select"</span>);</span><br><span class="line">    statement.execute(<span class="string">"SELECT * from test_prepare_statement"</span>);</span><br><span class="line">    ResultSet r = statement.getResultSet();</span><br><span class="line">    <span class="keyword">while</span> (r.next()) &#123;</span><br><span class="line">        System.out.println(r.getInt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(r.getString(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    statement.close();</span><br><span class="line">    c.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际使用中，推荐增大 Batch size 到 10w~100w 之间</p></blockquote><h4 id="连接参数"><a href="#连接参数" class="headerlink" title="连接参数"></a>连接参数</h4><p><a href="https://github.com/datafuselabs/databend-jdbc/blob/main/docs/Connection.md" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-jdbc/blob/main/docs/Connection.md</a></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>Q: <code>Upload to stream failed</code> 报错</p><p>A: 检查 Client 到 OSS 的网络情况</p><p>Q: Spring boot 等项目 Slf4j provider not found</p><p>A: 这可能是引入的 slf4j 包产生了冲突，检查 pom 中 slf4j 版本是否一致</p><p>Q: 如何将 NULL 写入表</p><p>A: ps.setNull(index, Types.NULL)</p><p>Q: Spring boot JDBCTemplate <code>getParameterType</code> not implement</p><p>A: <code>getParameterType</code> 在 databend JDBC 中目前还没有实现，已在开发计划中</p><h3 id="Golang-SDK"><a href="#Golang-SDK" class="headerlink" title="Golang SDK"></a>Golang SDK</h3><ul><li>Github: <a href="https://github.com/datafuselabs/databend-go" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-go</a></li></ul><h4 id="创建-sql-db-client"><a href="#创建-sql-db-client" class="headerlink" title="创建 sql.db client"></a>创建 sql.db client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line">_ <span class="string">"github.com/datafuselabs/databend-go"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">"databend"</span>, dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    db.Ping()</span><br><span class="line">    db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-SQL"><a href="#执行-SQL" class="headerlink" title="执行 SQL"></a>执行 SQL</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conn, err := sql.Open(<span class="string">"databend"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">conn.Exec(<span class="string">`DROP TABLE IF EXISTS data`</span>)</span><br><span class="line">_, err = conn.Exec(<span class="string">`    CREATE TABLE IF NOT EXISTS  data(        Col1 TINYINT,        Col2 VARCHAR    )`</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">_, err = conn.Exec(<span class="string">"INSERT INTO data VALUES (1, 'test-1')"</span>)</span><br></pre></td></tr></table></figure><h4 id="批量插入-1"><a href="#批量插入-1" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        conn, err := sql.Open(<span class="string">"databend"</span>, <span class="string">"http://databend:databend@localhost:8000/default?sslmode=disable"</span>)</span><br><span class="line">        tx, err := conn.Begin()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        batch, err := tx.Prepare(fmt.Sprintf(<span class="string">"INSERT INTO %s VALUES"</span>, <span class="string">"test"</span>))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">                _, err = batch.Exec(</span><br><span class="line">                        <span class="string">"1234"</span>,</span><br><span class="line">                        <span class="string">"2345"</span>,</span><br><span class="line">                        <span class="string">"3.1415"</span>,</span><br><span class="line">                        <span class="string">"test"</span>,</span><br><span class="line">                        <span class="string">"test2"</span>,</span><br><span class="line">                        <span class="string">"[4, 5, 6]"</span>,</span><br><span class="line">                        <span class="string">"[1, 2, 3]"</span>,</span><br><span class="line">                        <span class="string">"2021-01-01"</span>,</span><br><span class="line">                        <span class="string">"2021-01-01 00:00:00"</span>,</span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">        err = tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求单行-多行-Querying-Row-s"><a href="#请求单行-多行-Querying-Row-s" class="headerlink" title="请求单行/多行 (Querying Row/s)"></a>请求单行/多行 (<strong>Querying Row/s)</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// create table data (col1 uint8, col2 string);</span></span><br><span class="line"><span class="comment">// insert into data values(1,'col2');conn, err := sql.Open("databend", "http://databend:databend@localhost:8000/default?sslmode=disable")</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        row := conn.QueryRow(<span class="string">"SELECT * FROM data"</span>)</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">                col1 uint8col2 <span class="keyword">string</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> err := row.Scan(&amp;col1, &amp;col2); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(col2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-SDK"><a href="#Python-SDK" class="headerlink" title="Python SDK"></a>Python SDK</h3><h4 id="databend-py"><a href="#databend-py" class="headerlink" title="databend-py"></a>databend-py</h4><ul><li>Github: <a href="https://github.com/datafuselabs/databend-py" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-py</a></li></ul><h5 id="创建-client"><a href="#创建-client" class="headerlink" title="创建 client"></a>创建 client</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = Client.from_url(<span class="string">"http://user:password@host:port/db?secure=false"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Databend py DSN 中支持的参数可以参考： <a href="https://github.com/datafuselabs/databend-py/blob/main/docs/connection.md" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-py/blob/main/docs/connection.md</a></p></blockquote><h5 id="建表-amp-查询"><a href="#建表-amp-查询" class="headerlink" title="建表&amp;查询"></a>建表&amp;查询</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Client.from_url(databend_url)</span><br><span class="line">c.execute(<span class="string">'CREATE TABLE if not exists test (x Int32,y VARCHAR)'</span>)</span><br><span class="line">t, r = c.execute(<span class="string">'INSERT INTO test VALUES'</span>, [(<span class="number">3</span>, <span class="string">'aa'</span>),(<span class="number">4</span>,<span class="string">'bb'</span>)],with_column_types=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># execute 返回值有两个，第一个是(column_name, column_type)：[('a', 'Int32'), ('b', 'String')], 只有当 with_column_types=True 的时候才返回，默认为 False;</span></span><br><span class="line"><span class="comment"># 第二个返回值是数据集： [(1, 'a'), (2, 'b')]</span></span><br></pre></td></tr></table></figure><h5 id="批量插入-2"><a href="#批量插入-2" class="headerlink" title="批量插入"></a>批量插入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c = Client.from_url(databend_url)</span><br><span class="line">c.execute(<span class="string">'DROP TABLE IF EXISTS test'</span>)</span><br><span class="line">c.execute(<span class="string">'CREATE TABLE if not exists test (x Int32,y VARCHAR)'</span>)</span><br><span class="line">c.execute(<span class="string">'DESC  test'</span>)</span><br><span class="line">_, r1 = c.execute(<span class="string">'INSERT INTO test VALUES'</span>, [(<span class="number">3</span>, <span class="string">'aa'</span>), (<span class="number">4</span>, <span class="string">'bb'</span>)])</span><br><span class="line">assertEqual(r1, <span class="number">2</span>)</span><br><span class="line">_, ss = c.execute(<span class="string">'select * from test'</span>)</span><br><span class="line">assertEqual(ss, [(<span class="number">3</span>, <span class="string">'aa'</span>), (<span class="number">4</span>, <span class="string">'bb'</span>)])</span><br></pre></td></tr></table></figure><h5 id="Upload-data-to-stage"><a href="#Upload-data-to-stage" class="headerlink" title="Upload data to stage"></a>Upload data to stage</h5><p>databend py 可以直接将 python slice 数据以 csv 格式导入到 databend stage</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> databend_py <span class="keyword">import</span> Client</span><br><span class="line">client = Client.from_url(databend_url)</span><br><span class="line">stage_path = client.upload_to_stage(<span class="string">'@~'</span>, <span class="string">"upload.csv"</span>, [(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">1</span>, <span class="string">'b'</span>)])</span><br><span class="line"><span class="comment"># stage_path is @~/upload.csv</span></span><br></pre></td></tr></table></figure><h5 id="Upload-file-to-stage"><a href="#Upload-file-to-stage" class="headerlink" title="Upload file to stage"></a>Upload file to stage</h5><p>Databend py 也可以直接将文件上传到 stage</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> databend_py <span class="keyword">import</span> Client</span><br><span class="line">client = Client.from_url(self.databend_url)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"upload.csv"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">      stage_path = client.upload_to_stage(<span class="string">'@~'</span>, <span class="string">"upload.csv"</span>, f)</span><br><span class="line">      print(stage_path)</span><br></pre></td></tr></table></figure><h4 id="Databend-sqlalchemy"><a href="#Databend-sqlalchemy" class="headerlink" title="Databend sqlalchemy"></a>Databend sqlalchemy</h4><ul><li>Github： <a href="https://github.com/datafuselabs/databend-sqlalchemy" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-sqlalchemy</a></li></ul><h5 id="创建-sqlalchemy-connect-并查询"><a href="#创建-sqlalchemy-connect-并查询" class="headerlink" title="创建 sqlalchemy connect 并查询"></a>创建 sqlalchemy connect 并查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy <span class="keyword">import</span> create_engine, text</span><br><span class="line">from sqlalchemy.engine.base <span class="keyword">import</span> Connection, Engine</span><br><span class="line"></span><br><span class="line">engine = create_engine(</span><br><span class="line">            f<span class="string">"databend://&#123;username&#125;:&#123;password&#125;@&#123;host_port_name&#125;/&#123;database_name&#125;?sslmode=disable"</span></span><br><span class="line">        )</span><br><span class="line">connection = engine.connect()</span><br><span class="line">result = connection.execute(text(<span class="string">"SELECT 1"</span>))</span><br><span class="line"><span class="built_in">print</span>(result.fetchall())</span><br></pre></td></tr></table></figure><p>databend-sqlalchemy 在版本&lt;v0.4.0 使用[databend-py]（<a href="https://github.com/datafuselabs/databend-py）时作为内部" target="_blank" rel="noopener">https://github.com/datafuselabs/databend-py）时作为内部</a> Driver，&gt;= v0.4.0 时使用 <a href="（https://github.com/datafuselabs/bendsql/blob/main/main/bindings/python/readme.md）">databend driver python binding</a>作为内部驱动程序。两者之间的唯一区别是，DSN中提供的连接参数不同。使用相应的版本时应该参考相应驱动程序提供的连接参数。</p><h3 id="Bendsql"><a href="#Bendsql" class="headerlink" title="Bendsql"></a>Bendsql</h3><ul><li>GitHub：<a href="https://github.com/datafuselabs/bendsql" target="_blank" rel="noopener">https://github.com/datafuselabs/bendsql</a></li></ul><h4 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a><strong>Exec</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> databend_driver::Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dsn = <span class="string">"databend://root:@localhost:8000/default?sslmode=disable"</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> client = Client::new(dsn);</span><br><span class="line"><span class="keyword">let</span> conn = client.get_conn().await.unwrap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sql_create = <span class="string">"CREATE TABLE books (</span></span><br><span class="line"><span class="string">    title VARCHAR,</span></span><br><span class="line"><span class="string">    author VARCHAR,</span></span><br><span class="line"><span class="string">    date Date</span></span><br><span class="line"><span class="string">);"</span>;</span><br><span class="line">conn.exec(sql_create).await.unwrap();</span><br><span class="line"><span class="keyword">let</span> sql_insert = <span class="string">"INSERT INTO books VALUES ('The Little Prince', 'Antoine de Saint-Exupéry', '1943-04-06');"</span>;</span><br><span class="line">conn.exec(sql_insert).await.unwrap();</span><br></pre></td></tr></table></figure><h4 id="请求单行数据"><a href="#请求单行数据" class="headerlink" title="请求单行数据"></a><strong>请求单行数据</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = conn.query_row(<span class="string">"SELECT * FROM books;"</span>).await.unwrap();</span><br><span class="line"><span class="keyword">let</span> (title,author,date): (<span class="built_in">String</span>,<span class="built_in">String</span>,<span class="built_in">i32</span>) = row.unwrap().try_into().unwrap();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>, title, author, date);</span><br></pre></td></tr></table></figure><h4 id="请求多行"><a href="#请求多行" class="headerlink" title="请求多行"></a>请求多行</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rows = conn.query_iter(<span class="string">"SELECT * FROM books;"</span>).await.unwrap();</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(row) = rows.next().await &#123;</span><br><span class="line">    <span class="keyword">let</span> (title,author,date): (<span class="built_in">String</span>,<span class="built_in">String</span>,chrono::NaiveDate) = row.unwrap().try_into().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>, title, author, date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DSN-参数"><a href="#DSN-参数" class="headerlink" title="DSN 参数"></a>DSN 参数</h4><p>参考：<a href="https://github.com/datafuselabs/bendsql/blob/main/README.md#dsn" target="_blank" rel="noopener">https://github.com/datafuselabs/bendsql/blob/main/README.md#dsn</a></p><hr>]]></content>
    
    <summary type="html">
    
      Databend SDK 接入最佳实践&amp;常见问题
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/tags/Databend/"/>
    
      <category term="driver SDK" scheme="https://cloudsjhan.github.io/tags/driver-SDK/"/>
    
      <category term="生态" scheme="https://cloudsjhan.github.io/tags/%E7%94%9F%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>从 AutoMQ Kafka 导出数据到 Databend</title>
    <link href="https://cloudsjhan.github.io/2024/01/02/%E4%BB%8E-AutoMQ-Kafka-%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%88%B0-Databend/"/>
    <id>https://cloudsjhan.github.io/2024/01/02/从-AutoMQ-Kafka-导出数据到-Databend/</id>
    <published>2024-01-02T09:08:59.000Z</published>
    <updated>2024-01-02T09:11:41.752Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://github.com/datafuselabs/databend" target="_blank" rel="noopener">Databend</a>是使用 Rust 研发、开源的、完全面向云架构、基于对象存储构建的新一代云原生数据仓库，为企业提供湖仓一体化、计<br>算和存储分离的大数据分析平台。</p><p>本文将介绍如何通过 <a href="https://github.com/databendcloud/bend-ingest-kafka" target="_blank" rel="noopener">bend-ingest-kafka</a> 将数据从 AutoMQ for Kafka 导入 Databend。</p><blockquote><p>本文中提及的 AutoMQ Kafka 术语，均特指安托盟丘（杭州）科技有限公司通过 GitHub <a href="https://github.com/AutoMQ" target="_blank" rel="noopener">AutoMQ </a>组织下开源的 <a href="https://github.com/AutoMQ/automq-for-kafka" target="_blank" rel="noopener">automq-for-kafka</a> 项目。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="准备-Databend-Cloud-以及测试数据"><a href="#准备-Databend-Cloud-以及测试数据" class="headerlink" title="准备 Databend Cloud 以及测试数据"></a>准备 Databend Cloud 以及测试数据</h3><p>首先到 <a href="https://docs.databend.cn/guides/cloud/new-account" target="_blank" rel="noopener">Databend Cloud</a> 开启你的 Warehouse ，并在 worksheet 中创建数据库库和测试表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> automq_db;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">string</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    ts <span class="keyword">timestamp</span>,</span><br><span class="line">    <span class="keyword">status</span> <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="准备-AutoMQ-Kafka-环境和测试数据"><a href="#准备-AutoMQ-Kafka-环境和测试数据" class="headerlink" title="准备 AutoMQ Kafka 环境和测试数据"></a>准备 AutoMQ Kafka 环境和测试数据</h3><p>参考 <a href="https://docs.automq.com/zh/docs/automq-s3kafka/EKcdwqXFWixsm0kH5zVcqYzhnle" target="_blank" rel="noopener">部署 AutoMQ 到 AWS▸</a> 部署好 AutoMQ Kafka 集群，确保 AutoMQ Kafka 与 StarRocks 之间保持网络连通。</p><p>在AutoMQ Kafka中快速创建一个名为 example_topic 的主题并向其中写入一条测试 JSON 数据，可以通过以下步骤实现：</p><h4 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic:"></a><strong>创建Topic</strong>:</h4><p>使用 Apache Kafka 命令行工具来创建主题。你需要有 Kafka 环境的访问权限，并且确保 Kafka 服务正在运行。以下是创建主题的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --topic exampleto_topic --bootstrap-server 10.0.96.4:9092  --partitions 1 --replication-factor 1</span><br></pre></td></tr></table></figure><blockquote><p>注意：执行命令时，需要将 topic 和 bootstarp-server 替换为实际使用的 Kafka 服务器地址。</p></blockquote><p>创建 topic 之后可以用以下命令检查 topic 创建的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --describe example_topic --bootstrap-server 10.0.96.4:9092</span><br></pre></td></tr></table></figure><h4 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据:"></a><strong>生成测试数据</strong>:</h4><p>生成一条简单的 JSON 格式的测试数据，和前文的表需要对应。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"Test User"</span>,</span><br><span class="line">    <span class="attr">"ts"</span>:<span class="string">"2023-11-10T12:00:00"</span>,</span><br><span class="line">    <span class="attr">"status"</span>:<span class="string">"active"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入测试数据"><a href="#写入测试数据" class="headerlink" title="写入测试数据"></a><strong>写入测试数据</strong></h4><p>使用 Kafka 的命令行工具或者编程方式将测试数据写入到 <code>example_topic</code>。以下是使用命令行工具的一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo '&#123;"id": 1, "name": "测试用户", "ts": "2023-11-10T12:00:00", "status": "active"&#125;' | sh kafka-console-producer.sh --broker-list 10.0.96.4:9092 --topic example_topic</span><br></pre></td></tr></table></figure><p>使用如下命令可以查看刚写入的 topic 数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-console-consumer.sh --bootstrap-server 10.0.96.4:9092 --topic example_topic --from-beginning</span><br></pre></td></tr></table></figure><h2 id="创建-bend-ingest-databend-job"><a href="#创建-bend-ingest-databend-job" class="headerlink" title="创建 bend-ingest-databend job"></a>创建 bend-ingest-databend job</h2><p><a href="https://github.com/databendcloud/bend-ingest-kafka" target="_blank" rel="noopener">bend-ingest-kafka</a> 能够监控 kafka 并将数据批量写入 Databend Table。</p><p>部署 <code>bend-ingest-kafka</code> 之后，即可开启数据导入 job。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bend-ingest-kafka --kafka-bootstrap-servers="localhost:9094" --kafka-topic="example_topic" --kafka-consumer-group="Consumer Group" --databend-dsn="https://cloudapp:password@host:443" --databend-table="automq_db.users" --data-format="json" --batch-size=5 --batch-max-interval=30s</span><br></pre></td></tr></table></figure><blockquote><p>注意：将 kafka_broker_list 替换为实际使用的 Kafka 服务器地址。</p></blockquote><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><h4 id="databend-dsn"><a href="#databend-dsn" class="headerlink" title="databend-dsn"></a><strong>databend-dsn</strong></h4><p>Databend Cloud 提供的连接到 warehouse 的 DSN，可以参考<a href="https://docs.databend.cn/guides/cloud/using-databend-cloud/warehouses#connecting" target="_blank" rel="noopener">该文档</a> 获取。</p><h4 id="batch-size"><a href="#batch-size" class="headerlink" title="batch-size"></a><strong>batch-size</strong></h4><p><code>bend-ingest-kafka</code> 会积攒到 batch-size 条数据再触发一次数据同步。</p><h2 id="验证数据导入"><a href="#验证数据导入" class="headerlink" title="验证数据导入"></a>验证数据导入</h2><p>到 Databend Cloud worksheet 中查询 <code>automq_db.users</code> 表，可以看到数据已经从 AutoMq 同步到 Databend Table。</p><p><img src="https://dlink.host/wx1.sinaimg.cn/large/005UfcOkly8hlfe8hc6ocj31si0u0acx.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      从 AutoMQ Kafka 导出数据到 Databend
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/tags/Databend/"/>
    
      <category term="kafka" scheme="https://cloudsjhan.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>使用 LF Edge eKuiper 将物联网流处理数据写入 Databend</title>
    <link href="https://cloudsjhan.github.io/2023/09/15/%E4%BD%BF%E7%94%A8-LF-Edge-eKuiper-%E5%B0%86%E7%89%A9%E8%81%94%E7%BD%91%E6%B5%81%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-Databend/"/>
    <id>https://cloudsjhan.github.io/2023/09/15/使用-LF-Edge-eKuiper-将物联网流处理数据写入-Databend/</id>
    <published>2023-09-15T08:12:42.000Z</published>
    <updated>2023-09-15T08:16:11.544Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="LF-Edge-eKuiper"><a href="#LF-Edge-eKuiper" class="headerlink" title="LF Edge eKuiper"></a>LF Edge eKuiper</h2><p>[LF Edge eKuiper(<a href="https://github.com/lf-edge/ekuiper" target="_blank" rel="noopener">https://github.com/lf-edge/ekuiper</a>) 是 Golang 实现的轻量级物联网边缘分析、流式处理开源软件，可以运行在各类资源受限的边缘设备上。eKuiper 的主要目标是在边缘端提供一个流媒体软件框架（类似于 <a href="https://flink.apache.org/" target="_blank" rel="noopener">Apache Flink (opens new window)</a>）。eKuiper 的规则引擎允许用户提供基于 SQL 或基于图形（类似于 Node-RED）的规则，在几分钟内创建物联网边缘分析应用。具体介绍可以参考 <a href="https://ekuiper.org/docs/zh/latest/" target="_blank" rel="noopener">LF Edge eKuiper - 超轻量物联网边缘流处理软件</a>。</p><p><img src="https://p.ipic.vip/zk6cqs.png" alt=""></p><h2 id="Databend-Sql-Sink"><a href="#Databend-Sql-Sink" class="headerlink" title="Databend Sql Sink"></a>Databend Sql Sink</h2><p>eKuiper 支持通过 Golang 或者 Python 在<code>源 (Source)</code>，<code>SQL 函数</code>, <code>目标 (Sink)</code> 三个方面的扩展，通过支持不同的 Sink，允许用户将分析结果发送到不同的扩展系统中。Databend 作为 Sink 也被集成到了 eKuiper plugin 当中，下面通过一个案例来展示如何使用 eKuiper 将物联网流处理数据写入 Databend。</p><h2 id="编译-ekuiper-和-Databend-Sql-Plugin"><a href="#编译-ekuiper-和-Databend-Sql-Plugin" class="headerlink" title="编译 ekuiper 和 Databend Sql Plugin"></a>编译 ekuiper 和 Databend Sql Plugin</h2><h3 id="Ekuiper"><a href="#Ekuiper" class="headerlink" title="Ekuiper"></a>Ekuiper</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> clone https://github.com/lf-edge/ekuiper &amp; cd ekuiper</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="Databend-Sql-Plugin"><a href="#Databend-Sql-Plugin" class="headerlink" title="Databend Sql Plugin"></a>Databend Sql Plugin</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">go</span> build -trimpath --buildmode=plugin -tags databend -o plugins/sinks/Sql.so extensions/sinks/sql/sql.go</span><br></pre></td></tr></table></figure><p>编译后的 sink plugin 拷贝到 build 目录：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> plugins/sinks/Sql.so _build/kuiper-<span class="number">1</span>.<span class="number">11</span>.<span class="number">1</span>-<span class="number">18</span>-g42d9147f-darwin-arm64/plugins/sinks</span><br></pre></td></tr></table></figure><h2 id="Databend-建表"><a href="#Databend-建表" class="headerlink" title="Databend 建表"></a>Databend 建表</h2><p>在 Databend 中先创建目标表 ekuiper_test：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table ekuiper_test (name string,size bigint,id bigint);</span><br></pre></td></tr></table></figure><h2 id="启动-ekuiperd"><a href="#启动-ekuiperd" class="headerlink" title="启动 ekuiperd"></a>启动 ekuiperd</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> _build/kuiper-<span class="number">1</span>.<span class="number">11</span>.<span class="number">1</span>-<span class="number">18</span>-g42d9147f-darwin-arm64 </span><br><span class="line">./bin/kuiperd</span><br></pre></td></tr></table></figure><p>服务正常启动：</p><p><img src="https://p.ipic.vip/jheqto.png" alt="img"></p><h2 id="创建流（stream）-和-规则-rule"><a href="#创建流（stream）-和-规则-rule" class="headerlink" title="创建流（stream） 和 规则 (rule)"></a>创建流（stream） 和 规则 (rule)</h2><p>Ekuiper 提供了两种管理各种流、规则，目标端的方式，一种是通过 ekuiper-manager 的 docker image（<a href="https://hub.docker.com/r/lfedge/ekuiper）启动可视化管理界面，一种是通过" target="_blank" rel="noopener">https://hub.docker.com/r/lfedge/ekuiper）启动可视化管理界面，一种是通过</a> CLI 工具来管理。这里我们使用 CLI。</p><h3 id="创建-stream"><a href="#创建-stream" class="headerlink" title="创建 stream"></a>创建 stream</h3><p>流是 eKuiper 中数据源连接器的运行形式。它必须指定一个源类型来定义如何连接到外部资源。这里我们创建一个流，从 json 文件数据源中获取数据，并发送到 ekuiper 中。</p><p>首先配置文件数据源，连接器的配置文件位于 <code>/etc/sources/file.yaml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default:</span></span><br><span class="line">  <span class="comment"># 文件的类型，支持 json， csv 和 lines</span></span><br><span class="line"><span class="attr">  fileType:</span> <span class="string">json</span></span><br><span class="line">  <span class="comment"># 文件以 eKuiper 为根目录的目录或文件的绝对路径。</span></span><br><span class="line">  <span class="comment"># 请勿在此处包含文件名。文件名应在流数据源中定义</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">data</span></span><br><span class="line">  <span class="comment"># 读取文件的时间间隔，单位为ms。如果只读取一次，则将其设置为 0</span></span><br><span class="line"><span class="attr">  interval:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 读取后，两条数据发送的间隔时间</span></span><br><span class="line"><span class="attr">  sendInterval:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 是否并行读取目录中的文件</span></span><br><span class="line"><span class="attr">  parallel:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 文件读取后的操作</span></span><br><span class="line">  <span class="comment"># 0: 文件保持不变</span></span><br><span class="line">  <span class="comment"># 1: 删除文件</span></span><br><span class="line">  <span class="comment"># 2: 移动文件到 moveTo 定义的位置</span></span><br><span class="line"><span class="attr">  actionAfterRead:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 移动文件的位置, 仅用于 actionAfterRead 为 2 的情况</span></span><br><span class="line"><span class="attr">  moveTo:</span> <span class="string">/tmp/kuiper/moved</span></span><br><span class="line">  <span class="comment"># 是否包含文件头，多用于 csv。若为 true，则第一行解析为文件头。</span></span><br><span class="line"><span class="attr">  hasHeader:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 定义文件的列。如果定义了文件头，该选项将被覆盖。</span></span><br><span class="line">  <span class="comment"># columns: [id, name]</span></span><br><span class="line">  <span class="comment"># 忽略开头多少行的内容。</span></span><br><span class="line"><span class="attr">  ignoreStartLines:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 忽略结尾多少行的内容。最后的空行不计算在内。</span></span><br><span class="line"><span class="attr">  ignoreEndLines:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># 使用指定的压缩方法解压缩文件。现在支持`gzip`、`zstd` 方法。</span></span><br><span class="line"><span class="attr">  decompression:</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p>使用 CLI 创建 steam 名为 <code>stream1</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./bin/kuiper</span> <span class="string">create</span> <span class="string">stream</span> <span class="string">stream1</span> <span class="string">'(id BIGINT, name STRING,size BIGINT) WITH (DATASOURCE="test.json", FORMAT="json", TYPE="file");'</span></span><br></pre></td></tr></table></figure><p><img src="https://datafuselabs.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM5YjU2ZGQ4NzllOGQ2OTEyMGQ4MmUzOTVjOGY0ZDNfa3plRTRiRnB5aTZMVmdVamdlUUZCQ1BQSVAySVB0S05fVG9rZW46V2p0VWJTcTR6b1FUc254OFVjRWN5dXBqbkJoXzE2OTQ3NjU2NzA6MTY5NDc2OTI3MF9WNA" alt="img"></p><p>Json 文件的内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">"id"</span>: <span class="number">1</span>,<span class="attr">"size"</span>:<span class="number">100</span>, <span class="attr">"name"</span>: <span class="string">"John Doe"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"id"</span>: <span class="number">2</span>,<span class="attr">"size"</span>:<span class="number">200</span>, <span class="attr">"name"</span>: <span class="string">"Jane Smith"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"id"</span>: <span class="number">3</span>,<span class="attr">"size"</span>:<span class="number">300</span>, <span class="attr">"name"</span>: <span class="string">"Kobe Brant"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">"id"</span>: <span class="number">4</span>,<span class="attr">"size"</span>:<span class="number">400</span>, <span class="attr">"name"</span>: <span class="string">"Alen Iverson"</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="创建-Databend-Sink-Rule"><a href="#创建-Databend-Sink-Rule" class="headerlink" title="创建 Databend  Sink Rule"></a>创建 Databend  Sink Rule</h3><p>一个规则代表了一个流处理流程，定义了从将数据输入流的数据源到各种处理逻辑，再到将数据输入到外部系统的动作。ekuiper 有两种方法来定义规则的业务逻辑。要么使用SQL/动作组合，要么使用新增加的图API。</p><p>这里我们通过指定 <code>sql</code> 和 <code>actions</code> 属性，以声明的方式定义规则的业务逻辑。其中，<code>sql</code> 定义了针对预定义流运行的 SQL 查询，这将转换数据。然后，输出的数据可以通过 <code>action</code> 路由到多个位置。</p><p>规则由 JSON 定义，下面是准备创建的规则 myRule.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"myRule"</span>,</span><br><span class="line">  <span class="attr">"sql"</span>: <span class="string">"SELECT id, name from stream1"</span>,</span><br><span class="line">  <span class="attr">"actions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"log"</span>: &#123;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"sql"</span>: &#123;</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"databend://databend:databend@localhost:8000/default?sslmode=disable"</span>,</span><br><span class="line">        <span class="attr">"table"</span>: <span class="string">"ekuiper_test"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>: [<span class="string">"id"</span>,<span class="string">"name"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 CLI 创建规则：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kuiper create rule myRule -f myRule.json</span><br></pre></td></tr></table></figure><p><img src="https://p.ipic.vip/x9595c.png" alt="img"></p><p>可以查看所创建规则的运行状态：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kuiper getstatus rule myRule</span><br></pre></td></tr></table></figure><p><img src="https://datafuselabs.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQwYjA4NjRlYzZhMDBhMTcyZjExNjI4M2FjZTA0ZmVfYU03MWt0ZGpMamdPRWg0MTN0N3JCeWFXRll4TEJaY0RfVG9rZW46SGxkTGJtZnFibzFqdzh4Sk02QWN1MHhtbnBnXzE2OTQ3NjU2NzA6MTY5NDc2OTI3MF9WNA" alt="img"></p><p>规则创建后，会立即将符合规则条件的数据发送到目标端，此时我们查看 databend 的 ekuiper_test 表，可以看到文件数据源中的数据已经被写入到 databend：</p><p><img src="https://p.ipic.vip/1i2f2u.png" alt="img"></p><p>可以看到由于我们的规则 SQL 中只指定了 <code>id</code>, <code>name</code> 字段，所以这里只有这两个字段被写入。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Ekuiper 是 EMQ 旗下的一款流处理软件，其体积小、功能强大，在工业物联网、车辆网、公共数据分析等很多场景中得到广泛使用。本文介绍如何使用 eKuiper 将物联网流处理数据写入 Databend。</p><hr>]]></content>
    
    <summary type="html">
    
      使用 LF Edge eKuiper 将物联网流处理数据写入 Databend
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/tags/Databend/"/>
    
      <category term="EMQ" scheme="https://cloudsjhan.github.io/tags/EMQ/"/>
    
      <category term="stream data" scheme="https://cloudsjhan.github.io/tags/stream-data/"/>
    
  </entry>
  
  <entry>
    <title>databend kafka connect 构建实时数据同步</title>
    <link href="https://cloudsjhan.github.io/2023/09/08/databend-kafka-connect-%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <id>https://cloudsjhan.github.io/2023/09/08/databend-kafka-connect-构建实时数据同步/</id>
    <published>2023-09-08T05:42:15.000Z</published>
    <updated>2023-09-08T06:33:23.545Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="kafka-connect-介绍"><a href="#kafka-connect-介绍" class="headerlink" title="kafka connect 介绍"></a>kafka connect 介绍</h2><p>Kafka Connect 是一个用于在Apache Kafka®和其他数据系统之间可扩展且可靠地流式传输数据的工具。通过将数据移入和移出 Kafka 进行标准化，使得快速定义连接器以在 Kafka 中传输大型数据集变得简单，可以更轻松地构建大规模的实时数据管道。我们使用 Kafka Connector 读取或写入外部系统、管理数据流以及扩展系统，所有这些都无需开发新代码。Kafka Connect 管理与其他系统连接时的所有常见问题（Schema 管理、容错、并行性、延迟、投递语义等），每个 Connector 只关注如何在目标系统和 Kafka 之间复制数据。</p><p>Kafka 连接器通常用来构建 data pipeline，一般有两种使用场景：</p><p>开始和结束的端点：例如，将 Kafka 中的数据导出到 Databend 数据库，或者把 Mysql 数据库中的数据导入 Kafka 中。<br>数据传输的中间介质：例如，为了把海量的日志数据存储到 Elasticsearch 中，可以先把这些日志数据传输到 Kafka 中，然后再从 Kafka 中将这些数据导入到 Elasticsearch 中进行存储。Kafka 连接器可以作为数据管道各个阶段的缓冲区，将消费者程序和生产者程序有效地进行解耦。</p><p>Kafka connect 分为两种：</p><p>Source connect：负责将数据导入 Kafka。<br>Sink connect：负责将数据从 Kafka 系统中导出到目标表。<br><img src="https://p.ipic.vip/v9dpd7.png" alt="kafka-connect"></p><h2 id="Databend-Kafka-Connect"><a href="#Databend-Kafka-Connect" class="headerlink" title="Databend Kafka Connect"></a>Databend Kafka Connect</h2><p>Kafka 目前在 <a href="https://docs.confluent.io/platform/current/connect/kafka_connectors.html" target="_blank" rel="noopener">Confluent Hub</a> 上提供了上百种 connector，比如 <a href="https://docs.confluent.io/kafka-connectors/elasticsearch/current/overview.html" target="_blank" rel="noopener">Elasticsearch Service Sink Connector</a>, <a href="https://docs.confluent.io/kafka-connectors/s3-sink/current/overview.html" target="_blank" rel="noopener">Amazon Sink Connector</a>, <a href="https://docs.confluent.io/kafka-connectors/hdfs/current/overview.html" target="_blank" rel="noopener">HDFS Sink</a> 等，用户可以使用这些 connector 以 kafka 为中心构建任意系统之间的数据管道。现在我们也为 <a href="https://databend.rs" target="_blank" rel="noopener">Databend</a> 提供了 kafka connect sink plugin，这篇文章我们将会介绍如何使用 MySQL JDBC Source Connector 和 [Databend Sink Connector] 构建实时的数据同步管道。</p><h3 id="启动-Kafka-Connect"><a href="#启动-Kafka-Connect" class="headerlink" title="启动 Kafka Connect"></a>启动 Kafka Connect</h3><p>本文假定操作的机器上已经安装 Apache Kafka，如果用户还没有安装，可以参考 <a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">Kafka quickstart</a> 进行安装。</p><p>Kafka Connect 目前支持两种执行模式：Standalone 模式和分布式模式。</p><h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><h5 id="Standalone-模式"><a href="#Standalone-模式" class="headerlink" title="Standalone 模式"></a>Standalone 模式</h5><p>在 Standalone 模式下，所有的工作都在单个进程中完成。这种模式更容易配置以及入门，但不能充分利用 Kafka Connect 的某些重要功能，例如，容错。我们可以使用如下命令启动 Standalone 进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/connect-standalone.sh config/connect-standalone.properties connector1.properties [connector2.properties ...]</span><br></pre></td></tr></table></figure><p>第一个参数 config/connect-standalone.properties 是 worker 的配置。这其中包括 Kafka 连接参数、序列化格式以及提交 Offset 的频率等配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.servers=localhost:9092</span><br><span class="line">key.converter.schemas.enable=true</span><br><span class="line">value.converter.schemas.enable=true</span><br><span class="line">offset.storage.file.filename=/tmp/connect.offsets</span><br><span class="line">offset.flush.interval.ms=10000</span><br></pre></td></tr></table></figure><p>后面的配置是指定要启动的 connector 的参数。</p><p>上述提供的默认配置适用于使用 config/server.properties 提供的默认配置运行的本地集群。如果使用不同配置或者在生产部署，那就需要对默认配置做调整。但无论怎样，所有 Worker（独立的和分布式的）都需要一些配置：</p><ul><li>bootstrap.servers：该参数列出了将要与 Connect 协同工作的 broker 服务器，Connector 将会向这些 broker 写入数据或者从它们那里读取数据。你不需要指定集群的所有 broker，但是建议至少指定3个。</li><li>key.converter 和 value.converter：分别指定了消息键和消息值所使用的的转换器，用于在 Kafka Connect 格式和写入 Kafka 的序列化格式之间进行转换。这控制了写入 Kafka 或从 Kafka 读取的消息中键和值的格式。由于这与 Connector 没有任何关系，因此任何 Connector 可以与任何序列化格式一起使用。默认使用 Kafka 提供的 JSONConverter。有些转换器还包含了特定的配置参数。例如，通过将 key.converter.schemas.enable 设置成 true 或者 false 来指定 JSON 消息是否包含 schema。</li><li>offset.storage.file.filename：用于存储 Offset 数据的文件。</li></ul><p>这些配置参数可以让 Kafka Connect 的生产者和消费者访问配置、Offset 和状态 Topic。配置 Kafka Source 任务使用的生产者和 Kafka Sink 任务使用的消费者，可以使用相同的参数，但需要分别加上 ‘producer.’ 和 ‘consumer.’ 前缀。bootstrap.servers 是唯一不需要添加前缀的 Kafka 客户端参数。</p><h5 id="distributed-模式"><a href="#distributed-模式" class="headerlink" title="distributed 模式"></a>distributed 模式</h5><p>分布式模式可以自动平衡工作负载，并可以动态扩展（或缩减）以及提供容错。分布式模式的执行与 Standalone 模式非常相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/connect-distributed.sh config/connect-distributed.properties</span><br></pre></td></tr></table></figure><p>不同之处在于启动的脚本以及配置参数。在分布式模式下，使用 connect-distributed.sh 来代替 connect-standalone.sh。第一个 worker 配置参数使用的是 config/connect-distributed.properties 配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.servers=localhost:9092</span><br><span class="line">group.id=connect-cluster</span><br><span class="line">key.converter.schemas.enable=true</span><br><span class="line">value.converter.schemas.enable=true</span><br><span class="line">offset.storage.topic=connect-offsets</span><br><span class="line">offset.storage.replication.factor=1</span><br><span class="line"><span class="meta">#</span><span class="bash">offset.storage.partitions=25</span></span><br><span class="line">config.storage.topic=connect-configs</span><br><span class="line">config.storage.replication.factor=1</span><br><span class="line">status.storage.topic=connect-status</span><br><span class="line">status.storage.replication.factor=1</span><br><span class="line"><span class="meta">#</span><span class="bash">status.storage.partitions=5</span></span><br><span class="line">offset.flush.interval.ms=10000</span><br></pre></td></tr></table></figure><p>Kafka Connect 将 Offset、配置以及任务状态存储在 Kafka Topic 中。建议手动创建 Offset、配置和状态的 Topic，以达到所需的分区数和复制因子。如果在启动 Kafka Connect 时尚未创建 Topic，将使用默认分区数和复制因子来自动创建 Topic，这可能不适合我们的应用。在启动集群之前配置如下参数至关重要：</p><ul><li>group.id：Connect 集群的唯一名称，默认为 connect-cluster。具有相同 group id 的 worker 属于同一个 Connect 集群。需要注意的是这不能与消费者组 ID 冲突。</li><li>config.storage.topic：用于存储 Connector 和任务配置的 Topic，默认为 connect-configs。需要注意的是这是一个只有一个分区、高度复制、压缩的 Topic。我们可能需要手动创建 Topic 以确保配置的正确，因为自动创建的 Topic 可能有多个分区或自动配置为删除而不是压缩。</li><li>offset.storage.topic：用于存储 Offset 的 Topic，默认为 connect-offsets。这个 Topic 可以有多个分区。</li><li>status.storage.topic：用于存储状态的 Topic，默认为 connect-status。这个 Topic 可以有多个分区。</li></ul><p>需要注意的是在分布式模式下通过rest api来管理connector。</p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /connectors – 返回所有正在运行的connector名。</span><br><span class="line">POST /connectors – 新建一个connector; 请求体必须是json格式并且需要包含name字段和config字段，name是connector的名字，config是json格式，必须包含你的connector的配置信息。</span><br><span class="line">GET /connectors/&#123;name&#125; – 获取指定connetor的信息。</span><br><span class="line">GET /connectors/&#123;name&#125;/config – 获取指定connector的配置信息。</span><br><span class="line">PUT /connectors/&#123;name&#125;/config – 更新指定connector的配置信息。</span><br></pre></td></tr></table></figure><h3 id="配置-Connector"><a href="#配置-Connector" class="headerlink" title="配置 Connector"></a>配置 Connector</h3><h4 id="MySQL-Source-Connector"><a href="#MySQL-Source-Connector" class="headerlink" title="MySQL Source Connector"></a>MySQL Source Connector</h4><ol><li>安装 <strong>MySQL Source Connector plugin</strong></li></ol><p>这里我们使用 Confluent 提供的 JDBC Source Connector。</p><p>从 Confluent hub 下载 <a href="https://www.confluent.io/hub/confluentinc/kafka-connect-jdbc" target="_blank" rel="noopener">Kafka Connect JDBC</a> 插件并将 zip 文件解压到 /path/kafka/libs 目录下。</p><ol start="2"><li>安装 MySQL JDBC Driver</li></ol><p>因为 Connector 需要与数据库进行通信，所以还需要 JDBC 驱动程序。JDBC Connector 插件也没有内置 MySQL 驱动程序，需要我们单独下载驱动程序。MySQL 为许多平台提供了 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdownloads.mysql.com%2Farchives%2Fc-j%2F" target="_blank" rel="noopener">JDBC 驱动程序</a>。选择 Platform Independent 选项，然后下载压缩的 TAR 文件。该文件包含 JAR 文件和源代码。将此 tar.gz 文件的内容解压到一个临时目录。将 jar 文件（例如，mysql-connector-java-8.0.17.jar），并且仅将此 JAR 文件复制到与 kafka-connect-jdbc jar 文件相同的 <code>libs</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mysql-connector-j-8.0.32.jar /opt/homebrew/Cellar/kafka/3.4.0/libexec/libs/</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 MySQL Connector</li></ol><p>在  <code>/path/kafka/config</code> 下创建 <code>mysql.properties</code> 配置文件，并使用下面的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name=test-source-mysql-autoincrement</span><br><span class="line">connector.class=io.confluent.connect.jdbc.JdbcSourceConnector</span><br><span class="line">tasks.max=1</span><br><span class="line">connection.url=jdbc:mysql://localhost:3306/mydb?useSSL=false</span><br><span class="line">connection.user=root</span><br><span class="line">connection.password=123456</span><br><span class="line">#mode=timestamp+incrementing</span><br><span class="line">mode=incrementing</span><br><span class="line">table.whitelist=mydb.test_kafka</span><br><span class="line">poll.interval.ms=1000</span><br><span class="line">table.poll.interval.ms=3000</span><br><span class="line">incrementing.column.name=id</span><br><span class="line">#timestamp.column.name=tms</span><br><span class="line">topics=test_kafka</span><br></pre></td></tr></table></figure><p>针对配置我们这里重点介绍 <code>mode</code> ， <code>incrementing.column.name</code> ，和 <code>timestamp.column.name</code> 几个字段。Kafka Connect MySQL JDBC Source  提供了三种增量同步模式：</p><ul><li>incrementing</li><li>timestamp</li><li>timestamp+incrementing</li></ul><ol><li>在 incrementing 模式下，每次都是根据 incrementing.column.name 参数指定的列，查询大于自上次拉取的最大id：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mydb.test_kafka</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; ?</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><p>这种模式的缺点是无法捕获行上更新操作（例如，UPDATE、DELETE）的变更，因为无法增大该行的 id。</p><ol start="2"><li>timestamp 模式基于表上时间戳列来检测是否是新行或者修改的行。该列最好是随着每次写入而更新，并且值是单调递增的。需要使用 timestamp.column.name 参数指定时间戳列。</li></ol><p>需要注意的是时间戳列在数据表中不能设置为 Nullable.</p><p>在 timestamp 模式下，每次都是根据 timestamp.column.name 参数指定的列，查询大于自上次拉取成功的 gmt_modified：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mydb.test_kafka</span><br><span class="line"><span class="keyword">WHERE</span> tms &gt; ? <span class="keyword">AND</span> tms &lt; ?</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tms <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><p>这种模式可以捕获行上 UPDATE 变更，缺点是可能造成数据的丢失。由于时间戳列不是唯一列字段，可能存在相同时间戳的两列或者多列，假设在导入第二条的过程中发生了崩溃，在恢复重新导入时，拥有相同时间戳的第二条以及后面几条数据都会丢失。这是因为第一条导入成功后，对应的时间戳会被记录已成功消费，恢复后会从大于该时间戳的记录开始同步。此外，也需要确保时间戳列是随着时间递增的，如果人为的修改时间戳列小于当前同步成功的最大时间戳，也会导致该变更不能同步。</p><ol start="3"><li>仅使用 incrementing 或 timestamp 模式都存在缺陷。将 timestamp 和 incrementing 一起使用，可以充分利用 incrementing 模式不丢失数据的优点以及 timestamp 模式捕获更新操作变更的优点。需要使用 <code>incrementing.column.name</code> 参数指定严格递增列、使用 <code>timestamp.column.name</code> 参数指定时间戳列。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mydb.test_kafka</span><br><span class="line"><span class="keyword">WHERE</span> tms &lt; ?</span><br><span class="line">  <span class="keyword">AND</span> ((tms = ? <span class="keyword">AND</span> <span class="keyword">id</span> &gt; ?) <span class="keyword">OR</span> tms &gt; ?)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> tms, <span class="keyword">id</span> <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><blockquote><p>由于 MySQL JDBC Source Connector 是基于 query-based 的数据获取方式，使用 SELECT 查询来检索数据，并没有复杂的机制来检测已删除的行，所以不支持 <code>DELETE</code> 操作。可以使用基于 log-based 的 [<a href="https://rmoff.net/2018/03/24/streaming-data-from-mysql-into-kafka-with-kafka-connect-and-debezium/" target="_blank" rel="noopener">Kafka Connect Debezium</a>]。</p></blockquote><p>后面的演示中会分别演示上述模式的效果。更多的配置参数可以参考 <a href="https://docs.confluent.io/cloud/current/connectors/cc-mysql-source.html" target="_blank" rel="noopener">MySQL Source Configs</a> 。</p><h4 id="Databend-Kafka-Connector"><a href="#Databend-Kafka-Connector" class="headerlink" title="Databend Kafka Connector"></a><a href="https://github.com/databendcloud/databend-kafka-connect" target="_blank" rel="noopener">Databend Kafka Connector</a></h4><ol><li>安装 OR 编译 Databend Kafka Connector</li></ol><p>可以从源码编译得到 jar 或者从 <a href="https://github.com/databendcloud/databend-kafka-connect/releases" target="_blank" rel="noopener">release</a> 直接下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/databendcloud/databend-kafka-connect.git &amp; cd databend-kafka-connect</span><br><span class="line">mvn -Passembly -Dmaven.test.skip package</span><br></pre></td></tr></table></figure><p>将 <code>databend-kafka-connect.jar</code> 拷贝至 <code>/path/kafka/libs</code> 目录下。</p><ol start="2"><li>安装 Databend JDBC Driver</li></ol><p>从 <a href="https://central.sonatype.com/artifact/com.databend/databend-jdbc/0.1.2/versions" target="_blank" rel="noopener">Maven Central</a> 下载最新的 databend jdbc 并拷贝至 <code>/path/kafka/libs</code> 目录下。</p><ol start="3"><li>配置 Databend Kafka Connector</li></ol><p>在  <code>/path/kafka/config</code> 下创建 <code>mysql.properties</code> 配置文件，并使用下面的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">name=databend</span><br><span class="line">connector.class=com.databend.kafka.connect.DatabendSinkConnector</span><br><span class="line"></span><br><span class="line">connection.url=jdbc:databend://localhost:8000</span><br><span class="line">connection.user=databend</span><br><span class="line">connection.password=databend</span><br><span class="line">connection.attempts=5</span><br><span class="line">connection.backoff.ms=10000</span><br><span class="line">connection.database=default</span><br><span class="line"></span><br><span class="line">table.name.format=default.$&#123;topic&#125;</span><br><span class="line">max.retries=10</span><br><span class="line">batch.size=1</span><br><span class="line">auto.create=true</span><br><span class="line">auto.evolve=true</span><br><span class="line">insert.mode=upsert</span><br><span class="line">pk.mode=record_value</span><br><span class="line">pk.fields=id</span><br><span class="line">topics=test_kafka</span><br><span class="line">errors.tolerance=all</span><br></pre></td></tr></table></figure><p><code>auto.create</code> 和 <code>auto.evolve</code> 设置成 <code>true</code> 后会自动建表并在源表结构发生变化时同步到目标表。关于更多配置参数的介绍可以参考 <a href="https://github.com/databendcloud/databend-kafka-connect/blob/main/docs/docs.md#configuration-properties" target="_blank" rel="noopener">databend kafka connect properties</a>。</p><h3 id="测试-Databend-Kafka-Connect"><a href="#测试-Databend-Kafka-Connect" class="headerlink" title="测试 Databend Kafka Connect"></a>测试 Databend Kafka Connect</h3><h4 id="准备各个组件"><a href="#准备各个组件" class="headerlink" title="准备各个组件"></a>准备各个组件</h4><ol><li>启动 MySQL</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  postgres:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">debezium/example-postgres:1.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_DB=postgres</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_USER=postgres</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_PASSWORD=postgres</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">debezium/example-mysql:1.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306:3306"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_USER=mysqluser</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_PASSWORD=mysqlpw</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启动 Databend</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  databend:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">datafuselabs/databend</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/Users/hanshanjie/databend/local-test/databend/databend-query.toml:/etc/databend/query.toml</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      QUERY_DEFAULT_USER:</span> <span class="string">databend</span></span><br><span class="line"><span class="attr">      QUERY_DEFAULT_PASSWORD:</span> <span class="string">databend</span></span><br><span class="line"><span class="attr">      MINIO_ENABLED:</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'8000:8000'</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'9000:9000'</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'3307:3307'</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'8124:8124'</span></span><br></pre></td></tr></table></figure><ol start="3"><li>以 standalone 模式启动 kafka connect，并加载 MySQL Source Connector 和 Databend Sink Connector:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/connect-standalone.sh config/connect-standalone.properties config/databend.properties config/mysql.properties</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[2023-09-06 17:39:23,128] WARN [databend|task-0] These configurations '[metrics.context.connect.kafka.cluster.id]' were supplied but are not used yet. (org.apache.kafka.clients.consumer.ConsumerConfig:385)</span><br><span class="line">[2023-09-06 17:39:23,128] INFO [databend|task-0] Kafka version: 3.4.0 (org.apache.kafka.common.utils.AppInfoParser:119)</span><br><span class="line">[2023-09-06 17:39:23,128] INFO [databend|task-0] Kafka commitId: 2e1947d240607d53 (org.apache.kafka.common.utils.AppInfoParser:120)</span><br><span class="line">[2023-09-06 17:39:23,128] INFO [databend|task-0] Kafka startTimeMs: 1693993163128 (org.apache.kafka.common.utils.AppInfoParser:121)</span><br><span class="line">[2023-09-06 17:39:23,148] INFO Created connector databend (org.apache.kafka.connect.cli.ConnectStandalone:113)</span><br><span class="line">[2023-09-06 17:39:23,148] INFO [databend|task-0] [Consumer clientId=connector-consumer-databend-0, groupId=connect-databend] Subscribed to topic(s): test_kafka (org.apache.kafka.clients.consumer.KafkaConsumer:969)</span><br><span class="line">[2023-09-06 17:39:23,150] INFO [databend|task-0] Starting Databend Sink task (com.databend.kafka.connect.sink.DatabendSinkConfig:33)</span><br><span class="line">[2023-09-06 17:39:23,150] INFO [databend|task-0] DatabendSinkConfig values:...</span><br></pre></td></tr></table></figure><p><img src="https://p.ipic.vip/3xgn0n.png" alt="start-databend-kafka"></p><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p>Insert 模式下我们需要使用如下的 MySQL Connector 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name=test-source-mysql-jdbc-autoincrement</span><br><span class="line">connector.class=io.confluent.connect.jdbc.JdbcSourceConnector</span><br><span class="line">tasks.max=1</span><br><span class="line">connection.url=jdbc:mysql://localhost:3306/mydb?useSSL=false</span><br><span class="line">connection.user=root</span><br><span class="line">connection.password=123456</span><br><span class="line">#mode=timestamp+incrementing</span><br><span class="line">mode=incrementing</span><br><span class="line">table.whitelist=mydb.test_kafka</span><br><span class="line">poll.interval.ms=1000</span><br><span class="line">table.poll.interval.ms=3000</span><br><span class="line">incrementing.column.name=id</span><br><span class="line">#timestamp.column.name=tms</span><br><span class="line">topics=test_kafka</span><br></pre></td></tr></table></figure><p>在 MySQL 中创建数据库 <code>mydb</code> 和表 <code>test_kafka</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mydb;</span><br><span class="line"><span class="keyword">USE</span> mydb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_kafka (<span class="keyword">id</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,description <span class="built_in">VARCHAR</span>(<span class="number">512</span>));</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_kafka AUTO_INCREMENT = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在插入数据之前，databend-kafka-connect 并不会收到 event 进行建表和数据写入：</p><p><img src="https://p.ipic.vip/1p8u14.png" alt="image-20230906164854016"></p><p>插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_kafka <span class="keyword">VALUES</span> (<span class="keyword">default</span>,<span class="string">"scooter"</span>,<span class="string">"Small 2-wheel scooter"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"car battery"</span>,<span class="string">"12V car battery"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"12-pack drill bits"</span>,<span class="string">"12-pack of drill bits with sizes ranging from #40 to #3"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"12oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"14oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"16oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"rocks"</span>,<span class="string">"box of assorted rocks"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"jacket"</span>,<span class="string">"water resistent black wind breaker"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"cloud"</span>,<span class="string">"test for databend"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"spare tire"</span>,<span class="string">"24 inch spare tire"</span>);</span><br></pre></td></tr></table></figure><p>源表端插入数据后，</p><p><img src="https://p.ipic.vip/h4kgyh.png" alt="image-20230906170712759"></p><p>Databend 目标端的表就新建出来了：</p><p><img src="https://p.ipic.vip/pwrxwb.png" alt="image-20230906170818765"></p><p>同时数据也会成功插入：</p><p><img src="https://p.ipic.vip/5oigkn.png" alt="image-20230906205603282"></p><h4 id="Support-DDL"><a href="#Support-DDL" class="headerlink" title="Support DDL"></a>Support DDL</h4><p>我们在配置文件中 <code>auto.evolve=true</code>，所以在源表结构发生变化的时候，会将 DDL 同步至目标表。这里我们正好需要将 MySQL Source Connector 的模式从 <code>incrementing</code> 改成 <code>timestamp+incrementing</code>，需要新增一个 <code>timestamp</code> 字段并打开 <code>timestamp.column.name=tms</code> 配置。我们在原表中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test_kafka <span class="keyword">add</span> <span class="keyword">column</span> tms <span class="keyword">timestamp</span>;</span><br></pre></td></tr></table></figure><p>并插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_kafka <span class="keyword">values</span>(<span class="number">20</span>,<span class="string">"new data"</span>,<span class="string">"from kafka"</span>,<span class="keyword">now</span>());</span><br></pre></td></tr></table></figure><p>到目标表中查看：</p><p><img src="https://p.ipic.vip/t1krmm.png" alt="image-20230906210534970"></p><p>发现 <code>tms</code> 字段已经同步至 Databend table，并且该条数据也已经插入成功：</p><p><img src="https://p.ipic.vip/vb0j08.png" alt="image-20230906210713675"></p><h4 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h4><p>修改 MySQL Connector 的配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name=test-source-mysql-jdbc-autoincrement</span><br><span class="line">connector.class=io.confluent.connect.jdbc.JdbcSourceConnector</span><br><span class="line">tasks.max=1</span><br><span class="line">connection.url=jdbc:mysql://localhost:3306/mydb?useSSL=false</span><br><span class="line">connection.user=root</span><br><span class="line">connection.password=123456</span><br><span class="line">mode=timestamp+incrementing</span><br><span class="line">#mode=incrementing</span><br><span class="line">table.whitelist=mydb.test_kafka</span><br><span class="line">poll.interval.ms=1000</span><br><span class="line">table.poll.interval.ms=3000</span><br><span class="line">incrementing.column.name=id</span><br><span class="line">timestamp.column.name=tms</span><br><span class="line">topics=test_kafka</span><br></pre></td></tr></table></figure><p>重启 kafka connect。</p><p>在源表中更新一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> test_kafka <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">"update from kafka test"</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>到目标表中可以看到更新的数据：</p><p><img src="https://p.ipic.vip/8if4ez.png" alt="image-20230906211213647"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的内容可以看到 <code>databend kafka connect</code> 具有以下特性：</p><ol><li>Table 和 Column 支持自动创建：<code>auto.create</code> 和 `auto-evolve 的配置支持下，可以自动创建 Table 和 Column，Table name是基于 Kafka topic name 创建的；</li><li>Kafka Shemas 支持：connector 支持 Avro、JSON Schema 和 Protobuf 输入数据格式。必须启用 Schema Registry 才能使用基于 Schema Registry 的格式；</li><li>多个写入模式：Connector 支持 <code>insert</code> 和 <code>upsert</code> 写入模式；</li><li>多任务支持：在 kafka connect 的能力下，connector 支持运行一个或多个任务。增加任务的数量可以提高系统性能；</li><li>高可用：分布式模式下可以自动平衡工作负载，并可以动态扩展（或缩减）以及提供容错能力。</li></ol><p>同时，Databend Kafka Connect 也能够使用原生 connect 支持的配置，更多配置参考 <a href="https://docs.confluent.io/platform/current/installation/configuration/connect/sink-connect-configs.html" target="_blank" rel="noopener">Kafka Connect Sink Configuration Properties for Confluent Platform</a>。</p><hr>]]></content>
    
    <summary type="html">
    
      使用 databend kafka connect 构建实时数据同步
    
    </summary>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/categories/Databend/"/>
    
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/tags/CDC/"/>
    
      <category term="Databend" scheme="https://cloudsjhan.github.io/tags/Databend/"/>
    
      <category term="kafka connect" scheme="https://cloudsjhan.github.io/tags/kafka-connect/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 为 Databend 开发轻量级 CDC</title>
    <link href="https://cloudsjhan.github.io/2023/07/18/%E4%BB%8E-0-%E5%88%B0-1-%E4%B8%BA-Databend-%E8%AE%BE%E8%AE%A1%E8%BD%BB%E9%87%8F%E7%BA%A7-CDC/"/>
    <id>https://cloudsjhan.github.io/2023/07/18/从-0-到-1-为-Databend-设计轻量级-CDC/</id>
    <published>2023-07-18T02:24:52.000Z</published>
    <updated>2023-09-08T06:33:18.916Z</updated>
    
    <content type="html"><![CDATA[<hr><p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="什么是-CDC"><a href="#什么是-CDC" class="headerlink" title="什么是 CDC"></a>什么是 CDC</h2><p>CDC（Change Data Capture）是一种数据同步技术，用于实时捕获和传递数据库中的数据更改。通过 CDC，我们可以将数据库中的变更事件捕获并转换成数据流，然后将其传递给其他系统或应用程序，以实现数据的实时同步和分发。 常见的 CDC 格式为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "op": "Update", // "Insert", "Delete",</span><br><span class="line">  "event_time": "2022-11-01 12:00:00",</span><br><span class="line">  "payload": &#123;</span><br><span class="line">    "id": 123,</span><br><span class="line">    "author": "Franz Kafka",</span><br><span class="line">    "title": "Metamorphosis",</span><br><span class="line">    "published_at": "1915-01-01"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种生产可用的 CDC 系统架构可以是下图：</p><p><img src="https://p.ipic.vip/0xvmti.png" alt=""></p><h2 id="现阶段主流-CDC-方案和架构"><a href="#现阶段主流-CDC-方案和架构" class="headerlink" title="现阶段主流 CDC 方案和架构"></a>现阶段主流 CDC 方案和架构</h2><p>在目前的技术发展中，有几种主流的CDC方案和架构：</p><p><strong>1. Flink CDC</strong></p><p><a href="https://ververica.github.io/flink-cdc-connectors/release-2.1/content/about.html" title="Flink CDC" target="_blank" rel="noopener">Flink CDC</a> 是基于 Apache Flink 的 CDC 方案。它可以实时捕获数据库的变更事件，并将其转换成流数据。Flink CDC 提供了非常多的连接器组件，可以在异构的数据源之间实现数据流动。</p><p><img src="https://p.ipic.vip/4fgvvc.png" alt="Flink_CDC"></p><p>Databend 也提供了 <a href="https://github.com/databendcloud/flink-connector-databend" target="_blank" rel="noopener">flink-databend-connector</a>，可以与 MySQL，PG 等 RDBMS 构建实时数据同步。</p><p><img src="https://p.ipic.vip/hauu8v.png" alt=""></p><p><strong>2. Kafka Connector</strong></p><p><a href="https://docs.confluent.io/platform/current/connect/index.html" title="Kafka Connector" target="_blank" rel="noopener">Kafka Connector</a> 是基于 Apache Kafka 的 CDC 方案。Kafka 作为分布式消息队列，可以用于数据传递和分发。Kafka Connector 允许将数据从数据库中捕获，并将其发布到 Kafka 主题中，供其他系统消费。</p><p><img src="https://p.ipic.vip/sdnd3u.jpg" alt="ingest-data-upstream-systems"></p><p><strong>3. Canal</strong></p><p><a href="https://github.com/alibaba/canal" title="Canal" target="_blank" rel="noopener">Canal</a> 是阿里巴巴开源的 CDC 解决方案。它可以捕获 MySQL 数据库的变更，并将其转换成消息格式输出，常用于数据同步和业务解耦。限制是只能基于 MySQL 数据库增量日志解析。</p><p><img src="https://p.ipic.vip/c8zkw9.png" alt=""></p><p><strong>Debezium Server</strong></p><p><a href="https://debezium.io/documentation/reference/1.6/overview.html" title="Debezium Server" target="_blank" rel="noopener">Debezium Server</a> 是一个基于 Debezium Engine 的 CDC 项目。Debezium Engine 是 Debezium 项目的核心，用于捕获数据库的变更事件。Debezium Server 构建在该引擎之上，提供了一种轻量级的 CDC 解决方案，用于实时捕获数据库更改，并将其转换为事件流，最终将数据写入目标数据库。</p><p><img src="https://p.ipic.vip/40yu3q.png" alt=""></p><h2 id="Debezium-Server-Databend"><a href="#Debezium-Server-Databend" class="headerlink" title="Debezium Server Databend"></a>Debezium Server Databend</h2><p><a href="https://github.com/databendcloud/debezium-server-databend" title="Debezium Server Databend" target="_blank" rel="noopener">Debezium Server Databend</a> 是一个基于 Debezium Engine 自研的轻量级 CDC 项目，用于实时捕获数据库更改并将其作为事件流传递最终将数据写入目标数据库 Databend。它提供了一种简单的方式来监视和捕获关系型数据库的变化，并支持将这些变化转换为可消费事件。使用 Debezium server databend 实现 CDC 无须依赖大型的 Data Infra 比如 Flink, Kafka, Spark 等，只需一个启动脚本即可开启实时数据同步。</p><p><img src="https://p.ipic.vip/8sevgd.png" alt=""></p><h3 id="源码分析-debezium-server-databend-实现"><a href="#源码分析-debezium-server-databend-实现" class="headerlink" title="源码分析 debezium-server-databend 实现"></a>源码分析 debezium-server-databend 实现</h3><p><a href="https://github.com/databendcloud/debezium-server-databend/" target="_blank" rel="noopener">Debezium Server Databend</a> 实现了轻量级CDC方案，通过 Debezium Engine 捕获数据库变更事件，将其转换成事件流，然后将事件流传递给 Databend 数据库，实现数据的实时同步。下面先从代码层面分析一下该组件的实现原理。</p><p>主要代码的结构是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DatabendChangeConsumer.java</span><br><span class="line">├── DatabendChangeEvent.java</span><br><span class="line">├── DatabendTypes.java</span><br><span class="line">├── DatabendUtil.java</span><br><span class="line">├── DebeziumMetrics.java</span><br><span class="line">├── batchsizewait</span><br><span class="line">│   ├── InterfaceBatchSizeWait.java</span><br><span class="line">│   ├── MaxBatchSizeWait.java</span><br><span class="line">│   └── NoBatchSizeWait.java</span><br><span class="line">└── tablewriter</span><br><span class="line">    ├── AppendTableWriter.java</span><br><span class="line">    ├── BaseTableWriter.java</span><br><span class="line">    ├── RelationalTable.java</span><br><span class="line">    ├── TableNotFoundException.java</span><br><span class="line">    ├── TableWriterFactory.java</span><br><span class="line">    └── UpsertTableWriter.java</span><br></pre></td></tr></table></figure><p>Debezium server 的入口逻辑在 <code>DatabendChangeConsumer</code> 中，继承 <code>BaseChangeConsumer</code> 并实现相应方法， 作用是加载配置，初始化 server, database以及处理 batch event：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of the consumer that delivers the messages to databend database tables.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hantmac</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Named</span>(<span class="string">"databend"</span>)</span><br><span class="line"><span class="meta">@Dependent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabendChangeConsumer</span> <span class="keyword">extends</span> <span class="title">BaseChangeConsumer</span> <span class="keyword">implements</span> <span class="title">DebeziumEngine</span>.<span class="title">ChangeConsumer</span>&lt;<span class="title">ChangeEvent</span>&lt;<span class="title">Object</span>, <span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line">  ...<span class="comment">//  @ConfigProperty(name = "debezium.sink.databend.xxx", defaultValue = "")</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBatch</span><span class="params">(List&lt;ChangeEvent&lt;Object, Object&gt;&gt; records, DebeziumEngine.RecordCommitter&lt;ChangeEvent&lt;Object, Object&gt;&gt; committer)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码是在 handleBatch 中，在这里接收变更事件并发送到 <code>tablewriter</code> 中进一步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBatch</span><span class="params">(List&lt;ChangeEvent&lt;Object, Object&gt;&gt; records, DebeziumEngine.RecordCommitter&lt;ChangeEvent&lt;Object, Object&gt;&gt; committer)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//group events by destination</span></span><br><span class="line">      Map&lt;String, List&lt;DatabendChangeEvent&gt;&gt; result =</span><br><span class="line">              records.stream()</span><br><span class="line">                      .map((ChangeEvent&lt;Object, Object&gt; e)</span><br><span class="line">                              -&gt; &#123;</span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              <span class="keyword">return</span> <span class="keyword">new</span> DatabendChangeEvent(e.destination(),</span><br><span class="line">                                      valDeserializer.deserialize(e.destination(), getBytes(e.value())),</span><br><span class="line">                                      e.key() == <span class="keyword">null</span> ? <span class="keyword">null</span> : valDeserializer.deserialize(e.destination(), getBytes(e.key())),</span><br><span class="line">                                      mapper.readTree(getBytes(e.value())).get(<span class="string">"schema"</span>),</span><br><span class="line">                                      e.key() == <span class="keyword">null</span> ? <span class="keyword">null</span> : mapper.readTree(getBytes(e.key())).get(<span class="string">"schema"</span>)</span><br><span class="line">                              );</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                              <span class="keyword">throw</span> <span class="keyword">new</span> DebeziumException(ex);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;)</span><br><span class="line">                      .collect(Collectors.groupingBy(DatabendChangeEvent::destination));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// consume list of events for each destination table</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;DatabendChangeEvent&gt;&gt; tableEvents : result.entrySet()) &#123;</span><br><span class="line">          RelationalTable tbl = <span class="keyword">this</span>.getDatabendTable(mapDestination(tableEvents.getKey()), tableEvents.getValue().get(<span class="number">0</span>).schema()); <span class="comment">// 获取 tablewriter 实例</span></span><br><span class="line">          tableWriter.addToTable(tbl, tableEvents.getValue()); <span class="comment">// 将事件推送至 tablewriter</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (ChangeEvent&lt;Object, Object&gt; record : records) &#123;</span><br><span class="line">          LOGGER.trace(<span class="string">"Processed event '&#123;&#125;'"</span>, record);</span><br><span class="line">          committer.markProcessed(record);</span><br><span class="line">      &#125;</span><br><span class="line">      committer.markBatchFinished();</span><br><span class="line">      <span class="keyword">this</span>.logConsumerProgress(records.size());</span><br><span class="line"></span><br><span class="line">      batchSizeWait.waitMs(records.size(), (<span class="keyword">int</span>) Duration.between(start, Instant.now()).toMillis());</span><br></pre></td></tr></table></figure><p><code>TableWriterFactory</code>中提供了 <code>Append</code> 和 <code>Upsert</code> 两种模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BaseTableWriter <span class="title">get</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (upsert) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UpsertTableWriter(connection, identifierQuoteCharacter.orElse(<span class="string">""</span>), upsertKeepDeletes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendTableWriter(connection, identifierQuoteCharacter.orElse(<span class="string">""</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种模式都实现了 <code>addTable</code> 方法。</p><h3 id="Append-mode"><a href="#Append-mode" class="headerlink" title="Append mode"></a>Append mode</h3><p>在 CDC 中，Append Mode 是一种数据写入模式。当数据库的一条记录发生变化时，CDC 会将该变化作为一条新的事件追加到事件流中。</p><h3 id="Upsert-mode"><a href="#Upsert-mode" class="headerlink" title="Upsert mode"></a>Upsert mode</h3><p>Upsert Mode 是另一种数据写入模式。当数据库的一条记录发生变化时，CDC 会将该变化作为一个更新操作，如果记录不存在，则作为插入操作，以实现数据的更新和插入。</p><p>Upsert mode 用到了 Databend 的 <a href="https://databend.rs/doc/sql-commands/dml/dml-replace" target="_blank" rel="noopener">Replace into</a> 语法，所以需要用户指定一个 conflict key，这里我们提供一个配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debezium.sink.databend.database.primaryKey=id</span><br></pre></td></tr></table></figure><p>如果没有提供该配置，会退化成追加模式。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>Delete操作是指数据库中的记录被删除，CDC 会将该操作作为一个事件写入事件流，以通知其他系统该记录已被删除。</p><p> Debezim Server 对 Delete 的处理比较复杂，在 DELETE 操作下会生成两条事件记录：</p><ol><li>一个包含 “op”: “d”，其他的行数据以及字段；</li><li>一个tombstones记录，它具有与被删除行相同的键，但值为null。</li></ol><p>这两条事件会同时发出，在 Debezium Server Databend 中我们选择对 Delete 数据实行软删除，这就要求我们在 target table 中拥有 <code>__deleted</code> 字段，当 Delete 事件过来的时候我们将该字段置为 TRUE 后插入到目标表。</p><p>这样设计的好处是，有些用户最开始想要保留这些数据，但可能未来会想到将其删除，这样就为用户提供了可选的方案，未来想要删除这些数据的时候，只需要 <code>delete from table where __deleted=true</code> 即可。</p><p>关于 Debezium 对删除事件的说明以及处理方式，详情可参考<a href="https://debezium.io/documentation/reference/stable/transformations/event-flattening.html" title="Debezium Event Flattening" target="_blank" rel="noopener">文档</a>。</p><h3 id="使用轻量级-CDC-debezium-server-databend-构建-MySQL-到-Databend-的-实时数据同步"><a href="#使用轻量级-CDC-debezium-server-databend-构建-MySQL-到-Databend-的-实时数据同步" class="headerlink" title="使用轻量级 CDC debezium-server-databend 构建 MySQL 到 Databend 的 实时数据同步"></a>使用轻量级 CDC debezium-server-databend 构建 MySQL 到 Databend 的 实时数据同步</h3><p>下面用一个实际案例展示如何基于 Debezium server databend 快速构建 MySQL 到 Databend 的实时数据同步。</p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>准备一台已经安装了 Docker ，docker-compose 以及 Java 11 环境  的 Linux 或者 MacOS 。</p><h4 id="准备教程所需要的组件"><a href="#准备教程所需要的组件" class="headerlink" title="准备教程所需要的组件"></a><strong>准备教程所需要的组件</strong></h4><p>接下来的教程将以 <code>docker-compose</code> 的方式准备所需要的组件。</p><h5 id="debezium-MySQL"><a href="#debezium-MySQL" class="headerlink" title="debezium-MySQL"></a>debezium-MySQL</h5><p>docker-compose.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  postgres:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">debezium/example-postgres:1.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_DB=postgres</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_USER=postgres</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">POSTGRES_PASSWORD=postgres</span></span><br><span class="line"><span class="attr">  mysql:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">debezium/example-mysql:1.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3306:3306"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_USER=mysqluser</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MYSQL_PASSWORD=mysqlpw</span></span><br></pre></td></tr></table></figure><h5 id="Debezium-Server-Databend-1"><a href="#Debezium-Server-Databend-1" class="headerlink" title="Debezium Server Databend"></a>Debezium Server Databend</h5><ul><li>Clone 项目: <code>git clone `</code><a href="https://github.com/databendcloud/debezium-server-databend.git`" target="_blank" rel="noopener">https://github.com/databendcloud/debezium-server-databend.git`</a></li><li>从项目根目录开始:<ul><li>构建和打包 debezium server: <code>mvn -Passembly -Dmaven.test.skip package</code></li><li>构建完成后，解压服务器分发包: <code>unzip debezium-server-databend-dist/target/debezium-server-databend-dist*.zip -d databendDist</code></li><li>进入解压后的文件夹: <code>cd databendDist</code></li><li>创建 <code>application.properties</code> 文件并修改: <code>nano conf/application.properties</code>，将下面的 application.properties 拷贝进去，根据用户实际情况修改相应的配置。</li><li>使用提供的脚本运行服务: <code>bash run.sh</code></li><li>Debezium Server with Databend 将会启动</li></ul></li></ul><p>同时我们也提供了相应的 Docker image，可以在容器中一键启动：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2.1'</span></span><br><span class="line">services:</span><br><span class="line">  debezium:</span><br><span class="line">    image: ghcr.io/databendcloud/debezium-server-databend:pr-<span class="number">2</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8080:8080"</span></span><br><span class="line">      - <span class="string">"8083:8083"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - $PWD/conf:/app/conf</span><br><span class="line">      - $PWD/data:/app/data</span><br></pre></td></tr></table></figure><p>NOTE: 在容器中启动注意所连接数据库的网络。</p><h5 id="Debezium-Server-Databend-Application-Properties"><a href="#Debezium-Server-Databend-Application-Properties" class="headerlink" title="Debezium Server Databend Application Properties"></a>Debezium Server Databend Application Properties</h5><p>本文章使用下面提供的配置，更多的参数说明以及配置可以参考<a href="https://github.com/databendcloud/debezium-server-databend/blob/main/docs/docs.md" title="debezium-server-databend 配置文档" target="_blank" rel="noopener">文档</a>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">debezium.sink.type=databend</span><br><span class="line">debezium.sink.databend.upsert=true</span><br><span class="line">debezium.sink.databend.upsert-keep-deletes=false</span><br><span class="line">debezium.sink.databend.database.databaseName=debezium</span><br><span class="line">debezium.sink.databend.database.url=jdbc:databend://tnf34b0rm<span class="comment">--xxxxxx.default.databend.cn:443</span></span><br><span class="line">debezium.sink.databend.database.username=cloudapp</span><br><span class="line">debezium.sink.databend.database.password=password</span><br><span class="line">debezium.sink.databend.database.primaryKey=id</span><br><span class="line">debezium.sink.databend.database.tableName=products</span><br><span class="line">debezium.sink.databend.database.param.ssl=true</span><br><span class="line"></span><br><span class="line"># enable event schemas</span><br><span class="line">debezium.format.value.schemas.enable=true</span><br><span class="line">debezium.format.key.schemas.enable=true</span><br><span class="line">debezium.format.value=json</span><br><span class="line">debezium.format.key=json</span><br><span class="line"></span><br><span class="line"># mysql source</span><br><span class="line">debezium.source.connector.class=io.debezium.connector.mysql.MySqlConnector</span><br><span class="line">debezium.source.offset.storage.file.filename=data/offsets.dat</span><br><span class="line">debezium.source.offset.flush.interval.ms=60000</span><br><span class="line"></span><br><span class="line">debezium.source.database.hostname=127.0.0.1</span><br><span class="line">debezium.source.database.port=3306</span><br><span class="line">debezium.source.database.user=root</span><br><span class="line">debezium.source.database.password=123456</span><br><span class="line">debezium.source.database.dbname=mydb</span><br><span class="line">debezium.source.database.server.name=from_mysql</span><br><span class="line">debezium.source.include.schema.changes=false</span><br><span class="line">debezium.source.table.include.list=mydb.products</span><br><span class="line"># debezium.source.database.ssl.mode=required</span><br><span class="line"># Run without Kafka, use local file to store checkpoints</span><br><span class="line">debezium.source.database.history=io.debezium.relational.history.FileDatabaseHistory</span><br><span class="line">debezium.source.database.history.file.filename=data/status.dat</span><br><span class="line"># do event flattening. unwrap message!</span><br><span class="line">debezium.transforms=unwrap</span><br><span class="line">debezium.transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState</span><br><span class="line">debezium.transforms.unwrap.delete.handling.mode=rewrite</span><br><span class="line">debezium.transforms.unwrap.drop.tombstones=true</span><br><span class="line"></span><br><span class="line"># ############ SET LOG LEVELS ############</span><br><span class="line">quarkus.log.level=INFO</span><br><span class="line"># Ignore messages below warning level from Jetty, because it's a bit verbose</span><br><span class="line">quarkus.log.category."org.eclipse.jetty".level=WARN</span><br></pre></td></tr></table></figure><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a><strong>准备数据</strong></h4><h5 id="在-MySQL-数据库中准备数据"><a href="#在-MySQL-数据库中准备数据" class="headerlink" title="在 MySQL 数据库中准备数据"></a><strong>在</strong> <strong>MySQL</strong> <strong>数据库中准备数据</strong></h5><p>进入 MySQL 容器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker-compose</span> <span class="string">exec</span> <span class="string">mysql</span> <span class="string">mysql</span> <span class="bullet">-uroot</span> <span class="bullet">-p123456</span></span><br></pre></td></tr></table></figure><p>创建数据库 mydb 和表 <code>products</code>，并插入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mydb;</span><br><span class="line"><span class="keyword">USE</span> mydb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (<span class="keyword">id</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,description <span class="built_in">VARCHAR</span>(<span class="number">512</span>));</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products AUTO_INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span> (<span class="keyword">default</span>,<span class="string">"scooter"</span>,<span class="string">"Small 2-wheel scooter"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"car battery"</span>,<span class="string">"12V car battery"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"12-pack drill bits"</span>,<span class="string">"12-pack of drill bits with sizes ranging from #40 to #3"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"12oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"14oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"16oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"rocks"</span>,<span class="string">"box of assorted rocks"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"jacket"</span>,<span class="string">"water resistent black wind breaker"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"cloud"</span>,<span class="string">"test for databend"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"spare tire"</span>,<span class="string">"24 inch spare tire"</span>);</span><br></pre></td></tr></table></figure><h5 id="在-Databend-中创建-Database"><a href="#在-Databend-中创建-Database" class="headerlink" title="在 Databend 中创建 Database"></a>在 Databend 中创建 Database</h5><p><img src="https://p.ipic.vip/tfc5eg.png" alt="img"></p><p>NOTE: 用户可以不必先在 Databend 中创建表，系统检测到后会自动为用户建表。</p><h4 id="启动-Debezium-Server-Databend"><a href="#启动-Debezium-Server-Databend" class="headerlink" title="启动 Debezium Server Databend"></a>启动 Debezium Server Databend</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bash</span> <span class="string">run.sh</span></span><br></pre></td></tr></table></figure><p>首次启动会进入 init snapshot 模式，通过配置的 Batch Size 全量将 MySQL 中的数据同步到 Databend，所以在 Databend 中可以看到 MySQL 中的数据已经同步过来了：</p><p><img src="https://p.ipic.vip/plcu47.png" alt="img"></p><h4 id="同步-Insert-数据"><a href="#同步-Insert-数据" class="headerlink" title="同步 Insert 数据"></a>同步 Insert 数据</h4><p>我们继续往 MySQL 中插入 5 条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products <span class="keyword">VALUES</span> (<span class="keyword">default</span>,<span class="string">"scooter"</span>,<span class="string">"Small 2-wheel scooter"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"car battery"</span>,<span class="string">"12V car battery"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"12-pack drill bits"</span>,<span class="string">"12-pack of drill bits with sizes ranging from #40 to #3"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"12oz carpenter's hammer"</span>),</span><br><span class="line">(<span class="keyword">default</span>,<span class="string">"hammer"</span>,<span class="string">"14oz carpenter's hammer"</span>);</span><br></pre></td></tr></table></figure><p>Debezium server databend 日志：</p><p><img src="https://p.ipic.vip/sr7ydp.png" alt=""></p><p>同时在 Databend 中可以查到 5 条数据已经同步过来了：</p><p><img src="https://p.ipic.vip/e7k2bl.png" alt="img"></p><h4 id="同步-Update-数据"><a href="#同步-Update-数据" class="headerlink" title="同步 Update 数据"></a>同步 Update 数据</h4><p>配置文件中 <code>debezium.sink.databend.upsert=true</code> ，所以我们也可以处理 Update/Delete 的事件。</p><p>在 MySQL 中更新 id=10 的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> products <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">"from debezium"</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在 Databend 中可以查到 id 为 10 的数据已经被更新：</p><p><img src="https://p.ipic.vip/sbf8k0.png" alt="img"></p><h4 id="同步-Delete-数据"><a href="#同步-Delete-数据" class="headerlink" title="同步 Delete 数据"></a>同步 Delete 数据</h4><p>在配置文件中，有以下的配置，既可开启处理 Delete 事件的能力：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debezium.sink.databend.upsert-keep-deletes=false</span><br><span class="line">debezium.transforms=unwrap</span><br><span class="line">debezium.transforms.unwrap.type=io.debezium.transforms.ExtractNewRecordState</span><br><span class="line">debezium.transforms.unwrap.delete.handling.mode=rewrite</span><br><span class="line">debezium.transforms.unwrap.drop.tombstones=true</span><br></pre></td></tr></table></figure><p>在 MySQL 中删除 id=12 的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> products <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>在 Databend 中可以观察到 id=12 的值的 <code>__deleted</code> 字段已经被置为 <code>true</code>。</p><h4 id="环境清理"><a href="#环境清理" class="headerlink" title="环境清理"></a><strong>环境清理</strong></h4><p>操作结束后，在 <code>docker-compose.yml</code> 文件所在的目录下执行如下命令停止所有容器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>文章介绍了 databend 的轻量级 CDC 实现原理，演示了基于轻量级 CDC debezium server databend 构建 MySQL 到 Databend 的 实时数据同步的全部过程，这种方式不需要依赖 Flink, Kafka 等大型组件，启动和管理非常方便。</p>]]></content>
    
    <summary type="html">
    
      从 0 到 1 为 Databend 实现轻量级 CDC
    
    </summary>
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/categories/CDC/"/>
    
    
      <category term="CDC" scheme="https://cloudsjhan.github.io/tags/CDC/"/>
    
      <category term="Database" scheme="https://cloudsjhan.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>为 Databend Rust Driver 实现 Python Binding</title>
    <link href="https://cloudsjhan.github.io/2023/05/27/%E4%B8%BA-Databend-Rust-Driver-%E5%AE%9E%E7%8E%B0-Python-Binding/"/>
    <id>https://cloudsjhan.github.io/2023/05/27/为-Databend-Rust-Driver-实现-Python-Binding/</id>
    <published>2023-05-27T05:26:47.000Z</published>
    <updated>2023-05-27T05:41:03.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="HOW-PyO3-Maturin"><a href="#HOW-PyO3-Maturin" class="headerlink" title="HOW? PyO3 + Maturin"></a>HOW? PyO3 + Maturin</h3><p>Rust 和 Python 都拥有丰富的包和库。在 Python 中，很多包的底层是使用 C/C++ 编写的，而 Rust 天生与 C 兼容。因此，我们可以使用 Rust 为 Python 编写软件包，实现 Python 调用 Rust 的功能，从而获得更好的性能和速度。</p><p>为了实现这一目标，<a href="https://github.com/PyO3/pyo3" title="PyO3" target="_blank" rel="noopener">PyO3</a> 应运而生。PyO3 不仅提供了 Rust 与 Python 的绑定功能，还提供了一个名为 <a href="https://github.com/PyO3/maturin" title="maturin" target="_blank" rel="noopener">maturin</a> 的开箱即用的脚手架工具。通过 maturin，我们可以方便地创建基于 Rust 开发的 Python 扩展模块。这样一来，我们可以重新组织代码，使用 Rust 编写性能更好的部分，而其余部分仍然可以使用原始的 Python 代码。</p><p><img src="https://p.ipic.vip/xcbu06.jpg" alt="rust-rewrite"></p><p>Databend 目前有针对 Rust、Go、Python、Java 的多套 Driver SDK，维护成本颇高，上游一旦出现更新 SDK 便会手忙脚乱。 Rust 能提供对其他语言的 Binding 实现一套代码到处使用，而且又能获得更好地性能和速度，何乐而不为呢？</p><p>本篇文章我们关注如何在 python 中调用 Rust 开发的模块，以此来为 Databend Rust Driver 实现 Python Binding。</p><h3 id="简单的-Demo"><a href="#简单的-Demo" class="headerlink" title="简单的 Demo"></a>简单的 Demo</h3><p>这里我们以官网提供的最简单的方式来做个演示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir string_sum</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> string_sum</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 venv 的这一步不能省略，否则后续运行的时候会报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python -m venv .env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .env/bin/activate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install maturin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接使用 maturin 初始化项目即可，选择 pyo3，或者直接执行 maturin init --bindings pyo3</span></span><br><span class="line">❯ maturin init</span><br><span class="line">✔ 🤷 Which kind of bindings to use?</span><br><span class="line">  📖 Documentation: https://maturin.rs/bindings.html · pyo3</span><br><span class="line">  ✨ Done! Initialized project /Users/hanshanjie/rustProj/string_sum</span><br></pre></td></tr></table></figure><p><img src="https://p.ipic.vip/dv1sc3.png" alt="image-20230527100715138"></p><p>这个时候，我们可以得到一个简单的 Rust 项目，并且包含了调用的示例，打开 src/lib.rs：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> pyo3::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Formats the sum of two numbers as string.</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum_as_string</span></span>(a: <span class="built_in">usize</span>, b: <span class="built_in">usize</span>) -&gt; PyResult&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>((a + b).to_string())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A Python module implemented in Rust.</span></span><br><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string_sum</span></span>(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>pyfunction</code> 和 <code>pymodule</code> 两个 Rust 的宏，#[pymodule] 过程宏属性负责将模块的初始化函数导出到Python。它可以接受模块的名称作为参数，该名称必须是.so或.pyd文件的名称；默认值为Rust函数的名称。#[pyfunction] 注释一个函数，然后使用 wrap_pyfunction 宏将其添加到刚刚定义的模块中。</p><p>我们无需修改任何代码，可以直接执行下面的命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> maturin develop 会自动打包出一个 wheel 包，并且安装到当前的 venv 中 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> maturin develop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import string_sum</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; string_sum.sum_as_string(5, 20)</span></span><br><span class="line">'25'</span><br></pre></td></tr></table></figure><h3 id="构建-Databend-Driver-的-Python-Binding"><a href="#构建-Databend-Driver-的-Python-Binding" class="headerlink" title="构建 Databend Driver 的 Python Binding"></a>构建 Databend Driver 的 Python Binding</h3><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>在 <a href="https://github.com/datafuselabs/bendsql" target="_blank" rel="noopener">bendsql</a> 根目录下创建 <code>bindings/python</code>的 rust 项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bendsql </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir bindings &amp; <span class="built_in">cd</span> bindings</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir python &amp; <span class="built_in">cd</span> python</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python -m venv .env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .env/bin/activate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install maturin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接使用 maturin 初始化项目即可，选择 pyo3</span></span><br><span class="line">❯ maturin init</span><br></pre></td></tr></table></figure><p>为了使用PyO3，我们需要将其作为依赖项添加到我们的Cargo.toml文件中，以及其他依赖项。我们的Cargo.toml文件应该如下所示：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"databend-python"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.0.1"</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2021"</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">"Apache-2.0"</span></span><br><span class="line"><span class="attr">publish</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">"cdylib"</span>]</span><br><span class="line"><span class="attr">doc</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">chrono</span> = &#123; version = <span class="string">"0.4.24"</span>, default-features = <span class="literal">false</span>, features = [<span class="string">"std"</span>] &#125;</span><br><span class="line"><span class="attr">futures</span> = <span class="string">"0.3.28"</span></span><br><span class="line"><span class="attr">databend-driver</span> = &#123; path = <span class="string">"../../driver"</span>, version = <span class="string">"0.2.20"</span>, features = [<span class="string">"rustls"</span>, <span class="string">"flight-sql"</span>] &#125;</span><br><span class="line"><span class="attr">databend-client</span> = &#123; version = <span class="string">"0.1.15"</span>, path = <span class="string">"../../core"</span> &#125;</span><br><span class="line"><span class="attr">pyo3</span> = &#123; version = <span class="string">"0.18"</span>, features = [<span class="string">"abi3-py37"</span>] &#125;</span><br><span class="line"><span class="attr">pyo3-asyncio</span> = &#123; version = <span class="string">"0.18"</span>, features = [<span class="string">"tokio-runtime"</span>] &#125;</span><br><span class="line"><span class="attr">tokio</span> = <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>PyO3 添加为依赖项，并使用适当的属性注解 Rust 函数（我们将在后面介绍），就可以使用 PyO3 库创建一个可以被导入到 Python 脚本中的 Python 扩展模块。</p><h4 id="将-Rust-Struct-转换成-Python-模块"><a href="#将-Rust-Struct-转换成-Python-模块" class="headerlink" title="将 Rust Struct 转换成 Python 模块"></a>将 Rust Struct 转换成 Python 模块</h4><p><code>databend-client</code> 中提供了两种连接到 databend 的方式，flightSQL 和 http， <code>databend-driver</code> package 实现了一个 <code>Trait</code>来统一入口并自动解析协议：</p><blockquote><p>bendsql/driver/src/conn.rs</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[async_trait]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Connection</span></span>: DynClone + <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">info</span></span>(&amp;<span class="keyword">self</span>) -&gt; ConnectionInfo;</span><br><span class="line"></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">version</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> row = <span class="keyword">self</span>.query_row(<span class="string">"SELECT version()"</span>).await?;</span><br><span class="line">        <span class="keyword">let</span> version = <span class="keyword">match</span> row &#123;</span><br><span class="line">            <span class="literal">Some</span>(row) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> (version,): (<span class="built_in">String</span>,) = row.try_into()?;</span><br><span class="line">                version</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="string">""</span>.to_string(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="literal">Ok</span>(version)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>(&amp;<span class="keyword">self</span>, sql: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i64</span>&gt;;</span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">query_row</span></span>(&amp;<span class="keyword">self</span>, sql: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;Row&gt;&gt;;</span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">query_iter</span></span>(&amp;<span class="keyword">self</span>, sql: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;RowIterator&gt;;</span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">query_iter_ext</span></span>(&amp;<span class="keyword">self</span>, sql: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;(Schema, RowProgressIterator)&gt;;</span><br><span class="line"></span><br><span class="line">    async <span class="function"><span class="keyword">fn</span> <span class="title">stream_load</span></span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        sql: &amp;<span class="built_in">str</span>,</span><br><span class="line">        data: Reader,</span><br><span class="line">        size: <span class="built_in">u64</span>,</span><br><span class="line">        file_format_options: <span class="built_in">Option</span>&lt;BTreeMap&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;&gt;,</span><br><span class="line">        copy_options: <span class="built_in">Option</span>&lt;BTreeMap&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;&gt;,</span><br><span class="line">    ) -&gt; <span class="built_in">Result</span>&lt;QueryProgress&gt;;</span><br><span class="line">&#125;</span><br><span class="line">dyn_clone::clone_trait_object!(Connection);</span><br></pre></td></tr></table></figure><p>所以我们只需要将该 Trait 转换成 Python class ，就能在 python 中调用这些方法。Pyo3 官网中提供了转换 Trait 的方式，<a href="https://pyo3.rs/v0.12.3/trait_bounds，但是这种方式过于复杂，需要写太多的胶水代码，而且对用户也不友好，不能做到开箱即用。左思右想，为何不将" target="_blank" rel="noopener">https://pyo3.rs/v0.12.3/trait_bounds，但是这种方式过于复杂，需要写太多的胶水代码，而且对用户也不友好，不能做到开箱即用。左思右想，为何不将</a> Trait 封装一个 Struct 然后将 Struct 直接将转换成 python module ？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Connector</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> connector: FusedConnector,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">FusedConnector</span></span> = Arc&lt;dyn Connection&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For bindings</span></span><br><span class="line"><span class="keyword">impl</span> Connector &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_connector</span></span>(dsn: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">Box</span>&lt;<span class="keyword">Self</span>&gt;, Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> conn = new_connection(dsn).unwrap();</span><br><span class="line">        <span class="keyword">let</span> r = <span class="keyword">Self</span> &#123;</span><br><span class="line">            connector: FusedConnector::from(conn),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="literal">Ok</span>(<span class="built_in">Box</span>::new(r))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里写了一个 <code>Connector</code> 的 struct，里面封装了 Connection Trait，为 <code>Connector</code> 实现了 <code>new_connector</code> 方法，返回的正是一个指向 Connector 的指针，更多代码可以看<a href="https://github.com/datafuselabs/bendsql/blob/main/bindings/python/src/lib.rs#L50" title="bindings/python/src/lib.rs" target="_blank" rel="noopener">这里</a> 。</p><p>在 asyncio.rs 中我们就可以定义一个 Struct <code>AsyncDatabendDriver</code> 暴露为 python class，并定义 python module 为 <code>databend-driver</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// `AsyncDatabendDriver` is the entry for all public async API</span></span><br><span class="line"><span class="meta">#[pyclass(module = <span class="meta-string">"databend_driver"</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AsyncDatabendDriver</span></span>(Connector);</span><br></pre></td></tr></table></figure><p>接下来就要为 <code>AsyncDatabendDriver</code> 实现相应的方法，而底层调用的就是 rust 中实现的 Trait 中的方法（这里以 exec 为例）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pymethods]</span></span><br><span class="line"><span class="keyword">impl</span> AsyncDatabendDriver &#123;</span><br><span class="line">    <span class="meta">#[new]</span></span><br><span class="line">    <span class="meta">#[pyo3(signature = (dsn))]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(dsn: &amp;<span class="built_in">str</span>) -&gt; PyResult&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="literal">Ok</span>(AsyncDatabendDriver(build_connector(dsn)?))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// exec</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">exec</span></span>&lt;<span class="symbol">'p</span>&gt;(&amp;<span class="symbol">'p</span> <span class="keyword">self</span>, py: Python&lt;<span class="symbol">'p</span>&gt;, sql: <span class="built_in">String</span>) -&gt; PyResult&lt;&amp;<span class="symbol">'p</span> PyAny&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> this = <span class="keyword">self</span>.<span class="number">0</span>.clone();</span><br><span class="line">        future_into_py(py, async <span class="keyword">move</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 connection 中的 exec 方法</span></span><br><span class="line">            <span class="keyword">let</span> res = this.connector.exec(&amp;sql).await.unwrap();</span><br><span class="line">            <span class="literal">Ok</span>(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后在 lib.rs 中将 <code>AsyncDatabendDriver</code> 添加为 python class:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">_databend_driver</span></span>(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.add_class::&lt;AsyncDatabendDriver&gt;()?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-python-扩展模块信息"><a href="#定义-python-扩展模块信息" class="headerlink" title="定义 python 扩展模块信息"></a>定义 python 扩展模块信息</h4><p>创建 <a href="https://github.com/datafuselabs/bendsql/blob/main/bindings/python/pyproject.toml" title="pyproject.toml" target="_blank" rel="noopener">pyproject.toml</a> 和 <a href="https://github.com/datafuselabs/bendsql/tree/main/bindings/python/python/databend_driver" title="databend_driver" target="_blank" rel="noopener">python/databend_driver</a> 并定义 python module 相关信息。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这里我们使用 <code>behave</code> 进行测试，同时也可以看到能够以 <code>import databend_driver</code> 的形式在 python 项目中使用：</p><figure class="highlight feature"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Feature</span>: Databend-Driver Binding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Scenario</span>: Databend-Driver Async Operations</span><br><span class="line">        <span class="keyword">Given</span> A new Databend-Driver Async Connector</span><br><span class="line">        <span class="keyword">When</span> Async exec <span class="string">"CREATE TABLE if not exists test_data (x Int32,y VARCHAR)"</span></span><br><span class="line">        <span class="keyword">When</span> Async exec <span class="string">"INSERT INTO test_data(x,y) VALUES(1,'xx')"</span></span><br><span class="line">        <span class="keyword">Then</span> The select <span class="string">"SELECT * FROM test_data"</span> should run</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> behave <span class="keyword">import</span> given, when, then</span><br><span class="line"><span class="keyword">from</span> behave.api.async_step <span class="keyword">import</span> async_run_until_complete</span><br><span class="line"><span class="keyword">import</span> databend_driver</span><br><span class="line"></span><br><span class="line"><span class="meta">@given("A new Databend-Driver Async Connector")</span></span><br><span class="line"><span class="meta">@async_run_until_complete</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">step_impl</span><span class="params">(context)</span>:</span></span><br><span class="line">    dsn = os.getenv(<span class="string">"TEST_DATABEND_DSN"</span>, <span class="string">"databend+http://root:root@localhost:8000/?sslmode=disable"</span>)</span><br><span class="line">    context.ad = databend_driver.AsyncDatabendDriver(dsn)</span><br><span class="line"></span><br><span class="line"><span class="meta">@when('Async exec "&#123;sql&#125;"')</span></span><br><span class="line"><span class="meta">@async_run_until_complete</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">step_impl</span><span class="params">(context, sql)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> context.ad.exec(sql)</span><br><span class="line"></span><br><span class="line"><span class="meta">@then('The select "&#123;select_sql&#125;" should run')</span></span><br><span class="line"><span class="meta">@async_run_until_complete</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">step_impl</span><span class="params">(context, select_sql)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> context.ad.exec(select_sql)</span><br></pre></td></tr></table></figure><p>运行 <code>maturin develop</code> 会自动打包出一个 wheel 包，并且安装到当前的 venv 中 ，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    ....</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 8.71s</span><br><span class="line">📦 Built wheel for abi3 Python ≥ 3.7 to /var/folders/x5/4hndsx0x7cb5_45qgpfqx4th0000gn/T/.tmpyzRsUc/databend_driver-0.0.1-cp37-abi3-macosx_11_0_arm64.whl</span><br><span class="line">🛠 Installed databend-driver-0.0.1</span><br></pre></td></tr></table></figure><p>执行 <code>behave tests</code> 运行测试集:</p><p><img src="https://p.ipic.vip/9fdcwj.png" alt="image-20230527125008830"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>基于 Pyo3，我们可以比较方便地专注于 Rust 实现逻辑本身，无需关注太多 FFI （Foreign Function Interface）和转换细节就可以将 Rust 低成本地转换成 Python 模块，后期也只需要维护一套代码，极大地降低了维护成本。本文章抛砖引玉，只是将很少部分代码做了转换，后面会陆续将 rust driver 全部提供 Python binding 最终替换掉现在的 <a href="https://github.com/databendcloud/databend-py" title="databend-py" target="_blank" rel="noopener">databend-py</a>。</p><pre><code>HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​            </p><pre><code>​</code></pre>]]></content>
    
    <summary type="html">
    
      为 Databend Rust Driver 实现 Python Binding
    
    </summary>
    
      <category term="rust" scheme="https://cloudsjhan.github.io/categories/rust/"/>
    
    
      <category term="databend" scheme="https://cloudsjhan.github.io/tags/databend/"/>
    
      <category term="rust" scheme="https://cloudsjhan.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>2023 12 Open Source weekly report</title>
    <link href="https://cloudsjhan.github.io/2023/03/17/2023-12-Open-Source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2023/03/17/2023-12-Open-Source-weekly-report/</id>
    <published>2023-03-17T11:22:03.000Z</published>
    <updated>2023-03-18T09:38:50.003Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>不出意外这是 2023 年第一份周报，一直拖着不写倒不是因为没什么可写的，反而是因为最近这几个月接收的信息量太大，一时间没有办法吃透、理解，自然就无法做到有效输出。除了常规的工作以外，这段时间开始接触 ELT 相关的东西，比如 Airbyte、dbt，CDC 领域中的 TapData、Flink CDC ，完善 databend 在 BI 类工具的生态….比如 superset, redash, metadata 等，信息量可以说是爆炸式增长，很多东西也是一知半解的。</p><p>这周之所以想起来写是因为写了一点比较有意思的新东西，所以想记录并分享一下。</p><h2 id="Clojure-amp-Metabase"><a href="#Clojure-amp-Metabase" class="headerlink" title="Clojure &amp; Metabase"></a><a href="http://clojure.org/" target="_blank" rel="noopener">Clojure</a> &amp; Metabase</h2><p>是的你没看错，这周一直在写 Clojure。起因是要在 <a href="https://www.metabase.com/" target="_blank" rel="noopener">Metabase</a> 中支持 databend，metabase 是一款易用、开源、技术成熟、不断并快速迭代的 BI 工具，打开 metabase 的 Github <a href="https://github.com/metabase/metabase" target="_blank" rel="noopener">首页</a> 可以看到其主要是编程语言正是 Clojure。</p><p>很多年轻的朋友可能都没听说过这门编程语言。Clojure 是一种运行在<a href="https://baike.baidu.com/item/Java平台/3793459" target="_blank" rel="noopener">Java平台</a>上的类 Lisp 语言，看到 Lisp 是不是一种上古的气息扑面而来。Clojure 比较成功地把函数式编程引入了 JVM，在JVM平台运行的时候，会被编译为JVM的字节码进行运算。其最大的优势就是在保持了函数式语言的主要特性的前提下，例如immutable state，Full Lisp-style macro support，persistent data structures等等，还能够非常方便的调用Java类库的API，和Java类库进行良好的整合。</p><p>Metabase 提供了一种插件系统，方便开发者以开发插件的方式，将数据源添加到 metabase 中，因为要调用 metabase driver 的 API，所以插件的编写也需要使用 Clojure 来完成。</p><h2 id="上手-Clojure"><a href="#上手-Clojure" class="headerlink" title="上手 Clojure"></a>上手 Clojure</h2><p><img src="https://p.ipic.vip/fdru4v.png" alt="hello clojure"></p><p>Clojure 是完全的函数式编程，基本语法比较简单，大概看了半天的教程配置好开发环境就能写 hello world 了。A few days later….，支持 databend 的 metabase 插件就完成了，项目及相关代码在 <a href="https://github.com/databendcloud/metabase-databend-driver" target="_blank" rel="noopener">metabase databend driver</a> 。</p><h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>Metabase 的插件使用起来非常方便，只需要两个 jar 就能从 databend 读取并分析数据出报表了。</p><h3 id="Download-metabase-jar"><a href="#Download-metabase-jar" class="headerlink" title="Download metabase.jar"></a>Download metabase.jar</h3><p>Metabase是一个Java应用程序，可以通过<a href="https://www.metabase.com/start/oss/jar" target="_blank" rel="noopener">下载JAR文件</a> 并执行 <strong><code>java -jar metabase.jar</code></strong>来运行。Metabase 使用 JDBC  Driver 连接到 Databend。</p><h3 id="Download-metabase-Databend-Driver"><a href="#Download-metabase-Databend-Driver" class="headerlink" title="Download metabase  Databend Driver"></a>Download metabase  Databend Driver</h3><ol><li><p>在下载 <code>metabase.jar</code> 的目录下创建目录 <strong><code>plugins</code></strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls</span><br><span class="line">metabase.jar</span><br><span class="line"><span class="meta">$</span> mkdir plugins</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>下载最新的 databend metabase driver: <a href="https://github.com/databendcloud/metabase-databend-driver/releases/latest" target="_blank" rel="noopener">https://github.com/databendcloud/metabase-databend-driver/releases/latest</a> 到 plugins 目录下</p></li><li><p>启动 metabase</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar metabase.jar</span><br></pre></td></tr></table></figure><p>启动过程中看到下面的日志就表示 databend 驱动被正常加载:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-07 23:27:32 INFO plugins.lazy-loaded-driver :: Registering lazy loading driver :databend...</span><br><span class="line">2019-05-07 23:27:32 INFO metabase.driver :: Registered driver :databend (parents: #&#123;:sql-jdbc&#125;) 🚚</span><br></pre></td></tr></table></figure><p>访问  <a href="http://localhost:3000/" target="_blank" rel="noopener">http://hostname:3000</a> 即可打开 metabase 首页</p><p><img src="https://p.ipic.vip/f6c371.png" alt=""></p></li></ol><h3 id="Connect-Metabase-to-Databend"><a href="#Connect-Metabase-to-Databend" class="headerlink" title="Connect Metabase to Databend"></a>Connect Metabase to Databend</h3><ol><li>填写基本信息，选择 <code>I&#39;ll add my data later</code></li></ol><p><img src="https://p.ipic.vip/y11n06.png" alt=""></p><ol start="2"><li>点击<code>Add your own data</code> 创建 databend 数据库连接</li></ol><p><img src="https://p.ipic.vip/rykbju.png" alt=""></p><p>选择 databend (databend version &gt;=DatabendQuery v1.0.17)</p><p><img src="https://p.ipic.vip/ao0zt7.png" alt=""></p><p>填写数据库连接信息后点击保存</p><p><img src="https://p.ipic.vip/h8tll2.png" alt=""></p><ol start="3"><li><p>退出后台管理</p><p><img src="https://p.ipic.vip/9rgpuw.png" alt=""></p></li></ol><h3 id="Run-a-SQL-query"><a href="#Run-a-SQL-query" class="headerlink" title="Run a SQL query"></a>Run a SQL query</h3><ol><li><p>退出后台管理后，在右上角，单击 <code>+ New</code> 菜单，可以运行SQL查询和构建仪表盘。</p><p><img src="https://p.ipic.vip/mpaq1n.png" alt=""></p></li><li><p>举个 SQL 查询的🌰</p><p><img src="https://p.ipic.vip/vaennu.png" alt=""></p><p><img src="https://p.ipic.vip/0ulvaw.png" alt="9ff9873e-e8ee-44da-8126-e6b4f5b9cf3d"></p></li><li><p>点击左下角的可视化按钮可以构建仪表盘</p><p><img src="https://p.ipic.vip/nr3e25.png" alt=""></p></li></ol><h3 id="Learn-more"><a href="#Learn-more" class="headerlink" title="Learn more"></a>Learn more</h3><p>有关Metabase以及如何构建仪表板的更多信息，请访问 <a href="https://www.metabase.com/docs/latest/" target="_blank" rel="noopener">Metabase 文档</a>。</p><h2 id="一些感受"><a href="#一些感受" class="headerlink" title="一些感受"></a>一些感受</h2><p>写 Clojure 过程中感受最深的还是圆括号求值 <code>()</code>，因为 Clojure 中任何语句的一般形式需要在大括号中求值，向下面这样：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>) <span class="comment">;运算符在前</span></span><br><span class="line">------</span><br><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> clojure.examples.hello</span><br><span class="line">   (<span class="symbol">:gen-class</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> Example []</span><br><span class="line">   (<span class="name">println</span> (<span class="name"><span class="builtin-name">str</span></span> <span class="string">"Hello"</span> <span class="string">"World"</span>))</span><br><span class="line">   (<span class="name">println</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">2</span>)))</span><br><span class="line">(<span class="name">Example</span>)</span><br></pre></td></tr></table></figure><p>所以当一个函数比较大而且有高阶函数的时候，数括号就会成为一种灾难😂，这个时候就不得不依赖 IDE 的提示了。</p><p>机缘巧合粗浅地了解了这门编程语言，不过目前来看使用 Clojure 作为主力开发语言的公司非常少，坊间甚至一度传闻 <a href="https://news.ycombinator.com/item?id=14418013" target="_blank" rel="noopener">Clojure is dead</a>。但是语言只是工具，即使工作中无法使用，了解这门优雅、富有表现力的语言来扩展自己的眼界，也是不错的选择。Clojure 社区也有一些有意思的项目，这里抛砖引玉，感兴趣的同学可以去了解一下。</p><hr><blockquote><p> 索性在这里记录跟踪一下最近的一些跟开源相关的工作</p><ul><li><a href="https://github.com/tapdata/tapdata" target="_blank" rel="noopener">tapdata/tapdata </a><a href="https://github.com/tapdata/tapdata/pull/435" target="_blank" rel="noopener">🎉 New connector: databend</a></li><li><a href="https://github.com/clickvisual/clickvisual" target="_blank" rel="noopener">clickvisual/clickvisual </a><a href="https://github.com/clickvisual/clickvisual/pull/823" target="_blank" rel="noopener">Feat: support databend source</a> </li><li><a href="https://github.com/getredash/redash" target="_blank" rel="noopener">getredash/redash </a><a href="https://github.com/getredash/redash/pull/5902" target="_blank" rel="noopener">feat: New support databend for redash</a></li><li><a href="https://github.com/apache/superset" target="_blank" rel="noopener">apache/superset </a><a href="https://github.com/apache/superset/pull/23308" target="_blank" rel="noopener">feat: support databend for superset</a> </li><li><a href="https://github.com/airbytehq/airbyte" target="_blank" rel="noopener">airbytehq/airbyte </a><a href="https://github.com/airbytehq/airbyte/pull/21302" target="_blank" rel="noopener">🎉 New source connector: databend</a></li><li><a href="https://github.com/databendcloud/metabase-databend-driver" target="_blank" rel="noopener">metabase-databend-driver</a></li><li><a href="https://github.com/databendcloud/flink-connector-databend" target="_blank" rel="noopener">flink-connector-databend</a></li></ul></blockquote><hr>]]></content>
    
    <summary type="html">
    
      2023 NO.12 开源周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 51 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/12/17/2022-51-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/12/17/2022-51-Open-source-weekly-report/</id>
    <published>2022-12-17T02:25:18.000Z</published>
    <updated>2022-12-17T13:33:11.612Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>距离上一次 weekly report 已经过去整整一个月，在 <a href="https://github.com/databendcloud/databend-py" target="_blank" rel="noopener">databend-py</a>、<a href="https://github.com/databendcloud/databend-sqlalchemy" target="_blank" rel="noopener">databend-sqlalchemy</a> 基本可用的前提下我开始着手在 <a href="https://docs.getdbt.com/" target="_blank" rel="noopener">dbt</a> 的生态中支持 databend cloud。dbt 提供了一种插件生态，我们可以开发专有的 adapter plugin 从而将 DBT 扩展到任何数据平台。dbt 算是在数据领域的新物种，在国内感觉用的还不是很多，但是在国外已经俨然成为现代数据领域的后起之秀。所以下面先抛砖引玉，简单介绍一下 dbt。</p><h2 id="What-is-dbt"><a href="#What-is-dbt" class="headerlink" title="What is dbt?"></a>What is dbt?</h2><p>dbt 是一个非常强大和灵活的数据工具，它可以快速构建数据 pipe、基于  jinjia 模板以自动测试、构建和填充分析模型，包括文档的自动生成和开箱即用的数据血缘，非常适合自动化数仓的工作。其核心代码是一个开源 Python 库 - <a href="https://github.com/dbt-labs/dbt-core" target="_blank" rel="noopener">dbt-core</a> 。可以参考<a href="https://discourse.getdbt.com/t/how-we-set-up-our-computers-for-working-on-dbt-projects/243" target="_blank" rel="noopener">这个项目</a>快速上手体验一下。</p><p>需要强调的一点是 dbt 并不是传统的 ETL 工具，</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h973opa25sj30pw0bamxw.jpg" alt="ETL"></p><p>它并不在系统之间传输或者加载数据，而是通过使用 SQL 和 YAML 来转换已经被加载到数仓中的数据。这种先加载后转换的概念，称为 ELT。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h96n06kdcwj30qk0cg3zb.jpg" alt="ELT"></p><p>在 ELT 的过程中，数据无须等待即可进入数仓，转换出现错误也不需要重新加载，能够提高效率并降低成本。下面我也会介绍一个 EL 的工具 - airbyte，看 airbyte + dbt 如何实现完美的 ELT 流程。关于  dbt 的介绍就到这里，想要深入了解的同学可以参考 dbt 官网和 dbt-core 的 github 主页。</p><h2 id="How-to-use-dbt-with-Databend-Cloud"><a href="#How-to-use-dbt-with-Databend-Cloud" class="headerlink" title="How to use dbt with Databend Cloud"></a>How to use dbt with Databend Cloud</h2><p>经过几周与 dbt 的搏斗，支持 databend 的 dbt adapter 插件 <a href="https://github.com/databendcloud/dbt-databend" target="_blank" rel="noopener">dbt-databend-cloud</a> 终于能够跑通官方的 case 了✿✿ヽ(°▽°)ノ✿。开发的过程中也帮 databend 本身发现并解决了一些问题:</p><h4 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h4><p><a href="https://github.com/datafuselabs/databend/issues/8906" target="_blank" rel="noopener">Feature: support <code>a.*</code> in SQL</a></p><p><a href="https://github.com/datafuselabs/databend/issues/8876" target="_blank" rel="noopener">Feature: support <code>||</code> concat function in SQL</a></p><p><a href="https://github.com/datafuselabs/databend/issues/9131" target="_blank" rel="noopener">Feature: support SQL-style double-quoted identifier in get_path</a></p><h4 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h4><p><a href="https://github.com/datafuselabs/databend/pull/9206" target="_blank" rel="noopener">fix: double-quote in get_path</a></p><p>期间也有跟 dbt 社区的讨论，非常感谢 dbt 社区的热心帮助:</p><h4 id="Disscussion"><a href="#Disscussion" class="headerlink" title="Disscussion"></a>Disscussion</h4><p><a href="https://github.com/dbt-labs/dbt-core/discussions/6276" target="_blank" rel="noopener">Field “path” of type Path in DatabendRelation has invalid value</a></p><p>我们可以跟着这个 <a href="https://github.com/databendcloud/dbt-databend/wiki/How-to-use-dbt-with-Databend-Cloud" target="_blank" rel="noopener">wiki - How to use dbt with Databend Cloud</a> 体验一下 dbt 的强大能力，希望后面能顺利将 dbt-databend 加入到官方 dbt-adapters 的维护阵营当中去。</p><h2 id="What-is-airbyte"><a href="#What-is-airbyte" class="headerlink" title="What is airbyte?"></a>What is airbyte?</h2><p>上面我们介绍 ELT 的时候提到过 <code>airbyte</code>，这里再展开介绍一下。<a href="https://airbytehq.github.io/" target="_blank" rel="noopener">Airbyte</a> 是一个开源的云原生数据集成平台，可以让用户从各种来源提取、转换和加载数据到各种目标。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h972vmd7aqj318v0s9n14.jpg" alt="airbyte"></p><p>airbyte 的架构设计易于扩展，非常灵活，允许用户开发自定义的 source/destination connector ，并且可以很方便地加入到 airbyte 的平台里。这里我主要是开发了一个 destination connector，将 databend cloud 作为数据的目的入口，这样用户就可以很容易地从各个数据源，比如 S3, Clickhouse, Filebot ，甚至本地文件同步数据到 databend cloud，并且 airbyte 的 Normalization 能力结合 dbt 后能够将原始数据转换成完整表结构的数据表。</p><p>等这个 <a href="https://github.com/airbytehq/airbyte/pull/19815" target="_blank" rel="noopener">PR</a> 合并后就可以在 airbyte cloud 上使用 databend cloud 作为 data source 了。</p><h2 id="ClickVisual-支持-databend-source"><a href="#ClickVisual-支持-databend-source" class="headerlink" title="ClickVisual 支持 databend source"></a>ClickVisual 支持 databend source</h2><p>ClickVisual 是一个轻量级的由<a href="https://shimo.im/" target="_blank" rel="noopener">石墨文档</a>开源的日志查询、分析、报警的可视化平台，提供一站式应用可靠性的可视化的解决方案。既可以独立部署使用，也可作为插件集成到第三方系统。目前是市面上唯一一款支持 ClickHouse 的类 Kibana 的业务日志查询平台。之前 ClickVisual 只支持 Clickhouse 作为数据源来存储、查询日志，我添加了一些代码经过调试后现在也能支持 databend cloud 作为数据源。</p><p><a href="https://github.com/clickvisual/clickvisual/pull/823" target="_blank" rel="noopener">Feat: support databend source</a></p><p><a href="https://github.com/clickvisual/clickvisual/pull/835" target="_blank" rel="noopener">feat: support exist log table for databend</a></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h972v1gxwjj30zk0js76o.jpg" alt=""></p><p>但是由于目前 databend 不支持类似 Clickhouse <code>status=&#39;200&#39;</code> ( <code>status</code> 是 <code>int32</code> 类型) 这样的语法，所以字段过滤查询的功能需要等这个 <a href="https://github.com/clickvisual/clickvisual/issues/836" target="_blank" rel="noopener">issue-836</a> 解决后才能正常使用。</p><h2 id="Openkruise-遗留-PR"><a href="#Openkruise-遗留-PR" class="headerlink" title="Openkruise 遗留 PR"></a>Openkruise 遗留 PR</h2><p>说起来真是非常惭愧，不仅已经很久没有参加 OpenKruise 的双周会了而且还遗留了一个陈年老 PR 没有完成，其实两周前 <a href="https://github.com/zmberg" target="_blank" rel="noopener">zmberg</a> 就联系我尽快处理一下这个问题，所以这周无论如何也要把这个 <a href="https://github.com/openkruise/kruise/pull/1028" target="_blank" rel="noopener">PR</a> 关掉 😭。</p><hr><p>综上，希望 2022 的最后两周工作顺利🎉。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.51 周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 47 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/11/13/2022-47-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/11/13/2022-47-Open-source-weekly-report/</id>
    <published>2022-11-13T03:44:28.000Z</published>
    <updated>2022-11-13T14:17:19.032Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>自从 <a href="https://cloudsjhan.github.io/2022/10/21/2022-43-Open-source-weekly-report/#more">databend-go</a>  release 后，最近大部分时间都在与 Python 搏斗😂，太长时间没有正儿八经写 Python 了真是磨合了好几天才找到点感觉。<br>用了差不多两周，databend 的 Python Deiver <a href="https://github.com/databendcloud/databend-py" target="_blank" rel="noopener">databend-py</a> 以及支持 <code>SQLAlchemy</code> 语法的 <a href="https://github.com/databendcloud/databend-sqlalchemy" target="_blank" rel="noopener">databend-sqlalchemy</a> 已经基本可用。不得不说 Python 在数据的生态里还是王者，前几天有用户在使用 go driver 的时候遇到了一个 data type parser 的<a href="https://github.com/databendcloud/databend-go/issues/10" target="_blank" rel="noopener">问题</a>，之前在实现过程中就遇到过类似的类型问题，这种问题在强类型语言里简直就是灾难，但是对于 Python 来说就不存在。所以最后用户还是用了 Python 的 driver 解决了问题，看来后面要认真打磨 databend-py 了。</p><p>在使用方面也是 python 占优，pip install 然后 import 直接就是手到擒来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install databend-py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> databend_py <span class="keyword">import</span> Client</span><br><span class="line">client = Client(</span><br><span class="line">    host=<span class="string">'hostName'</span>,</span><br><span class="line">    database=<span class="string">"default"</span>,</span><br><span class="line">    user=<span class="string">"user"</span>,</span><br><span class="line">    password=<span class="string">"pass"</span>)</span><br><span class="line">print(client.execute(<span class="string">"SELECT 1"</span>))</span><br></pre></td></tr></table></figure><p>不过 <code>databend-py</code> 仅是提供了 python 连接到 databend cloud 的桥梁，并不能像使用 ORM 工具一样使用 <code>cursor.next</code>、<code>fetchall</code> 等方法。在准备实现 <a href="https://docs.getdbt.com/docs/introduction" target="_blank" rel="noopener">dbt</a> adapter 的时候发现需要依赖上面提到的 ORM 的方法，在 Python 生态里 SQLAlchemy 是 Python 中最有名的 ORM 工具，所以就有了 <code>databend-sqlalchemy</code> 这个项目。由于时间紧迫，先实现了对接 dbt 必须要用到的 <code>cursor, description, next, fetch</code> 方法，在 <code>databend-py</code> 的铺垫下，实现起来确实方便很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cursor = connector.connect(<span class="string">'http://root:@localhost:8081'</span>).cursor()</span><br><span class="line">    cursor.execute(<span class="string">'select 1'</span>)</span><br><span class="line">    <span class="comment"># print(cursor.fetchone())</span></span><br><span class="line">    print(cursor.fetchall())</span><br><span class="line">    print(cursor.description)</span><br></pre></td></tr></table></figure><p>几个字总结一下近期的状态就是：<code>与 Python 搏斗</code>，当然接下来可以预见的依然会跟 python 搏斗一段日子，因为最近要搞的 dbt adapter 是一个全新的, 陌生领域，完全就是一头雾水，所以接下来可能会先写几篇关于 dbt 的学习文章吧。</p><p>再就是最近开的 repo 有点多，加上实现的时间比较紧，感觉有些疲于应对，很多实现只能草草了事，估计 bug 会比较多，所以后面应该会多抽出一些个人的时间来完善这些项目。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.47 周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 43 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/10/21/2022-43-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/10/21/2022-43-Open-source-weekly-report/</id>
    <published>2022-10-21T10:34:16.000Z</published>
    <updated>2022-10-21T12:46:27.763Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="Go-driver-SDK-for-databend-cloud-released"><a href="#Go-driver-SDK-for-databend-cloud-released" class="headerlink" title="Go driver SDK for databend cloud released!"></a>Go driver SDK for databend cloud released!</h2><p>由于在 databend cloud 各个项目的代码中已经充斥着大量重复的请求 databend-query 的代码，所以亟需一个 driver SDK 来实现大一统，于是在几周前就开始着手实现 databend cloud 的 go driver，当时用比较短的时间大概实现了一个架子，详情可以见 <a href="https://cloudsjhan.github.io/2022/09/02/2022-36-Open-source-weekly-report/">这篇文章</a>。碍于中间有几个优先级比较高的工作就暂时搁置了，本周 all in 这个项目一周，终于 release 了 <a href="https://github.com/databendcloud/databend-go" target="_blank" rel="noopener">v0.0.1 版本</a>，虽然代码的结构、功能的丰富程度、代码的优雅程度都跟标杆 SDK - <a href="https://github.com/ClickHouse/clickhouse-go" target="_blank" rel="noopener">clickhouse-go</a> 的水平有较大差距，但基本的方法比如 <code>sql.Open</code>, <code>Exec</code>, <code>Query</code>, <code>Next</code>, <code>Rows</code> 等都已经可用。先来看几个🌰吧!</p><h3 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  dsn, cfg, err := getDSN()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"failed to create DSN from Config: %v, err: %v"</span>, cfg, err)</span><br><span class="line">      &#125;</span><br><span class="line">conn, err := sql.Open(<span class="string">"databend"</span>, dsn)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">  conn.Exec(<span class="string">`DROP TABLE IF EXISTS data`</span>)</span><br><span class="line">  _, err = conn.Exec(<span class="string">`</span></span><br><span class="line"><span class="string">  CREATE TABLE IF NOT EXISTS  data(</span></span><br><span class="line"><span class="string">      Col1 UInt8,</span></span><br><span class="line"><span class="string">      Col2 String</span></span><br><span class="line"><span class="string">  ) </span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  _, err = conn.Exec(<span class="string">"INSERT INTO data VALUES (1, 'test-1')"</span>)</span><br></pre></td></tr></table></figure><h3 id="Query-Row"><a href="#Query-Row" class="headerlink" title="Query Row"></a>Query Row</h3><p>可以用 <code>Scan</code> 方法来解析出单条数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">row := conn.QueryRow(<span class="string">"SELECT * FROM data"</span>)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    col1             <span class="keyword">uint8</span></span><br><span class="line">    col2, col3, col4 <span class="keyword">string</span></span><br><span class="line">    col5            []<span class="keyword">string</span></span><br><span class="line">    col6             time.Time</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err := row.Scan(&amp;col1, &amp;col2, &amp;col3, &amp;col4, &amp;col5, &amp;col6); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Query-Rows"><a href="#Query-Rows" class="headerlink" title="Query Rows"></a>Query Rows</h3><p>当然可以用 <code>Next</code> 来不断迭代获取所有数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">row := conn.QueryRow(<span class="string">"SELECT * FROM data"</span>)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    col1             <span class="keyword">uint8</span></span><br><span class="line">    col2, col3, col4 <span class="keyword">string</span></span><br><span class="line">    col5            []<span class="keyword">string</span></span><br><span class="line">    col6             time.Time</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="keyword">if</span> err := row.Scan(&amp;col1, &amp;col2, &amp;col3, &amp;col4, &amp;col5, &amp;col6); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"row: col1=%d, col2=%s, col3=%s, col4=%s, col5=%v, col6=%v\n"</span>, col1, col2, col3, col4, col5, col6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在请求 databend-query 的时候，就不用再每次都写一遍 http 请求/解析的代码啦。</p><h2 id="bendsql-尝鲜-go-driver"><a href="#bendsql-尝鲜-go-driver" class="headerlink" title="bendsql 尝鲜 go driver"></a>bendsql 尝鲜 go driver</h2><p>Go driver release 后马上就迎来了第一个用户(小白鼠) - <a href="https://github.com/databendcloud/bendsql" target="_blank" rel="noopener">bendsql</a>。bendsql 中有个命令用来执行 SQL 语句， <code>bendsql query &quot;select * from table&quot;</code>，所以我先将这里面请求 databend-query 的代码都换成了 go driver - <code>https://github.com/databendcloud/bendsql/pull/22</code>，可以看到删掉了不少代码，清晰了不少。接下来要在其他项目中去检验了。</p><p>来看看效果：<br><img src="https://tva1.sinaimg.cn/large/005UfcOkly8h7d6u4upl3j31gq0fuwfq.jpg" alt=""></p><h2 id="kruise-tools"><a href="#kruise-tools" class="headerlink" title="kruise-tools"></a>kruise-tools</h2><p>本周 <code>kubectl-kruise</code> 插件迎来了一次<a href="https://github.com/openkruise/kruise-tools/releases/tag/v1.0.5" target="_blank" rel="noopener">更新</a>，包含了两个 bug-fix 和新的 feature:</p><p>🐛 Bug fix:</p><ul><li>Fix rollout status of partitioned update <a href="https://github.com/openkruise/kruise-tools/pull/68" target="_blank" rel="noopener">https://github.com/openkruise/kruise-tools/pull/68</a></li><li>Fix ads patch for rollout undo <a href="https://github.com/openkruise/kruise-tools/pull/71" target="_blank" rel="noopener">https://github.com/openkruise/kruise-tools/pull/71</a></li></ul><p>🚀 Feat:</p><ul><li>Support kubectl-kruise create ContainerRecreateRequest <a href="https://github.com/openkruise/kruise-tools/pull/66" target="_blank" rel="noopener">https://github.com/openkruise/kruise-tools/pull/66</a></li><li><p>Add resourcedistribution generator <a href="https://github.com/openkruise/kruise-tools/pull/69" target="_blank" rel="noopener">https://github.com/openkruise/kruise-tools/pull/69</a>. Thanks @dong4325 </p><p>其中 resourcedistribution generator 是开源之夏的一个项目，主要是用来方便用户生成 resourceDistrubution 资源的，关于 <a href="https://openkruise.io/docs/user-manuals/resourcedistribution" target="_blank" rel="noopener">resouceDistribution</a> 和这个 generator 后面等功能稳定后再多做介绍。</p></li></ul><p>好了，以上。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.40 weekly report
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022-41 homebrew formula example for go</title>
    <link href="https://cloudsjhan.github.io/2022/10/06/homebrew-formula-example-for-go/"/>
    <id>https://cloudsjhan.github.io/2022/10/06/homebrew-formula-example-for-go/</id>
    <published>2022-10-06T12:35:49.000Z</published>
    <updated>2022-10-09T09:41:42.288Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>最近准备将 <code>bendsql</code> 发布到 homebrew 的 repo，这样就可以使用 <code>brew install bendsql</code> 方便地安装 <code>bendsql</code> 了。发布的方式就是为 bendsql 写一个 formula 并提 pr 到 <a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener">homebrew-core</a>，在此记录一下如何生成 homebrew formula。</p><p>说干就干， fork 了 homebrew-core 的 repo 然后 checkout 分支准备提 PR。</p><p> 执行 <code>brew create $download_URL</code> 执行后会生成 install 模板，根据模板填写需要的信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bendsql</span> &lt; Formula</span></span><br><span class="line">  desc <span class="string">"Work seamlessly with Databend Cloud from the command line."</span></span><br><span class="line">  homepage <span class="string">"https://github.com/databendcloud/bendsql"</span></span><br><span class="line">  url <span class="string">"https://github.com/databendcloud/bendsql/releases/download/v0.0.2/bendsql-darwin-amd64.tar.gz"</span></span><br><span class="line">  sha256 <span class="string">"25c1a2a4e1922261535325634a939fe42a0ffcc12ae6c262ed7021dab611f622"</span></span><br><span class="line">  license <span class="string">"MIT"</span></span><br><span class="line">  head <span class="string">"https://github.com/databendcloud/bendsql.git"</span>, <span class="symbol">branch:</span> <span class="string">"main"</span></span><br><span class="line"></span><br><span class="line">  depends_on <span class="string">"go"</span> =&gt; <span class="symbol">:build</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">install</span></span></span><br><span class="line">    system <span class="string">"go"</span>, <span class="string">"build"</span>, *std_go_args(<span class="symbol">ldflags:</span> <span class="string">"-s -w"</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  test <span class="keyword">do</span></span><br><span class="line">    system <span class="string">"make test"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>根据 homebrew-core 的文档，在提 PR 之前要完成几个前置操作：<br><img src="https://tva1.sinaimg.cn/large/005UfcOkly8h6z5wwxx48j31bm0e241t.jpg" alt=""></p><p>当执行到 <code>brew test bendsql</code> 的时候，发现向 homebrew 官方仓库提交应用是需要满足一定条件的：<br><img src="https://tva3.sinaimg.cn/large/005UfcOkly8h6z5domkzbj31c007swfx.jpg" alt=""></p><p>bendsql 刚开源一周还没满足以上条件，所以没法直接使用 <code>brew install bendsql</code>，只能另辟蹊径了。</p><p>想起来之前写其他工具的时候，只要在自己的账户中创建一个 homebrew-tap 的 repo, 比如 <a href="https://github.com/hantmac/homebrew-tap" target="_blank" rel="noopener">https://github.com/hantmac/homebrew-tap</a>, 就能实现类似的下载效果。</p><p>所以只要在 databendcloud 的账户下，新建一个这样的 repo，将上面配好的 formula 提交进去就可以 <code>brew tap databendcloud/homebrew-tap &amp;&amp; brew install bendsql</code> 很方便地下载了。</p><hr>]]></content>
    
    <summary type="html">
    
      homebrew formula example for go
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
      <category term="homebrew" scheme="https://cloudsjhan.github.io/tags/homebrew/"/>
    
  </entry>
  
  <entry>
    <title>2022 40 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/09/25/2022-40-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/09/25/2022-40-Open-source-weekly-report/</id>
    <published>2022-09-25T03:10:04.000Z</published>
    <updated>2022-10-21T10:38:41.015Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>不知不觉 Weekly report 已拖更三周，除了日常忙碌之外，也是觉得没有什么特别值得写的。<br>八月中旬的时候开始着手写一个工具 - bendsql（见<a href="https://cloudsjhan.github.io/2022/08/16/2022-33-Open-source-weekly-report/" title="33-weekly-report">33 weekly report</a>），用来帮助用户更高效地操作 <a href="https://www.databend.com/" title="Databend Cloud" target="_blank" rel="noopener">Databend Cloud</a>，当时是用了大概一周的时间完成了这个项目，经过几周的内部使用和迭代，现在已经被用在 perf test 和 e2e test 中，跑得还算稳定QUQ，所以决定本周将其开源，让更多的用户/开发者使用并参与到产品的开发中。</p><h2 id="bensql"><a href="#bensql" class="headerlink" title="bensql"></a>bensql</h2><blockquote><p>在这里先简单介绍一下 Databend Cloud: Databend Cloud 由 Databend 强力驱动，是一款基于 Databend 内核打造的 SAAS 云数仓平台，具有简单、弹性、安全、速度快、成本低等特性，专注于云端大数据一站式解决方案，以解决传统大数据项目中运维难，成本高，使用复杂的问题。</p></blockquote><p><a href="https://github.com/databendcloud/bendsql" target="_blank" rel="noopener"><code>bendsql</code></a> 是一个为 Databend Cloud 打造的 Cli 工具，能够帮助用户高效地操作数仓平台，比如 list/create/delete warehouse, list stage, upload 文件，执行 SQL 等，提供跟 web 页面近乎一致的体验。</p><h3 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h3><p>在使用 <code>bendsql</code> 之前，需要现在 <code>Databend Cloud</code> 上申请注册账号，然后在 <a href="https://github.com/databendcloud/bendsql/releases/latest" target="_blank" rel="noopener">下载页面</a> 找到对应平台的二进制包下载安装。</p><ol><li>auth login<br>首先用注册的账号登录,</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bendsql auth login</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ir06gf9jj20z80b0aat.jpg" alt=""></p><p>登录过程中选择需要使用的组织，直接回车使用默认组织。<br>当然，登录后也可以使用 <code>bendsql configure --org YOURORG</code> 来修改。</p><ol start="2"><li>操作 warehouse<br>使用 <code>bendsql</code> 就可以完成对 warehouse 的所有操作，<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">USAGE</span><br><span class="line">  bendsql warehouse cmd [flags]</span><br><span class="line"></span><br><span class="line">CORE COMMANDS</span><br><span class="line">  create:      Create a warehouse</span><br><span class="line">  delete:      Delete a warehouse</span><br><span class="line">  ls:          show warehouse list</span><br><span class="line">  resume:      Resume a warehouse</span><br><span class="line">  status:      show warehouse status</span><br><span class="line">  suspend:     Suspend a warehouse</span><br><span class="line"></span><br><span class="line">INHERITED FLAGS</span><br><span class="line">  --help   Show help for command</span><br><span class="line"></span><br><span class="line">LEARN MORE</span><br><span class="line">  Use 'bendsql &lt;command&gt; &lt;subcommand&gt; --help' for more information about a command.</span><br></pre></td></tr></table></figure></li></ol><p>参考使用文档即可，这里就不详细展开了。</p><ol start="3"><li>操作 stage<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Operate stage</span><br><span class="line"></span><br><span class="line">USAGE</span><br><span class="line">  bendsql stage &lt;command&gt; [flags]</span><br><span class="line"></span><br><span class="line">CORE COMMANDS</span><br><span class="line">  ls:          List stage or files in stage</span><br><span class="line">  upload:      Upload file to stage using warehouse</span><br><span class="line"></span><br><span class="line">INHERITED FLAGS</span><br><span class="line">  --help   Show help for command</span><br><span class="line"></span><br><span class="line">LEARN MORE</span><br><span class="line">  Use 'bendsql &lt;command&gt; &lt;subcommand&gt; --help' for more information about a command.</span><br></pre></td></tr></table></figure></li></ol><p>可以使用 <code>bendsql</code> 很方便地将文件上传到 stage 中。也可以查看目标 stage 中的文件情况。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ir805kvdj21m6084gng.jpg" alt=""></p><ol start="4"><li>Exec SQL</li></ol><p><code>bendsql</code> 可以来执行 SQL 语句，<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ir9xjyi3j20uo07cjrs.jpg" alt=""></p><p>假如你执行的 SQL 语句比较耗费资源，可以在执行 SQL 的同时指定使用更大规格的 warehouse,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bendsql query --sql YOURSQL --warehouse WAREHOUSE</span><br></pre></td></tr></table></figure></p><p>但是这种执行 SQL 的方式对用户来说不太友好，后面的 RoadMap 中会考虑支持 <code>bendsql query</code> 就进入到交互式 SQL 的环境中，再支持命令补全后，体验就大幅提升了。</p><p>关于使用就先介绍这些，感兴趣的可以下载安装 <code>bendsql -h</code> 后继续探索。</p><blockquote><p>彩蛋❀  最开始的时候这个工具并不是叫 <code>bendsql</code> ，而是 <code>bendctl</code>，大家觉得 <code>bendctl</code> 这个命名太过于工程师化了 =.=，经过讨论最后改为 <code>bendsql</code>。</p></blockquote><hr><p>以上。往期文章可以访问 <a href="https://cloudsjhan.github.io/">https://cloudsjhan.github.io/</a> 继续阅读。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.40 weekly report
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 36 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/09/02/2022-36-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/09/02/2022-36-Open-source-weekly-report/</id>
    <published>2022-09-02T09:46:37.000Z</published>
    <updated>2022-09-02T12:47:21.658Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><h4 id="新的挑战"><a href="#新的挑战" class="headerlink" title="新的挑战"></a>新的挑战</h4><p>本周开了一个新的项目 databend-go-driver，是一套类似于 <a href="https://github.com/snowflakedb/gosnowflake" target="_blank" rel="noopener">gosnowflake</a> 的数据库 SDK，主要是基于 Go 的 <a href="https://golang.org/pkg/database/sql/" target="_blank" rel="noopener">database/sql</a> package，实现相应的 interface 并注册 databend 到 database/sql，可以使用下面的代码像操作 mysql 一样操作 databend ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dsn, cfg, err := getDSN()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to create DSN from Config: %v, err: %v"</span>, cfg, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"databend"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to connect. %v, err: %v"</span>, dsn, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line">query := <span class="string">"SELECT 1"</span></span><br><span class="line">rows, err := db.Exec(query) <span class="comment">// no cancel is allowed</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to run a query. %v, err: %v"</span>, query, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(rows.RowsAffected())</span><br><span class="line">fmt.Printf(<span class="string">"Congrats! You have successfully run %v with databend DB!\n"</span>, query)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前项目的架子搭了一下，已经完成基本的注册和简单的 exec 功能，但距离真正生产可用比较遥远。。。还要实现 query, rows, async rows 等功能，完成这些工作就需要对 databend 的工作原理、结构有一定了解，可能是一个小挑战QUQ。</p><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>最近由于项目需要又用了一下 <a href="https://github.com/hantmac/fuckdb" target="_blank" rel="noopener">fuckdb</a>，这是一个能够一键将 mysql schema 转成带各种 tag 的 golang struct 的大大提高开发效率的工具，感兴趣的可以研究一下这里不多作介绍了。主要是在打开 github 项目页面的时候发现一个陈年老 <a href="https://github.com/hantmac/fuckdb/issues/47" target="_blank" rel="noopener">issue</a>，竟然是去年 7 月份用户提出来的，回想起去年 7 月，确实是忙得焦头烂额（懂的都懂），但没想到这个问题一搁置就是一年。<br>这个需求是将 struct 的 json tag 从 snake case 转成 camel case，改动之前生成的代码是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age           <span class="keyword">string</span>    <span class="string">`gorm:"column:slug" json:"age"`</span></span><br><span class="line">        Name           <span class="keyword">string</span>    <span class="string">`gorm:"column:name" json:"name"`</span></span><br><span class="line">        CreatorID      <span class="keyword">int64</span>     <span class="string">`gorm:"column:creator_id" json:"creator_id"`</span></span><br><span class="line">        CreatedAt      time.Time <span class="string">`gorm:"column:created_at" json:"created_at"`</span></span><br><span class="line">        UpdatedAt      time.Time <span class="string">`gorm:"column:updated_at" json:"updated_at"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snake case 本身也不符合 golang 的代码风格，所以就鲁了一个 <a href="https://github.com/hantmac/fuckdb/pull/63" target="_blank" rel="noopener">PR</a> 解决了这个问题，输出的 struct 就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structName <span class="keyword">struct</span> &#123;</span><br><span class="line">        Age           <span class="keyword">string</span>    <span class="string">`gorm:"column:slug" json:"age"`</span></span><br><span class="line">        Name           <span class="keyword">string</span>    <span class="string">`gorm:"column:name" json:"name"`</span></span><br><span class="line">        CreatorID      <span class="keyword">int64</span>     <span class="string">`gorm:"column:creator_id" json:"creatorId"`</span></span><br><span class="line">        CreatedAt      time.Time <span class="string">`gorm:"column:created_at" json:"createdAt"`</span></span><br><span class="line">        UpdatedAt      time.Time <span class="string">`gorm:"column:updated_at" json:"updatedAt"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，优雅了 =.=。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>记录一些随手拍：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5sisefrazj21400u00zr.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5sis3umflj20u014045i.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5sis9mtv5j21400u0n2g.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.36 周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 34 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/08/22/2022-34-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/08/22/2022-34-Open-source-weekly-report/</id>
    <published>2022-08-22T09:12:25.000Z</published>
    <updated>2022-08-22T09:56:03.003Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a>   <h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><code>bendctl</code> 一期的工作已完成 70%，进度之快出乎我的意料，等下周写完再来总结和介绍一下。</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>琐碎的事情好像一直不断，并没有大段的时间来阅读，无意间倒是偶然重读了冯骥才的《苦夏》，突然发现自己已经好久没有静下心来读完过一篇散文了。此时正值北方一夜入秋的天气，读罢文章更感觉秋意渐浓。</p><p>好的文章让人感动，再想起最近身边发生的一些事情，越发地觉得 <code>男人们的童年往事大多是在夏天里</code> 有多么的贴切，应该说，人生有一半的快乐来自童年，童年有大半的快乐来自夏天，在快乐的童年里，你根本不会感到蒸笼般夏天的难耐与煎熬。虽然长大后这种感觉渐行渐远，甚至在此后艰难的人生里，你能体会到一丝苦夏般的滋味，但那些童年夏天里的美好的事物总是在默默地治愈你。</p><p> <code>快乐把时光缩短，苦难把岁月拉长，一如这长长的没有尽头的苦夏</code>。冯骥才在怀念了童年的美好后，并没有抨击、厌恶这样的夏天，相反，他觉得 <code>苦</code> ，原是生活中的蜜。人生的一切收获都压在这沉甸甸的苦字下面，然而一半的苦字下边又是一无所有。当你用尽平生的力气，最终所获与初始时的愿望竟然去之千里。你该怎么想？</p><p>冯骥才是这样想的，<code>苦夏</code>-它不是无尽头的暑热的折磨，而是我们顶着毒日头默默又坚忍的苦斗的本身。人生的力量全是对手给的，那就是要把对手的压力吸入自己的骨头里。强者之力最主要的是承受力。只有在匪夷所思的承受中才会感到自己属于强者。所以冯骥才的写作一大半是在夏季完成的。</p><p>可能是那些沉重的人生的苦夏，煅造出这样的性格习惯。</p><p>唔，旧书不厌百回读，年幼时读过的书在谈不上多少生活阅历的发酵下也是能催化出一些不一样的感悟。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.34 周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 33 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/08/16/2022-33-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/08/16/2022-33-Open-source-weekly-report/</id>
    <published>2022-08-16T14:24:05.000Z</published>
    <updated>2022-08-16T15:09:17.198Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本周无杂事， all in <code>bendctl</code> ┓( ´∀` )┏.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h58zxy3gymj20gc068t8r.jpg" alt=""></p><p>突然感觉写代码和盖房子有异曲同工之妙。盖房子需要花很长的时间来坚固地基，浇灌混凝土，地基牢靠后一层一层地盖就事半功倍了，如果你地基搭得不好，盖的过程中还要回头修补地基，不仅项目进度很慢，质量也得不到保证。写代码也是一样，不要着急写功能，把各种依赖、框架、代码结构先写好，在此之上再写功能逻辑代码便手到擒来了。</p><p>上周说要抽出点时间看一下开源之夏的 proposal 结果放了鸽子，本周无论如何也要多花点时间在上面，否则便有不负责任之嫌QUQ。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.33 开源周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 32 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/08/08/2022-32-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/08/08/2022-32-Open-source-weekly-report/</id>
    <published>2022-08-08T09:25:00.000Z</published>
    <updated>2022-08-08T09:39:50.153Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3><p>本周参加了开源之夏的双周会，review 了参赛同学关于 rollout history 的 <a href="https://github.com/openkruise/rollouts/pull/61" target="_blank" rel="noopener">Proposal</a>，还有许多要修改的地方，难度感觉比想象中高，下周要多抽出点时间来看一下了。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>依旧忙碌，时间紧张暂时不展开说了。</p><h3 id="学习-amp-生活"><a href="#学习-amp-生活" class="headerlink" title="学习&amp;生活"></a>学习&amp;生活</h3><p>这周倒是趁着午饭时间看了一些 Rust 的东西，主要是 Trait 以及生命周期相关的。Trait 有点像 Go 里面的 interface，impl 去实现方法。生命周期着实是比较复杂，有函数中的生命周期，方法的，变量的。。。,主要是 Rust 生命周期的语法也让人眼花QUQ。<br>&lt;`a&gt; 居然是生命周期的注解，u1s1，ugly。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Anyway， 期待能早日上手用 Rust 干点好玩的事情 (：。</p><p>以上。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.32 开源周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>2022 31 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/07/30/2022-31-Open-source-weekly-report-1/"/>
    <id>https://cloudsjhan.github.io/2022/07/30/2022-31-Open-source-weekly-report-1/</id>
    <published>2022-07-30T09:24:39.000Z</published>
    <updated>2022-07-30T10:22:27.358Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>2022 年第 31 周，以下是本周的开源周报。</p><p>本周主要 focus 在 databend cloud 新版本的功能实现上，并且由于对系统和代码实现缺少深入的了解，在对一些 corner case 的处理上欠考虑，导致了一些本不该出现的 bug，浪费了一些时间。警示自己在考虑问题的时候要全面，同时也要尽快地熟悉 databend cloud 的代码细节。</p><p>这里只记录一个小的问题，使用 lister 从 k8s 集群 get 资源的时候，需要对返回的 err 做 NotFoundErr 和其他 Error 的判断，尤其是在获取其他资源的时候，不能因为 NotFoundErr 的子资源就返回报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r, err := lister.Resources(ns).Get(name)</span><br></pre></td></tr></table></figure><p>要做这样的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if err != nil &amp;&amp; errors.IsNotFound(err) &#123;</span><br><span class="line">    // something</span><br><span class="line">&#125;else if err != nil &#123;</span><br><span class="line">    // return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开源方面，kubectl-kruise 插件收到了开发者一个 <a href="https://github.com/openkruise/kruise-tools/issues/67" target="_blank" rel="noopener">bug report</a> ，主要是说 <code>kubectl-kruise rollout status clone/sample</code> 在原地升级的场景下会卡主，即使所有 Pod 都已经更新完成程序也不会退出。这个问题是由于 rollout status 中缺少对原地升级完成的判断条件，于是就提了一个 <a href="https://github.com/openkruise/kruise-tools/pull/68" target="_blank" rel="noopener">PR</a> 解决这个问题。</p><p>另外一个支持 Openkruise SidecarSet 根据 namespace selector 注入 Pod 的 <a href="https://github.com/openkruise/kruise/pull/1028" target="_blank" rel="noopener">PR</a> 正在 review 中，还需要根据 reviewer 的 comment 进行修改。</p><p>绿树浓荫夏日长，不知不觉七月已近尾声，下个周报就八月份见了，夏天大概要过去了吧。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.31 开源周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>kubectl kruise - OpenKruise Cli 利器</title>
    <link href="https://cloudsjhan.github.io/2022/07/24/kubectl-kruise-OpenKruise-Cli-%E5%88%A9%E5%99%A8/"/>
    <id>https://cloudsjhan.github.io/2022/07/24/kubectl-kruise-OpenKruise-Cli-利器/</id>
    <published>2022-07-24T14:45:53.000Z</published>
    <updated>2022-07-25T02:10:56.301Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      kubectl kruise - OpenKruise Cli 利器
    
    </summary>
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/categories/OpenKruise/"/>
    
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/tags/OpenKruise/"/>
    
  </entry>
  
  <entry>
    <title>2022 NO.30 Open source weekly report</title>
    <link href="https://cloudsjhan.github.io/2022/07/24/2022-30-Open-source-weekly-report/"/>
    <id>https://cloudsjhan.github.io/2022/07/24/2022-30-Open-source-weekly-report/</id>
    <published>2022-07-24T14:41:02.000Z</published>
    <updated>2022-07-30T09:14:25.857Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>2022 年第 30 周，以下是本周的开源周报。</p><h3 id="事出有因"><a href="#事出有因" class="headerlink" title="事出有因"></a>事出有因</h3><p>周中的时候在 OpenKruise 开源社区群里看到有开发者提到能不能在 <code>kubectl-kruise</code> 插件中提供一种便捷的方式，让用户能够快速使用 <code>ContainerRecreateRequest</code> 实现原地重启容器的能力。<br><img src="https://tva1.sinaimg.cn/large/005UfcOkly8h4izm1vc8hj30w40dyzlb.jpg" alt=""></p><p>其实这个想法我在很久之前就有了，<br><img src="https://tva1.sinaimg.cn/large/005UfcOkly8h4j31omjpfj30s8060aap.jpg" alt=""><br>当时搁置了一下就淹没在琐碎之中，详见这个 <a href="https://github.com/openkruise/kruise-tools/issues/36" target="_blank" rel="noopener">issue</a>。趁着这周末的空闲，打算把这个功能实现一把。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>ContainerRecreateRequest 是 OpenKruise 提供的一种运维增强的组件，可以帮助用户重启/重建存量 Pod 中一个或多个容器。<br>和 Kruise 提供的原地升级类似，当一个容器重建的时候，Pod 中的其他容器还保持正常运行。重建完成后，Pod 中除了该容器的 restartCount 增加以外不会有什么其他变化。</p><p>目前用户创建 CRR 实现容器原地重启的方式主要有两种方式：</p><ul><li>kubectl apply -f crr.yaml</li><li>OpenKruise API</li></ul><p>这两种方式对集群运维人员来说都不够友好，过于繁琐。最好的方式就是在 terminal 中使用一行命令就能创建 CRR 完成原地重启。而 <a href="https://github.com/openkruise/kruise-tools" title="kruise-tools" target="_blank" rel="noopener">Kruise-tools</a> 为 Kruise 的功能提供了一系列命令行工具，包括 kubectl-kruise，它的是 kubectl 的标准插件。在这个插件中可以很容易集成该功能。（关于 kubectl-kruise 后面打算专门开一篇文章来详细介绍。)</p><h3 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h3><p>首先我们需要保证输入的参数尽量少，其他的必须参数都给到合理的默认值，以便用户能够以最快的速度创建 CRR 重启容器，所以我在插件中定义了 CRR 的一个默认策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strategy:</span><br><span class="line">    failurePolicy: Fail                </span><br><span class="line">    orderedRecreate: false             </span><br><span class="line">    unreadyGracePeriodSeconds: 3       </span><br><span class="line">  activeDeadlineSeconds: 300        </span><br><span class="line">  ttlSecondsAfterFinished: 1800</span><br></pre></td></tr></table></figure><p>确定最终的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl kruise create ContainerRecreateRequest test-crr --pod=sample-k52bq --containers=nginx</span><br></pre></td></tr></table></figure><p>执行这条命令就可以重启 pod sample-k52bq 中名字为 <code>nginx</code> 的容器，其中 <code>--containers</code> 为一个列表，如果为空就重启 pod 中所有的容器，否则重启指定容器。</p><p>除了 <code>--pod</code>、<code>--containers</code> 还支持 <code>unreadyGracePeriodSeconds</code> 和 <code>terminationGracePeriodSeconds</code>，这两个参数都是选填。</p><ul><li>unreadyGracePeriodSeconds: 重建后新容器至少保持运行这段时间，才认为该容器重建成功</li><li>terminationGracePeriodSeconds： 等待容器优雅退出的时间，不填默认用 Pod 中定义的</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>相关的代码实现可以查看这个 <a href="https://github.com/openkruise/kruise-tools/pull/66" target="_blank" rel="noopener">PR</a>。</p><p>这部分代码合并后下周会 release 新版本，想要尝鲜的同学可以 clone 项目后自行编译。</p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>这篇文章是 weekly-report 系列的第一篇，之所以开始这个系列，真是说来话长。差不多就是刚开始写 blog 的时候是想每周都输出一篇有点子质量的技术文章，发现这样太难了，一是没有这么多内容输出，二是很容易被其他杂事打乱，很难坚持。这次开始以开源周报的名义写每周的 blog，实际上是想以一种随意、自由的方式，输出一点东西，不计篇幅也不考究质量，只为记录，这样大概能坚持下去吧。</p><p>都说日拱一卒，我先周拱一卒。</p><hr>]]></content>
    
    <summary type="html">
    
      2022 NO.30 开源周报
    
    </summary>
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/categories/weekly-report/"/>
    
    
      <category term="weekly-report" scheme="https://cloudsjhan.github.io/tags/weekly-report/"/>
    
  </entry>
  
  <entry>
    <title>OpenKruise 源码分析之 ResourceDistribution</title>
    <link href="https://cloudsjhan.github.io/2022/07/11/OpenKruise-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-ResourceDistribution/"/>
    <id>https://cloudsjhan.github.io/2022/07/11/OpenKruise-源码分析之-ResourceDistribution/</id>
    <published>2022-07-11T03:52:53.000Z</published>
    <updated>2022-07-11T04:18:27.592Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><blockquote><p>OpenKruise 是基于 CRD 的拓展，包含了很多应用工作负载和运维增强能力，本系列文章会从源码和底层原理上解读各个组件，以帮助大家更好地使用和理解 OpenKruise。让我们开始 OpenKruise 的源码之旅吧！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>]]></content>
    
    <summary type="html">
    
      OpenKruise 源码分析之 ResourceDistribution
    
    </summary>
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/categories/OpenKruise/"/>
    
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/tags/OpenKruise/"/>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>OpenKruise 源码分析之 ContainerRecreateRequest</title>
    <link href="https://cloudsjhan.github.io/2022/07/03/OpenKruise-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-ContainerRecreateRequest/"/>
    <id>https://cloudsjhan.github.io/2022/07/03/OpenKruise-源码分析之-ContainerRecreateRequest/</id>
    <published>2022-07-03T13:30:24.000Z</published>
    <updated>2022-07-08T23:11:40.595Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><blockquote><p>OpenKruise 是基于 CRD 的拓展，包含了很多应用工作负载和运维增强能力，本系列文章会从源码和底层原理上解读各个组件，以帮助大家更好地使用和理解 OpenKruise。让我们开始 OpenKruise 的源码之旅吧！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://cloudsjhan.github.io/2022/06/19/OpenKruise-源码解读之原地升级/" title="OpenKruise 源码分析之原地升级">上一篇文章</a>中我们解读了 OpenKruise 原地升级的原理和相关代码，在此基础上我们来研究一个基于原地升级能力的组件 - <a href="https://openkruise.io/zh/docs/user-manuals/containerrecreaterequest" title="kruise CRR" target="_blank" rel="noopener">ContainerRecreateRequest</a>。<br><code>ContainerRecreateRequest(下文简称 CRR)</code> 能够重建 Pod 中一个或多个容器。该功能和 Kruise 提供的原地升级类似，当一个容器重建的时候，Pod 中的其他容器还保持正常运行。重建完成后，Pod 中除了该容器的 restartCount 增加以外不会有什么其他变化。如果挂载了 volume mount 挂载卷，卷中的数据不会丢失也不需要重新挂载。这个功能实现了运维容器与业务容器的管理分离，比如一个 Pod 中会有主容器中运行核心业务，sidecar 中运行运维容器，比如日志收集等.当业务容器需要重启的时候，传统的更新方式会让整个 Pod 重启从而导致运维容器无故被重启从而中断服务，而使用 ContainerRecreateRequest 可以实现只让特定的容器重启，高效的同时更加安全。</p><p>今天就让我们从源码的角度来看一下 <code>ContainerRecreateRequest</code> 的实现原理。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>我们先来看一下整个 <code>CRR</code> 的代码流程概览，可以看到整个过程主要有三个组件参与，包括 CRR 的 admission webhook， controller manager，以及我们上一篇就提到过的原地升级中的重要组件 - <code>kruise-daemon</code> 中的 <code>crr daemon controller</code>。</p><p><img src="https://tva3.sinaimg.cn/large/005UfcOkly8h3zb5cpihfj31go0mcwhy.jpg" alt=""></p><p>然后我们再逐步拆开讲解每一步的内容。</p><h3 id="1-create-CRR"><a href="#1-create-CRR" class="headerlink" title="1. create CRR"></a>1. create CRR</h3><p>先看一下 CRR 这个自定义资源的 schema 定义:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps.kruise.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ContainerRecreateRequest</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">pod-namespace</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podName:</span> <span class="string">pod-name</span></span><br><span class="line"><span class="attr">  containers:</span>       <span class="comment"># 要重建的容器名字列表，至少要有 1 个</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">app</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">sidecar</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    failurePolicy:</span> <span class="string">Fail</span>                 <span class="comment"># 'Fail' 或 'Ignore'，表示一旦有某个容器停止或重建失败， CRR 立即结束</span></span><br><span class="line"><span class="attr">    orderedRecreate:</span> <span class="literal">false</span>              <span class="comment"># 'true' 表示要等前一个容器重建完成了，再开始重建下一个</span></span><br><span class="line"><span class="attr">    terminationGracePeriodSeconds:</span> <span class="number">30</span>   <span class="comment"># 等待容器优雅退出的时间，不填默认用 Pod 中定义的</span></span><br><span class="line"><span class="attr">    unreadyGracePeriodSeconds:</span> <span class="number">3</span>        <span class="comment"># 在重建之前先把 Pod 设为 not ready，并等待这段时间后再开始执行重建</span></span><br><span class="line"><span class="attr">    minStartedSeconds:</span> <span class="number">10</span>               <span class="comment"># 重建后新容器至少保持运行这段时间，才认为该容器重建成功</span></span><br><span class="line"><span class="attr">  activeDeadlineSeconds:</span> <span class="number">300</span>        <span class="comment"># 如果 CRR 执行超过这个时间，则直接标记为结束（未结束的容器标记为失败）</span></span><br><span class="line"><span class="attr">  ttlSecondsAfterFinished:</span> <span class="number">1800</span>     <span class="comment"># CRR 结束后，过了这段时间自动被删除掉</span></span><br></pre></td></tr></table></figure><p>然后开始走读代码流程。</p><h4 id="1-1-检查-feature-gate"><a href="#1-1-检查-feature-gate" class="headerlink" title="1.1 检查 feature-gate"></a>1.1 检查 feature-gate</h4><p>当我们创建一个 CRR 的时候，会最先经过 adminssion webhook，webhook 中会最先检查当前 feature gates 中是否开启了 <code>kruise-daemon</code> ，因为这个功能依赖于 kruise-daemon 组件来停止 Pod 容器，如果 KruiseDaemon feature-gate 被关闭了，ContainerRecreateRequest 也将无法使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ContainerRecreateRequestHandler)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, req admission.Request)</span> <span class="title">admission</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !utilfeature.DefaultFeatureGate.Enabled(features.KruiseDaemon) &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusForbidden, fmt.Errorf(<span class="string">"feature-gate %s is not enabled"</span>, features.KruiseDaemon))</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-注入默认值并检查-Pod"><a href="#1-2-注入默认值并检查-Pod" class="headerlink" title="1.2 注入默认值并检查 Pod"></a>1.2 注入默认值并检查 Pod</h4><p>创建 CRR 的时候要为其注入一些特定的标签，为后面控制启动容器的流程做准备，比如打上 <code>ContainerRecreateRequestPodNameKey</code>，<code>ContainerRecreateRequestActiveKey</code>的标签:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.Labels[appsv1alpha1.ContainerRecreateRequestPodNameKey] = obj.Spec.PodName</span><br><span class="line">obj.Labels[appsv1alpha1.ContainerRecreateRequestActiveKey] = <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>检查当前处理的 Pod 是否符合更新条件，比如 Pod 是否是 active 的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPodActive</span><span class="params">(p *v1.Pod)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v1.PodSucceeded != p.Status.Phase &amp;&amp;</span><br><span class="line">v1.PodFailed != p.Status.Phase &amp;&amp;</span><br><span class="line">p.DeletionTimestamp == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及 Pod 是否已经完成调度，如果未完成调度的话就无法完成原地重启(无法使用部署到节点上的 kruise-daemon)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !kubecontroller.IsPodActive(pod) &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, fmt.Errorf(<span class="string">"not allowed to recreate containers in an inactive Pod"</span>))</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> pod.Spec.NodeName == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, fmt.Errorf(<span class="string">"not allowed to recreate containers in a pending Pod"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-将-Pod-中的信息注入到-CRR"><a href="#1-3-将-Pod-中的信息注入到-CRR" class="headerlink" title="1.3 将 Pod 中的信息注入到 CRR"></a>1.3 将 Pod 中的信息注入到 CRR</h4><p>CRR 的运行需要获取 Pod 的信息，比如获取 Pod 中的 <code>Lifecycle.PreStop</code> 让 kruise-daemon 执行 preStop hook 后把容器停掉，获取指定容器的 <code>containerID</code> 来判断重启后 containerID 的变化等。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err = injectPodIntoContainerRecreateRequest(obj, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, err)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> podContainer.Lifecycle != <span class="literal">nil</span> &amp;&amp; podContainer.Lifecycle.PreStop != <span class="literal">nil</span> &#123;</span><br><span class="line">c.PreStop = &amp;appsv1alpha1.ProbeHandler&#123;</span><br><span class="line">Exec:      podContainer.Lifecycle.PreStop.Exec,</span><br><span class="line">HTTPGet:   podContainer.Lifecycle.PreStop.HTTPGet,</span><br><span class="line">TCPSocket: podContainer.Lifecycle.PreStop.TCPSocket,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p><h3 id="2-CRR-controller"><a href="#2-CRR-controller" class="headerlink" title="2. CRR controller"></a>2. CRR controller</h3><p>创建 CRR 并为其注入相关信息后，CRR 的 controller manager 接管 CRR 的更新。</p><h4 id="2-1-同步-container-status"><a href="#2-1-同步-container-status" class="headerlink" title="2.1 同步 container status"></a>2.1 同步 container status</h4><p>CRR 的 status 中包含所要重启的 container 的相关状态信息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ContainerRecreateRequestStatus <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Phase of this ContainerRecreateRequest, e.g. Pending, Recreating, Completed</span></span><br><span class="line">Phase ContainerRecreateRequestPhase <span class="string">`json:"phase"`</span></span><br><span class="line"><span class="comment">// Represents time when the ContainerRecreateRequest was completed. It is not guaranteed to</span></span><br><span class="line"><span class="comment">// be set in happens-before order across separate operations.</span></span><br><span class="line"><span class="comment">// It is represented in RFC3339 form and is in UTC.</span></span><br><span class="line">CompletionTime *metav1.Time <span class="string">`json:"completionTime,omitempty"`</span></span><br><span class="line"><span class="comment">// A human readable message indicating details about this ContainerRecreateRequest.</span></span><br><span class="line">Message <span class="keyword">string</span> <span class="string">`json:"message,omitempty"`</span></span><br><span class="line"><span class="comment">// ContainerRecreateStates contains the recreation states of the containers.</span></span><br><span class="line">ContainerRecreateStates []ContainerRecreateRequestContainerRecreateState <span class="string">`json:"containerRecreateStates,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ContainerRecreateRequestContainerRecreateState <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Name of the container.</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line"><span class="comment">// Phase indicates the recreation phase of the container.</span></span><br><span class="line">Phase ContainerRecreateRequestPhase <span class="string">`json:"phase"`</span></span><br><span class="line"><span class="comment">// A human readable message indicating details about this state.</span></span><br><span class="line">Message <span class="keyword">string</span> <span class="string">`json:"message,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CRR controller 不断更新 container 的重启信息到 status 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileContainerRecreateRequest)</span> <span class="title">syncContainerStatuses</span><span class="params">(crr *appsv1alpha1.ContainerRecreateRequest, pod *v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller 同步 container status 的逻辑非常重要，在这里笔者曾经遇到一个诡异的问题，就是创建了好几个 CRR 后，其中几个 CRR 一直卡在 <code>Recreating</code> 的状态，即使 container 已经重启完成或者 TTL 到期也不会发生变化，详情可以见这个 <a href="https://github.com/openkruise/kruise/issues/895" title="kruise issue 895" target="_blank" rel="noopener">issue</a>。原因就是同步 container status 的逻辑跟时钟同步有关：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">containerStatus := util.GetContainerStatus(c.Name, pod)</span><br><span class="line"><span class="keyword">if</span> containerStatus == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Not found %s container in Pod Status for CRR %s/%s"</span>, c.Name, crr.Namespace, crr.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> containerStatus.State.Running == <span class="literal">nil</span> || containerStatus.State.Running.StartedAt.Before(&amp;crr.CreationTimestamp) &#123;</span><br><span class="line"><span class="comment">// 只有 container 的创建时间晚于 crr 的创建时间，才认为 crr 重启了 container，假如此时 CRR 所处节点或者 Pod 所在节点的时钟发生漂移，那有可能出现 container 创建的时间早于 crr 创建时间，即使该 container 是由 crr 控制重启。</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>经过排查后发现确实是好多 k8s Node 的 NTP server 出现问题导致时钟漂移，再加上上述的逻辑，就不难解释为何 CRR 会卡住不动了。</p><h4 id="2-2-make-pod-not-ready"><a href="#2-2-make-pod-not-ready" class="headerlink" title="2.2 make pod not ready"></a>2.2 make pod not ready</h4><p>CRR 在重启 container 之前会给 Pod 注入一个 <code>v1.PodConditionType</code> - <code>KruisePodReadyConditionType</code> 并置为 false， 使 Pod 进入 not ready 状态，从 service 的 Endpoint 上摘掉流量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">condition := GetReadinessCondition(newPod) <span class="comment">// 获取 KruisePodReadyConditionType condition</span></span><br><span class="line"><span class="keyword">if</span> condition == <span class="literal">nil</span> &#123; <span class="comment">// 如果没有设置，就新建一个</span></span><br><span class="line">_, messages := addMessage(<span class="string">""</span>, msg)</span><br><span class="line">newPod.Status.Conditions = <span class="built_in">append</span>(newPod.Status.Conditions, v1.PodCondition&#123;</span><br><span class="line">Type:               appspub.KruisePodReadyConditionType,</span><br><span class="line">Message:            messages.dump(),</span><br><span class="line">LastTransitionTime: metav1.Now(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果存在该 condition，就置为 false</span></span><br><span class="line">changed, messages := addMessage(condition.Message, msg)</span><br><span class="line"><span class="keyword">if</span> !changed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">condition.Status = v1.ConditionFalse</span><br><span class="line">condition.Message = messages.dump()</span><br><span class="line">condition.LastTransitionTime = metav1.Now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-kruise-daemon-controller"><a href="#3-kruise-daemon-controller" class="headerlink" title="3. kruise daemon controller"></a>3. kruise daemon controller</h3><p>CRR kruise daemon controller 会监听 CRR 资源的 create, update, delete 事件，然后在 <code>manage</code> 函数中更新 CRR。</p><h4 id="3-1-watch-CRR"><a href="#3-1-watch-CRR" class="headerlink" title="3.1 watch CRR"></a>3.1 watch CRR</h4><p>CRR controller 将 update 和 create 事件都加入到 process 队列中，等待处理。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">crr, ok := obj.(*appsv1alpha1.ContainerRecreateRequest)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">enqueue(queue, crr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(oldObj, newObj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">crr, ok := newObj.(*appsv1alpha1.ContainerRecreateRequest)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">enqueue(queue, crr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">crr, ok := obj.(*appsv1alpha1.ContainerRecreateRequest)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">resourceVersionExpectation.Delete(crr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="3-2-CRR-phase-to-recreating"><a href="#3-2-CRR-phase-to-recreating" class="headerlink" title="3.2 CRR phase to recreating"></a>3.2 CRR phase to recreating</h4><p>daemon controller 的代码入口处先把 CRR 的 phase 设置为 <code>ContainerRecreateRequestRecreating</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once first update its phase to recreating</span></span><br><span class="line"><span class="keyword">if</span> crr.Status.Phase != appsv1alpha1.ContainerRecreateRequestRecreating &#123;</span><br><span class="line"><span class="keyword">return</span> c.updateCRRPhase(crr, appsv1alpha1.ContainerRecreateRequestRecreating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-wait-for-unready-grace-period"><a href="#3-3-wait-for-unready-grace-period" class="headerlink" title="3.3 wait for unready grace period"></a>3.3 wait for unready grace period</h4><p>CRR 中的 <code>unreadyGracePeriodSeconds</code> 表示在 2.2 步骤中将 Pod 设置为 not ready 后等待多久再执行 restart container。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crr_daemon_controller.go</span></span><br><span class="line"></span><br><span class="line">leftTime := time.Duration(*crr.Spec.Strategy.UnreadyGracePeriodSeconds)*time.Second - time.Since(unreadyTime)</span><br><span class="line"><span class="keyword">if</span> leftTime &gt; <span class="number">0</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">"CRR %s/%s is waiting for unready grace period %v left time."</span>, crr.Namespace, crr.Name, leftTime)</span><br><span class="line">c.queue.AddAfter(crr.Namespace+<span class="string">"/"</span>+crr.Spec.PodName, leftTime+<span class="number">100</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-KillContainer"><a href="#3-4-KillContainer" class="headerlink" title="3.4 KillContainer"></a>3.4 KillContainer</h4><p>kruise-daemon 会执行 preStop hook 后把容器停掉，然后 kubelet 感知到容器退出，则会新建一个容器并启动。 最后 kruise-daemon 看到新容器已经启动成功超过 minStartedSeconds 时间后，会上报这个容器的 phase 状态为 Succeeded。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// crr_daemon_controller.go</span></span><br><span class="line">err := runtimeManager.KillContainer(pod, kubeContainerStatus.ID, state.Name, msg, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><h4 id="3-5-更新-CRRContainerRecreateStates"><a href="#3-5-更新-CRRContainerRecreateStates" class="headerlink" title="3.5 更新 CRRContainerRecreateStates"></a>3.5 更新 CRRContainerRecreateStates</h4><p>不断更新 CRR status 中关于 container 的状态信息 - <code>containerRecreateStates</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.patchCRRContainerRecreateStates(crr, newCRRContainerRecreateStates)</span><br></pre></td></tr></table></figure></p><h3 id="4-完成-CRR"><a href="#4-完成-CRR" class="headerlink" title="4. 完成 CRR"></a>4. 完成 CRR</h3><h4 id="4-1-CRR-置为-completed"><a href="#4-1-CRR-置为-completed" class="headerlink" title="4.1 CRR 置为 completed"></a>4.1 CRR 置为 completed</h4><p>这部分逻辑在 <code>controller manager</code> 和 <code>kruise daemon</code> 都有，而且判定 CRR completed 的方式比较多，这里举几个典型的例子：</p><h5 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1"></a>4.1.1</h5><p>当完成重启 container 的数量跟 CRR 中 ContainerRecreateStates 的数组长度一致的时候认为已经完成所有容器的重启工作，可以标记 CRR 为完成。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> completedCount == <span class="built_in">len</span>(newCRRContainerRecreateStates) &#123;</span><br><span class="line"><span class="keyword">return</span> c.completeCRRStatus(crr, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="4-1-2"><a href="#4-1-2" class="headerlink" title="4.1.2"></a>4.1.2</h5><p>当发现有容器重启失败了，并且策略是 <code>ignore</code> 就直接标记本次 CRR 为 completed。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> appsv1alpha1.ContainerRecreateRequestFailed:</span><br><span class="line">completedCount++</span><br><span class="line"><span class="keyword">if</span> crr.Spec.Strategy.FailurePolicy == appsv1alpha1.ContainerRecreateRequestFailurePolicyIgnore &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.completeCRRStatus(crr, <span class="string">""</span>)</span><br></pre></td></tr></table></figure></p><h5 id="4-1-3"><a href="#4-1-3" class="headerlink" title="4.1.3"></a>4.1.3</h5><p>上面两个例子都是在 <code>crr_daemon_controller.go</code> 中的，这里列一个 <code>crr_controller</code> 判定完成的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> crr.Spec.ActiveDeadlineSeconds != <span class="literal">nil</span> &#123;</span><br><span class="line">leftTime := time.Duration(*crr.Spec.ActiveDeadlineSeconds)*time.Second - time.Since(crr.CreationTimestamp.Time)</span><br><span class="line"><span class="keyword">if</span> leftTime &lt;= <span class="number">0</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">"Complete CRR %s/%s as failure for recreating has exceeded the activeDeadlineSeconds"</span>, crr.Namespace, crr.Name)</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, r.completeCRR(crr, <span class="string">"recreating has exceeded the activeDeadlineSeconds"</span>)</span><br><span class="line">&#125;</span><br><span class="line">duration.Update(leftTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CRR 在规定的 TTL 时间里没有完成任务，会被在这里标记为完成，但是会标记一个含有失败信息的 message。</p><h4 id="4-2-到期删除-CRR"><a href="#4-2-到期删除-CRR" class="headerlink" title="4.2 到期删除 CRR"></a>4.2 到期删除 CRR</h4><p>如果 CRR 设置了 <code>TTLSecondsAfterFinished</code> 字段，达到该时间后，系统就会将 CRR 删除，这对定期清理已经完成的 CRR 很有帮助。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> crr.Spec.TTLSecondsAfterFinished != <span class="literal">nil</span> &#123;</span><br><span class="line">leftTime = time.Duration(*crr.Spec.TTLSecondsAfterFinished)*time.Second - time.Since(crr.Status.CompletionTime.Time)</span><br><span class="line"><span class="keyword">if</span> leftTime &lt;= <span class="number">0</span> &#123;</span><br><span class="line">klog.Infof(<span class="string">"Deleting CRR %s/%s for ttlSecondsAfterFinished"</span>, crr.Namespace, crr.Name)</span><br><span class="line"><span class="keyword">if</span> err = r.Delete(context.TODO(), crr); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, fmt.Errorf(<span class="string">"delete CRR error: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>文章的结尾再来回顾一下 CRR 是如何在几个组件协作之下工作的：<br><img src="https://tva3.sinaimg.cn/large/005UfcOkly8h3zwumldtfj31hg0re0z7.jpg" alt=""></p><p>传统的 Pod 重启就是将原有的 Pod 删除，等待重建新的 Pod，而 CRR 的出现为我们提供了一种全新的重启服务的方式。</p><hr>]]></content>
    
    <summary type="html">
    
      OpenKruise 源码剖析之 ContainerRecreateRequest
    
    </summary>
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/categories/OpenKruise/"/>
    
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/tags/OpenKruise/"/>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>OpenKruise 源码剖析之原地升级</title>
    <link href="https://cloudsjhan.github.io/2022/06/19/OpenKruise-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%8E%9F%E5%9C%B0%E5%8D%87%E7%BA%A7/"/>
    <id>https://cloudsjhan.github.io/2022/06/19/OpenKruise-源码解读之原地升级/</id>
    <published>2022-06-19T03:00:33.000Z</published>
    <updated>2022-07-02T03:23:38.796Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><blockquote><p>OpenKruise 是基于 CRD 的拓展，包含了很多应用工作负载和运维增强能力，本系列文章会从源码和底层原理上解读各个组件，以帮助大家更好地使用和理解 OpenKruise。让我们开始 OpenKruise 的源码之旅吧！</p></blockquote><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p><a href="https://openkruise.io/" title="OpenKruise" target="_blank" rel="noopener">OpenKruise</a> 是针对 Kubernetes 的增强能力套件，聚焦于云原生应用的部署、升级、运维、稳定性防护等领域。OpenKruise 提供的绝大部分能力都是基于 CRD 扩展来定义，它们不存在于任何外部依赖，可以运行在任意纯净的 Kubernetes 集群中。它包含了一系列增强版本的 Workloads（工作负载），比如 CloneSet、Advanced StatefulSet、Advanced DaemonSet、BroadcastJob 等, 它们不仅支持类似于 Kubernetes 原生 Workloads 的基础功能，还提供了如原地升级、可配置的扩缩容/发布策略、并发操作等。<br><img src="https://tva4.sinaimg.cn/large/005UfcOkly8h3se6zfp1kj30ge0dpjsh.jpg" alt=""><br>其中原地升级是 OpenKruise 的核心功能, 它只需要使用新的镜像重建 Pod 中的特定容器，整个 Pod 以及其中的其他容器都不会被影响。因此它带来了更快的发布速度，以及避免了对其他 Scheduler、CNI、CSI 等组件的负面影响， 像 CloneSet、AdvancedStatefulSet、AdvancedDaemonSet、SidecarSet 的热更新机制，ContainerRestartRequest 等功能都依赖原地升级。理解原地升级之后再去研究其他组件就会事半功倍，所以本文首先带大家分析原地升级的源码，来一窥其底层原理。</p><p>有关原地升级的使用和介绍可以先阅读<a href="https://openkruise.io/zh/docs/core-concepts/inplace-update" title="什么是原地升级" target="_blank" rel="noopener">这篇文档</a>，下面让我们开始解读源码。</p><h2 id="2-源码解读"><a href="#2-源码解读" class="headerlink" title="2. 源码解读"></a>2. 源码解读</h2><h3 id="2-1-Before-Pod-Update"><a href="#2-1-Before-Pod-Update" class="headerlink" title="2.1 Before Pod Update"></a>2.1 Before Pod Update</h3><h4 id="2-1-1-reconcile-入口函数"><a href="#2-1-1-reconcile-入口函数" class="headerlink" title="2.1.1 reconcile 入口函数"></a>2.1.1 reconcile 入口函数</h4><p>我们以 CloneSet 为例，当 CloneSet 更新后，相应的 controller 感知到资源变化，此时代码会走到 <code>cloneset_controller.go</code> 的 <code>doReconcile</code> 函数，该函数是处理 CloneSet 更新的主干入口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileCloneSet)</span> <span class="title">doReconcile</span><span class="params">(request reconcile.Request)</span> <span class="params">(res reconcile.Result, retErr error)</span></span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-syncCloneSet"><a href="#2-1-2-syncCloneSet" class="headerlink" title="2.1.2 syncCloneSet"></a>2.1.2 syncCloneSet</h4><p>经过一系列检查后，执行到 <code>syncCloneSet</code>, 该函数主要是处理 CloneSet 的 scale 和 update pod 的细节, 我们这里只关注 update 操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReconcileCloneSet)</span> <span class="title">syncCloneSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">instance *appsv1alpha1.CloneSet, newStatus *appsv1alpha1.CloneSetStatus,</span></span></span><br><span class="line"><span class="function"><span class="params">currentRevision, updateRevision *apps.ControllerRevision, revisions []*apps.ControllerRevision,</span></span></span><br><span class="line"><span class="function"><span class="params">filteredPods []*v1.Pod, filteredPVCs []*v1.PersistentVolumeClaim,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>Kruise 专门为这两个操作声明了两个 interface,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface for managing pods scaleing and updating.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Scale(</span><br><span class="line">currentCS, updateCS *appsv1alpha1.CloneSet,</span><br><span class="line">currentRevision, updateRevision <span class="keyword">string</span>,</span><br><span class="line">pods []*v1.Pod, pvcs []*v1.PersistentVolumeClaim,</span><br><span class="line">) (<span class="keyword">bool</span>, error)</span><br><span class="line"></span><br><span class="line">Update(cs *appsv1alpha1.CloneSet,</span><br><span class="line">currentRevision, updateRevision *apps.ControllerRevision, revisions []*apps.ControllerRevision,</span><br><span class="line">pods []*v1.Pod, pvcs []*v1.PersistentVolumeClaim,</span><br><span class="line">) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cloneset_update.go</code> 中实现了上述接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *realControl)</span> <span class="title">Update</span><span class="params">(cs *appsv1alpha1.CloneSet,</span></span></span><br><span class="line"><span class="function"><span class="params">currentRevision, updateRevision *apps.ControllerRevision, revisions []*apps.ControllerRevision,</span></span></span><br><span class="line"><span class="function"><span class="params">pods []*v1.Pod, pvcs []*v1.PersistentVolumeClaim,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-Pod-状态检查"><a href="#2-1-3-Pod-状态检查" class="headerlink" title="2.1.3 Pod 状态检查"></a>2.1.3 Pod 状态检查</h4><p>在对 pod 执行真正的 Update 之前，Kruise 做了很多的校验，比如更新 pod 的 lifecycle 的 state，设置可以更新的最大数量，过滤掉不符合 update 条件的 pod等。下面代码的注释中给出了详细的分析。</p><blockquote><p>有关 lifecycle(生命周期钩子) 的更多介绍，可以继续阅读 <a href="https://openkruise.io/zh/docs/user-manuals/cloneset#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" title="OpenKruise lifecycle" target="_blank" rel="noopener">这篇文档</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">    <span class="comment">// 判断该 pod 是否暂停升级</span></span><br><span class="line"><span class="keyword">if</span> coreControl.IsPodUpdatePaused(pod) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitUpdate, canUpdate <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> diffRes.updateNum &gt; <span class="number">0</span> &#123;</span><br><span class="line">waitUpdate = !clonesetutils.EqualToRevisionHash(<span class="string">""</span>, pod, updateRevision.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">waitUpdate = clonesetutils.EqualToRevisionHash(<span class="string">""</span>, pod, updateRevision.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> waitUpdate &#123;</span><br><span class="line"><span class="keyword">switch</span> lifecycle.GetPodLifecycleState(pod) &#123;</span><br><span class="line">                <span class="comment">// 准备删除的 Pod 就不升级了</span></span><br><span class="line"><span class="keyword">case</span> appspub.LifecycleStatePreparingDelete:</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"CloneSet %s/%s find pod %s in state %s, so skip to update it"</span>,</span><br><span class="line">cs.Namespace, cs.Name, pod.Name, lifecycle.GetPodLifecycleState(pod))</span><br><span class="line">                    <span class="comment">// 已经更新完成的 Pod 无须升级</span></span><br><span class="line"><span class="keyword">case</span> appspub.LifecycleStateUpdated:</span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"CloneSet %s/%s find pod %s in state %s but not in updated revision"</span>,</span><br><span class="line">cs.Namespace, cs.Name, pod.Name, appspub.LifecycleStateUpdated)</span><br><span class="line">canUpdate = <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> gracePeriod, _ := appspub.GetInPlaceUpdateGrace(pod); gracePeriod != <span class="string">""</span> &#123;</span><br><span class="line">                    <span class="comment">// 原地升级中提供了 graceful period 选项，作为优雅原地升级的策略。用户如果配置了 gracePeriodSeconds 这个字段，控制器在原地升级的过程中会先把 Pod status 改为 not-ready，然后等一段时间（gracePeriodSeconds），最后再去修改 Pod spec 中的镜像版本。 这样，就为 endpoints-controller 这些控制器留出了充足的时间来将 Pod 从 endpoints 端点列表中去除。</span></span><br><span class="line">klog.V(<span class="number">3</span>).Infof(<span class="string">"CloneSet %s/%s find pod %s still in grace period %s, so skip to update it"</span>,</span><br><span class="line">cs.Namespace, cs.Name, pod.Name, gracePeriod)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">canUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> canUpdate &#123;</span><br><span class="line">waitUpdateIndexes = <span class="built_in">append</span>(waitUpdateIndexes, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// PUB 是 OPenKruise 的可用性防护组件，是原生 PDB 的升级版，在升级的场景里也需要检查一下是否符合 PUB 的要求</span></span><br><span class="line">    allowed, _, err := pubcontrol.PodUnavailableBudgetValidatePod(c.Client, pod, pubcontrol.NewPubControl(pub, c.controllerFinder, c.Client), pubcontrol.UpdateOperation, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里有关于 <a href="https://openkruise.io/zh/docs/user-manuals/podunavailablebudget" title="PodUnavailableBudget" target="_blank" rel="noopener">PUB</a> 的详细介绍，感兴趣的可以继续深入了解。</p></blockquote><h3 id="2-2-Check-About-Pod-Inplace-Update"><a href="#2-2-Check-About-Pod-Inplace-Update" class="headerlink" title="2.2 Check About Pod Inplace Update"></a>2.2 Check About Pod Inplace Update</h3><h4 id="2-2-1-选择-UpdateStrategy-Inplace"><a href="#2-2-1-选择-UpdateStrategy-Inplace" class="headerlink" title="2.2.1 选择 UpdateStrategy = Inplace"></a>2.2.1 选择 UpdateStrategy = Inplace</h4><p>进入到 <code>updatePod</code> 函数，开始升级 Pod。要想使用原地升级机制，必须在 CloneSet 的 Spec 中指定 UpdateStrategy 的 Type 为 <code>InPlaceIfPossible</code> 或者 <code>InPlaceOnly</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cs.Spec.UpdateStrategy.Type == appsv1alpha1.InPlaceIfPossibleCloneSetUpdateStrategyType ||</span><br><span class="line">cs.Spec.UpdateStrategy.Type == appsv1alpha1.InPlaceOnlyCloneSetUpdateStrategyType &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-CanUpdateInPlace-检查是否满足原地升级的条件"><a href="#2-2-2-CanUpdateInPlace-检查是否满足原地升级的条件" class="headerlink" title="2.2.2 CanUpdateInPlace 检查是否满足原地升级的条件"></a>2.2.2 CanUpdateInPlace 检查是否满足原地升级的条件</h4><p>当 Kruise workload 的升级类型名为 <code>InplaceOnly</code> 的时候，表示强制使用原地升级，如果不满足原地升级条件，就会报错； 如果是 <code>InPlaceIfPossible</code>，它意味着 Kruise 会尽量对 Pod 采取原地升级，如果不能则退化到重建升级。</p><p>只有满足以下的改动条件会被允许执行原地升级：</p><ol><li>更新 workload 中的 <code>spec.template.metadata.*</code>，比如 labels/annotations，Kruise 只会将 metadata 中的改动更新到存量 Pod 上。</li><li>更新 workload 中的 <code>spec.template.spec.containers[x].image</code>，Kruise 会原地升级 Pod 中这些容器的镜像，而不会重建整个 Pod。</li><li>从 Kruise v1.0 版本开始（包括 v1.0 alpha/beta），更新 <code>spec.template.metadata.labels/annotations</code> 并且 container 中有配置 env from 这些改动的 labels/anntations，Kruise 会原地升级这些容器来生效新的 env 值。</li></ol><p>否则，其他字段的改动，比如 spec.template.spec.containers[x].env 或 spec.template.spec.containers[x].resources，都是会回退为重建升级。</p><p>完成这项检查的代码如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultCalculateInPlaceUpdateSpec</span><span class="params">(oldRevision, newRevision *apps.ControllerRevision, opts *UpdateOptions)</span> *<span class="title">UpdateSpec</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    patches, err := jsonpatch.CreatePatch(oldRevision.Data.Raw, newRevision.Data.Raw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oldTemp, err := GetTemplateFromRevision(oldRevision)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">newTemp, err := GetTemplateFromRevision(newRevision)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>defaultCalculateInPlaceUpdateSpec</code> 会计算出新旧两个版本的差异，如果 diff 中只包含第2步骤中的改动，就执行原地升级。</p><h4 id="2-2-3-更新-Pod-Readiness-gate"><a href="#2-2-3-更新-Pod-Readiness-gate" class="headerlink" title="2.2.3 更新 Pod Readiness-gate"></a>2.2.3 更新 Pod Readiness-gate</h4><p>符合原地升级条件的 pod 都会在 condition 中增加 <code>InPlaceUpdateReady</code> 的 ConditionType，开始原地升级的时候，将该值置为 false，如果 Pod 上层有 Service 的话，就会自动将准备升级的 pod 从 Endpoint 上摘下，避免升级过程中有流量损失。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> containsReadinessGate(pod) &#123;</span><br><span class="line">newCondition := v1.PodCondition&#123;</span><br><span class="line">Type:               appspub.InPlaceUpdateReady,</span><br><span class="line">LastTransitionTime: metav1.NewTime(Clock.Now()),</span><br><span class="line">Status:             v1.ConditionFalse,</span><br><span class="line">Reason:             <span class="string">"StartInPlaceUpdate"</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Begin-Inplace-update"><a href="#2-3-Begin-Inplace-update" class="headerlink" title="2.3 Begin Inplace update"></a>2.3 Begin Inplace update</h3><h4 id="2-3-1-Pod-annotation-中记录升级信息"><a href="#2-3-1-Pod-annotation-中记录升级信息" class="headerlink" title="2.3.1 Pod annotation 中记录升级信息"></a>2.3.1 Pod annotation 中记录升级信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inPlaceUpdateState := appspub.InPlaceUpdateState&#123;</span><br><span class="line">Revision:              spec.Revision,</span><br><span class="line">UpdateTimestamp:       metav1.NewTime(Clock.Now()),</span><br><span class="line">UpdateEnvFromMetadata: spec.UpdateEnvFromMetadata,</span><br><span class="line">&#125;</span><br><span class="line">inPlaceUpdateStateJSON, _ := json.Marshal(inPlaceUpdateState)</span><br><span class="line">clone.Annotations[appspub.InPlaceUpdateStateKey] = <span class="keyword">string</span>(inPlaceUpdateStateJSON)</span><br></pre></td></tr></table></figure><h4 id="2-3-2-根据配置设置-GracefulPeriod"><a href="#2-3-2-根据配置设置-GracefulPeriod" class="headerlink" title="2.3.2 根据配置设置 GracefulPeriod"></a>2.3.2 根据配置设置 GracefulPeriod</h4><p>原地升级中提供了 graceful period 选项，作为优雅原地升级的策略。用户如果配置了 <code>gracePeriodSeconds</code> 这个字段，控制器在原地升级的过程中会先把 Pod status 改为 not-ready，然后等一段时间（gracePeriodSeconds），最后再去修改 Pod spec 中的镜像版本。 这样，就为 endpoints-controller 这些控制器留出了充足的时间来将 Pod 从 endpoints 端点列表中去除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> spec.GraceSeconds &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> clone, err = opts.PatchSpecToPod(clone, spec, &amp;inPlaceUpdateState); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">appspub.RemoveInPlaceUpdateGrace(clone)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Put the info into annotation</span></span><br><span class="line">            <span class="comment">// 此处设置了 GracePeriod 后，效果会在 上面的 reconcile controller 中体现</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-Update-Pod"><a href="#2-3-3-Update-Pod" class="headerlink" title="2.3.3 Update Pod"></a>2.3.3 Update Pod</h4><p>在这里就调用 <code>UpdatePod</code> 方法开始真正对 Pod 做升级了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newPod, updateErr := c.podAdapter.UpdatePod(clone)</span><br></pre></td></tr></table></figure></p><p>以上原地升级相关的逻辑都是由 <code>kruise_manager</code> 组件负责的，但是当执行 <code>UpdatePod</code> 后，<code>Kruise_manager</code> 就只负责正常的 workload 状态更新，Container 的更新由原地升级的核心组件 <code>Kruise-demaon</code> 接管。</p><h3 id="2-4-kruise-daemon"><a href="#2-4-kruise-daemon" class="headerlink" title="2.4 kruise_daemon"></a>2.4 kruise_daemon</h3><p>当 Kubelet 收到一个 Pod 创建之后，通过 CRI（Container Runtime Interface） , CNI 以及类似的公共接口（例如 CSI）来调用底层真正的接口实现者去完成操作。对于容器运行时来说，是通过 CRI 接口调用底层真正的 Runtime 运行时来完成对容器的创建和启动镜像拉取这些操作。其中 CRI 是 Kubernetes1.5 之后加入的一个<a href="https://github.com/kubernetes/cri-api" title="cri-api" target="_blank" rel="noopener">新功能</a>，由协议缓冲区和 gRPC API 组成，提供了一个明确定义的抽象层，它的目的是对于 Kubelet 能屏蔽底下 Runtime 实现的细节而只显示所需的接口。</p><p><img src="https://tva2.sinaimg.cn/large/005UfcOkly8h3sdj2vcjzj30mv0fraaw.jpg" alt=""></p><p><code>Kruise_daemon</code> 就是一个全新的组件，作为 DaemonSet 部署到每个节点上，可以连接到节点上的 CRI API，来拓展 Kubernetes 容器进行时的操作, 它也可以调用 CRI 这一层来实现 Container Runtime 层面的能力，比如它可以拉镜像，可以重启容器。</p><h4 id="2-4-1-Kruise-daemon-入口"><a href="#2-4-1-Kruise-daemon-入口" class="headerlink" title="2.4.1 Kruise_daemon 入口"></a>2.4.1 Kruise_daemon 入口</h4><p><code>kruise_daemon</code> 的入口函数在 <code>kruise/cmd/daemon/main.go</code> 中，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d, err := daemon.NewDaemon(cfg, *bindAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">"Failed to new daemon: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入到 <code>NewDaemon</code> 函数中看一眼，发现这个 daemon 服务本质上也是几个 controller，用来监听相应的 Pod 变化并执行操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kruise/pkg/daemon/daemon.go</span></span><br><span class="line"><span class="comment">// 在这里也能看到很多组件都在这个函数中注册了 controller，因为这些组件都依赖原地升级的能力，比如 ImagePull, ContaienrRestartRequest 等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.DaemonWatchingPod) &#123;</span><br><span class="line">    <span class="comment">// DaemonWatchingPod enables kruise-daemon to list watch pods that belong to the same node.</span></span><br><span class="line">containerMetaController, err := containermeta.NewController(opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"failed to new containermeta controller: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">runnables = <span class="built_in">append</span>(runnables, containerMetaController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-计算-PlainHash-或者-ExtractedEnvFromMetadataHash"><a href="#2-4-2-计算-PlainHash-或者-ExtractedEnvFromMetadataHash" class="headerlink" title="2.4.2  计算 PlainHash 或者 ExtractedEnvFromMetadataHash"></a>2.4.2  计算 PlainHash 或者 ExtractedEnvFromMetadataHash</h4><p>2.4.2.1 如果只是 image update 的话，只需要更新 image 字段，kubelet 来执行 preStop 和 container restart。这是因为 Kubelet 在创建每个容器时，会为容器计算一个 <code>hash</code> 值，当上层修改了容器的 image 之后，Kubelet 就认为容器的 <code>hash</code> 值发生了变化。当 Kubelet 发现 Pod spec 中容器的 hash 值和实际的，如 container 对应的 <code>hash</code> 值不一致时，就会把旧的容器停掉，用新的镜像再重建新的容器，从而实现容器的原地升级的能力。</p><p>2.4.2.2 从 <code>Kruise v1.0</code> 版本开始（包括 v1.0 alpha/beta），更新 <code>spec.template.metadata.labels/annotations</code> 并且 container 中有配置 env from 这些改动的 labels/anntations，Kruise 会原地升级这些容器来生效新的 env 值。也就是修改环境变量 kruise 也支持原地重启，这部分工作就是由 kruise daemon 来完成的，核心的代码在 <code>kruise/pkg/daemon/containermeta/container_meta_controller.go</code> 中。</p><ol><li>开启 InPlaceUpdateEnvFromMetadata feature gate</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.InPlaceUpdateEnvFromMetadata)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>计算 ExtractedEnvFromMetadataHash</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerMeta.Hashes.ExtractedEnvFromMetadataHash, err = envHasher.GetCurrentHash(containerSpec, envGetter)</span><br></pre></td></tr></table></figure></li><li><p>将 container ID 传到 restarter 的处理队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.restarter.queue.AddRateLimited(status.ID)</span><br></pre></td></tr></table></figure></li></ol><p>restarter controller 专门用来处理需要原地重启的 container 队列，核心逻辑在 <code>sync</code> 函数中，上一步中加到队列的 <code>containerID</code> 就会在这里被处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *restartController)</span> <span class="title">sync</span><span class="params">(containerID kubeletcontainer.ContainerID)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>执行 killCOntainer</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *genericRuntimeManager)</span> <span class="title">KillContainer</span><span class="params">(pod *v1.Pod, containerID kubeletcontainer.ContainerID, containerName <span class="keyword">string</span>, message <span class="keyword">string</span>, gracePeriodOverride *<span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p><code>KillContainer</code> 中有两个重要的操作，首先调用对旧的 container 执行 <code>preStop</code> （如果有的话），然后调用容器运行时接口 <code>StopContainer</code>将容器停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the pre-stop lifecycle hooks if applicable and if there is enough time to run it</span></span><br><span class="line"><span class="keyword">if</span> containerSpec.Lifecycle != <span class="literal">nil</span> &amp;&amp; containerSpec.Lifecycle.PreStop != <span class="literal">nil</span> &amp;&amp; gracePeriod &gt; <span class="number">0</span> &#123;</span><br><span class="line">gracePeriod = gracePeriod - m.executePreStopHook(pod, containerID, containerSpec, gracePeriod)</span><br><span class="line">&#125;</span><br><span class="line">   ...</span><br><span class="line">   err := m.runtimeService.StopContainer(containerID.ID, gracePeriod)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h4 id="2-4-3-kubelet-image-pull-amp-create-container"><a href="#2-4-3-kubelet-image-pull-amp-create-container" class="headerlink" title="2.4.3 kubelet image pull &amp; create container"></a>2.4.3 kubelet image pull &amp; create container</h4><p>在上一步中容器被停止后，kubelet 会开始新建容器，然后更新容器的状态。</p><h4 id="2-4-4-kruise-manager-同步-pod-状态"><a href="#2-4-4-kruise-manager-同步-pod-状态" class="headerlink" title="2.4.4 kruise manager 同步 pod 状态"></a>2.4.4 kruise manager 同步 pod 状态</h4><p>与此同时，相关的 controller 也在同步 Pod/workloads 升级的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = r.statusUpdater.UpdateCloneSetStatus(instance, &amp;newStatus, filteredPods); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> reconcile.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-5-kubelet-标记-Pod-Ready"><a href="#2-4-5-kubelet-标记-Pod-Ready" class="headerlink" title="2.4.5 kubelet 标记 Pod Ready"></a>2.4.5 kubelet 标记 Pod Ready</h4><p>完成更新后，由 kubelet 标记 Pod Ready，kruise manager 将相应的 worklod 同步为更新完成。</p><p>至此，整个原地升级的流程就完成了。不难发现，原地升级除了用到原生 kubernetes 提供的 informer controller 机制外，最核心的也是最有亮点的地方就是巧妙地实现了一个类似 kubelet 的 plugin - <code>kruise daemon</code>， 为我们提供了一种全新的 Kubernetes 容器运行时 operations 的拓展思路。</p><h2 id="3-源码流程图"><a href="#3-源码流程图" class="headerlink" title="3. 源码流程图"></a>3. 源码流程图</h2><p>以上的代码可以总结简化为下面<a href="https://openkruise.io/zh/docs/core-concepts/inplace-update/" target="_blank" rel="noopener">这张图</a>：</p><p><img src="https://tva2.sinaimg.cn/large/005UfcOkly8h3se47ep4tj31po0u0gq1.jpg" alt=""></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>原地升级是 OpenKruise 的核心能力，是其他组件和功能实现的基石。了解其底层实现原理和源码能够扩宽自己的技术视野，加深对 kubernetes 的理解，给我们提供了一种新的拓展 kubelet 的新思路。同时，当我们在使用 Openkruise 遇到问题的时候，了解源码也有助于问题的排查。</p><hr>]]></content>
    
    <summary type="html">
    
      从源码解读 OpenKruise 原地升级的原理
    
    </summary>
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/categories/OpenKruise/"/>
    
    
      <category term="OpenKruise" scheme="https://cloudsjhan.github.io/tags/OpenKruise/"/>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>[摘要]如何构建分布式数据库 severless 服务?</title>
    <link href="https://cloudsjhan.github.io/2022/06/12/%E6%91%98%E8%A6%81-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-severless-%E6%9C%8D%E5%8A%A1/"/>
    <id>https://cloudsjhan.github.io/2022/06/12/摘要-如何构建分布式数据库-severless-服务/</id>
    <published>2022-06-12T09:37:32.000Z</published>
    <updated>2022-06-12T10:28:08.637Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="分布式数据库-severless-服务要点"><a href="#分布式数据库-severless-服务要点" class="headerlink" title="分布式数据库 severless 服务要点"></a>分布式数据库 severless 服务要点</h1><p>最近在读一些分布式数据库 serverless 服务化的文章，从中总结出一些构建此类服务面临的痛点以及如何破局的要点，算是一个读书笔记。主要参考的文章有 <a href="https://www.zenlife.tk/cockroach-severless.md" title="cockroachdb severless 解读" target="_blank" rel="noopener">cockroachdb severless 解读</a>, <a href="https://www.cockroachlabs.com/blog/how-we-built-cockroachdb-serverless/" title="How we built a forever-free serverless SQL database" target="_blank" rel="noopener">How we built a forever-free serverless SQL database</a>。</p><h3 id="大致内容提纲"><a href="#大致内容提纲" class="headerlink" title="大致内容提纲"></a>大致内容提纲</h3><p><img src="https://files.mdnice.com/user/4760/5032ef9f-f00b-4f09-82d3-2467f7ee07c6.png" alt="内容提要"></p><h3 id="为什么要云原生数据库"><a href="#为什么要云原生数据库" class="headerlink" title="为什么要云原生数据库"></a>为什么要云原生数据库</h3><p>数据库的 scale 能力决定了这个产品的上限，而一家公司能用多少人服务多少客户的 scale 能力，决定了公司营收的上限。而破局的方式就是数据库上云，把数据库的服务化，降低门槛。</p><h3 id="为什么要-serverless-化"><a href="#为什么要-serverless-化" class="headerlink" title="为什么要 serverless 化"></a>为什么要 serverless 化</h3><p>serverless 卖服务的形式，一个集群就可以服务”无穷”个租户，只要没有实际的使用，并不会产生成本。多增加一个租户，它的边际成本是零。所以这个模式是 scalable 的。</p><p>而为了实现 serverless 的目的，云原生数据库的架构大多是存储和计算分离的。</p><h3 id="多租户的资源隔离问题"><a href="#多租户的资源隔离问题" class="headerlink" title="多租户的资源隔离问题"></a>多租户的资源隔离问题</h3><p>如果是多租户共享计算层和存储层，那复杂 SQL 就会将整个集群的资源耗尽，影响其他租户；</p><p>如果是每个租户独享各自的计算层和存储层，也就是回到了每个租户一套集群的模式，成本非常高。</p><p>综上因素，比较好的方式是独享计算层，共享存储层。上层的 SQL 是租户之间物理隔离的，下面的 kv 存储是由所有租户去共享的。</p><h3 id="共享存储之后，如何区分租户数据"><a href="#共享存储之后，如何区分租户数据" class="headerlink" title="共享存储之后，如何区分租户数据"></a>共享存储之后，如何区分租户数据</h3><p>共享存储层后，可以在请求的 key 的编码中添加 tenant-id，多租户模式下，SQL 的表的数据映射成 kv 数据，最终的编码是 <code>/tenant-id/table-id/index-id/key</code>。</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><p><img src="https://files.mdnice.com/user/4760/664fe773-e326-4299-b061-187481c95389.png" alt="云原生数据库集群架构"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>Block storage: 多租户共享的存储</p><p>SQL Pod: 租户独享的 SQL 计算节点</p><p>Proxy Pod : 负责将租户的请求路由到正确的 SQL 节点上</p><p>计算节点无状态，这意味着 SQL pod 可以随用随起，也就是说，当某个 tenant 没有流量时，完全可以把它的 SQL 节点停下关掉，需要的时候再动态拉起。</p><p><a href="https://www.zenlife.tk/session-manager.md" title="云原生数据库架构系列之 session manager" target="_blank" rel="noopener">拓展阅读</a></p><p>以上。</p><hr>]]></content>
    
    <summary type="html">
    
      一点学习笔记
    
    </summary>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
      <category term="serverless" scheme="https://cloudsjhan.github.io/tags/serverless/"/>
    
  </entry>
  
  <entry>
    <title>云原生应用发布组件 Triton 开源之旅</title>
    <link href="https://cloudsjhan.github.io/2021/09/13/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%91%E5%B8%83%E7%BB%84%E4%BB%B6-Triton-%E5%BC%80%E6%BA%90%E4%B9%8B%E6%97%85/"/>
    <id>https://cloudsjhan.github.io/2021/09/13/云原生应用发布组件-Triton-开源之旅/</id>
    <published>2021-09-13T14:34:04.000Z</published>
    <updated>2021-09-13T14:36:34.319Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="Triton-概述"><a href="#Triton-概述" class="headerlink" title="Triton 概述"></a>Triton 概述</h2><p>伴随着云原生技术在越来越多的企业落地，如今的 Kubernetes 和容器已经完全进入主流市场，成为云计算的新界面，帮助企业充分享受云原生的优势，加速应用迭代创新效率，降低开发运维成本。但在向着云原生架构转型的过程中，也有许多问题需要被解决。比如原生 Kubernetes 的复杂性、容器化应用的生命周期管理，以及向以容器为基础设施迁移的过程中可能出现的服务稳定性挑战等等。</p><p>开源云原生应用发布组件 Triton 的出现，就是为了解决企业应用在容器化过程中安全落地生产的问题。Triton 以 <a href="https://openkruise.io/zh-cn/docs/what_is_openkruise.html" title="OpenKruise" target="_blank" rel="noopener">OpenKruise</a> 作为容器应用自动化引擎，实现应用负载的扩展增强能力，为原有持续交付系统带来全面升级，不仅解决了应用生命周期管理的问题，包括开发、部署、运维等，同时打通微服务治理，可以帮助研发提升持续交付的效率。</p><p>有关 Trion 设计方案、实现原理的详细介绍可以参考<a href="https://mp.weixin.qq.com/s/CAFNxnKkS5PjeE8ywfoQqQ" target="_blank" rel="noopener">这篇文章</a>。本文将从源码级安装、debug、demo 应用发布演示三个方面介绍 Triton 的核心特性以及 Triton 的快速上手使用、开发，最后介绍 Triton 的 Roadmap。由于时间关系，一键安装、Helm 安装的方式正在开发中，会在正式版本 release 中提供。</p><h2 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h2><p>本次带来的 v0.1.0 开源版本在代码上进行了重构，暂时去掉了对网络方案、微服务架构的依赖，抽象出应用模型的概念，更具备普适性，核心特性如下：</p><ul><li><p>全托管于 k8s 集群，便于组件安装、维护和升级；</p></li><li><p>支持使用 API 和 kubectl 插件（规划中）完成应用创建、部署、升级，并支持单批发布、分批发布和金丝雀发布；</p></li><li><p>提供从创建到运行的应用全生命周期管理服务，包括应用的发布、启动、停止、扩容、缩容和删除等服务，可以轻松管理上千个应用实例的交付问题；</p></li><li><p>Triton 提供了大量 API 来简化部署等操作，如Next、Cancel、Pause、Resume、Scale、Gets、Restart 等，轻松对接公司内部的 PaaS 系统；</p></li></ul><h2 id="操作指南"><a href="#操作指南" class="headerlink" title="操作指南"></a>操作指南</h2><p>  在开始之前，检查一下当前环境是否满足一下前提条件:</p><ol><li><p>确保环境能够与 kube-apiserver 连通；</p></li><li><p>确保 <code>OpenKruise</code> 已经在当前操作 k8s 集群安装，若未安装可以参考<a href="https://openkruise.io/en-us/docs/installation.html" title="OpenKruise 安装文档" target="_blank" rel="noopener">文档</a>；</p></li><li><p>确保有 Golang 开发环境，Fork &amp; git clone 代码后，执行 <code>make install</code> 安装 CRD <code>DeployFlow</code> ；</p></li><li><p>操作 API 的过程中需要 <code>grpcurl</code> 这个工具，参考 <a href="https://github.com/fullstorydev/grpcurl" title="grpcurl 安装文档" target="_blank" rel="noopener">grpcurl 文档</a>进行安装；</p></li></ol><h3 id="创建-DeployFlow-来发布-Nginx-Demo-Application"><a href="#创建-DeployFlow-来发布-Nginx-Demo-Application" class="headerlink" title="创建 DeployFlow 来发布 Nginx Demo Application"></a>创建 DeployFlow 来发布 Nginx Demo Application</h3><h4 id="运行-DeployFlow-controller"><a href="#运行-DeployFlow-controller" class="headerlink" title="运行 DeployFlow controller"></a>运行 DeployFlow controller</h4><p>  进入到代码根目录下执行  <code>make run</code></p><h4 id="创建-DeployFlow-准备发布应用"><a href="#创建-DeployFlow-准备发布应用" class="headerlink" title="创建 DeployFlow 准备发布应用"></a>创建 DeployFlow 准备发布应用</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://github.com/triton-io/triton/raw/main/docs/tutorial/v1/nginx-deployflow.yaml</span><br></pre></td></tr></table></figure><p>  <img src="https://tva1.sinaimg.cn/large/008i3skNly1guf6qrw2zpj61tq04cmya02.jpg" alt=""></p><p>  会创建出一个 DeployFlow 资源和本应用对应的 Service，可以查看该 yaml 文件了解详细的 DeployFlow 定义。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps.triton.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DeployFlow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">"12122"</span></span><br><span class="line">    <span class="string">app.kubernetes.io/instance:</span> <span class="number">12122</span><span class="bullet">-sample-10010</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">deploy-demo-hello</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">"10010"</span></span><br><span class="line"><span class="attr">    managed-by:</span> <span class="string">triton-io</span></span><br><span class="line"><span class="attr">  name:</span> <span class="number">12122</span><span class="bullet">-sample-10010-df</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  action:</span> <span class="string">create</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    appID:</span> <span class="number">12122</span></span><br><span class="line"><span class="attr">    appName:</span> <span class="string">deploy-demo-hello</span></span><br><span class="line"><span class="attr">    groupID:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">    instanceName:</span> <span class="number">12122</span><span class="bullet">-sample-10010</span></span><br><span class="line"><span class="attr">    replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">      matchLabels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">"12122"</span></span><br><span class="line">        <span class="string">app.kubernetes.io/instance:</span> <span class="number">12122</span><span class="bullet">-sample-10010</span></span><br><span class="line">        <span class="string">app.kubernetes.io/name:</span> <span class="string">deploy-demo-hello</span></span><br><span class="line"><span class="attr">        group:</span> <span class="string">"10010"</span></span><br><span class="line"><span class="attr">        managed-by:</span> <span class="string">triton-io</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      metadata:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">      spec:</span></span><br><span class="line"><span class="attr">        containers:</span></span><br><span class="line"><span class="attr">          - image:</span> <span class="attr">nginx:latest</span></span><br><span class="line"><span class="attr">            name:</span> <span class="number">12122</span><span class="bullet">-sample-10010-container</span></span><br><span class="line"><span class="attr">            ports:</span></span><br><span class="line"><span class="attr">              - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">                protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">            resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  updateStrategy:</span></span><br><span class="line"><span class="attr">    batchSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    batchIntervalSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    canary:</span> <span class="number">1</span> <span class="comment"># the number of canary batch</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">auto</span> <span class="comment"># the mode is auto after canary batch</span></span><br></pre></td></tr></table></figure><p>  可以看到我们本次发布的应用名字是 <code>12122-sample-10010</code>，副本数量是 3，批次大小是 1，有一个金丝雀批次，批次大小是 1，发布的模式是 auto，意味着本次发布只会在金丝雀批次和普通批次之间暂停，后续两个批次会以 <code>batchIntervalSeconds</code> 为时间间隔自动触发。</p><h4 id="检查-DeployFlow-状态"><a href="#检查-DeployFlow-状态" class="headerlink" title="检查 DeployFlow 状态"></a>检查 DeployFlow 状态</h4><p>  <img src="https://tva1.sinaimg.cn/large/008i3skNly1guf6slwhwvj62bm04aq3x02.jpg" alt=""></p><p>  可以看到我们创建出一个名为 <code>12122-sample-10010-df</code> 的 DeployFlow 资源，通过展示的字段了解到本次发布分为 3 个批次，当前批次的大小是 1，已升级和已完成的副本数量都是 0。</p><p>  启动几十秒后，检查 DeployFlow 的 status 字段：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get df  12122-sample-10010-df -o yaml</span><br></pre></td></tr></table></figure>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  availableReplicas:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  batches:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  conditions:</span></span><br><span class="line"><span class="attr">  - batch:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    batchSize:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    canary:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    failedReplicas:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    finishedAt:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    phase:</span> <span class="string">Smoked</span></span><br><span class="line"><span class="attr">    pods:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">172.31</span><span class="number">.230</span><span class="number">.23</span></span><br><span class="line"><span class="attr">      name:</span> <span class="number">12122</span><span class="bullet">-sample-10010-2mwkt</span></span><br><span class="line"><span class="attr">      phase:</span> <span class="string">ContainersReady</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      pullInStatus:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">    pulledInAt:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    startedAt:</span> <span class="string">"2021-09-13T12:49:04Z"</span></span><br><span class="line"><span class="attr">  failedReplicas:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  finished:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  finishedAt:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  finishedBatches:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  finishedReplicas:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  paused:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  phase:</span> <span class="string">BatchStarted</span></span><br><span class="line"><span class="attr">  pods:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">12122</span><span class="bullet">-sample-10010-2mwkt</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  replicasToProcess:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  startedAt:</span> <span class="string">"2021-09-13T12:49:04Z"</span></span><br><span class="line"><span class="attr">  updateRevision:</span> <span class="number">12122</span><span class="bullet">-sample-10010-6ddf9b7cf4</span></span><br><span class="line"><span class="attr">  updatedAt:</span> <span class="string">"2021-09-13T12:49:21Z"</span></span><br><span class="line"><span class="attr">  updatedReadyReplicas:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">  updatedReplicas:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>  可以看到目前在启动的是 <code>canary</code> 批次，该批次已经处于 <code>smoked</code> 阶段，该批次中的 pod 是 <code>12122-sample-10010-2mwkt</code> ，同时也能看到当前批次中 pod 的拉入状态、拉入时间等信息。</p><h4 id="将应用拉入流量"><a href="#将应用拉入流量" class="headerlink" title="将应用拉入流量"></a>将应用拉入流量</h4><p>在此之前我们可以先检查一下 Service 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe svc sample-12122-svc -o yaml</span><br></pre></td></tr></table></figure><p>从显示的结果来看，pod <code>12122-sample-10010-2mwkt</code> 并没有出现在 Service 的 <code>Endpoints</code> 中，意味着当前应用没有正式接入流量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span>              <span class="string">sample-12122-svc</span></span><br><span class="line"><span class="attr">Namespace:</span>         <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>            <span class="string">app=12122</span></span><br><span class="line">                   <span class="string">app.kubernetes.io/instance=12122-sample-10010</span></span><br><span class="line">                   <span class="string">app.kubernetes.io/name=deploy-demo-hello</span></span><br><span class="line">                   <span class="string">group=10010</span></span><br><span class="line">                   <span class="string">managed-by=triton-io</span></span><br><span class="line"><span class="attr">Annotations:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Selector:</span>          <span class="string">app.kubernetes.io/instance=12122-sample-10010,app.kubernetes.io/name=deploy-demo-hello,app=12122,group=10010,managed-by=triton-io</span></span><br><span class="line"><span class="attr">Type:</span>              <span class="string">ClusterIP</span></span><br><span class="line"><span class="string">IP</span> <span class="attr">Families:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">IP:</span>                <span class="number">10.22</span><span class="number">.6</span><span class="number">.154</span></span><br><span class="line"><span class="attr">IPs:</span>               <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Port:</span>              <span class="string">web</span>  <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">TargetPort:</span>        <span class="number">80</span><span class="string">/TCP</span></span><br><span class="line"><span class="attr">Endpoints:</span></span><br><span class="line"><span class="string">Session</span> <span class="attr">Affinity:</span>  <span class="string">None</span></span><br><span class="line"><span class="attr">Events:</span>            <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们执行拉入操作(Bake)，对应 pod 的状态会从 <code>ContainerReady</code> 变为 <code>Ready</code>，从而被挂载到对应 Service 的 Endpoints 上开始正式接入流量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Next</span><br></pre></td></tr></table></figure><p>再次检查 DeployFlow，Service，CloneSet 的状态后，发现 Pod 已被挂载到 Endpoints，DeployFlow 的 <code>UPDATED_READY_REPLICAS</code> 字段变为 1，金丝雀批次进入 <code>baking</code> 阶段，如果此时应用正常工作，我们再次执行上面的 <code>Next</code> 操作，将 DeployFlow 置为 <code>baked</code> 阶段，表示本批次点火成功，应用流量正常。</p><h4 id="Rollout-操作"><a href="#Rollout-操作" class="headerlink" title="Rollout 操作"></a>Rollout 操作</h4><p>金丝雀批次到达 <code>baked</code> 阶段后，执行 <code>Next</code> 操作就会进入后面的普通批次发布，由于我们应用的副本数量设置为 3，去掉金丝雀批次中的一个副本后，还剩 2 个，而 batchSize 的大小为 1，所有剩余的普通批次会分两个批次发布，两个批次之间会间隔 10s 触发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Next</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gufd0ojjm2j62eg04a3z902.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gufb22h1dej62dg04iwfk02.jpg" alt=""></p><p>最后应用发布完成，检查 DeployFlow 的状态为 <code>Success</code>:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gufb2saqe6j629604gq3x02.jpg" alt=""></p><p>再次查看 Service 的 Endpoints 可以看到本次发布的 3 个副本都已经挂载上去。</p><p>再次回顾整个发布流程，可以总结为下面的状态流转图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gufb5ht6w9j61du0ingnw02.jpg" alt="deployflow-status"></p><h4 id="暂停-继续-DeployFlow"><a href="#暂停-继续-DeployFlow" class="headerlink" title="暂停/继续 DeployFlow"></a>暂停/继续 DeployFlow</h4><p>在部署过程中，如果要暂停 DeployFlow，可以执行 <code>Pause</code> 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Pause</span><br></pre></td></tr></table></figure><p>可以继续发布了，就执行 <code>Resume</code> 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Resume</span><br></pre></td></tr></table></figure><h4 id="取消本次发布"><a href="#取消本次发布" class="headerlink" title="取消本次发布"></a>取消本次发布</h4><p>如果在发布过程中，遇到启动失败，或者拉入失败的情况，要取消本次发布，可执行 <code>Cancel</code> 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Cancel</span><br></pre></td></tr></table></figure><h4 id="启动一个扩缩容-DeployFlow"><a href="#启动一个扩缩容-DeployFlow" class="headerlink" title="启动一个扩缩容 DeployFlow"></a>启动一个扩缩容 DeployFlow</h4><p>同样可以使用 <code>auto</code> 或 <code>mannual</code> 模式划分多个批次来执行扩缩容操作。 当一个 CloneSet 缩容时，有时用户倾向于删除特定的 Pod，可以使用 podsToDelete 字段实现指定 Pod 缩容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod | grep 12122-sample</span><br><span class="line">12122-sample-10010-2mwkt                      1/1     Running             0          29m</span><br><span class="line">12122-sample-10010-hgdp6                      1/1     Running             0          9m55s</span><br><span class="line">12122-sample-10010-zh98f                      1/1     Running             0          10m</span><br></pre></td></tr></table></figure><p>我们在缩容的时候指定被缩掉的 Pod 为 <code>12122-sample-10010-zh98f</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"instance":&#123;"name":"12122-sample-10010","namespace":"default"&#125;,"replicas":2,"strategy":&#123;"podsToDelete":["12122-sample-10010-zh98f"],"batchSize":"1","batches":"1","batchIntervalSeconds":10&#125;&#125;'</span> \</span><br><span class="line">localhost:8099 application.Application/Scale</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"deployName"</span>: <span class="string">"12122-sample-10010-kvn6b"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">❯ kubectl get pod | grep 12122-sample</span><br><span class="line">12122-sample-10010-2mwkt                      1/1     Running             0          29m</span><br><span class="line">12122-sample-10010-zh98f                      1/1     Running             0          11m</span><br></pre></td></tr></table></figure><p>CloneSet 被缩容为 2 个副本，被缩容的 Pod 正是指定的那个。该功能的实现得益于 OpenKruise 中增强型无状态 workload CloneSet 提供的能力，具体的功能描述可以参考 OpenKruise 文档。</p><p>在操作过程中，Triton 也提供了 <code>Get</code> 方法实时获取当前 DeployFlow 的 Pod 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcurl --plaintext -d <span class="string">'&#123;"deploy":&#123;"name":"12122-sample-10010-df","namespace":"default"&#125;&#125;'</span> localhost:8099 deployflow.DeployFlow/Get</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"deploy"</span>: &#123;</span><br><span class="line">    <span class="attr">"namespace"</span>: <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"12122-sample-10010-df"</span>,</span><br><span class="line">    <span class="attr">"appID"</span>: <span class="number">12122</span>,</span><br><span class="line">    <span class="attr">"groupID"</span>: <span class="number">10010</span>,</span><br><span class="line">    <span class="attr">"appName"</span>: <span class="string">"deploy-demo-hello"</span>,</span><br><span class="line">    <span class="attr">"instanceName"</span>: <span class="string">"12122-sample-10010"</span>,</span><br><span class="line">    <span class="attr">"replicas"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"action"</span>: <span class="string">"create"</span>,</span><br><span class="line">    <span class="attr">"availableReplicas"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"updatedReplicas"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"updatedReadyReplicas"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"updateRevision"</span>: <span class="string">"6ddf9b7cf4"</span>,</span><br><span class="line">    <span class="attr">"conditions"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"batch"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"batchSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"canary"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"phase"</span>: <span class="string">"Baked"</span>,</span><br><span class="line">        <span class="attr">"pods"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"12122-sample-10010-2mwkt"</span>,</span><br><span class="line">            <span class="attr">"ip"</span>: <span class="string">"172.31.230.23"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">"phase"</span>: <span class="string">"Ready"</span>,</span><br><span class="line">            <span class="attr">"pullInStatus"</span>: <span class="string">"PullInSucceeded"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"startedAt"</span>: <span class="string">"2021-09-13T12:49:04Z"</span>,</span><br><span class="line">        <span class="attr">"finishedAt"</span>: <span class="string">"2021-09-13T13:07:43Z"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"batch"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"batchSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"phase"</span>: <span class="string">"Baked"</span>,</span><br><span class="line">        <span class="attr">"pods"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"12122-sample-10010-zh98f"</span>,</span><br><span class="line">            <span class="attr">"ip"</span>: <span class="string">"172.31.226.94"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">"phase"</span>: <span class="string">"Ready"</span>,</span><br><span class="line">            <span class="attr">"pullInStatus"</span>: <span class="string">"PullInSucceeded"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"startedAt"</span>: <span class="string">"2021-09-13T13:07:46Z"</span>,</span><br><span class="line">        <span class="attr">"finishedAt"</span>: <span class="string">"2021-09-13T13:08:03Z"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"batch"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"batchSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"phase"</span>: <span class="string">"Baked"</span>,</span><br><span class="line">        <span class="attr">"pods"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"12122-sample-10010-hgdp6"</span>,</span><br><span class="line">            <span class="attr">"ip"</span>: <span class="string">"172.31.227.215"</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">"phase"</span>: <span class="string">"Ready"</span>,</span><br><span class="line">            <span class="attr">"pullInStatus"</span>: <span class="string">"PullInSucceeded"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"startedAt"</span>: <span class="string">"2021-09-13T13:08:15Z"</span>,</span><br><span class="line">        <span class="attr">"finishedAt"</span>: <span class="string">"2021-09-13T13:08:45Z"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"phase"</span>: <span class="string">"Success"</span>,</span><br><span class="line">    <span class="attr">"finished"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"batches"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"batchSize"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"finishedBatches"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"finishedReplicas"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"startedAt"</span>: <span class="string">"2021-09-13T12:49:04Z"</span>,</span><br><span class="line">    <span class="attr">"finishedAt"</span>: <span class="string">"2021-09-13T13:08:45Z"</span>,</span><br><span class="line">    <span class="attr">"mode"</span>: <span class="string">"auto"</span>,</span><br><span class="line">    <span class="attr">"batchIntervalSeconds"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"canary"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"updatedAt"</span>: <span class="string">"2021-09-13T13:08:45Z"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODOS"><a href="#TODOS" class="headerlink" title="TODOS"></a>TODOS</h2><p>上面演示的就是 Triton 提供的核心能力。对于基础团队来说，Triton 不仅仅是一个开源项目，它也是一个真实的比较接地气的云原生持续交付项目。通过开源，我们希望 Triton 能丰富云原生社区的持续交付工具体系，为更多开发者和企业搭建云原生化的 PaaS 平台助力，提供一种现代的、高效的的技术方案。</p><p>开源只是迈出的一小步，未来我们会进一步推动 Triton 不断走向完善，包括但不限于以下几点：</p><ul><li>支持自定义注册中心，可以看到目前 Triton 采用的是 k8s 原生的 Service 作为应用的注册中心，但据我们所了解，很多企业都使用自定义的注册中心，比如 spring cloud 的 Nacos 等；</li><li>提供 helm 安装方式；</li><li>完善 REST &amp; GRPC API 以及相应文档；</li><li>结合内外部用户需求，持续迭代。项目开源后，我们也会根据开发者需求开展迭代。</li></ul><p>欢迎大家向 Triton 提交 issue 和 PR 共建 Triton 社区。我们诚心期待更多的开发者加入，也期待 Triton 能够助力越来越多的企业快速构建云原生持续交付平台。如果有企业或者用户感兴趣，我们可以提供专项技术支持和交流，欢迎入群咨询。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>项目地址：<a href="https://github.com/triton-io/triton" target="_blank" rel="noopener">https://github.com/triton-io/triton</a></p><h3 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gufd1pbwh9j60e60iuabg02.jpg" alt="triton-wechat" style="zoom:67%;"></p><hr>]]></content>
    
    <summary type="html">
    
      云原生应用发布组件 Triton 开源之旅
    
    </summary>
    
      <category term="持续交付" scheme="https://cloudsjhan.github.io/categories/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    
    
      <category term="云原生" scheme="https://cloudsjhan.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
      <category term="k8s" scheme="https://cloudsjhan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>掌门下一代容器发布系统 Triton</title>
    <link href="https://cloudsjhan.github.io/2021/07/21/%E6%8E%8C%E9%97%A8%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%AE%B9%E5%99%A8%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F-Triton/"/>
    <id>https://cloudsjhan.github.io/2021/07/21/掌门下一代容器发布系统-Triton/</id>
    <published>2021-07-21T05:45:59.000Z</published>
    <updated>2021-07-21T06:02:21.266Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>掌门下一代容器发布系统 Triton</p><p>CD 平台是掌门的持续交付系统，<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E9%87%8C%E5%90%8C" title="Triton 是希腊神话中海之信使" target="_blank" rel="noopener">Triton</a> 作为 CD 平台的核心容器发布组件，自 2020.4 月在 CD 平台上正式上线，支撑了掌门近 1000 个应用从虚机迁移至容器的过程，保障了虚机迁容器过程的稳定性。目前，Triton 除了提供日常的应用容器发布、网络策略配置、Ingress 域名配置等能力之外，也成为其他组件、平台的资源交付基座，比如，<a href="https://mp.weixin.qq.com/s/DFy_E6qN3hLyStaSand_Dg" title="掌门大规模流水线实践" target="_blank" rel="noopener">大规模的流水线交付</a>，压测平台等。Triton 解决了应用生命周期管理的问题，包括开发、部署、运维等，同时打通了微服务治理，极大地帮助研发提升了持续交付的效率。</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>云原生架构的快速普及带来了企业基础设施和应用架构等技术层面的革新。在 CNCF 2020 年度中国区云原生调查报告里面有一个亮眼的数字，72% 的受访者已经在生产环境当中使用 Kubernetes，同期全球调查报告的数字是 83%。可以看到，在 Kubernetes 的使用率上，中国和全球是持平的。如果看纯容器使用率，则更加惊人，超过 92%。从这些数据来看，我们可以得出结论：Kubernetes 和容器已经完全进入主流市场，成为所有人都在使用的技术。</p><p>在此之前，掌门的应用一直跑在虚机里，但是随着应用规模的不断扩大，虚机数量也随之快速增加，我们开始在运维成本、交付效率、应用管理上面临一些痛点：</p><ol><li>应用数量不断增加，基础设施的成本随之上升，降本迫在眉睫；</li><li>业务飞速发展，内部对资源、环境、应用的交付效率的要求不断提高；</li><li>应用数量增长很快，大量应用的管理给运维带来很大压力。</li></ol><p>所以，为了能够充分发挥云原生的优势，灵活地应对变化和弹性扩展以提升开发效率，加速迭代并降低成本，掌门于 2020 年 4 月份正式启动容器化项目。</p><p>为了最大程度降低迁移容器过程中对开发和业务的影响，我们决定在应用发布中完成从虚机到容器的迁移，以保障迁移过程中服务的稳定性，实现不停服迁移。要实现这个目标，一个全新的、支持容器发布的平台呼之欲出，Triton 就是在这种背景下诞生的。下面将介绍容器发布平台 Triton 的设计原理、实现方案。</p><h3 id="2-Triton-设计原理及实现方案"><a href="#2-Triton-设计原理及实现方案" class="headerlink" title="2. Triton 设计原理及实现方案"></a>2. Triton 设计原理及实现方案</h3><p>在介绍 Triton 之前我们先看一下 CNCF 对持续交付的定义，涵盖了一个云原生应用的全生命周期流程，图中的一些技术术语在本文中也会用到，比如 <code>workload</code>，<code>rollout</code>，<code>canary</code>等， <a href="https://docs.google.com/document/d/1gMhRz4vEwiHa3uD8DqFKHGTSxrVJNgkLG2WZWvi9lXo/edit#" title="CNCF SIG App Delivery" target="_blank" rel="noopener">这篇文档</a> 中有详细的介绍，需要的话可以查阅。</p><p>同时通过这张图，也可以清晰地了解 Triton 在整个持续发布系统中的定位。Topic 1，Topic 1.5 的主要内容是应用模型描述，打包、参数配置；Topic 4 是资源管理，网络，日志 / 监控等平台侧的功能；而 Triton 聚焦的工作是在 Topic 2 和 Topic 3 ，主要内容是应用生命周期管理，流量管理，workload 管理，提供发布策略，比如蓝绿部署、金丝雀部署等。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsfb5gf8ikj30zu0jggqr.jpg" alt="CNCF SIG App Delivery"></p><p>了解了 Triton 的定位后，下面将从方案选型，架构设计，UI 交互 3 个维度来详细介绍 Triton 的设计原理和实现方案。</p><h4 id="2-1-方案选型"><a href="#2-1-方案选型" class="headerlink" title="2.1 方案选型"></a>2.1 方案选型</h4><h5 id="2-1-1-workload-选型"><a href="#2-1-1-workload-选型" class="headerlink" title="2.1.1 workload 选型"></a>2.1.1 workload 选型</h5><p>众所周知，不管是无状态的 Deployment 还是有状态的 StatefulSet，kubernetes 都是支持服务的滚动更新的。我们也经常在一些文章中看到有基于原生 Deployment 实现应用的滚动发布和灰度发布，这种方式开发简单容易上手，但是随之带来了很多缺陷，使得我们无法细粒度控制发布的过程，比如不支持发布过程中暂停、继续，以及流量的优雅拉入拉出等能力。</p><p>为了实现更丰富的发布策略以及更加细粒度的发布控制，以保障容器发布过程的安全、稳定，Triton 选择 <a href="https://openkruise.io/zh-cn/docs/what_is_openkruise.html" title="OpenKruise" target="_blank" rel="noopener">OpenKruise</a>    作为应用的 workload。OpenKruise 是 Kubernetes 的一个标准扩展，它可以配合原生 Kubernetes 使用，并为管理应用容器、sidecar、镜像分发等方面提供更加强大和高效的能力。OpenKruise 提供了很多原生 kubernetes 的增强型资源，CloneSet、Advanced StatefulSet、SidecarSet 等。其中，CloneSet 提供了更加高效、确定可控的应用管理和部署能力，支持优雅原地升级、指定删除、发布顺序可配置、并行 / 灰度发布等丰富的策略，可以满足更多样化的应用场景，所以 Triton 选择基于 CloneSet 来实现无状态应用的发布流程。</p><h5 id="2-1-2-发布流程技术选型"><a href="#2-1-2-发布流程技术选型" class="headerlink" title="2.1.2 发布流程技术选型"></a>2.1.2 发布流程技术选型</h5><p>如何定义一种发布流程，并按照流程的定义去实现本次发布？为了寻找一些灵感，在设计 Triton 之前我们调研了目前在云原生领域做得比较好的的一些 CI/CD 组件，像云原生 CI 工具 Tekton，交付工具 Argo 都是设计了一套 CRD （自定义资源），然后在 Operator 中实现相应的逻辑以达到最终的目标状态（Operator 是由 CoreOS 开发的，用来扩展 Kubernetes API，特定的应用程序控制器，其基于 Kubernetes 的资源和控制器概念之上构建，但同时又包含了应用程序特定的领域知识。创建 Operator 的关键是 CRD 的设计）。</p><p>于是我们采用云原生的方式设计容器发布，<strong>原生为云而设计，在云上运行，充分利用和发挥云平台的弹性 + 分布式优势</strong>。我们设计了一种 CRD 来描述一次容器发布的完整流程，这样每次发布只需要创建 CRD 资源，就能定义好本次的发布流程，后续只需要在此资源基础上修改即可。经过内部讨论，最终该 CRD 被命名为 DeployFlow，即发布流的意思，关于 DeployFlow 的详细介绍请继续阅读下面的架构设计。</p><h4 id="2-2-架构设计"><a href="#2-2-架构设计" class="headerlink" title="2.2 架构设计"></a>2.2 架构设计</h4><p>在解决了 workload 和发布流程的技术选型后，DeployFlow 这个 CRD 的设计就成为了我们要去聚焦的核心工作。下图展示了 Triton 的主要设计架构，可以看到在 Kubernetes 和 OpenKruise 的基础之上，完成一次发布需要的配置由 CRD 定义，发布流程相关的逻辑控制通过 Operator 实现，同时 Triton 提供 REST、GRPC API 和前端 UI 实现交互。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsefhahnrfj30oj0hajss.jpg" alt="Triton 架构图"></p><h5 id="2-2-1-DeployFlow-和-Operator-实现"><a href="#2-2-1-DeployFlow-和-Operator-实现" class="headerlink" title="2.2.1 DeployFlow 和 Operator 实现"></a>2.2.1 DeployFlow 和 Operator 实现</h5><p>首先介绍下 DeployFlow 这个 CRD，通过 DeployFlow 我们定义了一次发布中需要的配置以及发布过程中需要的状态展示。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeployFlow is the Schema for the deploys API</span></span><br><span class="line"><span class="keyword">type</span> DeployFlow <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:",inline"`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:"metadata,omitempty"`</span></span><br><span class="line"></span><br><span class="line">Spec   DeployFlowSpec   <span class="string">`json:"spec,omitempty"`</span></span><br><span class="line">Status DeployFlowStatus <span class="string">`json:"status,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Spec</code> 字段的内容分为两部分，一部分是与应用相关的信息，比如 <code>AppID</code>、<code>GroupId</code>、<code>副本数量</code>、<code>AppName</code>等，另一部分是指定发布策略，比如是 <code>create</code>还是 <code>update</code> 操作，是 <code>scale in</code> 还是 <code>scale out</code>，不同的操作对应不同的发布策略，详细的字段解释可以通过下面代码来理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeployFlowSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Important: Run "make" to regenerate code after modifying this file</span></span><br><span class="line"></span><br><span class="line">AppID        <span class="keyword">int</span>    <span class="string">`json:"appID"`</span></span><br><span class="line">GroupID      <span class="keyword">int</span>    <span class="string">`json:"groupID"`</span></span><br><span class="line">AppName      <span class="keyword">string</span> <span class="string">`json:"appName"`</span></span><br><span class="line">......</span><br><span class="line">Action       <span class="keyword">string</span> <span class="string">`json:"action"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +nullable</span></span><br><span class="line">UpdateStrategy *DeployUpdateStrategy <span class="string">`json:"updateStrategy,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +nullable</span></span><br><span class="line">NonUpdateStrategy *DeployNonUpdateStrategy <span class="string">`json:"nonUpdateStrategy,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DeployUpdateStrategy</code> 代表了本次发布是一次更新操作，也就是会使 CloneSet 中的 <code>UpdateRevision</code> 字段发生变化，一般 <code>create</code>、<code>update</code> <code>rollback</code> 就是采用 <code>DeployUpdateStrategy</code> 的字段定义。</p><p>DeployNonUpdateStrategy 代表本次发布不会触发资源更新，也就是 <code>UpdateRevision</code> 不会发生变化，一般 <code>scale in</code>、<code>scale out</code>、<code>restart</code> 等操作要采用 <code>DeployNonUpdateStrategy</code>。</p><p>不同的发布策略肯定有不同的字段，但大部分的策略都是可以共用的，所以在此之上我们抽象出一个基础发布策略 <code>BaseStrategy</code>，由于 <code>BaseStrategy</code> 中的字段太多，我们这里放一张 CRD 的 <code>schema</code> 资源视图，然后再选择其中重要的字段进行解释。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsefqtkocuj30ld0j7js8.jpg" alt="DeployFlow"></p><p>先介绍 <code>DeployPhase</code> 字段，<code>DeployPhase</code> 表示一次发布过程中，DeployFlow 所经历的阶段。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsefuo465jj309z0b03yl.jpg" alt="DeployPhase"></p><p>字段的意思都比较好理解，这里就不展开讲 了。</p><p>在 <code>BaseStrategy</code> 中有个比较重要的字段 - <code>BatchSize</code> ，表示批次大小。这意味着 <code>DeployFlow</code> 支持分批次发布，用户可以自定义每个批次最大发布的副本数量，DeployFlow 会计算出本次发布的总批次是多少从而提前给出发布概览。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6x2fp89j30ao0dwmxk.jpg" alt="deploy overview"></p><p>从 <code>BaseStrategy</code> 的 <code>paused</code>、<code>canceled</code> 字段就可以知道，在发布过程中可以随时暂停、继续或者取消本次发布。<code>Mode</code> 表示 <code>DeployFlow</code> 不同批次之间的触发方式，分为 <code>auto</code> 和 <code>manual</code> 两种，当选择 <code>auto</code> 模式的时候，通过字段 <code>BatchIntervalSeconds</code> 可以设置不同批次之间的时间间隔，如果选择手动模式则每个批次之间需要手工触发。</p><p>由于 <code>DeployFlow</code> 是分批次发布，所以每个批次需要有阶段显示 - <code>BatchPhase</code> ，以表示当前的批次所处的阶段，我们来详细解释每种阶段的含义。</p><p><code>BatchPending</code>: 表示当前批次的 <code>pod</code> 正在准备资源，比如此时 pod 正在被调度中，image 在下载中，对应 Kubernetes 中的 pod 处于 <code>Pending</code>，<code>ContainerCreating</code> 状态。</p><p><code>BatchSmoking</code>: 表示当前批次的 pod 正在启动过程中，pod 处于 <code>Running</code> 状态，但是 <code>ContainerReady</code> 字段还没有置为 true。</p><p><code>BatchSmoked</code>: 表示当前批次的所有 pod 都已经启动成功，也就是 pod 中的 <code>ContainerReady</code> 字段已经被置为 true，但是 <code>Ready</code> 字段还处于 false。此时如果通过 service 来处理服务流量的话，启动的 pod 并不会被加入到对应 service 的 endpoint，如果是微服务架构，则该 pod 并不会被拉入到微服务的注册中心，从而保证了业务流量的安全。正是拥有了这种机制以及批次间可暂停的能力，我们可以轻松实现应用的金丝雀发布，这个在后面还会详细讲到。</p><p><code>BatchBaking</code>: 表示当前批次的所有 pod 都已经启动成功，正在执行流量拉入操作，也就是将 pod 的 <code>Ready</code> 字段置为 true。</p><p><code>BatchBaked</code>: 表示当前批次的所有 pod 的 <code>Ready</code> 字段都已被置为 true，pod 开始接收生产流量，至此也意味着本批次的结束，可以开始下一批次的操作。</p><p>在批次进行过程中，会有 smoke 失败或者 bake 失败的情况，对应的状态就是 <code>SmokeFailed</code>和 <code>BakeFailed</code>。</p><p>在 <code>UpdateStrategy</code> 中有一个 <code>canary</code> 字段，意味着 <code>DeployFlow</code> 支持金丝雀发布。其实在讲解了上述 DeployFlow 分批次处理的能力后，在此基础之上实现金丝雀发布是比较简单的。也就是在金丝雀批次处于 <code>BatchSmoked</code> 状态的时候，让发布暂停，在流量拉入之前也可以进行一些 API 验证的操作，开发者在验证没问题之后手工将该批次拉入，拉入金丝雀批次后， <code>DeployFlow</code> 也处于暂停的状态，此时开发者可以观察线上流量的监控，确认没有问题后再执行后面批次的发布。后面的 UI 交互会更加直观地展示该功能，这里我们先通过一张 DeployFlow 的状态流转示意图完整地展示一次发布的过程，我们以本次发布分为两个批次为例，金丝雀批次和普通批次。结合本图与上文的 CRD 解释，相信读者会对 DeployFlow 有一个更加清晰的认知。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse1rxtoa1j31du0injv8.jpg" alt="deployflow 状态流转"></p><p>至此，在 <code>DeployUpdateStrategy</code> 、<code>BaseStrategy</code> 中的核心字段都已经介绍完了，在 <code>DeployNonUpdateStrategy</code> 中还有一个 <code>PodsToDelete</code> 字段，这个字段是在应用缩容、重启操作时起作用的，原生 Kubernetes   对于资源的缩容操作有自己的规则，不能随意选择想要缩容的 pod。但是在 DeployFlow 中，你可以指定 pod 缩容，指定 pod 重启。</p><p>通过上面的介绍，读者对 DeployFlow 这个 CRD 的 spec 字段有了一定了解，下面来看下发布过程中我们需要展示的 status 字段。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsavi4wm8vj30r20os7ao.jpg" alt="DeployStatus"></p><p>熟悉 Kubernetes 的同学应该能够从字段的字面意思了解这些字段的含义，这里就不详细展开了。</p><p>CRD 设计完成后，Operator 的实现也就是水到渠成的事情了，除了 DeployFlow 的 Operator，Triton 中还重新实现了一些 controller 来满足个性化的需求，比如 Event controller 用来将发布过程中 pod、Cloneset、DeployFlow 等组件的日志发送到 ES 以方便开发者查看发布的情况，ReadinessGates controller 用来控制自定义 ReadinessGate 的拉入拉出操作等。</p><p>同时 Triton 提供 REST &amp; GRPC API 来操作 DeployFlow，调用方即使不了解容器和 Kubernetes 的知识，也可以很容易对接到 Triton 上实现发布的功能。</p><h4 id="2-3-UI-交互"><a href="#2-3-UI-交互" class="headerlink" title="2.3 UI 交互"></a>2.3 UI 交互</h4><p>底层架构以及核心组件 DeployFlow 的设计逻辑虽然稍显复杂，但得益于 Triton 暴露的 REST &amp; GRPC API 以及丰富的 status 字段，使得前端在发布的 UI 交互逻辑上能够做到简洁直观。下面让我们从 UI 入手，看下 Triton 如何进行应用的交付以及对应用的副本实例的规划。</p><h5 id="2-3-1-发布入口及发布清单"><a href="#2-3-1-发布入口及发布清单" class="headerlink" title="2.3.1 发布入口及发布清单"></a>2.3.1 发布入口及发布清单</h5><p>进入生产发布页面，在容器发布页签，选择需要发布的 group，点击“发布”。</p><p>点击后弹出一个发布清单的页面，在这里需要配置本次发布需要的策略以及相关参数。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6fi185rj30p70higm9.jpg" alt="发布单页"></p><p>其中有些参数在上面的 CRD 设计篇章中已经有所描述，比如应用描述，批次大小，批次间处理方式，批次间隔等，这里不再赘述。<strong>启动超时时间</strong> 是开放给开发者自定义应用需要用来启动的时间，比如有些应用尤其是 java 应用，在真正启动之前需要执行一些 warm up 的操作，开发者就可以根据自己应用的实际情况填写该值，避免这类应用启动失败。<strong>微服务拉出等待时间</strong> 是用来支持微服务 pod 优雅退出的。</p><p>那何谓优雅退出，为什么要优雅退出呢？在 Kubernetes 中当删掉一个 pod 的时候，理想状况当然是 Kubernetes 从对应的 Service（假如有的话）把这个 pod 摘掉，同时给 pod 发 SIGTERM 信号让 pod 中的各个容器优雅退出就行了。但实际上 pod 有可能犯各种幺蛾子：</p><ul><li>已经卡死了，处理不了优雅退出的代码逻辑或需要很久才能处理完成；</li><li>优雅退出的逻辑有 BUG，自己死循环了；</li><li>代码写得野，根本不理会 SIGTERM;</li></ul><p>因此，Kubernetes 的 pod 终止流程中还有一个”最多可以容忍的时间”，即 grace period （在 pod 的 <code>.spec.terminationGracePeriodSeconds</code> 字段中定义），这个值默认是 30 秒，我们在执行 <code>kubectl delete</code> 的时候也可通过 <code>--grace-period</code> 参数显式指定一个优雅退出时间来覆盖 pod 中的配置。而当 grace period 超出之后，Kubernetes 就只能选择 SIGKILL 强制干掉 pod 了。</p><p>但是在微服务的场景下，除了把 pod 从 Kubernetes 的 Service 上摘下来以及进程内部的优雅退出之外，我们还必须做一些额外的事情，比如说从 Kubernetes 外部的服务注册中心上反注册，不然可能会出现 pod 已经被删掉，但是注册中心上还留着已删掉 pod 的服务信息，此时有流量进入的话就会出现服务不可用的情况。所以我们在 prestop hook 中定义了一个名为 <code>gracefully_shutdown</code> 的文件来处理 pod 删除后的微服务优雅退出。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  contaienrs:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">demo-container</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      preStop:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span> <span class="string">["/bin/sh"，"-c"，"/gracefully_shutdown"]</span></span><br></pre></td></tr></table></figure><p>右侧的发布策略以及本次发布概览在之前的架构设计中已经讲过，这里不在赘述。</p><h5 id="2-3-2-开始发布"><a href="#2-3-2-开始发布" class="headerlink" title="2.3.2 开始发布"></a>2.3.2 开始发布</h5><p>完成发布配置后，即可开始发布。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsbols4lcij311g0j6jtj.jpg" alt="deploy-layout"></p><ul><li><strong>发布进度</strong>：展示发布的批次，及各个批次所启动的实例数量和状态。在发布过程中，人工操作的入口也在此区域；</li><li><strong>实例列表</strong>：展示发布的实例，可以切换实例版本查看各版本的实例；</li><li><strong>副本状态</strong>：形如 <code>0/1/0/0</code> 对应 <code>Pending/Running/Ready/Failed</code>  四个状态的数量 (1 个 pod 在发布中），其中 <code>Running</code> 对应发布中实例数，<code>Ready</code> 发布成功实例数，<code>Failed</code> 发布失败实例数。</li></ul><h5 id="2-3-3-发布过程"><a href="#2-3-3-发布过程" class="headerlink" title="2.3.3 发布过程"></a>2.3.3 发布过程</h5><p>一个典型的发布包括“金丝雀批次启动（Smoking）”-“金丝雀批次点火（Baking）”-“滚动发布（Rollout）” 三个阶段。</p><ol><li>金丝雀批次启动中（Smoking）</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6hz3ydej30vf05j3yl.jpg" alt="canary smoking"></p><ol start="2"><li>金丝雀批次启动成功，可以验证接口，确认没问题，可将其拉入点火（Baking）</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6ibwqyij30vk05gjrg.jpg" alt="canary smoked"></p><ol start="3"><li>金丝雀批次点火中，实例已接流量，由于此时 DeployFlow 处于暂停状态，开发者可以有充足的时间可观察日志、监控等是否有异常，确认没问题后再触发滚动发布（Rollout）</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6inamonj30vu05daa7.jpg" alt="canary baked"></p><ol start="4"><li>滚动发布中，如选择“手动” 模式，每个滚动批次都需要人为触发</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6iru83ij30vf05jmxb.jpg" alt="rollout"></p><p>滚动发布过程中，可以看到新旧实例的版本数量在交替变化。</p><ol start="5"><li>发布成功</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gse6j1t8uuj30vp05l74b.jpg" alt="deploy success"></p><p>至此，一次完整的 DeployFlow 流程就走完了，发布到达成功的状态。可以看到每个批次所负责的 pod 数量以及 pod 状态、日志等信息。</p><h5 id="2-3-4-指定实例的操作"><a href="#2-3-4-指定实例的操作" class="headerlink" title="2.3.4 指定实例的操作"></a>2.3.4 指定实例的操作</h5><p>在实例运行过程中，如果发现实例负载异常或需要重新加载 apollo 配置，就会有重启实例的需求。Kubernetes 本身没有提供重启的操作逻辑，一般通过杀掉一个 pod 来达到重启的效果，但这种方式比较粗暴而且存在安全隐患。Triton 提供了安全的重启策略，会先新增一个 pod 如果该 pod 启动成功成功，再删掉你所指定要重启的 pod，以此来达到安全重启的效果，这就是 Triton 的指定实例重启的功能。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsbpg358ndj30ry0k340h.jpg" alt="specify-pod-restart"></p><p>同样的原理，缩容的操作也可以指定想要缩掉的 pod 。</p><p>该功能的实现得益于 OpenKruise 中增强型无状态 workload CloneSet 提供的能力，具体的功能描述可以参考 <a href="https://openkruise.io/zh-cn/docs/cloneset.html#%E6%8C%87%E5%AE%9A-pod-%E7%BC%A9%E5%AE%B9" target="_blank" rel="noopener">OpenKruise 文档。</a></p><p>上面的内容就是有关 Triton 核心能力的 UI 交互，整个过程力求简洁、清晰，避免给开发者造成额外的理解负担，这为我们容器的接入、推进提供了很大的便捷。</p><h3 id="3-总结与展望"><a href="#3-总结与展望" class="headerlink" title="3. 总结与展望"></a>3. 总结与展望</h3><p>每个公司的容器发布平台都不尽相同，可能会有读者看完说 Triton 封装了太多的 Kubernetes 细节，没有向开发者真正展示原生 Kubenetes 的状态、含义或者理念。其实从一开始，我们的目标就是设计适用于掌门自身研发体系的容器发布系统，减少开发对发布操作的学习成本，从而快速上手以更快地赋能研发流程的迭代，加速业务应用的上线。而简洁清晰的 API 也有利于我们设计出更加简单的用户界面，简单的用户界面又让我们在推广时受益。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsf7n0y3mjj30ui04ogmr.jpg" alt=""></p><p>上图是 Triton 的一些关键指标，可见 Triton 已经成为 CD 平台的核心能力，在用户需求的迭代中不断进化，不过，现在的 Triton 依然有很大的优化空间，主要有：</p><ol><li>掌门有大量的 socket 长连接应用，对于这类应用的容器化，以及容器化后如何发布，还没有清晰的设计方案；</li><li>Triton 按应用粒度进行发布，不支持跨应用的发布流程编排；</li><li>对开发者快速拉起本地测试环境的支持较弱。</li></ol><p>我们目前也在进行针对这些优化项的工作。</p><hr>]]></content>
    
    <summary type="html">
    
      掌门下一代容器发布系统 Triton
    
    </summary>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/categories/kubernetes/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Kubernetes Deletion</title>
    <link href="https://cloudsjhan.github.io/2021/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Kubernetes-Deletion/"/>
    <id>https://cloudsjhan.github.io/2021/07/21/深入理解-Kubernetes-Deletion/</id>
    <published>2021-07-21T04:08:12.000Z</published>
    <updated>2021-07-21T04:10:58.319Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><code>kubectl delete</code> 这个命令我们几乎每天都在使用，看起来很容易理解，不就是删除 Kubernetes 的某种资源吗？但是要完全理解 Delete 操作还是很有挑战的，理解删除操作背后真正的原理，能够帮助你从容应对一些奇葩场景。这篇文章将从以下几个方面详细解释删除操作背后的故事：</p><ol><li>基本的删除操作</li><li>Finalizers 和 Owner Reference 会对删除操作产生什么影响</li><li>如何利用  propagation policy 改变删除的顺序</li><li>通过 examples 演示上述删除操作</li></ol><p>简单起见，所有示例都将使用 ConfigMaps 和 Basic Shell 命令来演示操作过程。</p><h3 id="The-basic-delete"><a href="#The-basic-delete" class="headerlink" title="The basic delete"></a>The basic <code>delete</code></h3><p>Kubernetes 有几种不同的命令，您可以使用它允许您创建，读取，更新和删除对象。 出于本博客文章的目的，我们将专注于四个 kubectl 命令：create<code>,</code>get<code>,</code>patch<code>, 和</code>delete。</p><p>下面是几个最简单的 <code>kubectl delete</code> 使用场景：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap mymap</span><br><span class="line">configmap/mymap created</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap/mymap</span><br><span class="line">NAME    DATA   AGE</span><br><span class="line">mymap   0      12s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete configmap/mymap</span><br><span class="line">configmap "mymap" deleted</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap/mymap</span><br><span class="line">Error from server (NotFound): configmaps "mymap" not found</span><br></pre></td></tr></table></figure><p>演示了一个 configMap 从创建、查询、到删除、再查询的过程，这个过程可以用下面的状态图表示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsnil61b40j30fx0710sw.jpg" alt="state diagra for delete"></p><p>这种 <code>delete</code> 操作是非常简单直观的，但当你遇到 <code>Finalizer</code>和 <code>Owner References</code> 的时候就会出现各种难以理解的现象。</p><h3 id="Understanding-Finalizers"><a href="#Understanding-Finalizers" class="headerlink" title="Understanding Finalizers"></a>Understanding Finalizers</h3><p>在理解 Kubernetes 的资源删除时，了解 <code>Finalizers</code> 的工作原理能够在你无法删除资源时给你一些解决问题的灵感。</p><p><code>Finalizers</code> 是触发 <code>pre-delete</code> 操作的关键，能够控制资源的垃圾回收。<code>Finalizers</code> 设计的初衷是帮助 controller 在处理资源删除之前，优先处理一些 clean up 的逻辑。但是 <code>Finalizers</code> 并不包含代码逻辑，使用上跟 <code>Annotation</code> 有些相似，很容易被添加或者删除。</p><p>你可以已经见过下面的 <code>Finalizers</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubernetes.io/pv-protection</span><br><span class="line">kubernetes.io/pvc-protection</span><br></pre></td></tr></table></figure><p>这两个 <code>Finalizer</code> 是用来防止误删除 volume 的，类似功能的 Finalizer 还有很多。</p><p>下面是一个自定义的 configmap，只包含一个 <code>Finalizer</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl create -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mymap</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p> 负责管理 configmap 的 controller 并不知道该如何处理 <code>kubernetes</code> 这个 Finalizer。现在我尝试去删除这个 configmap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete configmap/mymap &amp;</span><br><span class="line">configmap "mymap" deleted</span><br><span class="line">jobs</span><br><span class="line">[1]+  Running kubectl delete configmap/mymap</span><br></pre></td></tr></table></figure><p>Kubernetes 会返回一个信息告诉你这个 configmap 已经被删除了，然而并不是传统意义上的删除，而是出于一个 <code>deleting</code> 的状态。当我们再次执行 <code>get</code> 操作去获取该 configmap，会发现 configmap 资源已经被修改过了，deletionTimeStamp 设置了值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap/mymap -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: "2020-10-22T21:30:18Z"</span><br><span class="line">  deletionGracePeriodSeconds: 0</span><br><span class="line">  deletionTimestamp: "2020-10-22T21:30:34Z"</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">  name: mymap</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: "311456"</span><br><span class="line">  selfLink: /api/v1/namespaces/default/configmaps/mymap</span><br><span class="line">  uid: 93a37fed-23e3-45e8-b6ee-b2521db81638</span><br></pre></td></tr></table></figure><p>换句话说，这个 configmap 资源并没有被删除而是被更新了，这是因为 Kubernetes 看到资源中有一个 <code>Finalizer</code> 后把它置为了 read-only 状态。这个 configmap 只有在移除了 <code>Finalizer</code> 后，才会真正从集群中删除。</p><p>我们使用 <code>patch</code> 命令移除 <code>Finalizer</code> 来验证一下上面的说法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch configmap/mymap \</span><br><span class="line">    --type json \</span><br><span class="line">    --patch='[ &#123; "op": "remove", "path": "/metadata/finalizers" &#125; ]'</span><br><span class="line">configmap/mymap patched</span><br><span class="line">[1]+  Done  kubectl delete configmap/mymap</span><br></pre></td></tr></table></figure><p>此时我们再去 <code>get</code> configmap，发现已经获取不到了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap/mymap -o yaml</span><br><span class="line">Error from server (NotFound): configmaps "mymap" not found</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsnkddcs46j30l10b9t95.jpg" alt="state diagram for finalize"></p><p>上面展示了当一个资源带有 <code>Finalizer</code> 时，执行删除操作后的状态流转图。</p><h3 id="Owner-References"><a href="#Owner-References" class="headerlink" title="Owner References"></a>Owner References</h3><p>Owner reference 描述了多种资源之间的关联关系。它们是关于资源的属性，可以彼此指定关联关系，因此可以做到级联删除。</p><p>Kubernetes 中最常见的具备 owner reference 关系的场景就是 pod 将 replica set 作为自己的 owner，所以当 deployment 或者 statefulSet 删除的时候，作为子资源的 replica set 和 pod 都将被删除。</p><p>下面的例子解释了 owner reference 的工作原理。我们首先创建了一个父资源，然后创建子资源的时候指定其 owner reference：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl create -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mymap-parent</span><br><span class="line">EOF</span><br><span class="line">CM_UID=$(kubectl get configmap mymap-parent -o jsonpath="&#123;.metadata.uid&#125;")</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | kubectl create -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mymap-child</span><br><span class="line">  ownerReferences:</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    kind: ConfigMap</span><br><span class="line">    name: mymap-parent</span><br><span class="line">    uid: $CM_UID</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>当删除子资源时，父资源并不会被删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap</span><br><span class="line">NAME           DATA   AGE</span><br><span class="line">mymap-child    0      12m4s</span><br><span class="line">mymap-parent   0      12m4s</span><br><span class="line"></span><br><span class="line">kubectl delete configmap/mymap-child</span><br><span class="line">configmap "mymap-child" deleted</span><br><span class="line"></span><br><span class="line">kubectl get configmap</span><br><span class="line">NAME           DATA   AGE</span><br><span class="line">mymap-parent   0      12m10s</span><br></pre></td></tr></table></figure><p>我们再根据上面的 yaml 建立资源，然后我们删除父资源，这时发现所有的资源都被删除了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap</span><br><span class="line">NAME           DATA   AGE</span><br><span class="line">mymap-child    0      10m2s</span><br><span class="line">mymap-parent   0      10m2s</span><br><span class="line"></span><br><span class="line">kubectl delete configmap/mymap-parent</span><br><span class="line">configmap "mymap-parent" deleted</span><br><span class="line"></span><br><span class="line">kubectl get configmap</span><br><span class="line">No resources found in default namespace.</span><br></pre></td></tr></table></figure><p>简而言之，当父 - 子资源之间存在 owner reference 关系的时候，我们删除父资源，子资源也会随之删除，这叫做 <code>cascade</code> （级联删除）。默认情况下，<code>cascade</code> 的值是 true，你可以执行 <code>kubectl delete</code> 的时候加上参数 <code>--cascade=false</code> ，这样就可以只删除父资源而保留子资源。</p><p>在以下示例中，有一对父子资源，如果我使用 <code>--cascade = false</code> 删除父资源，但子资源仍然存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl get configmap</span><br><span class="line">NAME           DATA   AGE</span><br><span class="line">mymap-child    0      13m8s</span><br><span class="line">mymap-parent   0      13m8s</span><br><span class="line"></span><br><span class="line">kubectl delete --cascade=false configmap/mymap-parent</span><br><span class="line">configmap "mymap-parent" deleted</span><br><span class="line"></span><br><span class="line">kubectl get configmap</span><br><span class="line">NAME          DATA   AGE</span><br><span class="line">mymap-child   0      13m21s</span><br></pre></td></tr></table></figure><p><code>——cascade</code> 参数能够控制 API 中的删除传播策略（ propagation policy），它允许控制删除对象的顺序。在下面的示例中，使用 API 访问创建一个带有 background 传播策略的自定义 delete API 调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy --port=8080 &amp;</span><br><span class="line">Starting to serve on 127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">curl -X DELETE \</span><br><span class="line">  localhost:8080/api/v1/namespaces/default/configmaps/mymap-parent \</span><br><span class="line">  -d &apos;&#123; &quot;kind&quot;:&quot;DeleteOptions&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;propagationPolicy&quot;:&quot;Background&quot; &#125;&apos; \</span><br><span class="line">  -H &quot;Content-Type: application/json&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Status&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;&#125;,</span><br><span class="line">  &quot;status&quot;: &quot;Success&quot;,</span><br><span class="line">  &quot;details&quot;: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，不能使用 kubectl 在命令行上指定传播策略。必须使用自定义 API 调用来指定。需要创建一个代理，这样就可以从客户端访问 API Server，并执行 curl 命令来执行该删除命令。</p><p>一共有三种传播策略：</p><p><code>Foreground</code>：先删除子资源再删除父资源（post-order）</p><p><code>Background</code>：先删除父资源再删除子资源（pre-order）</p><p><code>Orphan</code>：忽略 owner reference</p><p>要注意，假如一个资源中同时设置了 owner reference 和 finalizer，finalizer 的优先级是最高的。</p><h3 id="Forcing-a-Deletion-of-a-Namespace"><a href="#Forcing-a-Deletion-of-a-Namespace" class="headerlink" title="Forcing a Deletion of a Namespace"></a>Forcing a Deletion of a Namespace</h3><p>你可以已经遇到过执行 <code>kubectl delete ns NS</code> 后，ns 无法删除的情况，这时候你可以通过 update 所删除 ns 的 <code>Finalizer</code> 字段来实行强制删除。这个操作会通知到 namespace controller 移除 finalizer ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | curl -X PUT \</span><br><span class="line">  localhost:8080/api/v1/namespaces/test/finalize \</span><br><span class="line">  -H "Content-Type: application/json" \</span><br><span class="line">  --data-binary @-</span><br><span class="line">&#123;</span><br><span class="line">  "kind": "Namespace",</span><br><span class="line">  "apiVersion": "v1",</span><br><span class="line">  "metadata": &#123;</span><br><span class="line">    "name": "test"</span><br><span class="line">  &#125;,</span><br><span class="line">  "spec": &#123;</span><br><span class="line">    "finalizers": null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这个操作要谨慎，因为它可能只删除名称空间，而将孤立资源留在现在不存在的名称空间中，会让集群处于让人很迷惑的状态。如果发生这种情况，可以手动重新创建该名称空间，有孤立的资源对象将重新出现在刚刚创建的名称空间下，可以手动清理和恢复。</p><h3 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h3><p>上面的例子说明，<code>Finalizer</code> 能够阻止 Kubernetes 删除资源，但是通常在代码中添加 <code>Finalizer</code> 是有原因的，因此应该在手动删除它之前进行检查。Owner reference 支持级联删除资源，但 <code>Finalizer</code> 的优先级更高。最后，可以使用传播策略通过自定义 API 调用指定删除顺序，从而控制对象的删除方式。通过上面的例子，相信大家对 Kubernetes 中的删除工作原理有了更多的了解，现在可以使用测试集群自己尝试一下。</p><p>原文地址：<a href="https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/" target="_blank" rel="noopener">https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/</a></p><hr>]]></content>
    
    <summary type="html">
    
      深入理解 kubernetes Deletion
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing is Beta Ready</title>
    <link href="https://cloudsjhan.github.io/2021/06/15/Fuzzing-is-Beta-Ready/"/>
    <id>https://cloudsjhan.github.io/2021/06/15/Fuzzing-is-Beta-Ready/</id>
    <published>2021-06-15T02:12:20.000Z</published>
    <updated>2021-06-15T02:15:13.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>近日 Golang 团队宣布，go 原生支持的模糊测试 (fuzzing) 的 beta 版本在 development 分支上已经可以使用了。开发人员可以使用该特性为项目构建 fuzzing 测试。</p><p>那么先来看下什么是 Fuzzing 呢？</p><h3 id="什么是-Fuzzing？"><a href="#什么是-Fuzzing？" class="headerlink" title="什么是 Fuzzing？"></a><strong>什么是 Fuzzing？</strong></h3><p>Fuzz 本意是“羽毛、细小的毛发、使模糊、变得模糊”，后来用在软件测试领域，中文一般指“模糊测试”，英文有的叫“Fuzzing”，有的叫“Fuzz Testing”。本文用 fuzzing 表示模糊测试。</p><p>Fuzzing 技术可以追溯到 1950 年，当时计算机的数据主要保存在打孔卡片上，计算机程序读取这些卡片的数据进行计算和输出。如果碰到一些垃圾卡片或一些废弃不适配的卡片，对应的计算机程序就可能产生错误和异常甚至崩溃，这样，Bug 就产生了。所以，Fuzzing 技术并不是什么新鲜技术，而是随着计算机的产生一起产生的古老的测试技术。</p><p>Fuzzing 技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。随着计算机的发展，Fuzzing 技术也在不断发展。</p><h3 id="Fuzzing有用么？"><a href="#Fuzzing有用么？" class="headerlink" title="Fuzzing有用么？"></a><strong>Fuzzing有用么？</strong></h3><p>Fuzzing 是模糊测试，顾名思义，意味着测试用例是不确定的、模糊的。</p><p>计算机是精确的科学和技术，测试技术应该也是一样的，有什么的输入，对应什么样的输出，都应该是明确的，怎么会有模糊不确定的用例呢？这些不确定的测试用例具体会有什么作用呢？</p><p>为什么会有不确定的测试用例，我想主要的原因是下面几点：</p><p>1、我们无法穷举所有的输入作为测试用例。我们编写测试用例的时候，一般考虑正向测试、反向测试、边界值、超长、超短等一些常见的场景，但我们是没有办法把所有的输入都遍历进行测试的。</p><p>2、我们无法想到所有可能的异常场景。由于人类脑力的限制，我们没有办法想到所有可能的异常组合，尤其是现在的软件越来越多的依赖操作系统、中间件、第三方组件，这些系统里的bug或者组合后形成的 bug，是我们某个项目组的开发人员、测试人员无法预知的。</p><p>3、Fuzzing 软件也同样无法遍历所有的异常场景。随着现在软件越来越复杂，可选的输入可以认为有无限个组合，所以即使是使用软件来遍历也是不可能实现的，否则你的版本可能就永远也发布不了。Fuzzing 技术本质是依靠随机函数生成随机测试用例来进行测试验证，所以是不确定的。</p><h3 id="这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的-Bug-么？"><a href="#这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的-Bug-么？" class="headerlink" title="这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的 Bug 么？"></a>这些不确定的测试用例会起到我们想要的测试结果么？能发现真正的 Bug 么？</h3><p>1、Fuzzing 技术首先是一种自动化技术，即软件自动执行相对随机的测试用例。因为是依靠计算机软件自动执行，所以测试效率相对人来讲远远高出几个数量级。比如，一个优秀的测试人员，一天能执行的测试用例数量最多也就是几十个，很难达到 100 个。而 Fuzzing 工具可能几分钟就可以轻松执行上百个测试用例。</p><p>2、Fuzzing 技术本质是依赖随机函数生成随机测试用例，随机性意味着不重复、不可预测，可能有意想不到的输入和结果。</p><p>3、根据概率论里面的“大数定律”，只要我们重复的次数够多、随机性够强，那些概率极低的偶然事件就必然会出现。Fuzzing 技术就是大数定律的典范应用，足够多的测试用例和随机性，就可以让那些隐藏的很深很难出现的Bug成为必然现象。</p><p>目前，Fuzzing 技术已经是软件测试、漏洞挖掘领域的最有效的手段之一。Fuzzing 技术特别适合用于发现 0 Day 漏洞，也是众多黑客或黑帽子发现软件漏洞的首选技术。Fuzzing 虽然不能直接达到入侵的效果，但是 Fuzzing 非常容易找到软件或系统的漏洞，以此为突破口深入分析，就更容易找到入侵路径，这就是黑客喜欢 Fuzzing 技术的原因。</p><p>想要了解更多特性可以参考 golang fuzzing 的设计草案  <a href="[https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md](https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md">draft-fuzzing</a>)</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get golang.org/dl/gotip</span><br><span class="line">$ gotip download dev.fuzz</span><br></pre></td></tr></table></figure><p>这将从 Dev.Fuzz 开发分支中构建 Go Toolchain，等将来代码合并到 Master 分支后就不需要自己构建了。 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gotip test -fuzz=FuzzFoo</span><br></pre></td></tr></table></figure><p>DEV.Fuzz 分支中会有正在进行的开发和错误修复，需要每次运行 <code>gotip download dev.fuzz</code> 以拉取最新的代码。</p><p>为了保障代码兼容性，在提交包含模糊测试的源文件时使用 <code>gofuzzbeta</code> 构建 tag。 默认情况下在Dev.Fuzz分支中的构建时已经启用此 tag。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build gofuzzbeta</span></span><br></pre></td></tr></table></figure><h3 id="Fuzz-测试样例"><a href="#Fuzz-测试样例" class="headerlink" title="Fuzz 测试样例"></a>Fuzz 测试样例</h3><p>Fuzz 测试与普通的单元测试类似，需要在 <code>*_test.go</code> 中定义 <code>Fuzzxxx</code> 函数。 此函数必须传递<code>*testing.f</code> 参数，就像 <code>* testing.t</code> 参数传递给 testxxx 函数一样。</p><p>下面是测试 <code>net/url</code> 的 fuzzing target 的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build gofuzzbeta</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fuzz</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuzzParseQuery</span><span class="params">(f *testing.F)</span></span> &#123;</span><br><span class="line">    f.Add(<span class="string">"x=1&amp;y=2"</span>)</span><br><span class="line">    f.Fuzz(<span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, queryStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        query, err := url.ParseQuery(queryStr)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Skip()</span><br><span class="line">        &#125;</span><br><span class="line">        queryStr2 := query.Encode()</span><br><span class="line">        query2, err := url.ParseQuery(queryStr2)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"ParseQuery failed to decode a valid encoded query %s: %v"</span>, queryStr2, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(query, query2) &#123;</span><br><span class="line">            t.Errorf(<span class="string">"ParseQuery gave different query after being encoded\nbefore: %v\nafter: %v"</span>, query, query2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过下面的命令使用 Go Doc 阅读有关 Fuzz API 的更多信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gotip doc testing</span><br><span class="line">gotip doc testing.F</span><br><span class="line">gotip doc testing.F.Add</span><br><span class="line">gotip doc testing.F.Fuzz</span><br></pre></td></tr></table></figure><h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><ol><li>模糊测试会消耗大量内存，并在运行时可能会影响机器的性能。 <code>go test -fuzz</code> 默认值以并行运行 <code>$ gomaxProcs</code> 进程中的模糊。 可以在运行 <code>Go Test</code> 时加上 <code>--parallel</code> 来限制并发使用 cpu 的数量。 </li><li>要注意目前没有限制写入 fuzzing 缓存的文件数或总字节数，因此它可能占据大量存储（即几个GB），可以通过运行 <code>gotip clean -fuzzcache</code> 来清除模糊测试后的缓存。</li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个特性并不会出现在即将发布的 Go1.17 中，但是计划在未来的某个 Go 版本中正式 release 这个特性。官方希望这个特性能够帮助 Go 开发人员开始编写 fuzzing 测试，并提供关于 fuzzing 的设计的反馈，为未来该功能的代码正式合并 master 做准备。</p><pre><code>Happy fuzzing!</code></pre><hr>]]></content>
    
    <summary type="html">
    
      Golang Fuzzing is beta ready
    
    </summary>
    
      <category term="Go" scheme="https://cloudsjhan.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://cloudsjhan.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.16 is released, Apple silicon M1 可以放心买啦</title>
    <link href="https://cloudsjhan.github.io/2021/02/20/Go-1-16-is-released-Apple-silicon-M1-%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%BF%83%E4%B9%B0%E5%95%A6/"/>
    <id>https://cloudsjhan.github.io/2021/02/20/Go-1-16-is-released-Apple-silicon-M1-可以放心买啦/</id>
    <published>2021-02-20T07:32:51.000Z</published>
    <updated>2021-02-20T07:35:16.002Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnqdzsw78rj31gk0rgtgs.jpg" alt="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6cc0de3ef1945649039cabc8c7e1580~tplv-k3u1fbpfcp-zoom-1.image"></p><p>2021 年 2 月 16 日，春节假期的最后一天，Go 官方终于将 1.16 版本 released。</p><p>下面简要介绍一下 1.16 版本最重要的一些特性：</p><h3 id="核心库加入了新的成员-embed"><a href="#核心库加入了新的成员-embed" class="headerlink" title="核心库加入了新的成员 - embed"></a>核心库加入了新的成员 - embed</h3><p>package <code>embed</code> 可访问正在运行的 Go 程序中所嵌入的静态文件。</p><p>使用 <code>embed</code> 可以使用 <code>// go：embed</code> 指令在编译时从包目录或子目录读取的文件的内容并使用它们。</p><p>例如，以下三种方法可以嵌入名为 <code>hello.txt</code> 的文件，然后在运行时打印其内容。</p><ul><li>将一个文件嵌入到字符串中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"embed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><ul><li>将一个文件嵌入 []byte</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"embed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">string</span>(b))</span><br></pre></td></tr></table></figure><ul><li>将一个或多个文件嵌入到文件系统中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"embed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed hello.txt</span></span><br><span class="line"><span class="keyword">var</span> f embed.FS</span><br><span class="line">data, _ := f.ReadFile(<span class="string">"hello.txt"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">string</span>(data))</span><br></pre></td></tr></table></figure><p>这种将静态文件在编译时嵌入可执行文件的方式，在极大地提高了 go 访问静态文件的灵活性的同时，也能提高了敏感配置文件的安全性。更大胆一点，是不是在前端领域，golang 也能插一脚了？</p><h3 id="增加对-Apple-silicon-ARM-64-架构的支持"><a href="#增加对-Apple-silicon-ARM-64-架构的支持" class="headerlink" title="增加对 Apple silicon ARM 64 架构的支持"></a>增加对 Apple silicon ARM 64 架构的支持</h3><p>Go 1.16 还添加了macOS ARM64 支持（也称为Apple silicon）。 自 Apple 宣布其新的 ARM64 架构以来，go team 一直在与他们紧密合作以确保 Go 得到完全的支持。一直在 观望 M1 的开发者这下可以放心去买新的 Mac 啦。</p><h3 id="默认开启-Go-modules"><a href="#默认开启-Go-modules" class="headerlink" title="默认开启 Go modules"></a>默认开启 Go modules</h3><p>Go 1.16 默认使用 Go modules。因为根据 go team 的 2020 Go 开发人员调查，现在有96％的 Go 开发人员已经在使用 Go modules了。</p><h3 id="其他的性能改善与提高"><a href="#其他的性能改善与提高" class="headerlink" title="其他的性能改善与提高"></a>其他的性能改善与提高</h3><p>最后，还有许多其他改进和 bug fix，比如构建速度提高了25％，内存使用量减少了15％。 有关更改的完整列表以及有关上述改进的更多信息，可以参考 <a href="[https://golang.org/doc/go1.16](https://golang.org/doc/go1.16">Go 1.16发行说明</a>)。</p><p>以上就是 Go 1.16 带来的新特性，有开发者调侃到 “最大的特性就是离泛型的版本号更近了（狗头）”哈哈哈。</p><hr>]]></content>
    
    <summary type="html">
    
      Go 1.16 is released, Apple silicon M1 可以放心买啦&#39;
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Redirecting godoc.org requests to pkg.go.dev</title>
    <link href="https://cloudsjhan.github.io/2020/12/16/Redirecting-godoc-org-requests-to-pkg-go-dev/"/>
    <id>https://cloudsjhan.github.io/2020/12/16/Redirecting-godoc-org-requests-to-pkg-go-dev/</id>
    <published>2020-12-16T06:54:42.000Z</published>
    <updated>2020-12-16T07:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>随着 Go Module 的引入和 Go 生态系统的发展，pkg.go.dev 于 <a href="https://blog.golang.org/go.dev" target="_blank" rel="noopener">2019 年</a>启动，为开发人员提供了了一个查找 Go package 的地方，官方称之为 <code>center place</code>。 像 godoc.org 一样，pkg.go.dev 提供 Go 文档，但它也支持 Go Module、更好的搜索功能以及帮助 Go 用户找到正确软件包的指引。</p><p>正如官方在 <a href="https://blog.golang.org/pkg.go.dev-2020" target="_blank" rel="noopener">2020年1月分享</a> 的那样，官方的目标是最终将流量从 godoc.org 重定向到 pkg.go.dev 上的相应页面。 用户可以还可以选择将自己的请求从godoc.org 重定向到 pkg.go.dev。</p><p>今年官方收到了很多反馈，很多问题已经在 <a href="https://github.com/golang/go/milestone/157?closed=1https://github.com/golang/go/milestone/157?closed=1" target="_blank" rel="noopener">pkgsite/godoc.org-redirect</a> 和 <a href="https://github.com/golang/go/milestone/159?closed=1" target="_blank" rel="noopener">pkgsite/design-2020</a> 进行跟踪和解决。 用户的反馈意见支持对 pkg.go.dev 上的高频功能的改进，以及最近对pkg.go.dev 的重新设计都有很大的帮助。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>一旦在 <a href="https://github.com/golang/go/milestone/157" target="_blank" rel="noopener">pkgsite/godoc.org-redirect</a> 里程碑中跟踪的工作完成, 官方就会将所有请求从 godoc.org 重定向到pkg.go.dev上的相应页面,这大概会在2021 年初开始。</p><p>官方鼓励大家现状就开始使用 pkg.go.dev, 可以通过访问 <code>godoc.org?redirect=on</code> 或单击任何<code>godoc.org</code> 页面右上角的 “Always use pkg.go.dev” 来实现。</p><h3 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h3><ul><li><p>A: godoc.org 还可以继续使用吗？<br>Q: YES! 我们会将所有访问 godoc.org 的请求重定向到 pkg.go.dev 上的相应页面，因此你所有的书签和链接依然有效。</p></li><li><p>A: <code>golang/gddo</code> repo 将会如何处理？<br>Q: repo 可以继续 fork 和使用，但是官方将对其标记为 <code>archived</code>。</p></li><li><p>A: <code>api.godoc.org</code> 还能继续使用吗？<br>Q: 此过渡不会对 api.godoc.org 产生影响。 在 pkg.go.dev 提供 API 之前，api.godoc.org 将继续为流量提供服务。 有关 pkg.go.dev 的 API 的更新，请参见 <a href="https://golang.org/issue/36785" target="_blank" rel="noopener">issue 36785</a>。</p></li></ul><h3 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h3><p>  <a href="https://go.googlesource.com/pkgsite" target="_blank" rel="noopener">Pkg.go.dev</a> 是一个开源项目。 如果你有兴趣为 pkg site 做出贡献，可以加入 Gophers Slack 上的 <code>#pkgsite</code> 频道以了解更多信息。</p><hr>]]></content>
    
    <summary type="html">
    
      Redirecting godoc.org requests to pkg.go.dev
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Can I convert a []T to an []interface{}?</title>
    <link href="https://cloudsjhan.github.io/2020/12/09/Can-I-convert-a-T-to-an-interface/"/>
    <id>https://cloudsjhan.github.io/2020/12/09/Can-I-convert-a-T-to-an-interface/</id>
    <published>2020-12-09T12:33:50.000Z</published>
    <updated>2020-12-09T12:35:21.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="Can-I-convert-a-T-to-an-interface"><a href="#Can-I-convert-a-T-to-an-interface" class="headerlink" title="Can I convert a []T to an []interface{}?"></a>Can I convert a []T to an []interface{}?</h3><p>众所周知，在 Golang 中，interface 是一种抽象类型，相对于抽象类型的是具体类型（concrete type）：int，string。<code>interface{}</code> 是一个空的 interface 类型，一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 <code>interface{}</code>。如果定义一个函数参数是 <code>interface{}</code> 类型，这个函数应该可以接受任何类型作为它的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然空的 interface 可以接受任何类型的参数，那么一个 <code>interface{}</code>类型的 slice 是不是就可以接受任何类型的 slice ?看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverseSlice</span><span class="params">(vals []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; </span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">nums := []<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;</span><br><span class="line">traverseSlice(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是说空的 interface 可以是任何类型吗？为何报了下面的错误？</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glhvf447lfj30ys04w0tk.jpg" alt="image-20201209202110198"></p><p>这个错误说明 go 没有自动把 <code>[]string</code> 转换成 <code>[]interface{}</code> ，所以出错了。<strong>go 不会对 类型是<code>interface{}</code> 的 slice 进行转换</strong> 。为什么 go 不帮我们自动转换? 在 golang 官方 blog 的 FAQ 中找到了对这个问题的解释，由于<code>interface{}</code> 会占用两部分存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 slice []interface{} 其长度是固定的<code>N*2</code>，但是 []T 的长度是<code>N*sizeof(T)</code>，用官方的解释就是两种类型在内存中的表现是不一样的。那该如何去转换呢？可以按照单个元素来转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(t))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glhvpfhteij30n205aglt.jpg" alt="image-20201209203108747"></p><p>附 <a href="https://golang.org/doc/faq#convert_slice_of_interface" target="_blank" rel="noopener">https://golang.org/doc/faq#convert_slice_of_interface</a> 对这个问题的解释：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glhvrg2vyfj31dy0f6acs.jpg" alt="image-20201209203306491"></p><hr>]]></content>
    
    <summary type="html">
    
      Can I convert a []T to an []interface{}?
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>kubectl delete pod 等待 30s 的问题排查与解决</title>
    <link href="https://cloudsjhan.github.io/2020/11/23/kubectl-delete-pod-%E7%AD%89%E5%BE%85-30s-%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>https://cloudsjhan.github.io/2020/11/23/kubectl-delete-pod-等待-30s-的问题排查与解决/</id>
    <published>2020-11-23T05:56:03.000Z</published>
    <updated>2020-11-23T07:50:19.908Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>我们平时在使用 Kubernetes 的时候，一般会使用 <code>kubectl delete pod podName</code> 的方式删除一个容器。 但我们发现，每次执行 <code>kubectl delete pod</code> 之后都要等待 30s kubectl 才会返回。也许你会觉得 30s 是一个可以忍受的时间， 只要最终能删掉 pod 就行，但这样的问题真的只有 30s 这么简单吗？ 为什么不能很快关闭容器呢？ 或者为什么恰好就是 30s 呢？下面就让我们从根源弄清楚这件事情并解决它。</p><h3 id="kubectl-delete-如何关闭并删除容器？"><a href="#kubectl-delete-如何关闭并删除容器？" class="headerlink" title="kubectl delete 如何关闭并删除容器？"></a>kubectl delete 如何关闭并删除容器？</h3><p><code>kubectl delete</code> 命令是在对容器发出停止命令时使用的，从发送信号上来讲，它将发送 <code>SIGTERM</code> 信号给容器，通知其结束运行。</p><blockquote><p>SIGINT 一般用于关闭前台进程，SIGTERM 会要求进程自己正常退出。</p></blockquote><p>当我们在 shell 中给进程发送 SIGTERM 和 SIGINT 信号的时候，这些进程往往都能正确的处理。 但是在容器中却不生效, 这是因为在 docker 中，只会将 SIGTERM 等所有的 signal 信号发送给 PID 为 1 的进程，当我们 docker 中运行的进程的 <code>PID</code> 不是 1 时，就不会收到这样的信号。</p><h3 id="那么为什么是等待-30s"><a href="#那么为什么是等待-30s" class="headerlink" title="那么为什么是等待 30s ?"></a>那么为什么是等待 30s ?</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkz4dhe673j31eg078jt2.jpg" alt=""></p><p>上图是官方文档的一段截图，Kubernetes 的 pod 中有一个参数 <code>terminationGracePeriodSeconds</code>，此时，k8s 等待指定的时间称为优雅终止宽限期。默认情况下，这个值是 30s。值得注意的是，这个过程中 preStop Hook 和 SIGTERM 信号并行发生。Kubernetes 不会等待 preStop Hook 完成。<br>这意味着如果你的应用程序完成关闭并在 terminationGracePeriod 完成之前退出，Kubernetes 会立即进入下一步。如果你的 Pod 通常需要超过 30s 才能关闭，那么必须增加这个参数的大小，可以通过在 pod 模板中设置 terminationGracePeriodSeconds 来实现。</p><p>如果达到上面的时间限制，k8s 将会通过给内核发送 <code>SIGKILL</code> 从而强制结束容器。<br>这就解释了为什么每次 <code>delete pod</code> 都要等待 30s，根本原因还是容器中的 java 进程的 PID 不是 1，所以该进程不会理解收到 <code>SIGTERM</code>，在等待 <code>default terminationGracePeriodSeconds</code> 的时长后被强制结束。</p><h3 id="强制关闭容器的后果是什么？"><a href="#强制关闭容器的后果是什么？" class="headerlink" title="强制关闭容器的后果是什么？"></a>强制关闭容器的后果是什么？</h3><p>现在我们已经了解了 <code>kubectl delete pod</code> 等待 30s 的原因了。 我们再来看看另一个问题： 强制关闭容器，真的就没问题吗？</p><p>或许你能想到，很多进程在结束阶段会做一些清理工作：比如删除临时目录、执行 shutdown hook 等。 但是当进程被强制关闭时，这些任务就不会被执行，那么我们就可能得到一些并不期望的结果。</p><p>以 Eureka 为例，Eureka client 在结束进程时，需要向 Eureka server 发送 shutdown 信号，以注销 client。 这本来没什么问题，因为 Eureka server 即使没有收到这样的信息，也会定期清理 client 信息。 但是 Eureka server 还有一个 self preservation 模式，以防止意外的网络事件导致大量的 client 下线。 这就有可能导致 Eureka 集群的注册表中出现大量的 client 信息，但它们其实已经关闭了。</p><h3 id="那么如何优雅地关闭容器"><a href="#那么如何优雅地关闭容器" class="headerlink" title="那么如何优雅地关闭容器?"></a>那么如何优雅地关闭容器?</h3><p>通过上面的分析我们不难找出解决这个问题的方法，就是让容器中的启动的进程 PID 为 1。<br>先看下之前的容器中 java 进程的 PID，确实不是 1， 是 8：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkz4jdcsdyj314y0560tz.jpg" alt=""></p><p>可以看到 PID 为 1 的是启动 java 进程的 shell 脚本。</p><p>这就要追溯到 Dockerfile 的 <code>ENTRYPOINT</code> 的两种写法，即 exec 和 shell，两者的区别在于：</p><ul><li><p>exec 形式的命令会使用 PID 1 的进程；</p></li><li><p>shell 形式的命令会被执行为 /bin/sh -c <command>，不会执行在 PID 1 上，也就不会收到 signal。</p></li></ul><p>我们检查了下启动 java 进程的脚本，发现确实是用 <code>exec</code> 的方式启动的，那为什么 java 进程的 PID 还不是 1 呢？</p><p>原因是 <code>exec</code> 形式的 <code>ENTRYPOINT</code> 只能解决 <code>无需任何准备工作就启动进程</code> 的场景，而不能解决一些需要准备工作的复杂场景。举个栗子，我们的 ENTRYPOINT 往往需要执行一个 shell 脚本，然后在脚本的最后才会去执行 <code>java -jar xxx</code>，这时候，我们的 java 进程就无法成为 PID 1 进程。</p><p>我们可以在 shell 中使用 exec 命令来解决。这个命令的作用就是使用新的进程替代原有的进程，并保持 PID 不变。 这就意味着我们可以在执行 java 命令的时候使用它，从而替换掉 PID 1 的 shell 脚本。</p><p>entrypoint.sh demo<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo "prepare..."</span><br><span class="line">exec java -jar app.jar</span><br></pre></td></tr></table></figure></p><p>修改后我们再来看下容器中的 java 进程的 PID：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkz5cr2pqrj313a052t9w.jpg" alt=""></p><p>使用 exec 之后，容器中 java 进程的 PID 成为 1，我们发出 delete pod 请求能让进程接收到 SIGTERM 信号，执行相应的操作后立即退出。</p><h3 id="篇外：docker-是如何创建容器的-PID-为-1-的进程"><a href="#篇外：docker-是如何创建容器的-PID-为-1-的进程" class="headerlink" title="篇外：docker 是如何创建容器的 PID 为 1 的进程?"></a>篇外：docker 是如何创建容器的 PID 为 1 的进程?</h3><p>当我们执行 <code>docker run -it busybox /bin/sh</code> 的时候，对于操作系统来讲是个进程, 操作系统会分配一个 PID 给这个进程, 比如这个进程号是 PID=8, 对于操作系统全局来讲它是 PID=8 的一个进程, 但是我们进入容器执行命令ps, 会发现 <code>/bin/sh</code> 的 PID=1。<br>这种就是 docker 的 namespace 机制, 对于全局来讲, 这条 docker 命令的的 PID 可能是 8, 但是对于容器内部来讲 , 它构建了一个假的命名空间, 使 <code>/bin/sh</code> 的 PID 进程等于 1。</p><p>其中用到的技术就是Linux的创建线程的 system call, 对应的系统调用函数就是 <code>clone()</code>。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, SIGCHLD, NULL);</span><br></pre></td></tr></table></figure><p>这个系统调用创建一个新的进程，并且返回它的 PID，而当我们用 <code>clone()</code> 系统调用创建一个新进程时，就可以在参数中指定 <code>CLONE_NEWPID</code> 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure><p>这时，新创建的这个进程将会看到一个全新的进程空间，在这个进程空间里，它的 PID 是 1。但是在宿主机真实的进程空间里，这个进程的 PID 还是系统的数值 8。</p><p>以上。</p><hr>]]></content>
    
    <summary type="html">
    
      kubectl delete pod 等待 30s 的问题排查与解决
    
    </summary>
    
      <category term="docker" scheme="https://cloudsjhan.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://cloudsjhan.github.io/tags/docker/"/>
    
      <category term="kubernetes" scheme="https://cloudsjhan.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Why is there no Goroutine ID?</title>
    <link href="https://cloudsjhan.github.io/2020/11/09/Why-is-there-no-goroutine-ID/"/>
    <id>https://cloudsjhan.github.io/2020/11/09/Why-is-there-no-goroutine-ID/</id>
    <published>2020-11-09T03:32:25.000Z</published>
    <updated>2020-11-09T03:35:41.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>在C/C++/Java等语言中，我们可以直接获取Thread Id，然后通过映射Thread Id和二级调度Task Id的关系，可以在日志中打印当前的TaskId，即用户不感知Task Id的打印，适配层统一封装，这使得多线程并发的日志的查看或过滤变得非常容易。</p><p>Goroutine 是 Golang 中轻量级线程的实现，由 Go Runtime 管理。Golang 在语言级别支持轻量级线程，叫协程。Golang 标准库提供的所有系统调用操作（当然也包括所有同步 IO 操作），都会出让 CPU 给其他 Goroutine。这让事情变得非常简单，让轻量级线程的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量。</p><p>官方曾经使用 <code>IIRC</code> 来暴露 <code>GoId</code> ，但是自从 go1.4 版本以后，Goroutine Id 无法直接从 Go Runtime 获取了。</p><p>禁用的原因有以下两点：</p><ol><li>当 Goroutine 关闭时，Goroutine 的 local storage 并不会立即被垃圾回收，这意味你只能拿到当前的 Goroutine 的 ID，但是不能正确拿到系统中所有正在运行的 GoId 列表。</li><li>你只能获取你写的代码生成的 Goroutine ID，但是通常你不能确保所有的标准库以及第三方代码库都做了这些工作。</li></ol><p>这样就很难对高并发日志进行查看和过滤。尽管在日志中可以使用业务本身的 ID ，但是在很多函数中仅仅为了打印而增加一些参数 ID 会让代码看起来没有那么优雅。</p><p>可以到 <a href="https://golang.org/doc/faq#no_Goroutine_id" target="_blank" rel="noopener">https://golang.org/doc/faq#no_Goroutine_id</a> 中看到官方对这个问题的详细解释，原文不长所以放在文章里。</p><hr><h3 id="Why-is-there-no-Goroutine-ID"><a href="#Why-is-there-no-Goroutine-ID" class="headerlink" title="Why is there no Goroutine ID?"></a>Why is there no Goroutine ID?</h3><p>Goroutines do not have names; they are just anonymous workers. They expose no unique identifier, name, or data structure to the programmer. Some people are surprised by this, expecting the <code>go</code> statement to return some item that can be used to access and control the Goroutine later.</p><p>The fundamental reason Goroutines are anonymous is so that the full Go language is available when programming concurrent code. By contrast, the usage patterns that develop when threads and Goroutines are named can restrict what a library using them can do.</p><p>Here is an illustration of the difficulties. Once one names a Goroutine and constructs a model around it, it becomes special, and one is tempted to associate all computation with that Goroutine, ignoring the possibility of using multiple, possibly shared Goroutines for the processing. If the <code>net/http</code> package associated per-request state with a Goroutine, clients would be unable to use more Goroutines when serving a request.</p><p>Moreover, experience with libraries such as those for graphics systems that require all processing to occur on the “main thread” has shown how awkward and limiting the approach can be when deployed in a concurrent language. The very existence of a special thread or Goroutine forces the programmer to distort the program to avoid crashes and other problems caused by inadvertently operating on the wrong thread.</p><p>For those cases where a particular Goroutine is truly special, the language provides features such as channels that can be used in flexible ways to interact with it.</p><hr>]]></content>
    
    <summary type="html">
    
      Why is there no Goroutine ID?
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go team 关于如何保持 Go Modules 兼容性的一些实践</title>
    <link href="https://cloudsjhan.github.io/2020/08/13/Go-team-%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81-Go-Modules-%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5/"/>
    <id>https://cloudsjhan.github.io/2020/08/13/Go-team-关于如何保持-Go-Modules-兼容性的一些实践/</id>
    <published>2020-08-13T06:05:13.000Z</published>
    <updated>2020-08-13T06:07:27.552Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>近日，Go team 在其官方 blog 上讨论了如何让你的 Go Modules 保持兼容性的话题，并给出了一些建议，这些建议都是该团队在实际开发中不断踩坑总结出来的精华，可以说是最佳实践。我们站在巨人的肩膀上，可以写出更优雅，更具有兼容性的代码，下面让我们深入逐条解读这些建议。</p><hr><p>随着新功能的添加，或者重构 Go Module 的某些公共部分，Go Module 将随着时间的推移而不断发生变化。</p><p>但是，发布新的 Go Module 版本对使用者来是一个噩耗。 他们必须找到新版本，学习新的API，并更改其代码。 而且某些用户可能永远不会更新，这意味着您必须永远为代码维护两个版本。 因此，通常最好以兼容的方式更改现有的 Go Module。</p><p>在本文中，我们将探讨一些代码技巧，能够让你保持 Go Module 的兼容性。 核心的思想就是是：添加，但是不要更改或删除你的 Go Module 代码。 我们还将从宏观角度讨论如何设计具备高度兼容性的 API 。</p><h3 id="新增函数"><a href="#新增函数" class="headerlink" title="新增函数"></a>新增函数</h3><p>通常来说，改变函数的形参是破坏代码兼容性最常见的情况。我们讲过讨论几个解决这种问题的方式，但让我们首先看一个不好的实践。</p><p>有这么一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>当我们出于某个情况要扩展这个函数，为这个函数添加一个形参 <code>size</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, size ...<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>假如你在其他代码中，或者 Go Module 的使用者更新了，那么像下面的代码就会出现问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg</span><br><span class="line"><span class="keyword">var</span> runner <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> = <span class="title">yourpkg</span>.<span class="title">Run</span></span></span><br></pre></td></tr></table></figure><p>原来的 <code>Run</code> 函数的类型是 <code>func(string)</code>，但是新的 <code>Run</code> 函数的类型变成了 <code>func(string, ...int)</code>，所以在编译阶段就会报错。必须要根据新的函数类型修改调用方式，这给使用 Go Module 的开发者造成很多不便，甚至出现 bug。</p><p>针对这种情况，我们可以新增一个函数来解决这个问题，而不是修改函数签名。我们都知道，<code>context</code> 包是 Golang 1.17 版本之后才引入的，通常 <code>ctx</code> 会做为函数的第一个参数传入。但是现有的已经很稳定的 API 的可导出函数不可能去修改函数签名，在其函数第一个入参添加 <code>context.Context</code>，这样会影响所有函数调用方，尤其在一些底层代码库中，这是非常危险的操作。</p><p>Go team 使用<code>新增函数</code> 的方法解决了这个问题。举个栗子，<code>database/sql</code> 这个 package 的 <code>Query</code> 方法的签名一直是:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure><p>当 <code>context</code> package 引入的时候，Go team 新增了这样一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure><p>并且只修改了一处代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.QueryContext(context.Background(), query, args...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，Go team 能够在平滑地升级一个 <code>package</code> 的同时不对代码的可读性、兼容性造成影响。类似的代码在 golang 源码中随处可见。</p><h3 id="可选参数（optional-arguments）"><a href="#可选参数（optional-arguments）" class="headerlink" title="可选参数（optional arguments）"></a>可选参数（optional arguments）</h3><p>如果你在实现 package 之前就确定这个函数后面可能会需要添加参数来扩展某些功能，那么你可以提前在函数签名是使用可选参数（optional arguments）。最简单的方法是在函数签名中使用结构体参数，下面是 golang 源码中 <code>crypto/tls.Dial</code> 的一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, addr <span class="keyword">string</span>, config *Config)</span> <span class="params">(*Conn, error)</span></span></span><br></pre></td></tr></table></figure><p><code>Dial</code> 函数实现 <code>TLS</code> 的握手操作，这个过程中需要其他很多参数，同时还支持默认值。当给 <code>config</code> 传递 <code>nil</code> 的时候就是使用默认值；当传递 <code>Config struct</code> 的时候将会覆盖默认值。假如以后出现了新的 <code>TLS</code> 配置参数，可以很轻松地通过在 <code>Config struct</code> 中添加新字段来实现，这种方式是向后兼容的。</p><p>有些情况下，新增函数和使用可选参数的方式可以结合起来，通过把可选参数的结构体变成一个方法的接收者(receiver)。比如，在 Go 1.11 之前，<code>net</code> package 中的<code>Listen</code> 方法的签名是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br></pre></td></tr></table></figure><p>但是在 Go 1.11 中，Go team 新增加了两个 <code>feature</code> :</p><ol><li>传递了 context 参数；</li><li>增加了 <code>control function</code>，允许调用者在网络连接还没有 <code>bind</code> 的时候调整原始连接的参数。</li></ol><p>这看起来是相当大的调整了，如果是一般开发者，最多也就会新增一个函数，参数中添加 <code>context</code>, <code>control function</code>。但是 Go team 的开发者非等闲之辈，<code>net</code> package 的作者想到未来的某一天这个函数是不是会有调整，或者需要更多的参数？于是就预留了一个 <code>ListenConfig</code> 的结构体，为这个 strcut 实现了 <code>Listen</code> 方法，从而也不用再新增一个函数才能解决问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListenConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Control <span class="function"><span class="keyword">func</span><span class="params">(network, address <span class="keyword">string</span>, c syscall.RawConn)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(*ListenConfig)</span> <span class="title">Listen</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span></span><br></pre></td></tr></table></figure><p>还有一种叫做可选类型的设计模式，是把可选的函数作为函数形参，每一个可选函数都可以通过参数来调整其状态。在 Rob Pike 的 blog (<a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a>) 里对这种模式进行了详细的解读。这种设计模式在 grpc 的源码中大量使用。</p><p><code>option types</code> 与函数参数中的 <code>option struct</code>具有相同的作用：它们是传递行为，修改配置的可扩展方式。 决定选择哪个很大程度上取决于具体场景。 来看一下 gRPC 的 <code>DialOption</code> 选项类型的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grpc.Dial(<span class="string">"some-target"</span>,</span><br><span class="line">  grpc.WithAuthority(<span class="string">"some-authority"</span>),</span><br><span class="line">  grpc.WithMaxDelay(time.Second),</span><br><span class="line">  grpc.WithBlock())</span><br></pre></td></tr></table></figure><p>当然你也可以作为 struct 选项实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notgrpc.Dial(<span class="string">"some-target"</span>, &amp;notgrpc.Options&#123;</span><br><span class="line">  Authority: <span class="string">"some-authority"</span>,</span><br><span class="line">  MaxDelay:  time.Minute,</span><br><span class="line">  Block:     <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上，任一种方式都是能够维持 Go Module 兼容性的方法，可以根据不同的场景选择合理的实现。</p><h3 id="保证-interfaces-的兼容性"><a href="#保证-interfaces-的兼容性" class="headerlink" title="保证 interfaces 的兼容性"></a>保证 interfaces 的兼容性</h3><p>有时候，新特性的支持需要更改对外暴露的（public）的接口:  需要使用新的方法来扩展接口。直接向接口添加方法是不合适的，这会导致接口的实现方都需要修改代码。那么，我们如何才能在公开的接口上支持新方法呢？</p><p>Go team 给出的建议是：使用新方法定义一个新接口，然后在使用旧接口的任何地方动态检查提供的类型是旧类型还是新类型。</p><p>让我们以 golang  源码中 <code>archive/tar</code> package 来详细说明一下。 <code>tar.NewReader</code> 以 <code>io.Reader</code> 作为参数，但是后来 Go team 觉得应该提供一种更加高效的方式，就是当调用 <code>Seek</code> 方法的时候可以跳过一个文件的 header。但是又不能直接在 <code>io.Reader</code> 中新增 <code>Seek</code> 方法，这会影响所有实现了 <code>io.Reader</code> 的方法（如果你有看过 golang 源码，就会知道 io.Reader 接口的应用有多广泛了）。</p><p>另外一种方法是将 <code>tar.NeaReader</code> 的入参改成 <code>io.ReaderSeeker</code> interface，因为该 interface 同时支持 <code>io.Reader</code> 和 <code>Seek</code> 。但是正如前面所讲，改变一个函数的签名，不是一种好的方式。</p><p>所以 Go team 决定维持 <code>tar.NewReader</code> 的签名不变，在 <code>Read</code> 方法中进行类型检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tar</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Reader&#123;r: r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> rs, ok := r.r.(io.Seeker); ok &#123;</span><br><span class="line">    <span class="comment">// Use more efficient rs.Seek.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Use less efficient r.r.Read.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果遇到要向现有接口添加方法的情况，则可以遵循此策略。 首先使用新方法创建新接口，或者使用新方法标识现有接口。 接下来，确定需要添加的相关代码啊，对第二个接口进行类型检查，并添加使用它的代码。</p><p>在可能的情况下，最好避免这种问题。 例如，在设计构造函数时，最好返回具体类型。 与接口不同，使用具体类型可以让你将来在不中断用户使用的情况下添加新方法，同时将来可以更轻松地扩展你的 Go Module。</p><p>Tip: 如果你用到了一个 interface，但是你不想用户去实现它，你可以为 interface 添加 <code>unexported</code> 的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Errorf(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A private method to prevent users implementing the</span></span><br><span class="line">    <span class="comment">// interface and so future additions to it will not</span></span><br><span class="line">    <span class="comment">// violate Go 1 compatibility.</span></span><br><span class="line"><span class="comment">// private 避免用户去实现它</span></span><br><span class="line">    private()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增配置方法"><a href="#新增配置方法" class="headerlink" title="新增配置方法"></a>新增配置方法</h3><p>到目前为止，我们讨论了修改函数签名或者为 interface 添加方法，会影响到用户的代码导致编译失败。实际上，函数行为的改变会造成同样的问题。例如，很多开发者希望 <code>json.Decoder</code> 可以忽略 <code>struct</code> 中没有的 <code>json</code> 字段。但是当 Go team 想要在这种情况下返回一些错误的时候，就必须要小心，因为这样做会导致很多使用该方法的用户突然收到以前从未遇到的错误。</p><p>因此，他们没有更改所有用户的行为，而是向Decoder结构添加了一种配置方法：<code>Decoder.DisallowUnknownFields</code> 。 调用此方法会使用户选择新行为，同时会为现有用户保留旧的方法。</p><h3 id="保持-struct-的兼容性"><a href="#保持-struct-的兼容性" class="headerlink" title="保持 struct 的兼容性"></a>保持 struct 的兼容性</h3><p>通过上面的内容我们了解到，对函数签名的任何更改都是一种破坏性的改动。 但是如果使用 <code>struct</code> 就会让你的代码灵活很多， 如果具有可导出的结构体类型，则几乎可以随时添加一个字段或删除一个未导出的字段而不会破坏兼容性。 添加字段时，请确保其零值有意义并保留旧的行为，以便未设置该字段的现有代码继续起作用。</p><p>还记得上面讲到的 <code>net</code> package 的作者在 Go 1.11 的时候添加的 <code>ListenConfig</code> struct 吗？事实证明他的设计是对的。在 Go 1.13 中，新增了 <code>KeepAlive</code> 字段，允许取消或使用 keep-alive 的功能。有了之前的设计，这个字段的加入就容易多了。</p><p>关于 struct 的使用，有一个细节如果你没有注意到的话，也会对用户造成很大的影响。如果 struct 中所有的字段都是可判等的（意思是可用通过 <code>==</code> or <code>!=</code>来比较，或者可以作为 map 的 key），那么这个 struct 就是可判等的。这种情况下，如果你为 struct 添加了一个不可判等的类型，将会导致这个 struct 也变成不可判等的。如果用户在代码中使用了你的 struct 进行判等操作，那么就会遇到代码错误。</p><p>如果你要保持结构体可判等，就不要向其添加不可比较的字段。可以为此编写测试用例来避免遗忘。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>从头开始规划 API 的时候，请仔细考虑 API 在将来的可扩展性。 而且当你确实需要添加新功能时，请记住以下规则：添加，不要更改或删除。请牢记，添加接口方法，函数参数和返回值都会导致 Go Module 不能向后兼容。</p><p>如果你确实需要大规模更改 API，或者要添加更多新特性，那么使用新的 API 版本会是更好的方式。 但是大多数时候，进行向后兼容的更改应该是你的首选，能够避免给用户带来麻烦。</p><hr>]]></content>
    
    <summary type="html">
    
      Go team 关于如何保持 Go Modules 兼容性的一些实践
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>lxcfs 实现容器资源视图隔离的最佳实践</title>
    <link href="https://cloudsjhan.github.io/2020/07/04/lxcfs-%E5%AE%9E%E7%8E%B0%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E8%A7%86%E5%9B%BE%E9%9A%94%E7%A6%BB%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E9%97%B4/"/>
    <id>https://cloudsjhan.github.io/2020/07/04/lxcfs-实现容器资源视图隔离的最佳时间/</id>
    <published>2020-07-04T12:49:46.000Z</published>
    <updated>2020-07-04T12:55:06.656Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><blockquote><p>LXCFS is a small FUSE filesystem written with the intention of making Linux containers feel more like a virtual machine. It started as a side-project of LXC but is useable by any runtime.</p></blockquote><p>用人话解释一下就是：</p><blockquote><p>xcfs 是一个开源的 FUSE（用户态文件系统）实现来支持 LXC 容器，它也可以支持 Docker 容器。让容器内的应用在读取内存和 CPU 信息的时候通过 lxcfs 的映射，转到自己的通过对 cgroup 中容器相关定义信息读取的虚拟数据上。</p></blockquote><h2 id="什么是资源视图隔离？"><a href="#什么是资源视图隔离？" class="headerlink" title="什么是资源视图隔离？"></a>什么是资源视图隔离？</h2><p>容器技术提供了不同于传统虚拟机技术的环境隔离方式。通常的Linux容器对容器打包和启动进行了加速，但也降低了容器的隔离强度。其中Linux容器最为知名的问题就是资源视图隔离问题。</p><p>容器可以通过 cgroup 的方式对资源的使用情况进行限制，包括: 内存，CPU 等。但是需要注意的是，如果容器内的一个进程使用一些常用的监控命令，如: free, top 等命令其实看到还是物理机的数据，而非容器的数据。这是由于容器并没有做到对 <code>/proc</code>, <code>/sys</code> 等文件系统的资源视图隔离。</p><h2 id="为什么要做容器的资源视图隔离？"><a href="#为什么要做容器的资源视图隔离？" class="headerlink" title="为什么要做容器的资源视图隔离？"></a>为什么要做容器的资源视图隔离？</h2><ol><li><p>从容器的视角来看，通常有一些业务开发者已经习惯了在传统的物理机，虚拟机上使用 <code>top</code>, <code></code>free` 等命令来查看系统的资源使用情况，但是容器没有做到资源视图隔离，那么在容器里面看到的数据还是物理机的数据。</p></li><li><p>从应用程序的视角来看，在容器里面运行进程和在物理机虚拟机上运行进程的运行环境是不同的。并且有些应用在容器里面运行进程会存在一些安全隐患:</p><p>对于很多基于 JVM 的 java 程序，应用启动时会根据系统的资源上限来分配 JVM 的堆和栈的大小。而在容器里面运行运行 JAVA 应用由于 JVM 获取的内存数据还是物理机的数据，而容器分配的资源配额又小于 JVM 启动时需要的资源大小，就会导致程序启动不成功。</p><p>对于需要获取 host cpu info 的程序，比如在开发 golang 服务端需要获取 golang中 <code>runtime.GOMAXPROCS(runtime.NumCPU())</code> 或者运维在设置服务启动进程数量的时候( 比如 nginx 配置中的 worker_processes auto )，都喜欢通过程序自动判断所在运行环境CPU的数量。但是在容器内的进程总会从<code>/proc/cpuinfo</code>中获取到 CPU 的核数，而容器里面的<code>/proc</code>文件系统还是物理机的，从而会影响到运行在容器里面服务的运行状态。</p><p>如何做容器的资源视图隔离？</p><h2 id="lxcfs-横空出世就是为了解决这个问题。"><a href="#lxcfs-横空出世就是为了解决这个问题。" class="headerlink" title="lxcfs 横空出世就是为了解决这个问题。"></a>lxcfs 横空出世就是为了解决这个问题。</h2><p>lxcfs 是通过文件挂载的方式，把 cgroup 中关于系统的相关信息读取出来，通过 docker 的 volume 挂载给容器内部的 proc 系统。 然后让 docker 内的应用读取 proc 中信息的时候以为就是读取的宿主机的真实的 proc。</p><p>下面是 lxcfs 的工作原理架构图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3n2n48tj318e0msmz5.jpg" alt="lxcfs" style="zoom:50%;"></p><p>解释一下这张图，当我们把宿主机的 <code>/var/lib/lxcfs/proc/memoinfo</code> 文件挂载到 Docker 容器的 <code>/proc/meminfo</code> 位置后，容器中进程读取相应文件内容时，lxcfs 的 <code>/dev/fuse</code> 实现会从容器对应的 Cgroup 中读取正确的内存限制。从而使得应用获得正确的资源约束。 cpu 的限制原理也是一样的。</p><h2 id="通过-lxcfs-实现资源视图隔离"><a href="#通过-lxcfs-实现资源视图隔离" class="headerlink" title="通过 lxcfs 实现资源视图隔离"></a>通过 lxcfs 实现资源视图隔离</h2><h3 id="安装-lxcfs"><a href="#安装-lxcfs" class="headerlink" title="安装 lxcfs"></a>安装 lxcfs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget &lt;https://copr-be.cloud.fedoraproject.org/results/ganto/lxc3/epel-7-x86_64/01041891-lxcfs/lxcfs-3.1.2-0.2.el7.x86_64.rpm&gt;</span><br><span class="line">rpm -ivh lxcfs-3.1.2-0.2.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>检查一下安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ifdasdfe2344 system]<span class="comment"># lxcfs -h</span></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">lxcfs [-f|-d] [-p pidfile] mountpoint</span><br><span class="line">  -f running foreground by default; -d <span class="built_in">enable</span> debug output</span><br><span class="line">  Default pidfile is /run/lxcfs.pid</span><br><span class="line">lxcfs -h</span><br></pre></td></tr></table></figure><h3 id="启动-lxcfs"><a href="#启动-lxcfs" class="headerlink" title="启动 lxcfs"></a>启动 lxcfs</h3><ol><li>直接后台启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxcfs /var/lib/lxcfs &amp;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过 systemd 启动（推荐）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">touch /usr/lib/systemd/system/lxcfs.service</span><br><span class="line"></span><br><span class="line">cat &gt; /usr/lib/systemd/system/lxcfs.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=lxcfs</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/lxcfs -f /var/lib/lxcfs</span><br><span class="line">Restart=on-failure</span><br><span class="line"><span class="comment">#ExecReload=/bin/kill -s SIGHUP $MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start lxcfs.service</span><br></pre></td></tr></table></figure><p>检查启动是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ifdasdfe2344 system]<span class="comment"># ps aux | grep lxcfs</span></span><br><span class="line">root      3276  0.0  0.0 112708   980 pts/2    S+   15:45   0:00 grep --color=auto lxcfs</span><br><span class="line">root     18625  0.0  0.0 234628  1296 ?        Ssl  14:16   0:00 /usr/bin/lxcfs -f /var/lib/lxcfs</span><br></pre></td></tr></table></figure><p>启动成功。</p><h2 id="验证-lxcfs-效果"><a href="#验证-lxcfs-效果" class="headerlink" title="验证 lxcfs 效果"></a>验证 lxcfs 效果</h2><h3 id="未开启-lxcfs"><a href="#未开启-lxcfs" class="headerlink" title="未开启 lxcfs"></a>未开启 lxcfs</h3><p>我们首先在未开启 lxcfs 的机器上运行一个容器，进入到容器中观察 cpu, memory 的信息。为了看出明显的差别，我们用了一台高配置服务器（32c128g）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行以下操作</span></span><br><span class="line">systemctl stop lxcfs</span><br><span class="line"></span><br><span class="line">docker run -it ubuntu /bin/bash <span class="comment"># 进入到 nginx 容器中</span></span><br><span class="line"></span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3p6a8yyj32jy07uk16.jpg" alt="image-20200704180911456" style="zoom:50%;"></p><p>通过上面的结果我们可以看到虽然是在容器中查看内存信息，但是显示的还是宿主机的 meminfo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看一下 CPU 的核数</span></span><br><span class="line">cat /proc/cpuinfo| grep <span class="string">"processor"</span>| wc -l</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3q20it9j31z003yq6j.jpg" alt="image-20200704181007610" style="zoom:50%;"></p><p>结果符合我们的猜想，没有开启 lxcfs ，容器所看到的 cpuinfo 就是宿主机的。</p><h3 id="开启-lxcfs"><a href="#开启-lxcfs" class="headerlink" title="开启 lxcfs"></a>开启 lxcfs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">systemctl start lxcfs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个容器，用 lxcfs 的 /proc 文件映射到容器中的 /proc 文件，容器内存设置为 256M：</span></span><br><span class="line">docker run -it -m 256m \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \\</span><br><span class="line">      ubuntu:latest /bin/bash</span><br><span class="line"></span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3qo5o8pj32he08012z.jpg" alt="image-20200704181044965" style="zoom:50%;"></p><p>可以看到容器本身的内存被正确获取到了，对于内存的资源视图隔离是成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --cpus 2，限定容器最多只能使用两个逻辑CPU</span></span><br><span class="line"></span><br><span class="line">docker run -it --rm -m 256m  --cpus 2  \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/<span class="built_in">stat</span>:/proc/<span class="built_in">stat</span>:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw \\</span><br><span class="line">      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw \\</span><br><span class="line">      ubuntu:latest /bin/sh</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3s9iz85j31lc05qdj8.jpg" alt="image-20200704181153515"></p><p>cpuinfo 也是我们所限制容器所能使用的逻辑 cpu 的数量了。指定容器只能在指定的 CPU 数量上运行应当是利大于弊的，就是在创建容器的时候需要额外做点工作，合理分配 cpuset。</p><h2 id="lxcfs-的-Kubernetes实践"><a href="#lxcfs-的-Kubernetes实践" class="headerlink" title="lxcfs 的 Kubernetes实践"></a>lxcfs 的 Kubernetes实践</h2><p>在kubernetes中使用lxcfs需要解决两个问题：</p><p>第一个问题是每个node上都要启动 lxcfs；</p><p>第二个问题是将 lxcfs 维护的 /proc 文件挂载到每个容器中；</p><h2 id="DaemonSet方式来运行-lxcfs-FUSE文件系统"><a href="#DaemonSet方式来运行-lxcfs-FUSE文件系统" class="headerlink" title="DaemonSet方式来运行 lxcfs FUSE文件系统"></a>DaemonSet方式来运行 lxcfs FUSE文件系统</h2><p>针对第一个问题，我们使用 daemonset 在每个 k8s node 上都安装 lxcfs。</p><p>直接使用下面的 yaml 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: lxcfs</span><br><span class="line">  labels:</span><br><span class="line">    app: lxcfs</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: lxcfs</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: lxcfs</span><br><span class="line">    spec:</span><br><span class="line">      hostPID: <span class="literal">true</span></span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">      containers:</span><br><span class="line">      - name: lxcfs</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/denverdino/lxcfs:3.0.4</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: <span class="literal">true</span></span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: cgroup</span><br><span class="line">          mountPath: /sys/fs/cgroup</span><br><span class="line">        - name: lxcfs</span><br><span class="line">          mountPath: /var/lib/lxcfs</span><br><span class="line">          mountPropagation: Bidirectional</span><br><span class="line">        - name: usr-local</span><br><span class="line">          mountPath: /usr/<span class="built_in">local</span></span><br><span class="line">      volumes:</span><br><span class="line">      - name: cgroup</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /sys/fs/cgroup</span><br><span class="line">      - name: usr-local</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /usr/<span class="built_in">local</span></span><br><span class="line">      - name: lxcfs</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/lib/lxcfs</span><br><span class="line">          <span class="built_in">type</span>: DirectoryOrCreate</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f lxcfs-daemonset.yaml</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggf3srgk92j32j006sgtt.jpg" alt="image-20200704181243710" style="zoom:50%;"></p><p>可以看到 lxcfs 的 daemonset 已经部署到每个 node 上。</p><h3 id="映射-lxcfs-的-proc-文件到容器"><a href="#映射-lxcfs-的-proc-文件到容器" class="headerlink" title="映射 lxcfs 的 proc 文件到容器"></a>映射 lxcfs 的 proc 文件到容器</h3><p>针对第二个问题，我们两种方法来解决。</p><p>第一种就是简单地在 k8s deployment 的 yaml 文件中声明对宿主机 <code>/var/lib/lxcfs/proc</code> 一系列文件的挂载。</p><p>第二种方式利用Kubernetes的扩展机制 Initializer，实现对 lxcfs 文件的自动化挂载。但是 <code>InitializerConfiguration</code> 的功能在 k8s 1.14 之后就不再支持了，这里不再赘述。但是我们可以实现 admission-webhook （准入控制（Admission Control）在授权后对请求做进一步的验证或添加默认参数, <a href="https://kubernetes.feisky.xyz/extension/auth/admission）来达到同样的目的。" target="_blank" rel="noopener">https://kubernetes.feisky.xyz/extension/auth/admission）来达到同样的目的。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证你的 k8s 集群是否支持 admission</span></span><br><span class="line">$ kubectl api-versions | grep admissionregistration.k8s.io/v1beta1</span><br><span class="line">admissionregistration.k8s.io/v1beta1</span><br></pre></td></tr></table></figure><p>关于 admission-webhook 的编写不属于本文的讨论范围，可以到官方文档中深入了解。</p><p>这里有一个实现 lxcfs admission webhook 的范例，可以参考：<a href="https://github.com/hantmac/lxcfs-admission-webhook" target="_blank" rel="noopener">https://github.com/hantmac/lxcfs-admission-webhook</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了通过 lxcfs 提供容器资源视图隔离的方法，可以帮助一些容器化应用更好的识别容器运行时的资源限制。</p><p>同时，在本文中我们介绍了利用容器和 DaemonSet 的方式部署 lxcfs FUSE，这不但极大简化了部署，也可以方便地利用 Kubernetes 自身的容器管理能力，支持 lxcfs 进程失效时自动恢复，在集群伸缩时也可以保证节点部署的一致性。这个技巧对于其他类似的监控或者系统扩展都是适用的。</p><p>另外我们介绍了利用Kubernetes的 admission webhook，实现对 lxcfs 文件的自动化挂载。整个过程对于应用部署人员是透明的，可以极大简化运维复杂度。</p><hr></li></ol>]]></content>
    
    <summary type="html">
    
      lxcfs 实现容器资源隔离的最佳实践
    
    </summary>
    
      <category term="docker" scheme="https://cloudsjhan.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://cloudsjhan.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>重磅！微软 VS Code 的 Go 语言插件迁移至由 Go 官方团队维护</title>
    <link href="https://cloudsjhan.github.io/2020/06/12/%E9%87%8D%E7%A3%85%EF%BC%81%E5%BE%AE%E8%BD%AF-VS-Code-%E7%9A%84-Go-%E8%AF%AD%E8%A8%80%E6%8F%92%E4%BB%B6%E8%BF%81%E7%A7%BB%E8%87%B3%E7%94%B1-Go-%E5%AE%98%E6%96%B9%E5%9B%A2%E9%98%9F%E7%BB%B4%E6%8A%A4/"/>
    <id>https://cloudsjhan.github.io/2020/06/12/重磅！微软-VS-Code-的-Go-语言插件迁移至由-Go-官方团队维护/</id>
    <published>2020-06-12T11:49:44.000Z</published>
    <updated>2020-06-12T11:51:42.038Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfpq8aa2ioj30qo05x74s.jpg" alt=""></p><p>Go 官方 6月 9日电：VS Code 的 <code>Go plugin</code> 已经转为 Go 官方团队维护的项目。其中有两个重要的标志性事件：</p><ol><li><code>GitHub</code> 仓库已经从 <a href="https://github.com/microsoft/vscode-go" target="_blank" rel="noopener">https://github.com/microsoft/vscode-go</a> 迁移至  <a href="https://github.com/golang/vscode-go" target="_blank" rel="noopener">https://github.com/golang/vscode-go</a> ；</li><li>在 VS Code 插件市场中的发布者也由 <code>Microsoft</code>  变更为  <code>Go Team at Google</code> 。</li></ol><p>自去年 <code>Go modules</code> 发布以来，<code>VS Code</code> 团队就和 <code>Go</code> 团队开始了紧密的合作，让插件得以支持 <code>Go</code> 的官方语言服务器 <code>gopls</code>，目前还正在改进对 <code>Delve</code> 调试器的支持。</p><p>从另一方面来看，迁移至由 <code>Go</code> 团队维护意味着此插件成为了 <code>Go</code> 项目的一部分，可确保 <code>Go</code> 社区成员能参与到项目的每一步。插件目前依赖于许多不同的工具和库，而这些工具和库均由社区维护，<code>VS Code</code> 团队希望与这些项目的所有者合作，以帮助减少 <code>Go</code> 社区的维护工作负担，并鼓励更多 <code>Gophers</code> 参与进来共同维护。</p><p>原文地址: <a href="https://blog.golang.org/vscode-go" target="_blank" rel="noopener">https://blog.golang.org/vscode-go</a></p><hr>]]></content>
    
    <summary type="html">
    
      重磅！微软 VS Code 的 Go 语言插件迁移至由 Go 官方团队维护
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Uber Go 语言编码规范</title>
    <link href="https://cloudsjhan.github.io/2020/06/09/Uber-Go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://cloudsjhan.github.io/2020/06/09/Uber-Go-语言编码规范/</id>
    <published>2020-06-09T02:36:29.000Z</published>
    <updated>2020-06-09T02:37:57.862Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><!--Editing this document:- Discuss all changes in GitHub issues first.- Update the table of contents as new sections are added or removed.- Use tables for side-by-side code samples. See below.Code Samples:Use 2 spaces to indent. Horizontal real estate is important in side-by-sidesamples.For side-by-side code samples, use the following snippet.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bad&lt;/th&gt;&lt;th&gt;Good&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">BAD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">GOOD CODE GOES HERE</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>(You need the empty lines between the <td> and code samples for it to be<br>treated as Markdown.)</p><p>If you need to add labels or descriptions below the code samples, add another<br>row before the </tbody></table> line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE BAD CODE&lt;/td&gt;</span><br><span class="line">&lt;td&gt;DESCRIBE GOOD CODE&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><p>–&gt;</p><!--change.md# 2019-12-17- 函数选项：推荐 “Option” 接口的结构实现- 而不是用闭包捕获值。# 2019-11-26- 添加针对全局变量变异的指导。# 2020-01-11- 为`open（..）`调用添加缺少的参数。# 2020-02-03- 使用 `"time"` 处理时间的建议- 添加有关在公共结构中嵌入类型的指导。# 2020-02-25- 添加有关接口验证是否符合编译时检查的指导。# 2020-06-05- 添加避免使用内置名称的指导意见--><h1 id="uber-go-guide-的中文翻译"><a href="#uber-go-guide-的中文翻译" class="headerlink" title="uber-go/guide 的中文翻译"></a><a href="https://github.com/uber-go/guide" target="_blank" rel="noopener">uber-go/guide</a> 的中文翻译</h1><h1 id="English"><a href="#English" class="headerlink" title="English"></a><a href="https://github.com/uber-go/guide/blob/master/style.md" target="_blank" rel="noopener">English</a></h1><h1 id="Uber-Go-语言编码规范"><a href="#Uber-Go-语言编码规范" class="headerlink" title="Uber Go 语言编码规范"></a>Uber Go 语言编码规范</h1><p> <a href="https://www.uber.com/" target="_blank" rel="noopener">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a>、<a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide" target="_blank" rel="noopener">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>当前更新版本：2020-06-05 版本地址：<a href="https://github.com/uber-go/guide/commit/2910ce2e11d0e0cba2cece2c60ae45e3a984ffe5" target="_blank" rel="noopener">commit:#93</a></li><li>如果您发现任何更新、问题或改进，请随时 fork 和 PR</li><li>Please feel free to fork and PR if you find any updates, issues or improvement.</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#2019-12-17">2019-12-17</a></li><li><a href="#2019-11-26">2019-11-26</a></li><li><a href="#2020-01-11">2020-01-11</a></li><li><a href="#2020-02-03">2020-02-03</a></li><li><a href="#2020-02-25">2020-02-25</a></li><li><a href="#2020-06-05">2020-06-05</a></li><li><a href="#uber-goguide-的中文翻译">uber-go/guide 的中文翻译</a></li><li><a href="#english">English</a></li><li><a href="#uber-go-语言编码规范">Uber Go 语言编码规范</a><ul><li><a href="#版本">版本</a></li><li><a href="#目录">目录</a></li><li><a href="#介绍">介绍</a></li><li><a href="#指导原则">指导原则</a><ul><li><a href="#指向-interface-的指针">指向 interface 的指针</a></li><li><a href="#interface-合理性验证">Interface 合理性验证</a></li><li><a href="#接收器-receiver-与接口">接收器 (receiver) 与接口</a></li><li><a href="#零值-mutex-是有效的">零值 Mutex 是有效的</a></li><li><a href="#在边界处拷贝-slices-和-maps">在边界处拷贝 Slices 和 Maps</a><ul><li><a href="#接收-slices-和-maps">接收 Slices 和 Maps</a></li><li><a href="#返回-slices-或-maps">返回 slices 或 maps</a></li></ul></li><li><a href="#使用-defer-释放资源">使用 defer 释放资源</a></li><li><a href="#channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的</a></li><li><a href="#枚举从-1-开始">枚举从 1 开始</a></li><li><a href="#使用-time-处理时间">使用 time 处理时间</a><ul><li><a href="#使用-timetime-表达瞬时时间">使用 <code>time.Time</code> 表达瞬时时间</a></li><li><a href="#使用-timeduration-表达时间段">使用 <code>time.Duration</code> 表达时间段</a></li><li><a href="#对外部系统使用-timetime-和-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li></ul></li><li><a href="#错误类型">错误类型</a></li><li><a href="#错误包装-error-wrapping">错误包装 (Error Wrapping)</a></li><li><a href="#处理类型断言失败">处理类型断言失败</a></li><li><a href="#不要-panic">不要 panic</a></li><li><a href="#使用-gouberorgatomic">使用 go.uber.org/atomic</a></li><li><a href="#避免可变全局变量">避免可变全局变量</a></li><li><a href="#避免在公共结构中嵌入类型">避免在公共结构中嵌入类型</a></li><li><a href="#避免使用内置名称">避免使用内置名称</a></li></ul></li><li><a href="#性能">性能</a><ul><li><a href="#优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt</a></li><li><a href="#避免字符串到字节的转换">避免字符串到字节的转换</a></li><li><a href="#尽量初始化时指定-map-容量">尽量初始化时指定 Map 容量</a></li></ul></li><li><a href="#规范">规范</a><ul><li><a href="#一致性">一致性</a></li><li><a href="#相似的声明放在一组">相似的声明放在一组</a></li><li><a href="#import-分组">import 分组</a></li><li><a href="#包名">包名</a></li><li><a href="#函数名">函数名</a></li><li><a href="#导入别名">导入别名</a></li><li><a href="#函数分组与顺序">函数分组与顺序</a></li><li><a href="#减少嵌套">减少嵌套</a></li><li><a href="#不必要的-else">不必要的 else</a></li><li><a href="#顶层变量声明">顶层变量声明</a></li><li><a href="#对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀</a></li><li><a href="#结构体中的嵌入">结构体中的嵌入</a></li><li><a href="#使用字段名初始化结构体">使用字段名初始化结构体</a></li><li><a href="#本地变量声明">本地变量声明</a></li><li><a href="#nil-是一个有效的-slice">nil 是一个有效的 slice</a></li><li><a href="#缩小变量作用域">缩小变量作用域</a></li><li><a href="#避免参数语义不明确avoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</a></li><li><a href="#使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义</a></li><li><a href="#初始化-struct-引用">初始化 Struct 引用</a></li><li><a href="#初始化-maps">初始化 Maps</a></li><li><a href="#字符串-string-format">字符串 string format</a></li><li><a href="#命名-printf-样式的函数">命名 Printf 样式的函数</a></li></ul></li><li><a href="#编程模式">编程模式</a><ul><li><a href="#表驱动测试">表驱动测试</a></li><li><a href="#功能选项">功能选项</a></li></ul></li><li><a href="#stargazers-over-time">Stargazers over time</a></li></ul></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p><p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p><p>该指南最初由 <a href="https://github.com/prashantv" target="_blank" rel="noopener">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52" target="_blank" rel="noopener">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p><p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p><ol><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">The Go common mistakes guide</a></li></ol><p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p><ul><li>保存时运行 <code>goimports</code></li><li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li></ul><p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：<br><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins" target="_blank" rel="noopener">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="指向-interface-的指针"><a href="#指向-interface-的指针" class="headerlink" title="指向 interface 的指针"></a>指向 interface 的指针</h3><p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p><p>接口实质上在底层用两个字段表示：</p><ol><li>一个指向某些特定类型信息的指针。您可以将其视为”type”。</li><li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li></ol><p>如果希望接口方法修改基础数据，则必须使用指针传递。</p><h3 id="Interface-合理性验证"><a href="#Interface-合理性验证" class="headerlink" title="Interface 合理性验证"></a>Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p><ul><li>将实现特定接口所需的导出类型作为其 API 的一部分</li><li>导出或未导出的类型是实现同一接口的类型集合的一部分</li><li>其他违反接口的情况会破坏用户。</li></ul><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = (*Handler)(<span class="literal">nil</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果 <code>*Handler</code> 永远不会与 <code>http.Handler</code> 接口匹配,那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译</p><p>赋值的右边应该是断言类型的零值。对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；对于结构类型，这是空结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h LogHandler)</span> <span class="title">ServeHTTP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  w http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">  r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收器-receiver-与接口"><a href="#接收器-receiver-与接口" class="headerlink" title="接收器 (receiver) 与接口"></a>接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p><p>例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你只能通过值调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：</span></span><br><span class="line"><span class="comment">//  sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>同样，即使该方法具有值接收器，也可以通过指针来满足接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure><p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">pointers vs. values</a> 的精彩讲解。</p><h3 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。<br>如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p><table><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex <span class="comment">// only for unexported types（仅适用于非导出类型）</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span> *<span class="title">smap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;smap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><br><br><tr><br><td>为私有类型或需要实现互斥接口的类型嵌入。</td><br><td>对于导出的类型，请使用专用字段。</td><br></tr><br><br></tbody></table><h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="接收-Slices-和-Maps"><a href="#接收-Slices-和-Maps" class="headerlink" title="接收 Slices 和 Maps"></a>接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><table><br><thead><tr><th>Bad</th> <th>Good</th></tr></thead><br><tbody><br><tr><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><br><br></td><br></tr><br><br></tbody><br></table><h4 id="返回-slices-或-maps"><a href="#返回-slices-或-maps" class="headerlink" title="返回 slices 或 maps"></a>返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="使用-defer-释放资源"><a href="#使用-defer-释放资源" class="headerlink" title="使用 defer 释放资源"></a>使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p><h3 id="Channel-的-size-要么是-1，要么是无缓冲的"><a href="#Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="Channel 的 size 要么是 1，要么是无缓冲的"></a>Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="枚举从-1-开始"><a href="#枚举从-1-开始" class="headerlink" title="枚举从 1 开始"></a>枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure><h3 id="使用-time-处理时间"><a href="#使用-time-处理时间" class="headerlink" title="使用 time 处理时间"></a>使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p><ol><li>一天有 24 小时</li><li>一小时有 60 分钟</li><li>一周有七天</li><li>一年 365 天</li><li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time" target="_blank" rel="noopener">还有更多</a></li></ol><p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p><p>因此，在处理时间时始终使用 <a href="https://golang.org/pkg/time/" target="_blank" rel="noopener"><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p><h4 id="使用-time-Time-表达瞬时时间"><a href="#使用-time-Time-表达瞬时时间" class="headerlink" title="使用 time.Time 表达瞬时时间"></a>使用 <code>time.Time</code> 表达瞬时时间</h4><p>在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noopener"><code>time.time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h4 id="使用-time-Duration-表达时间段"><a href="#使用-time-Duration-表达时间段" class="headerlink" title="使用 time.Duration 表达时间段"></a>使用 <code>time.Duration</code> 表达时间段</h4><p>在处理时间段时使用 <a href="https://golang.org/pkg/time/#Duration" target="_blank" rel="noopener"><code>time.Duration</code></a> .</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate" target="_blank" rel="noopener"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add" target="_blank" rel="noopener"><code>Time.Add</code></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">0</span>, <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>)</span><br><span class="line">maybeNewDay := t.Add(<span class="number">24</span> * time.Hour)</span><br></pre></td></tr></table></figure><h4 id="对外部系统使用-time-Time-和-time-Duration"><a href="#对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="对外部系统使用 time.Time 和 time.Duration"></a>对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p><ul><li>Command-line 标志: <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></li><li>JSON: <a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON" target="_blank" rel="noopener"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串</li><li>SQL: <a href="https://golang.org/pkg/database/sql/" target="_blank" rel="noopener"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</li><li>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2" target="_blank" rel="noopener"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</li></ul><p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p><p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"interval": 2&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interval <span class="keyword">int</span> <span class="string">`json:"interval"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;"intervalMillis": 2000&#125;</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  IntervalMillis <span class="keyword">int</span> <span class="string">`json:"intervalMillis"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 中定义的格式时间戳。默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText" target="_blank" rel="noopener"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339" target="_blank" rel="noopener"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p><p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728" target="_blank" rel="noopener">8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190" target="_blank" rel="noopener">15190</a>）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p><!-- TODO: section on String methods for enums --><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>Go 中有多种声明错误（Error) 的选项：</p><ul><li><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 对于简单静态字符串的错误</li><li><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li><li>实现 <code>Error()</code> 方法的自定义类型</li><li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li></ul><p>返回错误时，请考虑以下因素以确定最佳选择：</p><ul><li>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 足够了。</li><li>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</li><li>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#错误包装 (Error-Wrapping">section on error wrapping</a>) 部分的内容。</li><li>否则 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 就可以了。</li></ul><p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>，请使用一个错误变量。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"foo"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- TODO: Exposing the information to callers with accessor functions. --><h3 id="错误包装-Error-Wrapping"><a href="#错误包装-Error-Wrapping" class="headerlink" title="错误包装 (Error Wrapping)"></a>错误包装 (Error Wrapping)</h3><p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p><ul><li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li><li>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li><li>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a>。</li></ul><p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p><p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"failed to create new store: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><tr><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p><p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p><h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><!-- TODO: There are a few situations where the single assignment form isfine. --><h3 id="不要-panic"><a href="#不要-panic" class="headerlink" title="不要 panic"></a>不要 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  foo(os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := foo(os.Args[<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><!-- TODO: Explain how to use _test packages. --><h3 id="使用-go-uber-org-atomic"><a href="#使用-go-uber-org-atomic" class="headerlink" title="使用 go.uber.org/atomic"></a>使用 go.uber.org/atomic</h3><p>使用 <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p><p><a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。<br>既适用于函数指针又适用于其他值类型</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">var</span> _timeNow = time.Now</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">newSigner</span><span class="params">()</span> *<span class="title">signer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span> <span class="title">Sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSign</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p><p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。<br>相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">类型嵌入</a> 作为继承和组合之间的折衷。<br>外部类型获取嵌入类型的方法的隐式副本。<br>默认情况下，这些方法委托给嵌入实例的同一方法。</p><p>结构还获得与类型同名的字段。<br>所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p><p>很少需要嵌入类型。<br>这是一种方便，可以帮助您避免编写冗长的委托方法。</p><p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractList 是各种实体列表的通用实现。</span></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p><ul><li>向嵌入式接口添加方法是一个破坏性的改变。</li><li>删除嵌入类型是一个破坏性的改变。</li><li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li></ul><p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p><h3 id="避免使用内置名称"><a href="#避免使用内置名称" class="headerlink" title="避免使用内置名称"></a>避免使用内置名称</h3><p>Go语言规范<a href="https://golang.org/ref/spec" target="_blank" rel="noopener">language specification</a> 概述了几个内置的，<br>不应在Go项目中使用的名称标识<a href="https://golang.org/ref/spec#Predeclared_identifiers" target="_blank" rel="noopener">predeclared identifiers</a>。</p><p>根据上下文的不同，将这些标识符作为名称重复使用，<br>将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br>在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(error <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="keyword">string</span></span><br><span class="line"><span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 指向内置的非覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span></span><br><span class="line">    error  error</span><br><span class="line">    <span class="keyword">string</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err error</span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br>但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能方面的特定准则只适用于高频场景。</p><h3 id="优先使用-strconv-而不是-fmt"><a href="#优先使用-strconv-而不是-fmt" class="headerlink" title="优先使用 strconv 而不是 fmt"></a>优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns/op    2 allocs/op</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免字符串到字节的转换"><a href="#避免字符串到字节的转换" class="headerlink" title="避免字符串到字节的转换"></a>避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="尽量初始化时指定-Map-容量"><a href="#尽量初始化时指定-Map-容量" class="headerlink" title="尽量初始化时指定 Map 容量"></a>尽量初始化时指定 Map 容量</h3><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure><p>为 <code>make()</code> 提供容量信息（hint）尝试在初始化时调整 map 大小，<br>这减少了在将元素添加到 map 时增长和分配的开销。<br>注意，map 不能保证分配 hint 个容量。因此，即使提供了容量，添加元素仍然可以进行分配。 </p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。<br><br></td><td><br><br><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。<br><br></td></tr><br></tbody></table><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p><p>但是最重要的是，<strong>保持一致</strong>.</p><p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p><p>相反，一个单一的代码库会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、<br>代码审查痛苦、而且增加 bug 数量</p><p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p><h3 id="相似的声明放在一组"><a href="#相似的声明放在一组" class="headerlink" title="相似的声明放在一组"></a>相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>这同样适用于常量、变量和类型声明：</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  ENV_VAR = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV_VAR = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">    green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="import-分组"><a href="#import-分组" class="headerlink" title="import 分组"></a>import 分组</h3><p>导入应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><p>默认情况下，这是 goimports 应用的分组。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a> 和 <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a>.</p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p><h3 id="导入别名"><a href="#导入别名" class="headerlink" title="导入别名"></a>导入别名</h3><p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="函数分组与顺序"><a href="#函数分组与顺序" class="headerlink" title="函数分组与顺序"></a>函数分组与顺序</h3><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code> </p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="对于未导出的顶层常量和变量，使用-作为前缀"><a href="#对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="对于未导出的顶层常量和变量，使用_作为前缀"></a>对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><p>例外：未导出的错误值，应以<code>err</code>开头。</p><p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="结构体中的嵌入"><a href="#结构体中的嵌入" class="headerlink" title="结构体中的嵌入"></a>结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，几乎始终应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 强制执行。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地变量声明"><a href="#本地变量声明" class="headerlink" title="本地变量声明"></a>本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p><ul><li><p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li><li><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li><li><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table></li></ul><p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p><h3 id="缩小变量作用域"><a href="#缩小变量作用域" class="headerlink" title="缩小变量作用域"></a>缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#减少嵌套">减少嵌套</a>的规则冲突。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="避免参数语义不明确-Avoid-Naked-Parameters"><a href="#避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="避免参数语义不明确(Avoid Naked Parameters)"></a>避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用原始字符串字面值，避免转义"><a href="#使用原始字符串字面值，避免转义" class="headerlink" title="使用原始字符串字面值，避免转义"></a>使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原始字符串字面值</a>，也就是 “ ` “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="初始化-Struct-引用"><a href="#初始化-Struct-引用" class="headerlink" title="初始化 Struct 引用"></a>初始化 Struct 引用</h3><p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="初始化-Maps"><a href="#初始化-Maps" class="headerlink" title="初始化 Maps"></a>初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br>这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br>声明和初始化看起来非常相似的。<br><br></td><td><br><br>声明和初始化看起来差别非常大。<br><br></td></tr><br></tbody></table><p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#尽量初始化时指定-Map-容量">尽量初始化时指定 Map 容量</a>。</p><p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p><h3 id="字符串-string-format"><a href="#字符串-string-format" class="headerlink" title="字符串 string format"></a>字符串 string format</h3><p>如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。</p><p>这有助于<code>go vet</code>对格式字符串执行静态分析。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><h3 id="命名-Printf-样式的函数"><a href="#命名-Printf-样式的函数" class="headerlink" title="命名 Printf 样式的函数"></a>命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p><p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf 系列</a>。</p><p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go vet -printfuncs=wrapf,statusf</span></span><br></pre></td></tr></table></figure><p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>.</p><h2 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h2><h3 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p><p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p><p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p><table><br><thead><tr><th>Bad</th><th>Good</th></tr></thead><br><tbody><br><tr><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  logger *zap.Logger</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td><td><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></td></tr><br><tr><td><br><br>必须始终提供缓存和记录器参数，即使用户希望使用默认值。<br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr, db.DefaultCache, zap.NewNop())</span><br><span class="line">db.Open(addr, db.DefaultCache, log)</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())</span><br><span class="line">db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br></pre></td></tr></table></figure><br><br></td><td><br><br>只有在需要时才提供选项。<br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Open(addr)</span><br><span class="line">db.Open(addr, db.WithLogger(log))</span><br><span class="line">db.Open(addr, db.WithCache(<span class="literal">false</span>))</span><br><span class="line">db.Open(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCache(<span class="literal">false</span>),</span><br><span class="line">  db.WithLogger(log),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br></td></tr><br></tbody></table><p>Our suggested way of implementing this pattern is with an <code>Option</code> interface<br>that holds an unexported method, recording options on an unexported <code>options</code><br>struct.</p><p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  cache  <span class="keyword">bool</span></span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheOption <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.cache = <span class="keyword">bool</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span> <span class="title">apply</span><span class="params">(opts *options)</span></span> &#123;</span><br><span class="line">  opts.logger = l.Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p><p>还可以参考下面资料：</p><ul><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li></ul><!-- TODO: replace this with parameter structs and functional options, when touse one vs other --><h2 id="Stargazers-over-time"><a href="#Stargazers-over-time" class="headerlink" title="Stargazers over time"></a>Stargazers over time</h2><p><a href="https://starchart.cc/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener"><img src="https://starchart.cc/xxjwxc/uber_go_guide_cn.svg" alt="Stargazers over time"></a></p><hr>]]></content>
    
    <summary type="html">
    
      Uber Go 编码规范
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>关于 golang 错误处理的一些思考</title>
    <link href="https://cloudsjhan.github.io/2020/06/01/%E5%85%B3%E4%BA%8E-golang-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://cloudsjhan.github.io/2020/06/01/关于-golang-错误处理的一些思考/</id>
    <published>2020-06-01T07:03:21.000Z</published>
    <updated>2020-06-01T07:04:45.637Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><blockquote><p>写在前面：你是还没在error上栽跟头，当你栽了跟头时才会哭着想起来，当年为什么没好好思考和反省错误处理这么一个宏大的话题</p></blockquote><h2 id="关于-Golang-错误处理的实践"><a href="#关于-Golang-错误处理的实践" class="headerlink" title="关于 Golang 错误处理的实践"></a>关于 Golang 错误处理的实践</h2><blockquote><p>Golang有很多优点，这也是它如此流行的主要原因。但是 Go 1 对错误处理的支持过于简单了，以至于日常开发中会有诸多不便利，遭到很多开发者的吐槽。<br>这些不足催生了一些开源解决方案。与此同时， Go 官方也在从语言和标准库层面作出改进。<br>这篇文章将给出几种常见创建错误的方式并分析一些常见问题，对比各种解决方案，并展示了迄今为止(go 1.13)的最佳实践。</p></blockquote><h2 id="几种创建错误的方式"><a href="#几种创建错误的方式" class="headerlink" title="几种创建错误的方式"></a>几种创建错误的方式</h2><blockquote><p>首先介绍几种常见的创建错误的方法</p></blockquote><ol><li>基于字符串的错误</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">err1 := errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line"></span><br><span class="line">err2 := fmt.Errorf(<span class="string">"math: square root of negative number %g"</span>, x)</span><br></pre></td></tr></table></figure><ol start="2"><li>带有数据的自定义错误<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zError</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/satori/go.uuid"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime/debug"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseError <span class="keyword">struct</span> &#123;</span><br><span class="line">InnerError error</span><br><span class="line">Message    <span class="keyword">string</span></span><br><span class="line">StackTrace <span class="keyword">string</span></span><br><span class="line">Misc       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WrapError</span><span class="params">(err error, message <span class="keyword">string</span>, messageArgs ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">BaseError</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> BaseError&#123;</span><br><span class="line">InnerError: err,</span><br><span class="line">Message:    fmt.Sprintf(message, messageArgs),</span><br><span class="line">StackTrace: <span class="keyword">string</span>(debug.Stack()),</span><br><span class="line">Misc:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err *BaseError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 实现 Error 接口</span></span><br><span class="line"><span class="keyword">return</span> err.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><blockquote><p>开发中经常需要检查返回的错误值并作相应处理。下面给出一个最简单的示例。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sql.ErrNoRows</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> GetSql()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Call()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"got err, %+v\n"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Outputs:</span></span><br><span class="line"><span class="comment">// got err, sql: no rows in result set</span></span><br></pre></td></tr></table></figure><p>有时需要根据返回的error类型作不同处理，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sql.ErrNoRows</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> GetSql()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Call()</span><br><span class="line">   <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found, %+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Outputs:</span></span><br><span class="line"><span class="comment">// data not found, sql: no rows in result set</span></span><br></pre></td></tr></table></figure><p>实践中经常需要为错误增加上下文信息后再返回，以方便调用者了解错误场景。例如 Getcall 方法时常写成：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getcall</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">"GetSql err, %v"</span>, sql.ErrNoRows)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这个时候 <code>err == sql.ErrNoRows</code> 就不成立了。除此之外，上述写法都在返回错误时都丢掉了调用栈这个重要的信息。我们需要更灵活、更通用的方式来应对此类问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>针对存在的不足，目前有几种解决方案。这些方式可以对错误进行上下文包装，并携带原始错误信息， 还能尽量保留完整的调用栈</p></blockquote><h3 id="方案-1：-github-com-pkg-errors"><a href="#方案-1：-github-com-pkg-errors" class="headerlink" title="方案 1： github.com/pkg/errors"></a>方案 1： github.com/pkg/errors</h3><p>如果只有错误的文本，我们很难定位到具体的出错地点。虽然通过在代码中搜索错误文本也是有可能找到出错地点的，但是信息有限。所以，在实践中，我们往往会将出错时的调用栈信息也附加上去。调用栈对消费方是没有意义的，从隔离和自治的角度来看，消费方唯一需要关心的就是错误文本和错误类型。调用栈对实现者自身才是是有价值的。所以，如果一个方法需要返回错误，我们一般会使用errors.WithStack(err)或者errors.Wrap(err, “custom message”)的方式，把此刻的调用栈加到error里去，并且在某个统一地方记录日志，方便开发者快速定位问题。</p><ol><li>Wrap 方法用来包装底层错误，增加上下文文本信息并附加调用栈。 一般用于包装对第三方代码（标准库或第三方库）的调用。</li><li>WithMessage 方法仅增加上下文文本信息，不附加调用栈。 如果确定错误已被 Wrap 过或不关心调用栈，可以使用此方法。 注意：不要反复 Wrap ，会导致调用栈重复</li><li>Cause方法用来判断底层错误 。</li></ol><p>现在我们用这三个方法来重写上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.Wrap(sql.ErrNoRows, <span class="string">"GetSql failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.WithMessage(GetSql(), <span class="string">"bar failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Call()</span><br><span class="line">   <span class="keyword">if</span> errors.Cause(err) == sql.ErrNoRows &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found, %v\n"</span>, err)</span><br><span class="line">      fmt.Printf(<span class="string">"%+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">data not found, Call failed: GetSql failed: sql: no rows in result set</span></span><br><span class="line"><span class="comment">sql: no rows in result set</span></span><br><span class="line"><span class="comment">main.GetSql</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:11</span></span><br><span class="line"><span class="comment">main.Call</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:15</span></span><br><span class="line"><span class="comment">main.main</span></span><br><span class="line"><span class="comment">    /usr/three/main.go:19</span></span><br><span class="line"><span class="comment">runtime.main</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从输出内容可以看到， 使用 %v 作为格式化参数，那么错误信息会保持一行， 其中依次包含调用栈的上下文文本。 使用 %+v ，则会输出完整的调用栈详情。<br>如果不需要增加额外上下文信息，仅附加调用栈后返回，可以使用 WithStack 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.WithStack(sql.ErrNoRows)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：无论是 Wrap ， WithMessage 还是 WithStack ，当传入的 err 参数为 nil 时， 都会返回nil， 这意味着我们在调用此方法之前无需作 nil 判断，保持了代码简洁</p></blockquote><h3 id="方案-2：golang-org-x-xerrors"><a href="#方案-2：golang-org-x-xerrors" class="headerlink" title="方案 2：golang.org/x/xerrors"></a>方案 2：golang.org/x/xerrors</h3><p>结合社区反馈，Go 团队完成了在 Go 2 中简化错误处理的提案。 Go核心团队成员 Russ Cox 在xerrors中部分实现了提案中的内容。它用与 github.com/pkg/errors相似的思路解决同一问题， 引入了一个新的 fmt 格式化动词: %w，使用 Is 进行判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"golang.org/x/xerrors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := GetSql(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> xerrors.Errorf(<span class="string">"bar failed: %w"</span>, GetSql())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> xerrors.Errorf(<span class="string">"GetSql failed: %w"</span>, sql.ErrNoRows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Call()</span><br><span class="line">   <span class="keyword">if</span> xerrors.Is(err, sql.ErrNoRows) &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found, %v\n"</span>, err)</span><br><span class="line">      fmt.Printf(<span class="string">"%+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Outputs:</span></span><br><span class="line"><span class="comment">data not found, Call failed: GetSql failed: sql: no rows in result set</span></span><br><span class="line"><span class="comment">bar failed:</span></span><br><span class="line"><span class="comment">    main.Call</span></span><br><span class="line"><span class="comment">        /usr/four/main.go:12</span></span><br><span class="line"><span class="comment">  - GetSql failed:</span></span><br><span class="line"><span class="comment">    main.GetSql</span></span><br><span class="line"><span class="comment">        /usr/four/main.go:18</span></span><br><span class="line"><span class="comment">  - sql: no rows in result set</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>与 github.com/pkg/errors 相比，它有几点不足：</p><ol><li>使用 : %w 代替了 Wrap ， 看似简化， 但失去了编译期检查。 如果没有冒号，或 : %w 不位于于格式化字符串的结尾，或冒号与百分号之间没有空格，包装将失效且不报错；</li><li>而且，调用 xerrors.Errorf 之前需要对参数进行nil判断。 这完全没有简化开发者的工作</li></ol><h3 id="方案-3：Go-1-13-内置支持"><a href="#方案-3：Go-1-13-内置支持" class="headerlink" title="方案 3：Go 1.13 内置支持"></a>方案 3：Go 1.13 内置支持</h3><p> Go 1.13 将 xerrors 的部分功能（不是全部）整合进了标准库。 它继承了上面提到的 xerrors 的全部缺点， 并额外贡献了一项。因此目前没有使用它的必要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"database/sql"</span></span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := GetSql(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fmt.Errorf(<span class="string">"Call failed: %w"</span>, GetSql())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSql</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">"GetSql failed: %w"</span>, sql.ErrNoRows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := Call()</span><br><span class="line">   <span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"data not found,  %+v\n"</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// unknown error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Outputs:</span></span><br><span class="line"><span class="comment">data not found,  Call failed: GetSql failed: sql: no rows in result set</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码与 xerrors 版本非常接近。但是它不支持调用栈信息输出， 根据官方的说法， 此功能没有明确的支持时间。因此其实用性远低于 github.com/pkg/errors。</p><h2 id="Golang-中将来可能的错误处理方式"><a href="#Golang-中将来可能的错误处理方式" class="headerlink" title="Golang 中将来可能的错误处理方式"></a>Golang 中将来可能的错误处理方式</h2><blockquote><p>在Go 2的草案中，我们看到了有关于error相关的一些提案，那就是check/handle函数。</p></blockquote><p>我们也许在下一个大版本的Golang可以像下面这样处理错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">game</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    handle err &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"dependencies error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resource := check findResource() <span class="comment">// return resource, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resource.Release()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    profile := check loadProfile() <span class="comment">// return profile, error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        profile.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的同学可以关注下这个提案：<a href="https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md</a></p><h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><blockquote><p>重要的是要记住，包装错误会使该错误成为您API的一部分。如果您不想将来将错误作为API的一部分来支持，则不应包装该错误。<br>无论是否包装错误，错误文本都将相同。那些试图理解错误的人将得到相同的信息，无论采用哪种方式; 是否要包装错误的选择取决于是否要给程序提供更多信息，以便他们可以做出更明智的决策，还是保留该信息以保留抽象层。</p></blockquote><p>通过以上对比， 相信你已经有了选择。 再明确一下我的看法，如果你正在使用 <code>github.com/pkg/errors</code> ，那就保持现状吧。目前还没有比它更好的选择。如果你已经大量使用 golang.org/x/xerrors ， 别盲目换成 go 1.13 的内置方案。</p><p>总的来说，Go 在诞生之初就在各个方面表现得相当成熟、稳健。 在演进路线上很少出现犹疑和摇摆， 而在错误处理方面却是个例外。 除了被广泛吐槽的 if err != nil 之外， 就连其改进路线也备受争议、分歧明显，以致于一个改进提案都会因为压倒性的反对意见而不得不作出调整。 好在 Go 团队比以前更加乐于倾听社区意见，团队甚至专门就此问题建了个反馈收集页面。相信最终大家会找到更好的解决方案。</p><hr>]]></content>
    
    <summary type="html">
    
      关于 golang 错误处理的一些思考
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>官宣：2019 年 Go 开发者调查报告</title>
    <link href="https://cloudsjhan.github.io/2020/05/10/%E5%AE%98%E5%AE%A3%EF%BC%9A2019-%E5%B9%B4-Go-%E5%BC%80%E5%8F%91%E8%80%85%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/"/>
    <id>https://cloudsjhan.github.io/2020/05/10/官宣：2019-年-Go-开发者调查报告/</id>
    <published>2020-05-10T08:30:53.000Z</published>
    <updated>2020-05-10T08:36:16.496Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="2019-年-Go-开发者调查"><a href="#2019-年-Go-开发者调查" class="headerlink" title="2019 年 Go 开发者调查"></a>2019 年 Go 开发者调查</h2><blockquote><p>4月20日，Go 官方释出 2019 年的 Go 开发者调研报告。官方非常感谢参与本次调查的数千名Go开发人员。 在2019年，官方收到了 10,975 份问卷，几乎是去年的两倍！ 团队成员非常感谢开发者花时间和精力填写这份 Go 开发者调研。</p></blockquote><blockquote><p>本次调研，官方改进了对开放式、自由文本回答的问题的分析。去年使用的是机器学习来粗略但快速地对这些问卷进行分类。今年，两名研究人员手动分析和分类了这些问卷，允许进行更细致的分析，与去年的数字进行有效的比较。这个变化的目的是提供一个 2019 年以后的可靠基线。</p></blockquote><hr><h3 id="一分钟速读"><a href="#一分钟速读" class="headerlink" title="一分钟速读"></a>一分钟速读</h3><p>这篇文章很长。以下是本次调研的主要结论:</p><ul><li>这次的受访者的受众特征与 Stack Overflow 的调查受访者相似，使得这些结果可以代表更多的 Go 开发人员的心声。</li><li>大多数受访者每天都使用 Go，而且这个数字每年都在上升。</li><li>Go 的使用仍集中在技术公司，但是 Go 在越来越多的行业中被用到，例如金融行业和媒体相关。</li><li>开发者使用 Go 解决的问题很相似，基本集中在构建 API, RPC 服务和 CLI 工具。</li><li>大多数团队都试图尽快更新到最新的 Go 版本。 但是第三方 package 的 provider 更新地会相对慢一点。</li><li>现在，Go生态系统中的几乎每个人都在使用 Go Modules，但是用户对软件包管理方面仍然存在困惑。</li><li>有待改进的重点领域包括改善开发人员的 debug 体验，Go Modules 和 cloud service 方面的体验。</li><li>VS Code 和 GoLand 仍然是最受欢迎的编辑器，受访的四个人中就有三个在使用他们。</li></ul><hr><h3 id="受访的开发者群体"><a href="#受访的开发者群体" class="headerlink" title="受访的开发者群体"></a>受访的开发者群体</h3><h4 id="受访者公司规模"><a href="#受访者公司规模" class="headerlink" title="受访者公司规模"></a>受访者公司规模</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen8j9j94sj31b40riad1.jpg" alt=""></p><h4 id="受访者的编程工作年限"><a href="#受访者的编程工作年限" class="headerlink" title="受访者的编程工作年限"></a>受访者的编程工作年限</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen8krfpo2j31820oogo9.jpg" alt=""></p><h4 id="受访者使用-Go-编程的时间"><a href="#受访者使用-Go-编程的时间" class="headerlink" title="受访者使用 Go 编程的时间"></a>受访者使用 Go 编程的时间</h4><p>从使用 Go 的经验来看，我们发现大多数受访者（56％）使用 Go 的时间不到两年，相对较新。 多数人还说，他们在工作中（72％）和工作外（62％）使用Go。 可以看到在工作中使用 Go 的受访者比例每年都在上升。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen8pgrzp3j31200u0dil.jpg" alt=""></p><h4 id="受访者的开发背景"><a href="#受访者的开发背景" class="headerlink" title="受访者的开发背景"></a>受访者的开发背景</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen8u1p9ffj318y0to424.jpg" alt=""></p><p>使用 Go 时间较长的受访者与新的 Go 开发人员的背景不同。 这些 Go 老兵更有可能拥有 C / C ++ 的专业知识，而不太可能具备 JavaScript，TypeScript 和 PHP 的专业知识。 但是不管他们使用 Go 已有多长时间，Python似乎都是大多数受访者熟悉的语言（不是Go🤔）。</p><h4 id="受访者所从事的行业"><a href="#受访者所从事的行业" class="headerlink" title="受访者所从事的行业"></a>受访者所从事的行业</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen8wibkmuj30yx0u0425.jpg" alt=""></p><p>去年，我们询问了受访者从事哪些行业，发现大多数人在软件，互联网或网络服务公司工作。 今年看来，受访者所从事的行业更加广泛了。</p><h4 id="受访者对-Go-开源项目的贡献"><a href="#受访者对-Go-开源项目的贡献" class="headerlink" title="受访者对 Go 开源项目的贡献"></a>受访者对 Go 开源项目的贡献</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen90a3r5kj31620suju1.jpg" alt=""></p><p>Go 是一个成功的开源项目，但这并不意味着使用它的开发人员也正在编写​​免费或开源软件。 与往年一样，我们发现大多数受访者并不是 Go 开源项目的频繁贡献者，有 75％ 的受访者表示他们“很少”或“从不”参与 Go 开源项目。 随着Go社区的扩展，我们发现从未为 Go 开源项目做出过贡献的受访者所占的比例正在缓慢上升。</p><h3 id="开发工具篇"><a href="#开发工具篇" class="headerlink" title="开发工具篇"></a>开发工具篇</h3><h4 id="受访者开发中使用的-OS"><a href="#受访者开发中使用的-OS" class="headerlink" title="受访者开发中使用的 OS"></a>受访者开发中使用的 OS</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen954rg3zj316u0os40m.jpg" alt=""></p><p>与往年一样，绝大多数开发者表示在 Linux 和 macOS 系统上使用 Go。 这是我们的受访者与StackOverflow的2019 年调查结果之间存在很大差异的一个方面：在我们的调查中，只有20％的受访者使用 Windows 作为主要开发平台，而对于 StackOverflow 而言，这一比例为 45％。 Linux 的使用率为 66％，macOS 的使用率为 53％，这两者都远远高于 StackOverflow 的受众，后者分别报告了 25％ 和 30％（看来 Gopher 还是喜欢 UNIX 多一些）。</p><h4 id="受访者使用的-IDE"><a href="#受访者使用的-IDE" class="headerlink" title="受访者使用的 IDE"></a>受访者使用的 IDE</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen97prm9bj30ut0u0adw.jpg" alt=""></p><p>今年，IDE 整合的趋势仍在继续。 GoLand 今年的使用量增长最快，从 24％ → 34％ 上升。 VS Code的增长速度有所放缓，但仍然是受访者中最受欢迎的编辑器，占41％。 结合起来，这两个 IDE 现在的占有率是 75%。</p><h4 id="关于自建-Go-document-server"><a href="#关于自建-Go-document-server" class="headerlink" title="关于自建 Go document server"></a>关于自建 Go document server</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen9c42reaj315q0dy75o.jpg" alt=""></p><p>今年，我们添加了一个有关内部 Go 文档工具（例如 gddo ）的问题。 少数受访者（ 6％ ）表示他们的组织运行自己的Go文档服务器，尽管当我们查看大公司受访者（拥有至少5,000名员工）时，这一比例几乎翻了一番（达到11％），但当我们与后者交流时，他们说基本已经停止了自建 document server，原因是收益小，成本高。</p><h3 id="受访者对-Go-的使用意向"><a href="#受访者对-Go-的使用意向" class="headerlink" title="受访者对 Go 的使用意向"></a>受访者对 Go 的使用意向</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen9l5v6hvj31880mmq5d.jpg" alt=""></p><p>大部分受访者都认为 Go 在他们的团队中表现良好（86％），并且他们希望将其用于下一个项目（89％）。 我们还发现，超过一半的受访者（59％）认为 Go 对其公司的成功至关重要。 自2016年以来，这些指标一直保持稳定。</p><h4 id="受访者对-Go-生态的满意度"><a href="#受访者对-Go-生态的满意度" class="headerlink" title="受访者对 Go 生态的满意度"></a>受访者对 Go 生态的满意度</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen9q557lwj31aw0pcn0b.jpg" alt=""></p><p>在 Go 生态的满意度上，我们看到很大比例的受访者同意每种说法（82％–88％），并且在过去四年中，这些比率在很大程度上保持稳定。</p><h4 id="受访者所在行业对-Go-生态的满意度"><a href="#受访者所在行业对-Go-生态的满意度" class="headerlink" title="受访者所在行业对 Go 生态的满意度"></a>受访者所在行业对 Go 生态的满意度</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen9stmm3kj31b80p40vu.jpg" alt=""></p><p>今年，我们对各个行业的满意度进行了更细微的考察，以建立基准。 总体而言，无论行业如何，受访者都对在工作中使用Go表示满意。 我们确实在几个领域（尤其是制造业）中看到了一些不满，我们计划通过后续研究进行调查。</p><h4 id="受访者对-Go-特性的关注度"><a href="#受访者对-Go-特性的关注度" class="headerlink" title="受访者对 Go 特性的关注度"></a>受访者对 Go 特性的关注度</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gen9zwcigoj31980ogq5i.jpg" alt=""></p><p>同样，我们调查了对 Go 开发各个方面的满意度以及重要性。 将这些结果结合在一起可以突出显示三个特别关注的主题：debug（包括调试并发性），go modules 和 cloud service。 大多数人都将这些主题中的每一个评为“非常”或“至关重要”，但与其他主题相比，这些方面的满意度得分明显较低。</p><h4 id="受访者对-Go-社区的满意度"><a href="#受访者对-Go-社区的满意度" class="headerlink" title="受访者对 Go 社区的满意度"></a>受访者对 Go 社区的满意度</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gena24q35rj316a0tg41v.jpg" alt=""></p><p>上面的调查结果可能不足为奇，因为参与 Go 开发者调查的人们喜欢 Go 的概率更大（手动狗头）。</p><h3 id="使用-Go-完成的工作内容"><a href="#使用-Go-完成的工作内容" class="headerlink" title="使用 Go 完成的工作内容"></a>使用 Go 完成的工作内容</h3><p>构建API / RPC服务（71％）和CLI（62％）仍然是 Go 的重头戏。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gendj3ibsxj30u012swjq.jpg" alt=""></p><p>我们调查了受访者使用 Go 的更大领域。 到目前为止，最常见的领域是 Web 开发（66％），但其他常见的领域包括数据库（45％），网络编程（42％），系统编程（38％）和 DevOps （37％）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gendjjfdt3j31350u077p.jpg" alt=""></p><h4 id="Go-开发过程的常用技术"><a href="#Go-开发过程的常用技术" class="headerlink" title="Go 开发过程的常用技术"></a>Go 开发过程的常用技术</h4><p>除了受访者正在构建的内容之外，我们还询问了他们使用的一些开发技术。 绝大多数受访者表示，他们依靠 log 进行调试（88％），而他们的回答表明，这是因为提供的调试工具难以有效使用。 但是，本地逐步调试（例如，使用Delve），性能分析和使用竞争检测器进行测试的情况并不少见，约有50％的受访者其使用中至少一种技术。</p><h4 id="关于-Go-Modules"><a href="#关于-Go-Modules" class="headerlink" title="关于 Go Modules"></a>关于 Go Modules</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gendvm7u8nj314y0ig0ui.jpg" alt=""></p><p>在包管理方面，我们发现绝大多数受访者(89%)采用了 Go Modules。对于开发者来说，这是一个巨大的转变，几乎整个社区都在同时经历这一转变。</p><h3 id="云原生时代的-Go"><a href="#云原生时代的-Go" class="headerlink" title="云原生时代的 Go"></a>云原生时代的 Go</h3><p>Go在设计时考虑到了现代分布式计算，我们希望继续改进使用Go构建云服务的开发人员体验。今年，我们扩展了关于云开发的问题，以便更好地了解受访者如何与云提供商合作，他们喜欢当前开发者体验的哪些方面，以及哪些方面可以改进。</p><p>我们可以清晰地感受到以下两个趋势：</p><ol><li>全球三大云提供商（Amazon Web Services，Google Cloud Platform和Microsoft Azure）在受访者中的使用率均呈上升趋势，而大多数其他提供商每年使用的受访者比例都较小。</li><li>到自有或公司拥有的服务器的本地部署继续减少，并且在统计上已与AWS（44％比42％）绑定为最常见的部署平台。</li></ol><h4 id="Go-project-的部署云平台"><a href="#Go-project-的部署云平台" class="headerlink" title="Go project 的部署云平台"></a>Go project 的部署云平台</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gene19viz8j30uj0u00x7.jpg" alt=""></p><p>总体而言，大多数受访者对在所有三大主要云提供商上使用 Go 感到满意。 受访者具有对 Go（AWS）（80％满意）和GCP（78％）的 满意度。</p><h4 id="Go-project-的部署服务类型"><a href="#Go-project-的部署服务类型" class="headerlink" title="Go project 的部署服务类型"></a>Go project 的部署服务类型</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gene34rbeqj30yj0u042n.jpg" alt=""></p><h3 id="存在的痛点"><a href="#存在的痛点" class="headerlink" title="存在的痛点"></a>存在的痛点</h3><p>受访者表示无法使用Go的主要原因有三个：</p><ol><li>（56％）当前的项目正在使用其他语言；</li><li>团队更倾向于使用其他语言（37％）；</li><li>Go本身缺乏一些关键功能 （25％）。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geneex9jfcj30u00xnq8a.jpg" alt=""></li></ol><h4 id="对一些-Go-特性的期待"><a href="#对一些-Go-特性的期待" class="headerlink" title="对一些 Go 特性的期待"></a>对一些 Go 特性的期待</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genei7lamdj31940lyack.jpg" alt=""></p><p>在 25% 的受访者中，认为 Go 缺乏他们需要的语言特性。其中 79% 认为泛型是一个严重缺失的特性。22% 的人提到了对错误处理的持续改进(除了 Go 1.13 的更改之外)，13 %的人要求更多的函数式编程特性，尤其是内置的map/filter/reduce 功能。需要说明的是，这些数字来自受访者的子集，他们表示，如果提供了他们需要的一个或多个关键功能，他们将能够更多地使用 Go。</p><h4 id="没有使用-Go-作为项目的语言的一些原因"><a href="#没有使用-Go-作为项目的语言的一些原因" class="headerlink" title="没有使用 Go 作为项目的语言的一些原因"></a>没有使用 Go 作为项目的语言的一些原因</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genekp7b9mj30u00um43z.jpg" alt=""></p><p>对于他们所从事的工作来说，Go “不是一种合适的语言”的受访者有各种各样的理由和用例。最常见的是他们从事某种形式的前端开发(22%)，例如用于 web、桌面或移动设备的g ui。另一个常见的回答是，受访者说他们工作的领域中已经有占主导地位的语言(9%)，因此很难使用不同的语言。一些受访者还告诉我们他们指的是哪个领域(或者只是提到了一个领域，而没有提到另一种更常见的语言)，我们通过下面的“I work on [domain]”行来说明这一点。受访者提到的另一个主要原因是需要更好的性能(9%)，尤其是实时计算。</p><h4 id="受访者认为目前存在的最大的阻碍"><a href="#受访者认为目前存在的最大的阻碍" class="headerlink" title="受访者认为目前存在的最大的阻碍"></a>受访者认为目前存在的最大的阻碍</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genepofpmhj30x70u078l.jpg" alt=""></p><p>受访者报告的最大阻碍与去年基本保持一致。 Go 缺乏泛型和模块，包管理工具仍然是最主要的问题（分别占反馈的15％和12％），并且强调工具问题的受访者比例有所增加。 这些数字与上面的图表不同，因为这个问题是所有受访者都提出的，无论他们说最大的阻碍什么。 这三个问题都是今年 Go 团队关注的领域，我们希望在未来几个月内极大地改善开发人员的体验，尤其是在模块，工具和入门经验方面。</p><h4 id="Debug-Go-project-的痛点"><a href="#Debug-Go-project-的痛点" class="headerlink" title="Debug Go project 的痛点"></a>Debug Go project 的痛点</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geneu7w8ftj31860rutcf.jpg" alt=""></p><p>任何一种语言的 debug 和 benchmark 都具有挑战性。 受访者告诉我们，这两个方面的最大挑战不是 Go 的工具所特有的，而是一个更根本的问题：缺乏知识，经验或最佳实践。 我们希望在今年晚些时候通过文档和其他材料来帮助解决这些问题。 其他主要问题涉及到工具的使用，尤其是在学习/使用 Go 的调试和 profile 分析工具时，在成本/收益方面存在不利的权衡，以及使工具在各种环境中工作的挑战（例如，在容器中进行调试或从生产环境中获取性能分析）。</p><h3 id="Go-community"><a href="#Go-community" class="headerlink" title="Go community"></a>Go community</h3><p>大约三分之二的受访者使用 Stack Overflow 来回答与 go 相关的问题(64%)。其他排名靠前的答案来源是godoc.org(47%)，直接阅读源代码(42%)和 golang.org (33%)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genf1jh4xqj30ws0u00wd.jpg" alt=""></p><h4 id="关于-MeetUp"><a href="#关于-MeetUp" class="headerlink" title="关于 MeetUp"></a>关于 MeetUp</h4><p>上表突展示了不同的寻求帮助的方式(几乎都是社区驱动的)，受访者在使用Go开发过程中依靠它们来克服挑战。事实上，对于许多 gopher 来说，这可能是他们与更大的社区互动的主要要点之一: 随着我们的社区不断扩大，我们看到越来越多的受访者不用参加任何与 go 相关的活动。在2019年，这一比例接近三分之二的受访者(62%)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genf5welcoj30wu0u0tcr.jpg" alt=""></p><h4 id="受访者的语言"><a href="#受访者的语言" class="headerlink" title="受访者的语言"></a>受访者的语言</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1genf7s960qj318w0qqju6.jpg" alt=""></p><p>由于谷歌更新了全谷歌范围内的隐私指南，我们无法再询问受访者生活在哪个国家。相反，我们询问了首选的口语/书面语作为 Go 在全球使用的粗略调查，这有助于为潜在的本地化工作提供数据。</p><p>由于本次调查是用英语进行的，因此对于讲英语的人和英语为第二或第三种常见语言的人群可能会有很大的误差。 因此，非英语数字应解释为可能的最小值，而不是Go的全球受众人数的近似值。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>我们希望你了解这次 2019 年开发者调查的结果。了解开发人员的经验和挑战有助于我们为 2020 年制定计划并确定工作的优先级。再一次，非常感谢所有参与调查的人，你们的反馈将有助于在未来一年甚至更长的时间内引导 Go 前进的方向。</p><hr>]]></content>
    
    <summary type="html">
    
      官宣：2019 年 Go 开发者调查报告
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现高性能 kubernetes web terminal</title>
    <link href="https://cloudsjhan.github.io/2020/04/24/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD-kubernetes-web-terminal/"/>
    <id>https://cloudsjhan.github.io/2020/04/24/手把手教你实现高性能-kubernetes-web-terminal/</id>
    <published>2020-04-24T10:03:44.000Z</published>
    <updated>2020-04-24T10:03:44.116Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>##</p><p>##</p><p>##</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>并发访问 slice 如何做到优雅和安全？</title>
    <link href="https://cloudsjhan.github.io/2020/04/22/%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE-slice-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%BC%98%E9%9B%85%E5%92%8C%E5%AE%89%E5%85%A8%EF%BC%9F/"/>
    <id>https://cloudsjhan.github.io/2020/04/22/并发访问-slice-如何做到优雅和安全？/</id>
    <published>2020-04-22T03:43:15.000Z</published>
    <updated>2020-04-22T04:04:52.297Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>由于 slice/map 是引用类型，golang函数是传值调用，所用参数副本依然是原来的 slice， 并发访问同一个资源会导致竟态条件。</p><p>看下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        slc = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        n   = <span class="number">10000</span></span><br><span class="line">        wg  sync.WaitGroup</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wg.Add(n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            slc = <span class="built_in">append</span>(slc, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(slc))</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="built_in">len</span>: <span class="number">8586</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>真实的输出并没有达到我们的预期，len(slice) &lt; n。 问题出在哪？我们都知道slice是对数组一个连续片段的引用，当slice长度增加的时候，可能底层的数组会被换掉。当出在换底层数组之前，切片同时被多个goroutine拿到，并执行append操作。那么很多goroutine的append结果会被覆盖，导致n个gouroutine append后，长度小于n。</p><p>那么如何解决这个问题呢？<br>map 在 go 1.9 以后官方就给出了 sync.map 的解决方案，但是如果要并发访问 slice 就要自己好好设计一下了。下面提供两种方式，帮助你解决这个问题。</p><h3 id="方案-1-加锁-🔐"><a href="#方案-1-加锁-🔐" class="headerlink" title="方案 1: 加锁 🔐"></a>方案 1: 加锁 🔐</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slc := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">      <span class="comment">// 加🔐</span></span><br><span class="line">lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">slc = <span class="built_in">append</span>(slc, a)</span><br><span class="line">&#125;(i)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slc))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优点是比较简单，适合对性能要求不高的场景。</p></blockquote><h3 id="方案-2：-使用-channel-串行化操作"><a href="#方案-2：-使用-channel-串行化操作" class="headerlink" title="方案 2： 使用 channel 串行化操作"></a>方案 2： 使用 channel 串行化操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceData <span class="keyword">struct</span> &#123;</span><br><span class="line">ch   <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 用来 同步的channel</span></span><br><span class="line">data []<span class="keyword">int</span>    <span class="comment">// 存储数据的slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceData)</span> <span class="title">Schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从 channel 接收数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s.ch &#123;</span><br><span class="line">s.data = <span class="built_in">append</span>(s.data, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceData)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 最后关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(s.ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServiceData)</span> <span class="title">AddData</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s.ch &lt;- v <span class="comment">// 发送数据到 channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScheduleJob</span><span class="params">(size <span class="keyword">int</span>, done <span class="keyword">func</span>()</span>) *<span class="title">ServiceData</span></span> &#123;</span><br><span class="line">s := &amp;ServiceData&#123;</span><br><span class="line">ch:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, size),</span><br><span class="line">data: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 并发地 append 数据到 slice</span></span><br><span class="line">s.Schedule()</span><br><span class="line">done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">n  = <span class="number">1000</span></span><br><span class="line">)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 了这个 job 后，该 job 就开始准备从 channel 接收数据了</span></span><br><span class="line">s := NewScheduleJob(n, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;)</span><br><span class="line"></span><br><span class="line">wg.Add(n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">s.AddData(v)</span><br><span class="line"></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">s.Close()</span><br><span class="line">&lt;-c</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s.data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现相对复杂，优点是性能很好，利用了channel的优势</p></blockquote><p>以上代码都有比较详细的注释，就不展开讲了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717c5c5de0af19a?w=227&amp;h=227&amp;f=jpeg&amp;s=20015" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      并发访问 slice 如何做到优雅和安全？
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>java转go遇到Apollo?让agollo来帮你平滑迁移</title>
    <link href="https://cloudsjhan.github.io/2020/04/17/java%E8%BD%ACgo%E9%81%87%E5%88%B0Apollo-%E8%AE%A9agollo%E6%9D%A5%E5%B8%AE%E4%BD%A0%E5%B9%B3%E6%BB%91%E8%BF%81%E7%A7%BB/"/>
    <id>https://cloudsjhan.github.io/2020/04/17/java转go遇到Apollo-让agollo来帮你平滑迁移/</id>
    <published>2020-04-17T07:50:33.000Z</published>
    <updated>2020-04-17T07:52:46.723Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdueckqd79j30u00u043g.jpg" alt=""></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>agollo 是<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo</a>的 Golang 客户端</p><blockquote><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p></blockquote><p>如果在使用 golang 重构 java 的过程中，使用到了分布式配置中心 Apollo，那么最快的方式就是使用原来的配置，保持最平滑的迁移，这个时候你就需要一个 Apollo 的 golang 客户端，agollo 可以是你的一个选择。</p><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="1-1-环境要求"><a href="#1-1-环境要求" class="headerlink" title="1.1.环境要求"></a>1.1.环境要求</h3><ul><li>Go 1.11+ (最好使用Go 1.12)</li></ul><h3 id="1-2-依赖"><a href="#1-2-依赖" class="headerlink" title="1.2.依赖"></a>1.2.依赖</h3><h4 id="1-2-1-使用-go-get-方式"><a href="#1-2-1-使用-go-get-方式" class="headerlink" title="1.2.1.使用 go get 方式"></a>1.2.1.使用 go get 方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/zouyx/agollo/v3@latest</span><br></pre></td></tr></table></figure><h4 id="1-2-2-使用-go-mod-方式"><a href="#1-2-2-使用-go-mod-方式" class="headerlink" title="1.2.2.使用 go mod 方式"></a>1.2.2.使用 go mod 方式</h4><p>go.mod<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com/zouyx/agollo/v3 latest</span><br></pre></td></tr></table></figure></p><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></p><p>import<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/zouyx/agollo/v3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>FAQ</p><ul><li><a href="https://github.com/golang/go/wiki/Modules#semantic-import-versioning" target="_blank" rel="noopener">为什么要加+incompatible</a></li><li><a href="https://github.com/zouyx/agollo/issues/85" target="_blank" rel="noopener">go.mod不能下载agollo的解决方法</a></li></ul><h3 id="1-3-必要设置"><a href="#1-3-必要设置" class="headerlink" title="1.3.必要设置"></a>1.3.必要设置</h3><p>Apollo 客户端依赖于 AppId，Environment 等环境信息来工作，所以请确保阅读下面的说明并且做正确的配置：</p><ul><li>main ： your application</li><li>app.properties (必要) ： 连接服务端必要配置</li><li>seelog.xml（非必要）</li></ul><h4 id="1-3-1-配置"><a href="#1-3-1-配置" class="headerlink" title="1.3.1.配置"></a>1.3.1.配置</h4><p>加载优先级：</p><ol><li>类配置</li><li>环境变量指定配置文件</li><li>默认（app.properties）配置文件</li></ol><h5 id="1-3-1-1-类配置"><a href="#1-3-1-1-类配置" class="headerlink" title="1.3.1.1.类配置"></a>1.3.1.1.类配置</h5><p>会覆盖<code>app.properties</code>中配置，在调用Start方法之前调用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">readyConfig:=&amp;AppConfig&#123;</span><br><span class="line">AppId:<span class="string">"test1"</span>,</span><br><span class="line">Cluster:<span class="string">"dev1"</span>,</span><br><span class="line">NamespaceName:<span class="string">"application1"</span>,</span><br><span class="line">Ip:<span class="string">"localhost:8889"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitCustomConfig(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(*AppConfig, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> readyConfig,<span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>类配置 agollo 的 demo:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/zouyx/agollo/v3"</span></span><br><span class="line"><span class="string">"github.com/zouyx/agollo/v3/env/config"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitAgolloConfig</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">readyConfig := &amp;config.AppConfig&#123;</span><br><span class="line">AppID:         <span class="string">"test"</span>,</span><br><span class="line">Cluster:       <span class="string">"default"</span>,</span><br><span class="line">NamespaceName: <span class="string">"application"</span>,</span><br><span class="line">IP:            <span class="string">"localhost:8080"</span>,</span><br><span class="line">&#125;</span><br><span class="line">agollo.InitCustomConfig(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(*config.AppConfig, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> readyConfig, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">err := agollo.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Init Apollo</span></span><br><span class="line">err := config.InitAgolloConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Errorf(<span class="string">"初始化Apollo失败"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    fmt.Println(<span class="string">"初始化Apollo配置成功"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Use your apollo key to test</span></span><br><span class="line">    value := agollo.GetStringValue(<span class="string">"key"</span>, <span class="string">""</span>)</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-1-2-环境变量指定配置文件"><a href="#1-3-1-2-环境变量指定配置文件" class="headerlink" title="1.3.1.2.环境变量指定配置文件"></a>1.3.1.2.环境变量指定配置文件</h5><p>Linux/Mac<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> AGOLLO_CONF=/a/conf.properties</span><br></pre></td></tr></table></figure></p><p>Windows<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> AGOLLO_CONF=c:/a/conf.properties</span><br></pre></td></tr></table></figure></p><p>配置文件内容与app.properties内容一样</p><h5 id="1-3-1-3-文件配置-app-properties"><a href="#1-3-1-3-文件配置-app-properties" class="headerlink" title="1.3.1.3.文件配置 - app.properties"></a>1.3.1.3.文件配置 - app.properties</h5><p>1.开发:请确保 <strong>app.properties</strong> 文件存在于workingdir目录下</p><p>2.打包后:请确保 <strong>app.properties</strong> 文件存在于与打包程序同级目录下，参考1.3.必要配置。</p><p>目前只支持json形式，其中字段包括：</p><ul><li><em>appId</em> ：应用的身份信息，是从服务端获取配置的一个重要信息。</li><li><em>cluster</em> ：需要连接的集群，默认default</li><li><p><em>namespaceName</em> ：命名空间，默认：application（具体定义参考：<a href="https://github.com/ctripcorp/apollo/wiki/Apollo核心概念之“Namespace”" target="_blank" rel="noopener">namespace</a>）,<strong>多namespace使用英文逗号分割</strong>，<br>非key/value配置（json,properties,yml等），则配置为：namespace.文件类型。如：namespace.json</p></li><li><p><em>ip</em> ：Apollo的CONFIG_SERVICE的ip，非META_SERVICE地址</p></li></ul><p>配置例子如下：</p><p><strong>一般配置</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"appId"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="attr">"cluster"</span>: <span class="string">"dev"</span>,</span><br><span class="line">    <span class="attr">"namespaceName"</span>: <span class="string">"application"</span>,</span><br><span class="line">    <span class="attr">"ip"</span>: <span class="string">"localhost:8888"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>多namespace配置</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"appId"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="attr">"cluster"</span>: <span class="string">"dev"</span>,</span><br><span class="line">    <span class="attr">"namespaceName"</span>: <span class="string">"application, applications1"</span>,</span><br><span class="line">    <span class="attr">"ip"</span>: <span class="string">"localhost:8888"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>非key/value namespace配置</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"appId"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="attr">"cluster"</span>: <span class="string">"dev"</span>,</span><br><span class="line">    <span class="attr">"namespaceName"</span>: <span class="string">"application.json,a.yml"</span>,</span><br><span class="line">    <span class="attr">"ip"</span>: <span class="string">"localhost:8888"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-4日志组件"><a href="#1-4日志组件" class="headerlink" title="1.4日志组件"></a>1.4日志组件</h3><p>参考:</p><ul><li><a href="https://github.com/zouyx/agollo/wiki/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">自定义日志组件</a></li><li><a href="https://github.com/zouyx/agollo/wiki/使用seelog日志组件" target="_blank" rel="noopener">使用seelog日志组件</a></li></ul><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><ul><li>异步启动 agollo</li></ul><p>场景：启动程序不依赖加载Apollo的配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> agollo.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步启动 agollo（v1.2.0+）</li></ul><p>场景：启动程序依赖加载 Apollo 的配置。例：初始化程序基础配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> agollo.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动 agollo - 自定义 logger 控件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> agollo.StartWithLogger(loggerInterface)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动 agollo - 自定义 cache 控件 (v1.7.0+)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> agollo.StartWithCache(cacheInterface)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动 agollo - 自定义各种控件 (v1.8.0+)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    agollo.SetLogger(loggerInterface)</span><br><span class="line">agollo.SetCache(cacheInterface)</span><br><span class="line">agollo.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听变更事件（阻塞）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">event := agollo.ListenChangeEvent()</span><br><span class="line">changeEvent := &lt;-event</span><br><span class="line">bytes, _ := json.Marshal(changeEvent)</span><br><span class="line">fmt.Println(<span class="string">"event:"</span>, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ul><li>String</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agollo.GetStringValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Int</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agollo.GetIntValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Float</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agollo.GetFloatValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Bool</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agollo.GetBoolValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><h2 id="切换namespace获取配置"><a href="#切换namespace获取配置" class="headerlink" title="切换namespace获取配置"></a>切换namespace获取配置</h2><ul><li>根据namespace获取配置</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config := agollo.GetConfig(namespace)</span><br></pre></td></tr></table></figure><ul><li>String</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.GetStringValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Int</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.GetIntValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Float</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.GetFloatValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><ul><li>Bool</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.GetBoolValue(Key,DefaultValue)</span><br></pre></td></tr></table></figure><h2 id="自定义日志组件"><a href="#自定义日志组件" class="headerlink" title="自定义日志组件"></a>自定义日志组件</h2><p>复制以下代码至项目中，并在其中引用日志组件的方法进行打印 log</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DefaultLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Debugf</span><span class="params">(format <span class="keyword">string</span>, params ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Infof</span><span class="params">(format <span class="keyword">string</span>, params ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Warnf</span><span class="params">(format <span class="keyword">string</span>, params ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, params ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Debug</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Info</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Warn</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DefaultLogger)</span><span class="title">Error</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   agollo.SetLogger(&amp;DefaultLogger&#123;&#125;)</span><br><span class="line">   agollo.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义缓存组件"><a href="#自定义缓存组件" class="headerlink" title="自定义缓存组件"></a>自定义缓存组件</h2><h3 id="声明自定义缓存组件"><a href="#声明自定义缓存组件" class="headerlink" title="声明自定义缓存组件"></a>声明自定义缓存组件</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultCache 默认缓存</span></span><br><span class="line"><span class="keyword">type</span> DefaultCache <span class="keyword">struct</span> &#123;</span><br><span class="line">defaultCache sync.Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set 获取缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value []<span class="keyword">byte</span>, expireSeconds <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span>  &#123;</span><br><span class="line">d.defaultCache.Store(key,value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EntryCount 获取实体数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">EntryCount</span><span class="params">()</span> <span class="params">(entryCount <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line">count:=<span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">d.defaultCache.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get 获取缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, err error)</span></span>&#123;</span><br><span class="line">v, ok := d.defaultCache.Load(key)</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">"load default cache fail"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v.([]<span class="keyword">byte</span>),<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Range 遍历缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span>&#123;</span><br><span class="line">d.defaultCache.Range(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Del 删除缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(affected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">d.defaultCache.Delete(key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Clear 清除所有缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCache)</span><span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.defaultCache=sync.Map&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultCacheFactory 构造默认缓存组件工厂类</span></span><br><span class="line"><span class="keyword">type</span> DefaultCacheFactory <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create 创建默认缓存组件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DefaultCacheFactory)</span> <span class="title">Create</span><span class="params">()</span><span class="title">CacheInterface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DefaultCache&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">agollo.SetCache(&amp;DefaultCacheFactory&#123;&#125;)</span><br><span class="line">agollo.Start()</span><br></pre></td></tr></table></figure><hr><ul><li>项目地址: <a href="https://github.com/zouyx/agollo" target="_blank" rel="noopener">https://github.com/zouyx/agollo</a></li></ul><p>​                          <em>方资讯\</em>最新技术*独家解读*</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcmcur033tj306b06b74o.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      java 转 go 遇到 Apollo？ 让 agollo 来帮你平滑迁移
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>fuckdb Lite, 帮助你更快地生成go struct代码</title>
    <link href="https://cloudsjhan.github.io/2020/04/06/fuckdb-Lite-%E5%B8%AE%E5%8A%A9%E4%BD%A0%E6%9B%B4%E5%BF%AB%E5%9C%B0%E7%94%9F%E6%88%90go-struct%E4%BB%A3%E7%A0%81/"/>
    <id>https://cloudsjhan.github.io/2020/04/06/fuckdb-Lite-帮助你更快地生成go-struct代码/</id>
    <published>2020-04-06T01:07:07.000Z</published>
    <updated>2020-04-06T01:12:34.978Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="前言-amp-背景"><a href="#前言-amp-背景" class="headerlink" title="前言&amp;背景"></a>前言&amp;背景</h2><p>在golang的开发过程中，当我们使用orm的时候，常常需要将数据库表对应到golang的一个struct，这些struct会携带orm对应的<code>tag</code>，就像下面的struct定义一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type InsInfo struct &#123;</span><br><span class="line">  Connections  string    `gorm:&quot;column:connections&quot;`</span><br><span class="line">  CPU          int       `gorm:&quot;column:cpu&quot;`</span><br><span class="line">  CreateTime   time.Time `gorm:&quot;column:create_time&quot;`</span><br><span class="line">  Env          int       `gorm:&quot;column:env&quot;`</span><br><span class="line">  ID           int64     `gorm:&quot;column:id;primary_key&quot;`</span><br><span class="line">  IP           string    `gorm:&quot;column:ip&quot;`</span><br><span class="line">  Organization string    `gorm:&quot;column:organization&quot;`</span><br><span class="line">  Pass         string    `gorm:&quot;column:pass&quot;`</span><br><span class="line">  Port         string    `gorm:&quot;column:port&quot;`</span><br><span class="line">  RegionId     string    `gorm:&quot;column:regionid&quot;`</span><br><span class="line">  ServerIP     string    `gorm:&quot;column:server_ip&quot;`</span><br><span class="line">  Status       int       `gorm:&quot;column:status&quot;`</span><br><span class="line">  Type         string    `gorm:&quot;column:type&quot;`</span><br><span class="line">  UUID         string    `gorm:&quot;column:uuid&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是gorm对应的数据库表的struct映射，即使数据表的字段不多，如果是手动写起来也是一些重复性的工作。像MySQL这种关系型数据库，我们一般会用orm去操作数据库，于是就想mysql的数据表能不能来自动生成golang 的struct定义 ，减少重复性的开发工作（早点下班）。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>调研了一下目前有一些工具，比如chrome插件SQL2Struct(一款根据sql语句自动生成golang结构体的chrome插件)，感觉用起来比较繁琐，每次需要进入数据库，执行SQL语句拿到建表语句copy到浏览器中，才能使用。在想能不能提供一个开箱即用的环境，提供web界面，我们只需要填写数据库信息，就可以一键生成对应的ORM的struct，于是就诞生了这个项目：<a href="https://github.com/hantmac/fuckdb" target="_blank" rel="noopener">https://github.com/hantmac/fuckdb</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>mysql有个自带的数据库<code>information_schema</code>，有一张表<code>COLUMNS</code>，它的字段包含数据库名、表名、字段名、字段类型等，我们可以利用这个表的数据，把对应的表的字段信息读取出来，然后再根据golang的语法规则，生成对应的struct。具体不详细展开了，感兴趣的可以去看下源码。</p><h2 id="Web-版"><a href="#Web-版" class="headerlink" title="Web 版"></a>Web 版</h2><h3 id="连接本地数据库"><a href="#连接本地数据库" class="headerlink" title="连接本地数据库"></a>连接本地数据库</h3><p>如果你的数据库在本地，那么只需要执行 <code>docker-compose up -d</code>，<br>访问<code>localhost:8000</code>，你就会得到下面的界面：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714cf8416f8ebde?w=3324&amp;h=892&amp;f=png&amp;s=151985" alt=""></p><h3 id="服务器上的数据库"><a href="#服务器上的数据库" class="headerlink" title="服务器上的数据库"></a>服务器上的数据库</h3><p>如果你的数据库在内网服务器上，你需要先修改后端接口的ip:port,然后重新build Docker镜像，push到自己的镜像仓库，然后修改docker-compose.yaml，再执行<code>docker-compose up -d</code>。修改的位置是：<code>fuckdb/frontend/src/config/index.js</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let APIdb2struct</span><br><span class="line"></span><br><span class="line">if(process.env.NODE_ENV === &quot;development&quot;)&#123;</span><br><span class="line">  APIdb2struct = &quot;http://0.0.0.0:8000&quot; //修改为部署服务器的ip</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  APIdb2struct = &quot;http://0.0.0.0:8000&quot; //修改为部署服务器的ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  APIdb2struct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要填入数据库相关信息，以及你想得到的golang代码的<code>package name</code>、<code>struct name</code>,然后点击生成，就可以得到gorm对应的结构体映射。</p><p>在你的项目项目中只要 Ctrl+C&amp;Ctrl+V 即可。我们知道golang的struct的tag有很多功能，这里也提供了很多tag的可选项，比如<code>json</code>,<code>xml</code>等，后面会增加更多的tag可选项支持。</p><p>web版的特色功能是数据库信息缓存功能，能够记忆你之前填写过的数据库信息，省去了大量重复的操作，你不用再填写繁琐的数据库名，表名，只需一键，就可以得到对应的代码，配合附带json-to-go插件(<a href="https://github.com/mholt/json-to-go)，开发效率得到极速提升。目前这个工具在我们组内已经开始使用，反馈比较好，节省了很多重复的工作，尤其是在开发的时候用到同一个库的多张表，很快就可以完成数据库表-&gt;strcut的映射。" target="_blank" rel="noopener">https://github.com/mholt/json-to-go)，开发效率得到极速提升。目前这个工具在我们组内已经开始使用，反馈比较好，节省了很多重复的工作，尤其是在开发的时候用到同一个库的多张表，很快就可以完成数据库表-&gt;strcut的映射。</a></p><p><strong>来看一段演示视频。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714cf9e25576889?w=1920&amp;h=1080&amp;f=gif&amp;s=765691" alt=""></p><h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>前几天有同学找上门，说fuckdb的web版部署后无法使用，解决了半天也没能让用户部署起来，反馈过来还是感觉部署有些复杂。反思了一下，对于一个工具化的软件，有些用户并不想做一些复杂的部署流程或者不熟悉部署操作，可能就是想暂时使用一下，所以应该让工具更加轻量化，更加开箱即用，于是连夜写了一个fuckdb lite, 更容易上手使用，更方便的安装流程，1分钟拿到你想要的代码。</p><h2 id="fuckdb-Lite"><a href="#fuckdb-Lite" class="headerlink" title="fuckdb Lite"></a>fuckdb Lite</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>基于 cobra(<a href="https://github.com/spf13/cobra)，核心代码继承web版。" target="_blank" rel="noopener">https://github.com/spf13/cobra)，核心代码继承web版。</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>听取用户反馈，安装流程极简化，Mac用户可以直接brew install 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap hantmac/tap &amp;&amp; brew install fuckdb</span><br></pre></td></tr></table></figure><ul><li>Linux用户:<br><code>curl https://github.com/hantmac/fuckdb/releases/download/v0.2/fuckdb_linux.tar.gz</code> 下载、解压、安装</li><li>windows用户emmm, 就去GitHub的release手动下载吧</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fuckdb --help</span><br><span class="line">From mysql schema generate golang struct with gorm, json tag</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  fuckdb [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  generate    use `fuckdb generate` to generate fuckdb.json</span><br><span class="line">  go          fuckdb go to generate golang struct with gorm and json tag</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help   help for fuckdb</span><br><span class="line"></span><br><span class="line">Use &quot;fuckdb [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>目前提供了两个主要命令，<code>fuckdb generate</code> 和 <code>fuckdb go</code>，我们依次来看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuckdb generate</span><br></pre></td></tr></table></figure><p>生成一个存储MySQL信息的<code>fuckdb.json</code>文件,<br>编辑 fuckdb.json  ，填写你的MySQL信息，该文件可复用，简单修改表名即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;db&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;localhost&quot;,</span><br><span class="line">    &quot;port&quot;: 3306,</span><br><span class="line">    &quot;password&quot;: &quot;password&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;table&quot;: &quot;tableName&quot;,</span><br><span class="line">    &quot;database&quot;: &quot;example&quot;,</span><br><span class="line">    &quot;packageName&quot;: &quot;packageName&quot;,</span><br><span class="line">    &quot;structName&quot;: &quot;structName&quot;,</span><br><span class="line">    &quot;jsonAnnotation&quot;: true,</span><br><span class="line">    &quot;gormAnnotation&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>修改完文件后，就完成了准备工作，go go go!</p><p>​执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuckdb go</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714cfdc08b200b9?w=1238&amp;h=528&amp;f=png&amp;s=619750" alt=""><br><strong>Enjoy Your Code！</strong></p><p>来看一段演示操作(说好一分钟拿到代码，绝不超1秒)</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714cfdf3764125e?w=1736&amp;h=1080&amp;f=gif&amp;s=675007" alt=""></p><p>比之前的web版的安装简直方便了太多，妈妈再也不用担心我加班啦。</p><p>ps:  fuckdb.json文件必须在操作目录下。</p><p>欢迎试用&amp;反馈&amp;Contribute。代码地址：<a href="https://github.com/hantmac/fuckdb" target="_blank" rel="noopener">https://github.com/hantmac/fuckdb</a></p><hr><pre><code>官方资讯*最新技术*独家解读</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714cfed71ef0758?w=227&amp;h=227&amp;f=jpeg&amp;s=24842" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      fuckdb Lite, 帮助你更快地生成go struct代码
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Proposals for Go 1.15(译)</title>
    <link href="https://cloudsjhan.github.io/2020/02/01/Proposals-for-Go-1-15-%E8%AF%91/"/>
    <id>https://cloudsjhan.github.io/2020/02/01/Proposals-for-Go-1-15-译/</id>
    <published>2020-02-01T02:48:54.000Z</published>
    <updated>2020-04-01T09:03:03.550Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h2 id="Proposals-for-Go-1-15-译"><a href="#Proposals-for-Go-1-15-译" class="headerlink" title="Proposals for Go 1.15(译)"></a><a href="https://blog.golang.org/go1.15-proposals" target="_blank" rel="noopener">Proposals for Go 1.15</a>(译)</h2><hr><p><em>本文是Golang官方对于Go近期版本的现状总结以及Go 1.15版本的一些提案，原文发布于 The Go Blog</em></p><p><em>Robert Griesemer, for the Go team</em><br>        <em>28 January 2020</em></p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>Go 1.14的RC1版本已经准备就绪，如果一切顺利，Go 1.14计划将于今年2月份发布。按照<a href="https://blog.golang.org/go2-here-we-come" target="_blank" rel="noopener">Go 2,here we come!</a>的规划，在我们的开发周期中又到了这样的一个时刻：考虑下一个版本中（暂定于几年8月份发布的Go 1.15），到底要提供哪些Golang本身或者Go lib中的新特性。</p><p>当前版本的Go的优化目标仍然围绕着软件包和版本管理，更好的错误处理支持以及泛型特性。Go Module 目前使用状态比较好，并且每天都在不断完善，对泛型的支持也有一些推进（今年晚些时候会有更多进展）。为了提供更好的错误处理机制，大约在7个月前我们提出了<a href="https://golang.org/issue/32437" target="_blank" rel="noopener">try_proposal</a>的提案，有少部分人支持该提案，但是大部分还是持强烈的反对态度，于是我们决定放弃这个想法。在此之后，也有许多建议，但它们有些都没有足够的说服力，有些还不如<a href="https://golang.org/issue/32437" target="_blank" rel="noopener">try_proposal</a>。因此，我们暂时没有进一步的计划去改善错误处理机制，也许未来会出现一些比较好的点子帮助我们解决这个问题。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>鉴于Go Module和泛型正在积极的推进中，且错误处理机制没有进一步的计划，那么还有哪些特性值得我们去关注呢？如果非要说有的话，有一些编程语言中经久不衰的特性，例如枚举类型和不可变类型的需求，但是这些idea还没有被Go团队深入地思考，所以Go团队也没有投入过多精力在其中，尤其是改进这些语言特性需要很大的成本。</p><p>Go team不希望在没有长期计划的情况下增添很多新的特性，在审核了大量可行的提案之后，Go 团队得出结论：这一次不进行重大更改。相反，我们会集中精力做一些新的 <code>go vet</code>支持和语言层面的一下小调整。我们选择了以下三个提案：</p><p><a href="https://golang.org/issue/32479" target="_blank" rel="noopener">#32479</a> <code>go vet</code>中支持string(int) 转换的检测</p><p>我们原计划在即将发布的Go 1.14版本中实现该功能，但我们并没有解决这个问题，所以放在Go 1.15中解决。string(int) 转换在很早的Go版本中就已经引入了，但是有些特性（string(10)是”\n”，并不是”10”）会让Go新手迷惑，并且unicode/utf8包中也已经提供了该功能。自从<a href="https://golang.org/issue/3939" target="_blank" rel="noopener">removing this coversion</a>的提案不是一个向后兼容的改变，所以我们需要在<code>go vet</code>中提供string(int)的错误检测能力。</p><p><a href="https://golang.org/issue/4483" target="_blank" rel="noopener">#4483</a> <code>go vet</code>中支持错误的x.(T)的类型断言</p><p>当前，Go允许任何类型断言x.(T)（以及相应的类型切换情况），其中x和T为接口类型。但是，如果x和T有相同名字的方法，但是签名不同，则分配给x的任何值也不能实现T（这种类型的断言在运行时总是失败，panic或evaluate to false）。因为我们在编译时就知道这一点，所以编译器会报告错。在这种情况下，编译报错不是向后兼容的，因此我们也将在<code>go vet</code>中添加对该情况的检查。</p><p><a href="https://golang.org/issue/28591" target="_blank" rel="noopener">#28591</a> 使用常量字符串和索引进行常量求值的索引和切片表达式</p><p>当前，用一个或多个常量索引对常量字符串进行索引或切片会分别产生一个非常量字节或字符串值。 但是，如果所有操作数都是常量，则编译器可以对这些表达式进行常量求值，并生成常量（可能是无类型的）结果。 这是完全向后兼容的更改，我们将对开发规范和编译器进行必要的调整。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>Go team认为这三个提案应该是没有什么争议的，但是人非圣贤孰能无过，因此我们计划在Go 1.15的发布周期开发(Go 1.14发布时或之后)开始采纳开发者对该三个提案的建议，以便有足够的时间收集反馈。在<a href="https://blog.golang.org/go2-here-we-come" target="_blank" rel="noopener">proposal evalution process</a>，最终的提案将在2020年5月初决定。</p><h2 id="One-more-thing…"><a href="#One-more-thing…" class="headerlink" title="One more thing…"></a>One more thing…</h2><p>我们收到了大量的语言特性修正的提案(<a href="https://github.com/golang/go/labels/LanguageChange" target="_blank" rel="noopener">issue label LanguageChange</a>)，但是我们没有时间去仔细地彻底地评估。举个栗子，单是关于错误处理机制的提案，就有57个issue，到目前为止还有5个处于open的状态。由于进行语言更改的成本，无论大小如何，对于开发者来说其实都很高，而且收益往往很小，因此我们必须谨慎行事。由于大多数提案反馈的人数很少，这些提案都会遭到拒绝。但是有些开发者花费了大量时间去写提案的细节，到头来还是被拒；另一方面，由于总体提案流程比较简单，因此提交一些无关紧要的语言变更提案非常容易，从而给审核委员会带来大量不必要的工作，也有可能埋没比较好的提案。为了解决这个问题我们新增了一个关于Go提案的<a href="https://github.com/golang/proposal/blob/master/go2-language-changes.md" target="_blank" rel="noopener">问卷</a>：填写该模板将有助于审核者更有效地评估提案，因为他们无需尝试自己回答这些问题。 它能从一开始就设定一些限制，从而为提议者提供更好的指导。 这是一个实验性的尝试，我们会根据需要随着时间的推移进行完善。</p><p>感谢您帮助我们改善Go的体验！</p><hr><p>原文地址：<a href="https://blog.golang.org/go1.15-proposals" target="_blank" rel="noopener">https://blog.golang.org/go1.15-proposals</a></p><hr>]]></content>
    
    <summary type="html">
    
      本文是Golang官方对于Go近期版本的现状总结以及Go 1.15版本的一些提案，原文发布于 The Go Blog
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go GC 20问</title>
    <link href="https://cloudsjhan.github.io/2020/01/06/Go-GC-20%E9%97%AE/"/>
    <id>https://cloudsjhan.github.io/2020/01/06/Go-GC-20问/</id>
    <published>2020-01-06T06:05:44.000Z</published>
    <updated>2020-01-06T13:18:19.500Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h2 id="Go-GC-20-问"><a href="#Go-GC-20-问" class="headerlink" title="Go GC 20 问"></a>Go GC 20 问</h2><p>原创： 欧长坤 码农桃花源 <a href="https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q</a></p><p>本文作者欧长坤，德国慕尼黑大学在读博士，Go/etcd/Tensorflow contributor，开源书籍《Go 语言原本》作者，《Go 夜读》SIG 成员/讲师，对 Go 有很深的研究。Github：@changkun，<a href="https://changkun.de。" target="_blank" rel="noopener">https://changkun.de。</a></p><p>本文首发于 Github 开源项目 《Go-Questions》，点击阅读原文直达。全文不计代码，共 1.7w+ 字，建议收藏后精读。另外，本文结尾有彩蛋。</p><p>按惯例，贴上本文的目录：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gan2vk1a5ej30u00ojad2.jpg" alt="img"></p><blockquote><p>本文写于 Go 1.14 beta1，当文中提及目前、目前版本等字眼时均指 Go 1.14，此外，文中所有 go 命令版本均为 Go 1.14。</p></blockquote><h1 id="GC-的认识"><a href="#GC-的认识" class="headerlink" title="GC 的认识"></a>GC 的认识</h1><h2 id="1-什么是-GC，有什么作用？"><a href="#1-什么是-GC，有什么作用？" class="headerlink" title="1. 什么是 GC，有什么作用？"></a>1. 什么是 GC，有什么作用？</h2><p><code>GC</code>，全称 <code>Garbage Collection</code>，即垃圾回收，是一种自动内存管理的机制。</p><p>当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。而负责垃圾回收的程序组件，即为垃圾回收器。</p><p>垃圾回收其实一个完美的 “Simplicity is Complicated” 的例子。一方面，程序员受益于 GC，无需操心、也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。另一方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。</p><p>通常，垃圾回收器的执行过程被划分为两个半独立的组件：</p><ul><li>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</li><li>回收器（Collector）：负责执行垃圾回收的代码。</li></ul><h2 id="2-根对象到底是什么？"><a href="#2-根对象到底是什么？" class="headerlink" title="2. 根对象到底是什么？"></a>2. 根对象到底是什么？</h2><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><ol><li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ol><h2 id="3-常见的-GC-实现方式有哪些？Go-语言的-GC-使用的是什么？"><a href="#3-常见的-GC-实现方式有哪些？Go-语言的-GC-使用的是什么？" class="headerlink" title="3. 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？"></a>3. 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？</h2><p>所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。</p><ul><li><p>追踪式 GC </p><p>从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。</p></li><li><p>引用计数式 GC</p><p>每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。</p></li></ul><p>目前比较常见的 GC 实现方式包括：</p><ul><li>追踪式，分为多种不同类型，例如：<ul><li>标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。</li><li>标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。</li><li>增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，达到近似实时、几乎无停顿的目的。</li><li>增量整理：在增量式的基础上，增加对对象的整理过程。</li><li>分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</li></ul></li><li>引用计数：根据对象自身的引用计数来回收，当引用计数归零时立即回收。</li></ul><p>关于各类方法的详细介绍及其实现不在本文中详细讨论。对于 Go 而言，Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。<a href="https://groups.google.com/d/msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ" target="_blank" rel="noopener">原因</a>在于：</p><ol><li>对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 tcmalloc 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。</li><li>分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过<strong>逃逸分析</strong>将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。</li></ol><h2 id="4-三色标记法是什么？"><a href="#4-三色标记法是什么？" class="headerlink" title="4. 三色标记法是什么？"></a>4. 三色标记法是什么？</h2><p>理解<strong>三色标记法</strong>的关键是理解对象的<strong>三色抽象</strong>以及<strong>波面（wavefront）推进</strong>这两个概念。三色抽象只是一种描述追踪式回收器的方法，在实践中并没有实际含义，它的重要作用在于从逻辑上严密推导标记清理这种垃圾回收方法的正确性。也就是说，当我们谈及三色标记法时，通常指标记清扫的垃圾回收。</p><p>从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：</p><ul><li>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</li><li>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</li><li>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</li></ul><p>这样三种不变性所定义的回收过程其实是一个<strong>波面</strong>不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。</p><p>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。如下图所示：</p><p><img src="https://user-images.githubusercontent.com/7698088/70995777-505fc800-210c-11ea-9f6d-3549f884ff46.png" alt="三色标记法全貌"></p><p>图中展示了根对象、可达对象、不可达对象，黑、灰、白对象以及波面之间的关系。</p><h2 id="5-STW-是什么意思？"><a href="#5-STW-是什么意思？" class="headerlink" title="5. STW 是什么意思？"></a>5. STW 是什么意思？</h2><p><code>STW</code> 是 <code>Stop the World</code> 的缩写，即万物静止，是指在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。</p><p>在这个过程中整个用户代码被停止或者放缓执行， <code>STW</code> 越长，对用户代码造成的影响（例如延迟）就越大，早期 Go 对垃圾回收器的实现中 <code>STW</code> 长达几百毫秒，对时间敏感的实时通信等应用程序会造成巨大的影响。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">runtime.GC()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"OK"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个程序在 Go 1.14 以前永远都不会输出 <code>OK</code>，其罪魁祸首是 STW 无限制的被延长。</p><p>尽管 STW 如今已经优化到了半毫秒级别以下，但这个程序被卡死原因在于仍然是 STW 导致的。原因在于，GC 在进入 STW 时，需要等待让所有的用户态代码停止，但是 <code>for {}</code> 所在的 goroutine 永远都不会被中断，从而停留在 STW 阶段。实际实践中也是如此，当程序的某个 goroutine 长时间得不到停止，强行拖慢 STW，这种情况下造成的影响（卡死）是非常可怕的。好在自 Go 1.14 之后，这类 goroutine 能够被异步地抢占，从而使得 STW 的时间如同普通程序那样，不会超过半个毫秒，程序也不会因为仅仅等待一个 goroutine 的停止而停顿在 STW 阶段。</p><h2 id="6-如何观察-Go-GC？"><a href="#6-如何观察-Go-GC？" class="headerlink" title="6. 如何观察 Go GC？"></a>6. 如何观察 Go GC？</h2><p>我们以下面的程序为例，先使用四种不同的方式来介绍如何观察 GC，并在后面的问题中通过几个详细的例子再来讨论如何优化 GC。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">()</span></span> &#123;</span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">100000</span>; n++ &#123;</span><br><span class="line">allocate()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式1：GODEBUG-gctrace-1"><a href="#方式1：GODEBUG-gctrace-1" class="headerlink" title="方式1：GODEBUG=gctrace=1"></a>方式1：<code>GODEBUG=gctrace=1</code></h3><p>我们首先可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ GODEBUG=gctrace=1 ./main</span><br><span class="line"></span><br><span class="line">gc 1 @0.000s 2%: 0.009+0.23+0.004 ms clock, 0.11+0.083/0.019/0.14+0.049 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 12 P</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 57, consumed: 6 (MB)</span><br><span class="line">gc 2 @0.001s 2%: 0.018+1.1+0.029 ms clock, 0.22+0.047/0.074/0.048+0.34 ms cpu, 4-&gt;7-&gt;3 MB, 5 MB goal, 12 P</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">gc 3 @0.003s 2%: 0.018+0.59+0.011 ms clock, 0.22+0.073/0.008/0.042+0.13 ms cpu, 5-&gt;6-&gt;1 MB, 6 MB goal, 12 P</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 2, idle: 61, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">gc 4 @0.003s 4%: 0.019+0.70+0.054 ms clock, 0.23+0.051/0.047/0.085+0.65 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 12 P</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 4, idle: 59, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">gc 5 @0.004s 12%: 0.021+0.26+0.49 ms clock, 0.26+0.046/0.037/0.11+5.8 ms cpu, 4-&gt;7-&gt;3 MB, 5 MB goal, 12 P</span><br><span class="line">scvg: inuse: 5, idle: 58, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">gc 6 @0.005s 12%: 0.020+0.17+0.004 ms clock, 0.25+0.080/0.070/0.053+0.051 ms cpu, 5-&gt;6-&gt;1 MB, 6 MB goal, 12 P</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 1, idle: 62, sys: 63, released: 56, consumed: 7 (MB)</span><br></pre></td></tr></table></figure><p>在这个日志中可以观察到两类不同的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gc 1 @0.000s 2%: 0.009+0.23+0.004 ms clock, 0.11+0.083/0.019/0.14+0.049 ms cpu, 4-&gt;6-&gt;2 MB, 5 MB goal, 12 P</span><br><span class="line">gc 2 @0.001s 2%: 0.018+1.1+0.029 ms clock, 0.22+0.047/0.074/0.048+0.34 ms cpu, 4-&gt;7-&gt;3 MB, 5 MB goal, 12 P</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 57, consumed: 6 (MB)</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 56, consumed: 7 (MB)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于用户代码向运行时申请内存产生的垃圾回收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc 2 @0.001s 2%: 0.018+1.1+0.029 ms clock, 0.22+0.047/0.074/0.048+0.34 ms cpu, 4-&gt;7-&gt;3 MB, 5 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>含义由下表所示：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">gc 2</td><td style="text-align:left">第二个 GC 周期</td></tr><tr><td style="text-align:left">0.001</td><td style="text-align:left">程序开始后的 0.001 秒</td></tr><tr><td style="text-align:left">2%</td><td style="text-align:left">该 GC 周期中 CPU 的使用率</td></tr><tr><td style="text-align:left">0.018</td><td style="text-align:left">标记开始时， STW 所花费的时间（wall clock）</td></tr><tr><td style="text-align:left">1.1</td><td style="text-align:left">标记过程中，并发标记所花费的时间（wall clock）</td></tr><tr><td style="text-align:left">0.029</td><td style="text-align:left">标记终止时， STW 所花费的时间（wall clock）</td></tr><tr><td style="text-align:left">0.22</td><td style="text-align:left">标记开始时， STW 所花费的时间（cpu time）</td></tr><tr><td style="text-align:left">0.047</td><td style="text-align:left">标记过程中，标记辅助所花费的时间（cpu time）</td></tr><tr><td style="text-align:left">0.074</td><td style="text-align:left">标记过程中，并发标记所花费的时间（cpu time）</td></tr><tr><td style="text-align:left">0.048</td><td style="text-align:left">标记过程中，GC 空闲的时间（cpu time）</td></tr><tr><td style="text-align:left">0.34</td><td style="text-align:left">标记终止时， STW 所花费的时间（cpu time）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">标记开始时，堆的大小的实际值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">标记结束时，堆的大小的实际值</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">标记结束时，标记为存活的对象大小</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">标记结束时，堆的大小的预测值</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">P 的数量</td></tr></tbody></table><blockquote><p>wall clock 是指开始执行到完成所经历的实际时间，包括其他程序和本程序所消耗的时间；<br>cpu time 是指特定程序使用 CPU 的时间；<br>他们存在以下关系：</p><ul><li>wall clock &lt; cpu time: 充分利用多核</li><li>wall clock ≈ cpu time: 未并行执行</li><li>wall clock &gt; cpu time: 多核优势不明显</li></ul></blockquote><p>对于运行时向操作系统申请内存产生的垃圾回收（向操作系统归还多余的内存）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 3, idle: 60, sys: 63, released: 57, consumed: 6 (MB)</span><br></pre></td></tr></table></figure><p>含义由下表所示：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">8 KB released</td><td style="text-align:left">向操作系统归还了 8 KB 内存</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">已经分配给用户代码、正在使用的总内存大小 (MB)。MB used or partially used spans</td></tr><tr><td style="text-align:left">60</td><td style="text-align:left">空闲以及等待归还给操作系统的总内存大小（MB）。MB spans pending scavenging</td></tr><tr><td style="text-align:left">63</td><td style="text-align:left">通知操作系统中保留的内存大小（MB）MB mapped from the system</td></tr><tr><td style="text-align:left">57</td><td style="text-align:left">已经归还给操作系统的（或者说还未正式申请）的内存大小（MB）。MB released to the system</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">已经从操作系统中申请的内存大小（MB）。MB allocated from the system</td></tr></tbody></table><h3 id="方式2：go-tool-trace"><a href="#方式2：go-tool-trace" class="headerlink" title="方式2：go tool trace"></a>方式2：<code>go tool trace</code></h3><p><code>go tool trace</code> 的主要功能是将统计而来的信息以一种可视化的方式展示给用户。要使用此工具，可以通过调用 trace API：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">trace.Start(f)</span><br><span class="line"><span class="keyword">defer</span> trace.Stop()</span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go tool trace trace.out</span><br><span class="line">2019/12/30 15:50:33 Parsing trace...</span><br><span class="line">2019/12/30 15:50:38 Splitting trace...</span><br><span class="line">2019/12/30 15:50:45 Opening browser. Trace viewer is listening on http://127.0.0.1:51839</span><br></pre></td></tr></table></figure><p>命令来启动可视化界面：</p><p><img src="./assets/gc-trace.png" alt=""></p><p>选择第一个链接可以获得如下图示：</p><p><img src="assets/gc-trace2.png" alt=""></p><p>右上角的问号可以打开帮助菜单，主要使用方式包括：</p><ul><li>w/s 键可以用于放大或者缩小视图</li><li>a/d 键可以用于左右移动</li></ul><h3 id="方式3：debug-ReadGCStats"><a href="#方式3：debug-ReadGCStats" class="headerlink" title="方式3：debug.ReadGCStats"></a>方式3：<code>debug.ReadGCStats</code></h3><p>此方式可以通过代码的方式来直接实现对感兴趣指标的监控，例如我们希望每隔一秒钟监控一次 GC 的状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGCStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.NewTicker(time.Second)</span><br><span class="line">s := debug.GCStats&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">debug.ReadGCStats(&amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"gc %d last@%v, PauseTotal %v\n"</span>, s.NumGC, s.LastGC, s.PauseTotal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> printGCStats()</span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够看到如下输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">gc <span class="number">4954</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">37.505575</span> +<span class="number">0100</span> CET, PauseTotal <span class="number">29.901171</span>ms</span><br><span class="line">gc <span class="number">9195</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">38.50565</span> +<span class="number">0100</span> CET, PauseTotal <span class="number">77.579622</span>ms</span><br><span class="line">gc <span class="number">13502</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">39.505714</span> +<span class="number">0100</span> CET, PauseTotal <span class="number">128.022307</span>ms</span><br><span class="line">gc <span class="number">17555</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">40.505579</span> +<span class="number">0100</span> CET, PauseTotal <span class="number">182.816528</span>ms</span><br><span class="line">gc <span class="number">21838</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">19</span>:<span class="number">41.505595</span> +<span class="number">0100</span> CET, PauseTotal <span class="number">246.618502</span>ms</span><br></pre></td></tr></table></figure><h3 id="方式4：runtime-ReadMemStats"><a href="#方式4：runtime-ReadMemStats" class="headerlink" title="方式4：runtime.ReadMemStats"></a>方式4：<code>runtime.ReadMemStats</code></h3><p>除了使用 debug 包提供的方法外，还可以直接通过运行时的内存相关的 API 进行监控：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMemStats</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.NewTicker(time.Second)</span><br><span class="line">s := runtime.MemStats&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">runtime.ReadMemStats(&amp;s)</span><br><span class="line">fmt.Printf(<span class="string">"gc %d last@%v, next_heap_size@%vMB\n"</span>, s.NumGC, time.Unix(<span class="keyword">int64</span>(time.Duration(s.LastGC).Seconds()), <span class="number">0</span>), s.NextGC/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> printMemStats()</span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">gc <span class="number">4887</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">56</span> +<span class="number">0100</span> CET, next_heap_size@<span class="number">4</span>MB</span><br><span class="line">gc <span class="number">10049</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">57</span> +<span class="number">0100</span> CET, next_heap_size@<span class="number">4</span>MB</span><br><span class="line">gc <span class="number">15231</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">58</span> +<span class="number">0100</span> CET, next_heap_size@<span class="number">4</span>MB</span><br><span class="line">gc <span class="number">20378</span> last@<span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">59</span> +<span class="number">0100</span> CET, next_heap_size@<span class="number">6</span>MB</span><br></pre></td></tr></table></figure><p>当然，后两种方式能够监控的指标很多，读者可以自行查看 <a href="https://golang.org/pkg/runtime/debug/#GCStats" target="_blank" rel="noopener"><code>debug.GCStats</code></a> 和<br><a href="https://golang.org/pkg/runtime/#MemStats" target="_blank" rel="noopener"><code>runtime.MemStats</code></a> 的字段，这里不再赘述。</p><h2 id="7-有了-GC，为什么还会发生内存泄露？"><a href="#7-有了-GC，为什么还会发生内存泄露？" class="headerlink" title="7. 有了 GC，为什么还会发生内存泄露？"></a>7. 有了 GC，为什么还会发生内存泄露？</h2><p>在一个具有 GC 的语言中，我们常说的内存泄漏，用严谨的话来说应该是：预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。</p><p>在 Go 中，由于 goroutine 的存在，所谓的内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。</p><h3 id="形式1：预期能被快速释放的内存因被根对象引用而没有得到迅速释放"><a href="#形式1：预期能被快速释放的内存因被根对象引用而没有得到迅速释放" class="headerlink" title="形式1：预期能被快速释放的内存因被根对象引用而没有得到迅速释放"></a>形式1：预期能被快速释放的内存因被根对象引用而没有得到迅速释放</h3><p>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">m := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">cache[i] = m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形式2：goroutine-泄漏"><a href="#形式2：goroutine-泄漏" class="headerlink" title="形式2：goroutine 泄漏"></a>形式2：goroutine 泄漏</h3><p>Goroutine 作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>我们可以通过如下形式来调用上述两个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">trace.Start(f)</span><br><span class="line"><span class="keyword">defer</span> trace.Stop()</span><br><span class="line">keepalloc()</span><br><span class="line">keepalloc2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>会看到程序中生成了 <code>trace.out</code> 文件，我们可以使用 <code>go tool trace trace.out</code> 命令得到下图：</p><p><img src="./assets/gc-leak1.png" alt=""></p><p>可以看到，途中的 Heap 在持续增长，没有内存被回收，产生了内存泄漏的现象。</p><p>值得一提的是，这种形式的 goroutine 泄漏还可能由 channel 泄漏导致。而 channel 的泄漏本质上与 goroutine 泄漏存在直接联系。Channel 作为一种同步原语，会连接两个不同的 goroutine，如果一个 goroutine 尝试向一个没有接收方的无缓冲 channel 发送消息，则该 goroutine 会被永久的休眠，整个 goroutine 及其执行栈都得不到释放，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 没有接收方，goroutine 会一直阻塞</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-并发标记清除法的难点是什么？"><a href="#8-并发标记清除法的难点是什么？" class="headerlink" title="8. 并发标记清除法的难点是什么？"></a>8. 并发标记清除法的难点是什么？</h2><p>在没有用户态代码并发修改<code>三色抽象</code>的情况下，回收可以正常结束。但是并发回收的根本问题在于，用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。这时以一个固定的三色波面作为回收过程前进的边界则不再合理。</p><p>我们不妨考虑赋值器写操作的例子：</p><table><thead><tr><th>时序</th><th>回收器</th><th>赋值器</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>shade(A, gray)</td><td></td><td>回收器：根对象的子节点着色为灰色对象</td></tr><tr><td>2</td><td>shade(C, black)</td><td></td><td>回收器：当所有子节点着色为灰色后，将节点着为黑色</td></tr><tr><td>3</td><td></td><td>C.ref3 = C.ref2.ref1</td><td>赋值器：并发的修改了 C 的子节点</td></tr><tr><td>4</td><td></td><td>A.ref1 = nil</td><td>赋值器：并发的修改了 A 的子节点</td></tr><tr><td>5</td><td>shade(A.ref1, gray)</td><td></td><td>回收器：进一步灰色对象的子节点并着色为灰色对象，这时由于 <code>A.ref1</code> 为 <code>nil</code>，什么事情也没有发生</td></tr><tr><td>6</td><td>shade(A, black)</td><td></td><td>回收器：由于所有子节点均已标记，回收器也不会重新扫描已经被标记为黑色的对象，此时 A 被着色为黑色，<code>scan(A)</code> 什么也不会发生，进而 B 在此次回收过程中永远不会被标记为黑色，进而错误地被回收。</td></tr></tbody></table><ul><li>初始状态：假设某个黑色对象 C 指向某个灰色对象 A ，而 A 指向白色对象 B；</li><li><code>C.ref3 = C.ref2.ref1</code>：赋值器并发地将黑色对象 C 指向（ref3）了白色对象 B；</li><li><code>A.ref1 = nil</code>：移除灰色对象 A 对白色对象 B 的引用（ref2）；</li><li>最终状态：在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象 B 被错误地回收。</li></ul><p><img src="./assets/gc-mutator.png" alt="gc-mutator"></p><p>总而言之，并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性。</p><h2 id="9-什么是写屏障、混合写屏障，如何实现？"><a href="#9-什么是写屏障、混合写屏障，如何实现？" class="headerlink" title="9. 什么是写屏障、混合写屏障，如何实现？"></a>9. 什么是写屏障、混合写屏障，如何实现？</h2><p>要讲清楚写屏障，就需要理解三色标记清除算法中的<strong>强弱不变性</strong>以及<strong>赋值器的颜色</strong>，理解他们需要一定的抽象思维。写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：<strong>不应出现对象的丢失，也不应错误的回收还不需要回收的对象。</strong></p><p>可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性：</p><ul><li><strong>条件 1</strong>: 赋值器修改对象图，导致某一黑色对象引用白色对象；</li><li><strong>条件 2</strong>: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。</li></ul><p>只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：</p><ul><li>如果条件 1 被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；</li><li>如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。</li></ul><p>我们不妨将三色不变性所定义的波面根据这两个条件进行削弱：</p><ul><li>当满足原有的三色不变性定义（或上面的两个条件都不满足时）的情况称为<strong>强三色不变性（strong tricolor invariant）</strong><!-- 即不存在黑色对象指向白色对象的指针； --></li><li>当赋值器令黑色对象引用白色对象时（满足条件 1 时）的情况称为<strong>弱三色不变性（weak tricolor invariant）</strong><!-- 即所有黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）。 --></li></ul><p>当赋值器进一步破坏灰色对象到达白色对象的路径时（进一步满足条件 2 时），即打破弱三色不变性，也就破坏了回收器的正确性；或者说，在破坏强弱三色不变性时必须引入额外的辅助操作。弱三色不变形的好处在于：<strong>只要存在未访问的能够到达白色对象的路径，就可以将黑色对象指向白色对象。</strong></p><p>如果我们考虑并发的用户态代码，回收器不允许同时停止所有赋值器，就是涉及了存在的多个不同状态的赋值器。为了对概念加以明确，还需要换一个角度，把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短），从而引入赋值器的颜色：</p><ul><li>黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。</li><li>灰色赋值器：尚未被回收器扫描过，或尽管已经扫描过但仍需要重新扫描。</li></ul><p>赋值器的颜色对回收周期的结束产生影响：</p><ul><li>如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描对象图。</li><li>如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能在其根中插入新的非黑色的引用，如此往复，直到重新扫描过程中没有发现新的白色或灰色对象。</li></ul><p>于是，在允许灰色赋值器存在的算法，最坏的情况下，回收器只能将所有赋值器线程停止才能完成其跟对象的完整扫描，也就是我们所说的 STW。</p><p>为了确保强弱三色不变性的并发指针更新操作，需要通过赋值器屏障技术来保证指针的读写操作一致。因此我们所说的 Go 中的写屏障、混合写屏障，其实是指赋值器的写屏障，赋值器的写屏障用来保证赋值器在进行指针写操作时，不会破坏弱三色不变性。</p><p>有两种非常经典的写屏障：Dijkstra 插入屏障和 Yuasa 删除屏障。</p><p>灰色赋值器的 Dijkstra 插入屏障的基本思想是避免满足条件 1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 灰色赋值器 Dijkstra 插入屏障</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DijkstraWritePointer</span><span class="params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    shade(ptr)</span><br><span class="line">    *slot = ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止黑色对象指向白色对象，应该假设 <code>*slot</code> 可能会变为黑色，为了确保 <code>ptr</code> 不会在被赋值到 <code>*slot</code> 前变为白色，<code>shade(ptr)</code> 会先将指针 <code>ptr</code> 标记为灰色，进而避免了条件 1。但是，由于并不清楚赋值器以后会不会将这个引用删除，因此还需要重新扫描来重新确定关系图，这时需要 STW，如图所示：</p><p><img src="./assets/gc-wb-dijkstra.png" alt=""></p><p>Dijkstra 插入屏障的好处在于可以立刻开始并发标记，但由于产生了灰色赋值器，缺陷是需要标记终止阶段 STW 时进行重新扫描。</p><p>黑色赋值器的 Yuasa 删除屏障的基本思想是避免满足条件 2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 黑色赋值器 Yuasa 屏障</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YuasaWritePointer</span><span class="params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    shade(*slot)</span><br><span class="line">    *slot = ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止丢失从灰色对象到白色对象的路径，应该假设 <code>*slot</code> 可能会变为黑色，为了确保 <code>ptr</code> 不会在被赋值到 <code>*slot</code> 前变为白色，<code>shade(*slot)</code> 会先将 <code>*slot</code> 标记为灰色，进而该写操作总是创造了一条灰色到灰色或者灰色到白色对象的路径，进而避免了条件 2。</p><p>Yuasa 删除屏障的优势则在于不需要标记结束阶段的重新扫描，缺陷是依然会产生丢失的对象，需要在标记开始前对整个对象图进行快照。</p><p><img src="./assets/gc-wb-yuasa.png" alt=""></p><p>Go 在 1.8 的时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将 Dijkstra 插入屏障和 Yuasa 删除屏障进行混合，形成混合写屏障。该屏障提出时的基本思想是：<strong>对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。</strong></p><p>但在最终实现时<a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener">原提案</a>中对 <code>ptr</code> 的着色还额外包含对执行栈的着色检查，但由于时间有限，并未完整实现过，所以混合写屏障在目前的实现伪代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合写屏障</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HybridWritePointerSimple</span><span class="params">(slot *unsafe.Pointer, ptr unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    shade(*slot)</span><br><span class="line">  shade(ptr)</span><br><span class="line">    *slot = ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，如果无条件对引用双方进行着色，自然结合了 Dijkstra 和 Yuasa 写屏障的优势，但缺点也非常明显，因为着色成本是双倍的，而且编译器需要插入的代码也成倍增加，随之带来的结果就是编译后的二进制文件大小也进一步增加。为了针对写屏障的性能进行优化，Go 1.10 前后，Go 团队随后实现了批量写屏障机制。其基本想法是将需要着色的指针同一写入一个缓存，每当缓存满时统一对缓存中的所有 <code>ptr</code> 指针进行着色。</p><h1 id="GC-的实现细节"><a href="#GC-的实现细节" class="headerlink" title="GC 的实现细节"></a>GC 的实现细节</h1><h2 id="10-Go-语言中-GC-的流程是什么？"><a href="#10-Go-语言中-GC-的流程是什么？" class="headerlink" title="10. Go 语言中 GC 的流程是什么？"></a>10. Go 语言中 GC 的流程是什么？</h2><p>当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段：</p><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">说明</th><th style="text-align:center">赋值器状态</th></tr></thead><tbody><tr><td style="text-align:center">GCMark</td><td style="text-align:center">标记准备阶段，为并发标记做准备工作，启动写屏障</td><td style="text-align:center">STW</td></tr><tr><td style="text-align:center">GCMark</td><td style="text-align:center">扫描标记阶段，与赋值器并发执行，写屏障开启</td><td style="text-align:center">并发</td></tr><tr><td style="text-align:center">GCMarkTermination</td><td style="text-align:center">标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td><td style="text-align:center">STW</td></tr><tr><td style="text-align:center">GCoff</td><td style="text-align:center">内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</td><td style="text-align:center">并发</td></tr><tr><td style="text-align:center">GCoff</td><td style="text-align:center">内存归还阶段，将过多的内存归还给操作系统，写屏障关闭</td><td style="text-align:center">并发</td></tr></tbody></table><p>具体而言，各个阶段的触发函数分别为：</p><p><img src="https://user-images.githubusercontent.com/7698088/71047691-930aba00-2177-11ea-84d5-4e9eac2df723.png" alt="gc-process"></p><h2 id="11-触发-GC-的时机是什么？"><a href="#11-触发-GC-的时机是什么？" class="headerlink" title="11. 触发 GC 的时机是什么？"></a>11. 触发 GC 的时机是什么？</h2><p>Go 语言中对 GC 的触发时机存在两种形式：  </p><ol><li><p><strong>主动触发</strong>，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。</p></li><li><p><strong>被动触发</strong>，分为两种方式：</p><ul><li><p>使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。</p></li><li><p>使用步调（Pacing）算法，其核心思想是控制内存增长的比例。</p></li></ul></li></ol><p>通过 <code>GOGC</code> 或者 <code>debug.SetGCPercent</code> 进行控制（他们控制的是同一个变量，即堆的增长率 $\rho$）。整个算法的设计考虑的是优化问题：如果设上一次 GC 完成时，内存的数量为 $H_m$（heap marked），估计需要触发 GC 时的堆大小 $H_T$（heap trigger），使得完成 GC 时候的目标堆大小 $H_g$（heap goal） 与实际完成时候的堆大小 $H_a$（heap actual）最为接近，即： $\min |H_g - H_a| = \min|(1+\rho)H_m - H_a|$。</p><p><img src="https://user-images.githubusercontent.com/7698088/71047935-5e4b3280-2178-11ea-9abd-c86667ac9f88.png" alt="gc-pacing"></p><p>除此之外，步调算法还需要考虑 CPU 利用率的问题，显然我们不应该让垃圾回收器占用过多的 CPU，即不应该让每个负责执行用户 goroutine 的线程都在执行标记过程。理想情况下，在用户代码满载的时候，GC 的 CPU 使用率不应该超过 25%，即另一个优化问题：如果设 $u_g$为目标 CPU 使用率（goal utilization），而 $u_a$为实际 CPU 使用率（actual utilization），则 $\min|u_g - u_a|$。</p><blockquote><p>求解这两个优化问题的具体数学建模过程我们不在此做深入讨论，有兴趣的读者可以参考两个设计文档：<a href="https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#" target="_blank" rel="noopener">Go 1.5 concurrent garbage collector pacing</a> 和 <a href="https://github.com/golang/proposal/blob/master/design/14951-soft-heap-limit.md" target="_blank" rel="noopener">Separate soft and hard heap size goal</a>。</p></blockquote><p>计算 $H_T$ 的最终结论（从 Go 1.10 时开始 $h_t$ 增加了上界 $0.95 \rho$，从 Go 1.14 开始时 $h_t$ 增加了下界 0.6）是：</p><ul><li>设第 n 次触发 GC 时 (n &gt; 1)，估计得到的堆增长率为 $h_t^{(n)}$、运行过程中的实际堆增长率为 $h_a^{(n)}$，用户设置的增长率为 $\rho = \text{GOGC}/100$（ $\rho &gt; 0$）则第 $n+1$ 次出触发 GC 时候，估计的堆增长率为：</li></ul><p>$$<br>h_t^{(n+1)} = h_t^{(n)} + 0.5 \left[ \frac{H_g^{(n)} - H_a^{(n)}}{H_a^{(n)}} - h_t^{(n)} - \frac{u_a^{(n)}}{u_g^{(n)}} \left( h_a^{(n)} - h_t^{(n)} \right) \right]<br>$$</p><ul><li><p>特别的，$h_t^{(1)} = 7 / 8$，$u_a^{(1)} = 0.25$，$u_g^{(1)} = 0.3$。第一次触发 GC 时，如果当前的堆小于 $4\rho$ MB，则强制调整到 $4\rho$ MB 时触发 GC</p></li><li><p>特别的，当 $h_t^{(n)}&lt;0.6$时，将其调整为 $0.6$，当 $h_t^{(n)} &gt; 0.95 \rho$ 时，将其设置为 $0.95 \rho$</p></li><li><p>默认情况下，$\rho = 1$（即 GOGC = 100），第一次触发 GC 时强制设置触发第一次 GC 为 4MB，可以写如下程序进行验证：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/trace"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stop <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过对象 P 的释放状态，来确定 GC 是否已经完成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcfinished</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">p := <span class="number">1</span></span><br><span class="line">runtime.SetFinalizer(&amp;p, <span class="function"><span class="keyword">func</span><span class="params">(_ *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"gc finished"</span>)</span><br><span class="line">atomic.StoreUint64(&amp;stop, <span class="number">1</span>) <span class="comment">// 通知停止分配</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 每次调用分配 0.25MB</span></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>((<span class="number">1</span>&lt;&lt;<span class="number">20</span>)*<span class="number">0.25</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">trace.Start(f)</span><br><span class="line"><span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">gcfinished()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当完成 GC 时停止分配</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">1</span>; atomic.LoadUint64(&amp;stop) != <span class="number">1</span>; n++ &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"#allocate: "</span>, n)</span><br><span class="line">allocate()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"terminate"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来验证最简单的一种情况，即第一次触发 GC 时的堆大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ GODEBUG=gctrace=1 ./main</span><br><span class="line">#allocate:  1</span><br><span class="line">(...)</span><br><span class="line">#allocate:  20</span><br><span class="line">gc finished</span><br><span class="line">gc 1 @0.001s 3%: 0.016+0.23+0.019 ms clock, 0.20+0.11/0.060/0.13+0.22 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 12 P</span><br><span class="line">scvg: 8 KB released</span><br><span class="line">scvg: inuse: 1, idle: 62, sys: 63, released: 58, consumed: 5 (MB)</span><br><span class="line">terminate</span><br></pre></td></tr></table></figure><p>通过这一行数据我们可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc 1 @0.001s 3%: 0.016+0.23+0.019 ms clock, 0.20+0.11/0.060/0.13+0.22 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 12 P</span><br></pre></td></tr></table></figure><ol><li>程序在完成第一次 GC 后便终止了程序，符合我们的设想</li><li>第一次 GC 开始时的堆大小为 4MB，符合我们的设想</li><li>当标记终止时，堆大小为 5MB，此后开始执行清扫，这时分配执行到第 20 次，即 20*0.25 = 5MB，符合我们的设想</li></ol><p>我们将分配次数调整到 50 次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">1</span>; n &lt; <span class="number">50</span>; n++ &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"#allocate: "</span>, n)</span><br><span class="line">allocate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来验证第二次 GC 触发时是否满足公式所计算得到的值（为 GODEBUG 进一步设置 <code>gcpacertrace=1</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ GODEBUG=gctrace=1,gcpacertrace=1 ./main</span><br><span class="line">#allocate:  1</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line">pacer: H_m_prev=2236962 h_t=+8.750000e-001 H_T=4194304 h_a=+2.387451e+000 H_a=7577600 h_g=+1.442627e+000 H_g=5464064 u_a=+2.652227e-001 u_g=+3.000000e-001 W_a=152832 goalΔ=+5.676271e-001 actualΔ=+1.512451e+000 u_a/u_g=+8.840755e-001</span><br><span class="line">#allocate:  28</span><br><span class="line">gc 1 @0.001s 5%: 0.032+0.32+0.055 ms clock, 0.38+0.068/0.053/0.11+0.67 ms cpu, 4-&gt;7-&gt;3 MB, 5 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">(...)</span><br><span class="line">#allocate:  37</span><br><span class="line">pacer: H_m_prev=3307736 h_t=+6.000000e-001 H_T=5292377 h_a=+7.949171e-001 H_a=5937112 h_g=+1.000000e+000 H_g=6615472 u_a=+2.658428e-001 u_g=+3.000000e-001 W_a=154240 goalΔ=+4.000000e-001 actualΔ=+1.949171e-001 u_a/u_g=+8.861428e-001</span><br><span class="line">#allocate:  38</span><br><span class="line">gc 2 @0.002s 9%: 0.017+0.26+0.16 ms clock, 0.20+0.079/0.058/0.12+1.9 ms cpu, 5-&gt;5-&gt;0 MB, 6 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>我们可以得到数据：</p><ul><li>第一次估计得到的堆增长率为 $h_t^{(1)} = 0.875$</li><li>第一次的运行过程中的实际堆增长率为 $h_a^{(1)} = 0.2387451$</li><li>第一次实际的堆大小为 $H_a^{(1)}=7577600$</li><li>第一次目标的堆大小为 $H_g^{(1)}=5464064$</li><li>第一次的 CPU 实际使用率为 $u_a^{(1)} = 0.2652227$</li><li>第一次的 CPU 目标使用率为 $u_g^{(1)} = 0.3$</li></ul><p>我们据此计算第二次估计的堆增长率：</p><p>$$<br>\begin{align}<br>h_t^{(2)} &amp;= h_t^{(1)} + 0.5 \left[ \frac{H_g^{(1)} - H_a^{(1)}}{H_a^{(1)}} - h_t^{(1)} - \frac{u_a^{(1)}}{u_g^{(1)}} \left( h_a^{(1)} - h_t^{(1)} \right) \right] \<br>&amp;= 0.875 + 0.5 \left[ \frac{5464064 - 7577600}{5464064} - 0.875 - \frac{0.2652227}{0.3} \left( 0.2387451 - 0.875 \right) \right] \<br>&amp; \approx 0.52534543909 \<br>\end{align}<br>$$</p><p>因为 $0.52534543909 &lt; 0.6\rho = 0.6$，因此下一次的触发率为 $h_t^{2} = 0.6$，与我们实际观察到的第二次 GC 的触发率 0.6 吻合。</p><h2 id="12-如果内存分配速度超过了标记清除的速度怎么办？"><a href="#12-如果内存分配速度超过了标记清除的速度怎么办？" class="headerlink" title="12. 如果内存分配速度超过了标记清除的速度怎么办？"></a>12. 如果内存分配速度超过了标记清除的速度怎么办？</h2><p>目前的 Go 实现中，当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用时进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。</p><p>编译器会分析用户代码，并在需要分配内存的位置，将申请内存的操作翻译为 <code>mallocgc</code> 调用，而 <code>mallocgc</code> 的实现决定了标记辅助的实现，其伪代码思路如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(t typ.Type, size <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> enableMarkAssist &#123;</span><br><span class="line"><span class="comment">// 进行标记辅助，此时用户代码没有得到执行</span></span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行内存分配</span></span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GC-的优化问题"><a href="#GC-的优化问题" class="headerlink" title="GC 的优化问题"></a>GC 的优化问题</h1><h2 id="13-GC-关注的指标有哪些？"><a href="#13-GC-关注的指标有哪些？" class="headerlink" title="13. GC 关注的指标有哪些？"></a>13. GC 关注的指标有哪些？</h2><p>Go 的 GC 被设计为成比例触发、大部分工作与赋值器并发、不分代、无内存移动且会主动向操作系统归还申请的内存。因此最主要关注的、能够影响赋值器的性能指标有：</p><ul><li>CPU 利用率：回收算法会在多大程度上拖慢程序？有时候，这个是通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述的。</li><li>GC 停顿时间：回收器会造成多长时间的停顿？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。</li><li>GC 停顿频率：回收器造成的停顿频率是怎样的？目前的 GC 中需要考虑 STW 和 Mark Assist 两个部分可能造成的停顿。</li><li>GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何？但大部分的程序可能并不一定关心这个问题。</li></ul><h2 id="14-Go-的-GC-如何调优？"><a href="#14-Go-的-GC-如何调优？" class="headerlink" title="14. Go 的 GC 如何调优？"></a>14. Go 的 GC 如何调优？</h2><p>Go 的 GC 被设计为极致简洁，与较为成熟的 Java GC 的数十个可控参数相比，严格意义上来讲，Go 可供用户调整的参数只有 GOGC 环境变量。当我们谈论 GC 调优时，通常是指减少用户代码对 GC 产生的压力，这一方面包含了减少用户代码分配内存的数量（即对程序的代码行为进行调优），另一方面包含了最小化 Go 的 GC 对 CPU 的使用率（即调整 GOGC）。</p><p>GC 的调优是在特定场景下产生的，并非所有程序都需要针对 GC 进行调优。只有那些对执行延迟非常敏感、<br>当 GC 的开销成为程序性能瓶颈的程序，才需要针对 GC 进行性能调优，几乎不存在于实际开发中 99% 的情况。<br>除此之外，Go 的 GC 也仍然有一定的可改进的空间，也有部分 GC 造成的问题，目前仍属于 Open Problem。</p><p>总的来说，我们可以在现在的开发中处理的有以下几种情况：</p><ol><li>对停顿敏感：GC 过程中产生的长时间停顿、或由于需要执行 GC 而没有执行用户代码，导致需要立即执行的用户代码执行滞后。</li><li>对资源消耗敏感：对于频繁分配内存的应用而言，频繁分配内存增加 GC 的工作量，原本可以充分利用 CPU 的应用不得不频繁地执行垃圾回收，影响用户代码对 CPU 的利用率，进而影响用户代码的执行效率。</li></ol><p>从这两点来看，所谓 GC 调优的核心思想也就是充分的围绕上面的两点来展开：优化内存的申请速度，尽可能的少申请内存，复用已申请的内存。或者简单来说，不外乎这三个关键字：<strong>控制、减少、复用</strong>。</p><p>我们将通过三个实际例子介绍如何定位 GC 的存在的问题，并一步一步进行性能调优。当然，在实际情况中问题远比这些例子要复杂，这里也只是讨论调优的核心思想，更多的时候也只能具体问题具体分析。</p><h3 id="例1：合理化内存分配的速度、提高赋值器的-CPU-利用率"><a href="#例1：合理化内存分配的速度、提高赋值器的-CPU-利用率" class="headerlink" title="例1：合理化内存分配的速度、提高赋值器的 CPU 利用率"></a>例1：合理化内存分配的速度、提高赋值器的 CPU 利用率</h3><p>我们来看这样一个例子。在这个例子中，<code>concat</code> 函数负责拼接一些长度不确定的字符串。并且为了快速完成任务，出于某种原因，在两个嵌套的 for 循环中一口气创建了 800 个 goroutine。在 main 函数中，启动了一个 goroutine 并在程序结束前不断的触发 GC，并尝试输出 GC 的平均执行时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/trace"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">stop  <span class="keyword">int32</span></span><br><span class="line">count <span class="keyword">int64</span></span><br><span class="line">sum   time.Duration</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">100</span>; n++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"Go GC"</span></span><br><span class="line">s += <span class="string">" "</span> + <span class="string">"Hello"</span></span><br><span class="line">s += <span class="string">" "</span> + <span class="string">"World"</span></span><br><span class="line">_ = s</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">trace.Start(f)</span><br><span class="line"><span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t time.Time</span><br><span class="line"><span class="keyword">for</span> atomic.LoadInt32(&amp;stop) == <span class="number">0</span> &#123;</span><br><span class="line">t = time.Now()</span><br><span class="line">runtime.GC()</span><br><span class="line">sum += time.Since(t)</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"GC spend avg: %v\n"</span>, time.Duration(<span class="keyword">int64</span>(sum)/count))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">concat()</span><br><span class="line">atomic.StoreInt32(&amp;stop, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的执行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ ./main</span><br><span class="line">GC spend avg: 2.583421ms</span><br></pre></td></tr></table></figure><p>GC 平均执行一次需要长达 2ms 的时间，我们再进一步观察 trace 的结果：</p><p><img src="./assets/gc-tuning-ex1-1.png" alt=""></p><p>程序的整个执行过程中仅执行了一次 GC，而且仅 Sweep STW 就耗费了超过 1 ms，非常反常。甚至查看赋值器 mutator 的 CPU 利用率，在整个 trace 尺度下连 40% 都不到：</p><p><img src="./assets/gc-tuning-ex1-2.png" alt=""></p><p>主要原因是什么呢？我们不妨查看 goroutine 的分析：</p><p><img src="./assets/gc-tuning-ex1-3.png" alt=""></p><p>在这个榜单中我们不难发现，goroutine 的执行时间占其生命周期总时间非常短的一部分，但大部分时间都花费在调度器的等待上了（蓝色的部分），说明同时创建大量 goroutine 对调度器产生的压力确实不小，我们不妨将这一产生速率减慢，一批一批地创建 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">100</span>; n++ &#123;</span><br><span class="line">wg.Add(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"Go GC"</span></span><br><span class="line">s += <span class="string">" "</span> + <span class="string">"Hello"</span></span><br><span class="line">s += <span class="string">" "</span> + <span class="string">"World"</span></span><br><span class="line">_ = s</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们再来看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ ./main</span><br><span class="line">GC spend avg: 328.54µs</span><br></pre></td></tr></table></figure><p>GC 的平均时间就降到 300 微秒了。这时的赋值器 CPU 使用率也提高到了 60%，相对来说就很可观了：</p><p><img src="./assets/gc-tuning-ex1-4.png" alt=""></p><p>当然，这个程序仍然有优化空间，例如我们其实没有必要等待很多 goroutine 同时执行完毕才去执行下一组 goroutine。而可以当一个 goroutine 执行完毕时，直接启动一个新的 goroutine，也就是 goroutine 池的使用。<br>有兴趣的读者可以沿着这个思路进一步优化这个程序中赋值器对 CPU 的使用率。</p><h3 id="例2：降低并复用已经申请的内存"><a href="#例2：降低并复用已经申请的内存" class="headerlink" title="例2：降低并复用已经申请的内存"></a>例2：降低并复用已经申请的内存</h3><p>我们通过一个非常简单的 Web 程序来说明复用内存的重要性。在这个程序中，每当产生一个 <code>/example2</code><br>的请求时，都会创建一段内存，并用于进行一些后续的工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBuf</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br><span class="line">  </span><br><span class="line">http.HandleFunc(<span class="string">"/example2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">b := newBuf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行一些工作</span></span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[idx] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Fprintf(w, <span class="string">"done, %v"</span>, r.URL.Path[<span class="number">1</span>:])</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了进行性能分析，我们还额外创建了一个监听 6060 端口的 goroutine，用于使用 pprof 进行分析。<br>我们先让服务器跑起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build -o main</span><br><span class="line">$ ./main</span><br></pre></td></tr></table></figure><p>我们这次使用 pprof 的 trace 来查看 GC 在此服务器中面对大量请求时候的状态，要使用 trace 可以通过访问 <code>/debug/pprof/trace</code> 路由来进行，其中 <code>seconds</code> 参数设置为 20s，并将 trace 的结果保存为 <code>trace.out</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://127.0.0.1:6060/debug/pprof/trace\?seconds\=20 -O trace.out</span><br><span class="line">--2020-01-01 22:13:34--  http://127.0.0.1:6060/debug/pprof/trace?seconds=20</span><br><span class="line">Connecting to 127.0.0.1:6060... connected.</span><br><span class="line">HTTP request sent, awaiting response...</span><br></pre></td></tr></table></figure><p>这时候我们使用一个压测工具 <code>ab</code>，来同时产生 500 个请求<br>（<code>-n</code> 一共 500 个请求，<code>-c</code> 一个时刻执行请求的数量，每次 100 个并发请求）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ ab -n 500 -c 100 http://127.0.0.1:8080/example2</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1843412 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking 127.0.0.1 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Finished 500 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        </span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /example2</span><br><span class="line">Document Length:        14 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   0.987 seconds</span><br><span class="line">Complete requests:      500</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      65500 bytes</span><br><span class="line">HTML transferred:       7000 bytes</span><br><span class="line">Requests per second:    506.63 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       197.382 [ms] (mean)</span><br><span class="line">Time per request:       1.974 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          64.81 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    1   1.1      0       7</span><br><span class="line">Processing:    13  179  77.5    170     456</span><br><span class="line">Waiting:       10  168  78.8    162     455</span><br><span class="line">Total:         14  180  77.3    171     458</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    171</span><br><span class="line">  66%    203</span><br><span class="line">  75%    222</span><br><span class="line">  80%    239</span><br><span class="line">  90%    281</span><br><span class="line">  95%    335</span><br><span class="line">  98%    365</span><br><span class="line">  99%    400</span><br><span class="line"> 100%    458 (longest request)</span><br></pre></td></tr></table></figure><p><img src="./assets/gc-tuning-ex2-1.png" alt=""></p><p>GC 反复被触发，一个显而易见的原因就是内存分配过多。我们可以通过 <code>go tool pprof</code> 来查看究竟是谁分配了大量内存（使用 web 指令来使用浏览器打开统计信息的可视化图形）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof http://127.0.0.1:6060/debug/pprof/heap</span><br><span class="line">Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap</span><br><span class="line">Saved profile <span class="keyword">in</span> /Users/changkun/pprof/pprof.alloc_objects.alloc_space.inuse_o</span><br><span class="line">bjects.inuse_space.003.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Jan 1, 2020 at 11:15pm (CET)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p><img src="./assets/gc-tuning-ex2-2.png" alt=""></p><p>可见 <code>newBuf</code> 产生的申请的内存过多，现在我们使用 sync.Pool 来复用 <code>newBuf</code> 所产生的对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sync.Pool 复用需要的 buf</span></span><br><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br><span class="line">http.HandleFunc(<span class="string">"/example2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">b := bufPool.Get().([]<span class="keyword">byte</span>)</span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[idx] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"done, %v"</span>, r.URL.Path[<span class="number">1</span>:])</span><br><span class="line">bufPool.Put(b)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 ab 输出的统计结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ ab -n 500 -c 100 http://127.0.0.1:8080/example2</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1843412 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking 127.0.0.1 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Finished 500 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        </span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /example2</span><br><span class="line">Document Length:        14 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   0.427 seconds</span><br><span class="line">Complete requests:      500</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      65500 bytes</span><br><span class="line">HTML transferred:       7000 bytes</span><br><span class="line">Requests per second:    1171.32 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       85.374 [ms] (mean)</span><br><span class="line">Time per request:       0.854 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          149.85 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    1   1.4      1       9</span><br><span class="line">Processing:     5   75  48.2     66     211</span><br><span class="line">Waiting:        5   72  46.8     63     207</span><br><span class="line">Total:          5   77  48.2     67     211</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%     67</span><br><span class="line">  66%     89</span><br><span class="line">  75%    107</span><br><span class="line">  80%    122</span><br><span class="line">  90%    148</span><br><span class="line">  95%    167</span><br><span class="line">  98%    196</span><br><span class="line">  99%    204</span><br><span class="line"> 100%    211 (longest request)</span><br></pre></td></tr></table></figure><p>但从 <code>Requests per second</code> 每秒请求数来看，从原来的 506.63 变为 1171.32 得到了近乎一倍的提升。从 trace 的结果来看，GC 也没有频繁的被触发从而长期消耗 CPU 使用率：</p><p><img src="./assets/gc-tuning-ex2-3.png" alt=""></p><p>sync.Pool 是内存复用的一个最为显著的例子，从语言层面上还有很多类似的例子，例如在例 1 中，<code>concat</code> 函数可以预先分配一定长度的缓存，而后再通过 append 的方式将字符串存储到缓存中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">100</span>; n++ &#123;</span><br><span class="line">wg.Add(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"Go GC"</span>...)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">' '</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"Hello"</span>...)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">' '</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"World"</span>...)</span><br><span class="line">_ = <span class="keyword">string</span>(s)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因在于 <code>+</code> 运算符会随着字符串长度的增加而申请更多的内存，并将内容从原来的内存位置拷贝到新的内存位置，造成大量不必要的内存分配，先提前分配好足够的内存，再慢慢地填充，也是一种减少内存分配、复用内存形式的一种表现。</p><h3 id="例3：调整-GOGC"><a href="#例3：调整-GOGC" class="headerlink" title="例3：调整 GOGC"></a>例3：调整 GOGC</h3><p>我们已经知道了 GC 的触发原则是由步调算法来控制的，其关键在于估计下一次需要触发 GC 时，堆的大小。可想而知，如果我们在遇到海量请求的时，为了避免 GC 频繁触发，是否可以通过将 GOGC 的值设置得更大，让 GC 触发的时间变得更晚，从而减少其触发频率，进而增加用户代码对机器的使用率呢？答案是肯定的。</p><p>我们可以非常简单粗暴的将 GOGC 调整为 1000，来执行上一个例子中未复用对象之前的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ GOGC=1000 ./main</span><br></pre></td></tr></table></figure><p>这时我们再重新执行压测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ ab -n 500 -c 100 http://127.0.0.1:8080/example2</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1843412 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking 127.0.0.1 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Finished 500 requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        </span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            8080</span><br><span class="line"></span><br><span class="line">Document Path:          /example2</span><br><span class="line">Document Length:        14 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   0.923 seconds</span><br><span class="line">Complete requests:      500</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      65500 bytes</span><br><span class="line">HTML transferred:       7000 bytes</span><br><span class="line">Requests per second:    541.61 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       184.636 [ms] (mean)</span><br><span class="line">Time per request:       1.846 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          69.29 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    1   1.8      0      20</span><br><span class="line">Processing:     9  171 210.4     66     859</span><br><span class="line">Waiting:        5  158 199.6     62     813</span><br><span class="line">Total:          9  173 210.6     68     860</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%     68</span><br><span class="line">  66%    133</span><br><span class="line">  75%    198</span><br><span class="line">  80%    292</span><br><span class="line">  90%    566</span><br><span class="line">  95%    696</span><br><span class="line">  98%    723</span><br><span class="line">  99%    743</span><br><span class="line"> 100%    860 (longest request)</span><br></pre></td></tr></table></figure><p>可以看到，压测的结果得到了一定幅度的改善（<code>Requests per second</code> 从原来的 506.63 提高为了 541.61），<br>并且 GC 的执行频率明显降低：</p><p><img src="./assets/gc-tuning-ex3.png" alt=""></p><p>在实际实践中可表现为需要紧急处理一些由 GC 带来的瓶颈时，人为将 GOGC 调大，加钱加内存，扛过这一段峰值流量时期。</p><p>当然，这种做法其实是治标不治本，并没有从根本上解决内存分配过于频繁的问题，极端情况下，反而会由于 GOGC 太大而导致回收不及时而耗费更多的时间来清理产生的垃圾，这对时间不算敏感的应用还好，但对实时性要求较高的程序来说就是致命的打击了。</p><p>因此这时更妥当的做法仍然是，定位问题的所在，并从代码层面上进行优化。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上面的三个例子我们可以看到在 GC 调优过程中 <code>go tool pprof</code> 和 <code>go tool trace</code> 的强大作用是帮助我们快速定位 GC 导致瓶颈的具体位置，但这些例子中仅仅覆盖了其功能的很小一部分，我们也没有必要完整覆盖所有的功能，因为总是可以通过<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">http pprof 官方文档</a>、<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">runtime pprof官方文档</a>以及<a href="https://golang.org/pkg/runtime/trace/" target="_blank" rel="noopener">trace 官方文档</a>来举一反三。</p><p>现在我们来总结一下前面三个例子中的优化情况：</p><ol><li>控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。</li><li>减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。</li><li>需要时，增大 GOGC 的值，降低 GC 的运行频率。</li></ol><p>这三种情况几乎涵盖了 GC 调优中的核心思路，虽然从语言上还有很多小技巧可说，但我们并不会在这里事无巨细的进行总结。实际情况也是千变万化，我们更应该着重于培养具体问题具体分析的能力。</p><p>当然，我们还应该谨记 <strong>过早优化是万恶之源</strong>这一警语，在没有遇到应用的真正瓶颈时，将宝贵的时间分配在开发中其他优先级更高的任务上。</p><h2 id="15-Go-的垃圾回收器有哪些相关的-API？其作用分别是什么？"><a href="#15-Go-的垃圾回收器有哪些相关的-API？其作用分别是什么？" class="headerlink" title="15. Go 的垃圾回收器有哪些相关的 API？其作用分别是什么？"></a>15. Go 的垃圾回收器有哪些相关的 API？其作用分别是什么？</h2><p>在 Go 中存在数量极少的与 GC 相关的 API，它们是</p><ul><li>runtime.GC：手动触发 GC</li><li>runtime.ReadMemStats：读取内存相关的统计信息，其中包含部分 GC 相关的统计信息</li><li>debug.FreeOSMemory：手动将内存归还给操作系统</li><li>debug.ReadGCStats：读取关于 GC 的相关统计信息</li><li>debug.SetGCPercent：设置 GOGC 调步变量</li><li>debug.SetMaxHeap（尚未发布）：设置 Go 程序堆的上限值<!-- - https://github.com/golang/go/issues/23044 --></li></ul><h1 id="GC-的历史及演进"><a href="#GC-的历史及演进" class="headerlink" title="GC 的历史及演进"></a>GC 的历史及演进</h1><h2 id="16-Go-历史各个版本在-GC-方面的改进？"><a href="#16-Go-历史各个版本在-GC-方面的改进？" class="headerlink" title="16. Go 历史各个版本在 GC 方面的改进？"></a>16. Go 历史各个版本在 GC 方面的改进？</h2><ul><li><p>Go 1：串行三色标记清扫</p></li><li><p>Go 1.3：并行清扫，标记过程需要 STW，停顿时间在约几百毫秒</p></li><li><p>Go 1.5：并发标记清扫，停顿时间在一百毫秒以内</p></li><li><p>Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在十毫秒以内</p></li><li><p>Go 1.7：停顿时间控制在两毫秒以内</p></li><li><p>Go 1.8：混合写屏障，停顿时间在半个毫秒左右</p></li><li><p>Go 1.9：彻底移除了栈的重扫描过程 </p></li><li><p>Go 1.12：整合了两个阶段的 Mark Termination，但引入了一个严重的 GC Bug 至今未修（见问题 20），尚无该 Bug 对 GC 性能影响的报告</p></li><li><p>Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger</p></li><li><p>Go 1.14：替代了仅存活了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题</p></li></ul><p>可以用下图直观地说明 GC 的演进历史：</p><p><img src="assets/gc1.png" alt=""></p><p>在 Go 1 刚发布时的版本中，甚至没有将 Mark-Sweep 的过程并行化，当需要进行垃圾回收时，所有的代码都必须进入 STW 的状态。而到了 Go 1.1 时，官方迅速地将清扫过程进行了并行化的处理，即仅在标记阶段进入 STW。</p><p>这一想法很自然，因为并行化导致算法结果不一致的情况仅仅发生在标记阶段，而当时的垃圾回收器没有针对并行结果的一致性进行任何优化，因此才需要在标记阶段进入 STW。对于 Scavenger 而言，早期的版本中会有一个单独的线程来定期将多余的内存归还给操作系统。</p><p><img src="assets/gc2.png" alt=""></p><p>而到了 Go 1.5 后，Go 团队花费了相当大的力气，通过引入写屏障的机制来保证算法的一致性，才得以将整个 GC 控制在很小的 STW 内，而到了 1.8 时，由于新的混合屏障的出现，消除了对栈本身的重新扫描，STW 的时间进一步缩减。</p><p>从这个时候开始，Scavenger 已经从独立线程中移除，并合并至系统监控这个独立的线程中，并周期性地向操作系统归还内存，但仍然会有内存溢出这种比较极端的情况出现，因为程序可能在短时间内应对突发性的内存申请需求时，内存还没来得及归还操作系统，导致堆不断向操作系统申请内存，从而出现内存溢出。</p><p><img src="assets/gc3.png" alt=""></p><p>到了 Go 1.13，定期归还操作系统的问题得以解决，Go 团队开始将周期性的 Scavenger 转化为可被调度的 goroutine，并将其与用户代码并发执行。而到了 Go 1.14，这一向操作系统归还内存的操作时间进一步得到缩减。</p><h2 id="17-Go-GC-在演化过程中还存在哪些其他设计？为什么没有被采用？"><a href="#17-Go-GC-在演化过程中还存在哪些其他设计？为什么没有被采用？" class="headerlink" title="17. Go GC 在演化过程中还存在哪些其他设计？为什么没有被采用？"></a>17. Go GC 在演化过程中还存在哪些其他设计？为什么没有被采用？</h2><h3 id="并发栈重扫"><a href="#并发栈重扫" class="headerlink" title="并发栈重扫"></a>并发栈重扫</h3><p>正如我们前面所说，允许灰色赋值器存在的垃圾回收器需要引入重扫过程来保证算法的正确性，除了引入混合屏障来消除重扫这一过程外，有另一种做法可以提高重扫过程的性能，那就是将重扫的过程并发执行。然而这一<a href="https://github.com/golang/proposal/blob/master/design/17505-concurrent-rescan.md" target="_blank" rel="noopener">方案</a>并没有得以实现，原因很简单：实现过程相比引入混合屏障而言十分复杂，而且引入混合屏障能够消除重扫这一过程，将简化垃圾回收的步骤。</p><h3 id="ROC"><a href="#ROC" class="headerlink" title="ROC"></a>ROC</h3><p>ROC 的全称是<a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit" target="_blank" rel="noopener">面向请求的回收器</a>（Request Oriented Collector），它其实也是分代 GC 的一种重新叙述。它提出了一个请求假设（Request Hypothesis）：与一个完整请求、休眠 goroutine 所关联的对象比其他对象更容易死亡。这个假设听起来非常符合直觉，但在实现上，由于垃圾回收器必须确保是否有 goroutine 私有指针被写入公共对象，因此写屏障必须一直打开，这也就产生了该方法的致命缺点：昂贵的写屏障及其带来的缓存未命中，这也是这一设计最终没有被采用的主要原因。</p><h3 id="传统分代-GC"><a href="#传统分代-GC" class="headerlink" title="传统分代 GC"></a>传统分代 GC</h3><p>在发现 ROC 性能不行之后，作为备选方案，Go 团队还尝试了实现<a href="https://go-review.googlesource.com/c/go/+/137476/12" target="_blank" rel="noopener">传统的分代式 GC</a>。但最终同样发现分代假设并不适用于 Go 的运行栈机制，年轻代对象在栈上就已经死亡，扫描本就该回收的执行栈并没有为由于分代假设带来明显的性能提升。这也是这一设计最终没有被采用的主要原因。</p><h2 id="18-目前提供-GC-的语言以及不提供-GC-的语言有哪些？GC-和-No-GC-各自的优缺点是什么？"><a href="#18-目前提供-GC-的语言以及不提供-GC-的语言有哪些？GC-和-No-GC-各自的优缺点是什么？" class="headerlink" title="18. 目前提供 GC 的语言以及不提供 GC 的语言有哪些？GC 和 No GC 各自的优缺点是什么？"></a>18. 目前提供 GC 的语言以及不提供 GC 的语言有哪些？GC 和 No GC 各自的优缺点是什么？</h2><p>从原理上而言，所有的语言都能够自行实现 GC。从语言诞生之初就提供 GC 的语言，例如：</p><ul><li>Python</li><li>JavaScript</li><li>Java</li><li>Objective-C</li><li>Swift</li></ul><p>而不以 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：</p><ul><li>C</li><li>C++</li></ul><p>也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如：</p><ul><li>Rust</li></ul><p>垃圾回收使程序员无需手动处理内存释放，从而能够消除一些需要手动管理内存才会出现的运行时错误：</p><ol><li>在仍然有指向内存区块的指针的情况下释放这块内存时，会产生悬挂指针，从而后续可能错误的访问已经用于他用的内存区域。</li><li>多重释放同一块申请的内存区域可能导致不可知的内存损坏。</li></ol><p>当然，垃圾回收也会伴随一些缺陷，这也就造就了没有 GC 的一些优势：</p><ol><li>没有额外的性能开销</li><li>精准的手动内存管理，极致的利用机器的性能</li></ol><h2 id="19-Go-对比-Java、V8-中-JavaScript-的-GC-性能如何？"><a href="#19-Go-对比-Java、V8-中-JavaScript-的-GC-性能如何？" class="headerlink" title="19. Go 对比 Java、V8 中 JavaScript 的 GC 性能如何？"></a>19. Go 对比 Java、V8 中 JavaScript 的 GC 性能如何？</h2><p>无论是 Java 还是 JavaScript 中的 GC 均为分代式 GC。分代式 GC 的一个核心假设就是分代假说：将对象依据存活时间分配到不同的区域，每次回收只回收其中的一个区域。</p><h3 id="V8-的-GC"><a href="#V8-的-GC" class="headerlink" title="V8 的 GC"></a>V8 的 GC</h3><p>在 V8 中主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长、常驻内存、占用内存较大的对象：</p><ol><li>新生代中的对象主要通过副垃圾回收器进行回收。该回收过程是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，这两个空间中只有一个处于使用中，另一个则处于闲置状态。处于使用状态的空间称为 From 空间，处于闲置的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配，当开始垃圾回收时，会检查 From 空间中的存活对象，并将这些存活对象复制到 To 空间中，而非存活对象占用的空间被释放。完成复制后，From 空间和 To 空间的角色互换。也就是通过将存活对象在两个空间中进行复制。</li><li>老生代则由主垃圾回收器负责。它实现的是标记清扫过程，但略有不同之处在于它还会在清扫完成后对内存碎片进行整理，进而是一种标记整理的回收器。</li></ol><h3 id="Java-的-GC"><a href="#Java-的-GC" class="headerlink" title="Java 的 GC"></a>Java 的 GC</h3><p>Java 的 GC 称之为 G1，并将整个堆分为年轻代、老年代和永久代。包括四种不同的收集操作，从上往下的这几个阶段会选择性地执行，触发条件是用户的配置和实际代码行为的预测。</p><ol><li>年轻代收集周期：只对年轻代对象进行收集与清理</li><li>老年代收集周期：只对老年代对象进行收集与清理</li><li>混合式收集周期：同时对年轻代和老年代进行收集与清理</li><li>完整 GC 周期：完整的对整个堆进行收集与清理</li></ol><p>在回收过程中，G1 会对停顿时间进行预测，竭尽所能地调整 GC 的策略从而达到用户代码通过系统参数（<code>-XX:MaxGCPauseMillis</code>）所配置的对停顿时间的要求。</p><p>这四个周期的执行成本逐渐上升，优化得当的程序可以完全避免完整 GC 周期。</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>在 Go、Java 和 V8 JavaScript 之间比较 GC 的性能本质上是一个不切实际的问题。如前面所说，垃圾回收器的设计权衡了很多方面的因素，同时还受语言自身设计的影响，因为语言的设计也直接影响了程序员编写代码的形式，也就自然影响了产生垃圾的方式。</p><p>但总的来说，他们三者对垃圾回收的实现都需要 STW，并均已达到了用户代码几乎无法感知到的状态（据 Go GC 作者 Austin 宣称 <a href="https://groups.google.com/d/msg/golang-dev/Ab1sFeoZg_8/_DaL0E8fAwAJ" target="_blank" rel="noopener">STW 小于 100 微秒</a>）。当然，随着 STW 的减少，垃圾回收器会增加 CPU 的使用率，这也是程序员在编写代码时需要手动进行优化的部分，即充分考虑内存分配的必要性，减少过多申请内存带给垃圾回收器的压力。</p><h2 id="20-目前-Go-语言的-GC-还存在哪些问题？"><a href="#20-目前-Go-语言的-GC-还存在哪些问题？" class="headerlink" title="20. 目前 Go 语言的 GC 还存在哪些问题？"></a>20. 目前 Go 语言的 GC 还存在哪些问题？</h2><p>尽管 Go 团队宣称 STW 停顿时间得以优化到 100 微秒级别，但这本质上是一种取舍。原本的 STW 某种意义上来说其实转移到了可能导致用户代码停顿的几个位置；除此之外，由于运行时调度器的实现方式，同样对 GC 存在一定程度的影响。</p><p>目前 Go 中的 GC 仍然存在以下问题：</p><h3 id="1-Mark-Assist-停顿时间过长"><a href="#1-Mark-Assist-停顿时间过长" class="headerlink" title="1. Mark Assist 停顿时间过长"></a>1. Mark Assist 停顿时间过长</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"runtime/trace"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">windowSize = <span class="number">200000</span></span><br><span class="line">msgCount   = <span class="number">1000000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">best    time.Duration = time.Second</span><br><span class="line">bestAt  time.Time</span><br><span class="line">worst   time.Duration</span><br><span class="line">worstAt time.Time</span><br><span class="line"></span><br><span class="line">start = time.Now()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">trace.Start(f)</span><br><span class="line"><span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">measure()</span><br><span class="line">worst = <span class="number">0</span></span><br><span class="line">best = time.Second</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c channel</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; msgCount; i++ &#123;</span><br><span class="line">c.sendMsg(i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Best send delay %v at %v, worst send delay: %v at %v. Wall clock: %v \n"</span>, best, bestAt.Sub(start), worst, worstAt.Sub(start), time.Since(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> channel [windowSize][]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *channel)</span> <span class="title">sendMsg</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟发送</span></span><br><span class="line">(*c)[id%windowSize] = newMsg(id)</span><br><span class="line"></span><br><span class="line">end := time.Now()</span><br><span class="line">elapsed := end.Sub(start)</span><br><span class="line"><span class="keyword">if</span> elapsed &gt; worst &#123;</span><br><span class="line">worst = elapsed</span><br><span class="line">worstAt = end</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> elapsed &lt; best &#123;</span><br><span class="line">best = elapsed</span><br><span class="line">bestAt = end</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMsg</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> m &#123;</span><br><span class="line">m[i] = <span class="keyword">byte</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序我们可以得到类似下面的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"></span><br><span class="line">Best send delay 330ns at 773.037956ms, worst send delay: 7.127915ms at 579.835487ms. Wall clock: 831.066632ms </span><br><span class="line">Best send delay 331ns at 873.672966ms, worst send delay: 6.731947ms at 1.023969626s. Wall clock: 1.515295559s </span><br><span class="line">Best send delay 330ns at 1.812141567s, worst send delay: 5.34028ms at 2.193858359s. Wall clock: 2.199921749s </span><br><span class="line">Best send delay 338ns at 2.722161771s, worst send delay: 7.479482ms at 2.665355216s. Wall clock: 2.920174197s </span><br><span class="line">Best send delay 337ns at 3.173649445s, worst send delay: 6.989577ms at 3.361716121s. Wall clock: 3.615079348s</span><br></pre></td></tr></table></figure><p><img src="./assets/gc-mark-assist.png" alt=""></p><p>在这个结果中，第一次的最坏延迟时间高达 7.12 毫秒，发生在程序运行 578 毫秒左右。通过 <code>go tool trace</code> 可以发现，这个时间段中，Mark Assist 执行了 7112312ns，约为 7.127915ms；可见，此时最坏情况下，标记辅助拖慢了用户代码的执行，是造成 7 毫秒延迟的原因。</p><!-- https://github.com/golang/go/issues/27732 --><!-- https://github.com/golang/go/issues/27410 --><h3 id="2-Sweep-停顿时间过长"><a href="#2-Sweep-停顿时间过长" class="headerlink" title="2. Sweep 停顿时间过长"></a>2. Sweep 停顿时间过长</h3><p>同样还是刚才的例子，如果我们仔细观察 Mark Assist 后发生的 Sweep 阶段，竟然对用户代码的影响长达约 30ms，根据调用栈信息可以看到，该 Sweep 过程发生在内存分配阶段：</p><p><img src="./assets/gc-mark-sweep.png" alt=""></p><!-- https://github.com/golang/go/issues/18155 --><h3 id="3-由于-GC-算法的不正确性导致-GC-周期被迫重新执行"><a href="#3-由于-GC-算法的不正确性导致-GC-周期被迫重新执行" class="headerlink" title="3. 由于 GC 算法的不正确性导致 GC 周期被迫重新执行"></a>3. 由于 GC 算法的不正确性导致 GC 周期被迫重新执行</h3><p>此问题很难复现，但是一个已知的问题，根据 Go 团队的描述，<a href="https://github.com/golang/go/issues/27993#issuecomment-441719687" target="_blank" rel="noopener">能够在 1334 次构建中发生一次</a>，我们可以计算出其触发概率约为 0.0007496251874。虽然发生概率很低，但一旦发生，GC 需要被重新执行，非常不幸。</p><!-- https://github.com/golang/go/issues/27993 --><h3 id="4-创建大量-Goroutine-后导致-GC-消耗更多的-CPU"><a href="#4-创建大量-Goroutine-后导致-GC-消耗更多的-CPU" class="headerlink" title="4. 创建大量 Goroutine 后导致 GC 消耗更多的 CPU"></a>4. 创建大量 Goroutine 后导致 GC 消耗更多的 CPU</h3><p>这个问题可以通过以下程序进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGCLargeGs</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ng := <span class="number">100</span>; ng &lt;= <span class="number">1000000</span>; ng *= <span class="number">10</span> &#123;</span><br><span class="line">b.Run(fmt.Sprintf(<span class="string">"#g-%d"</span>, ng), <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建大量 goroutine，由于每次创建的 goroutine 会休眠</span></span><br><span class="line"><span class="comment">// 从而运行时不会复用正在休眠的 goroutine，进而不断创建新的 g</span></span><br><span class="line">wg.Add(ng)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ng; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现运行一次 GC 来提供一致的内存环境</span></span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录运行 b.N 次 GC 需要的时间</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">runtime.GC()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果可以通过如下指令来获得：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> -bench=BenchmarkGCLargeGs -run=^$ -count=5 -v . | tee 4.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> benchstat 4.txt</span></span><br><span class="line">name                     time/op</span><br><span class="line">GCLargeGs/#g-100-12       192µs ± 5%</span><br><span class="line">GCLargeGs/#g-1000-12      331µs ± 1%</span><br><span class="line">GCLargeGs/#g-10000-12    1.22ms ± 1%</span><br><span class="line">GCLargeGs/#g-100000-12   10.9ms ± 3%</span><br><span class="line">GCLargeGs/#g-1000000-12  32.5ms ± 4%</span><br></pre></td></tr></table></figure><p>这种情况通常发生于峰值流量后，大量 goroutine 由于任务等待被休眠，从而运行时不断创建新的 goroutine，<br>旧的 goroutine 由于休眠未被销毁且得不到复用，导致 GC 需要扫描的执行栈越来越多，进而完成 GC 所需的时间越来越长。<br>一个解决办法是使用 goroutine 池来限制创建的 goroutine 数量。</p><!-- https://github.com/golang/go/issues/34457 --><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GC 是一个复杂的系统工程，本文讨论的二十个问题尽管已经展现了一个相对全面的 Go GC。但它们仍然只是 GC 这一宏观问题的一些较为重要的部分，还有非常多的细枝末节、研究进展无法在有限的篇幅内完整讨论。</p><p>从 Go 诞生之初，Go 团队就一直在对 GC 的表现进行实验与优化，但仍然有诸多未解决的问题，我们不妨对 GC 未来的改进拭目以待。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>【Why golang garbage-collector not implement Generational and Compact gc?】<a href="https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ</a></p><p>【写一个内存分配器】<a href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#more-3590" target="_blank" rel="noopener">http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#more-3590</a></p><p>【观察 GC】<a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></p><p>【煎鱼 Go debug】<a href="https://segmentfault.com/a/1190000020255157" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020255157</a></p><p>【煎鱼 go tool trace】<a href="https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/go-tool-trace" target="_blank" rel="noopener">https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/go-tool-trace</a></p><p>【trace 讲解】<a href="https://www.itcodemonkey.com/article/5419.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/5419.html</a></p><p>【An Introduction to go tool trace】<a href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner" target="_blank" rel="noopener">https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner</a></p><p>【http pprof 官方文档】<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/net/http/pprof/</a></p><p>【runtime pprof 官方文档】<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/runtime/pprof/</a></p><p>【trace 官方文档】<a href="https://golang.org/pkg/runtime/trace/" target="_blank" rel="noopener">https://golang.org/pkg/runtime/trace/</a></p><h1 id="推荐阅读-1"><a href="#推荐阅读-1" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h1><p>【Why golang garbage-collector not implement Generational and Compact gc?】<a href="https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ</a></p><p>【写一个内存分配器】<a href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#more-3590" target="_blank" rel="noopener">http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/#more-3590</a></p><p>【观察 GC】<a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></p><p>【煎鱼 Go debug】<a href="https://segmentfault.com/a/1190000020255157" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020255157</a></p><p>【煎鱼 go tool trace】<a href="https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/go-tool-trace" target="_blank" rel="noopener">https://eddycjy.gitbook.io/golang/di-9-ke-gong-ju/go-tool-trace</a></p><p>【trace 讲解】<a href="https://www.itcodemonkey.com/article/5419.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/5419.html</a></p><p>【An Introduction to go tool trace】<a href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner" target="_blank" rel="noopener">https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner</a></p><p>【http pprof 官方文档】<a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/net/http/pprof/</a></p><p>【runtime pprof 官方文档】<a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">https://golang.org/pkg/runtime/pprof/</a></p><p>【trace 官方文档】<a href="https://golang.org/pkg/runtime/trace/" target="_blank" rel="noopener">https://golang.org/pkg/runtime/trace/</a></p><hr>]]></content>
    
    <summary type="html">
    
      Go GC 20问
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang自动生成对应MySQL数据库表的struct定义</title>
    <link href="https://cloudsjhan.github.io/2020/01/01/golang%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AF%B9%E5%BA%94MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84struct%E5%AE%9A%E4%B9%89/"/>
    <id>https://cloudsjhan.github.io/2020/01/01/golang自动生成对应MySQL数据库表的struct定义/</id>
    <published>2020-01-01T14:37:14.000Z</published>
    <updated>2020-01-01T15:16:15.693Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>在golang的开发过程中，当我们使用orm的时候，常常需要将数据库表对应到golang的一个struct，这些struct会携带orm对应的<code>tag</code>,就像下面的struct定义一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InsInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Connections  <span class="keyword">string</span>    <span class="string">`gorm:"column:connections"`</span></span><br><span class="line">CPU          <span class="keyword">int</span>       <span class="string">`gorm:"column:cpu"`</span></span><br><span class="line">CreateTime   time.Time <span class="string">`gorm:"column:create_time"`</span></span><br><span class="line">Env          <span class="keyword">int</span>       <span class="string">`gorm:"column:env"`</span></span><br><span class="line">ID           <span class="keyword">int64</span>     <span class="string">`gorm:"column:id;primary_key"`</span></span><br><span class="line">IP           <span class="keyword">string</span>    <span class="string">`gorm:"column:ip"`</span></span><br><span class="line">Organization <span class="keyword">string</span>    <span class="string">`gorm:"column:organization"`</span></span><br><span class="line">Pass         <span class="keyword">string</span>    <span class="string">`gorm:"column:pass"`</span></span><br><span class="line">Port         <span class="keyword">string</span>    <span class="string">`gorm:"column:port"`</span></span><br><span class="line">RegionId     <span class="keyword">string</span>    <span class="string">`gorm:"column:regionid"`</span></span><br><span class="line">ServerIP     <span class="keyword">string</span>    <span class="string">`gorm:"column:server_ip"`</span></span><br><span class="line">Status       <span class="keyword">int</span>       <span class="string">`gorm:"column:status"`</span></span><br><span class="line">Type         <span class="keyword">string</span>    <span class="string">`gorm:"column:type"`</span></span><br><span class="line">UUID         <span class="keyword">string</span>    <span class="string">`gorm:"column:uuid"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是gorm对应的数据库表的struct映射，即使数据表的字段不多，如果是手动写起来也是一些重复性的工作。像MySQL这种关系型数据库，我们一般会用orm去操作数据库，于是就想，mysql的数据表能不能来自动生成golang 的struct定义。我们知道mysql有个自带的数据库<code>information_schema</code>，有一张表<code>COLUMNS</code>，它的字段包含数据库名、表名、字段名、字段类型等，我们可以利用这个表的数据，把对应的表的字段信息读取出来，然后再根据golang的语法规则，生成对应的struct。<br>    调研了一下目前有一些命令行工具像 db2struct等，感觉用起来比较繁琐，在想能不能提供一个开箱即用的环境，提供web界面，我们只需要填写数据库信息，就可以一键生成对应的ORM的struct，于是就诞生了这个项目：<a href="https://github.com/hantmac/fuckdb" target="_blank" rel="noopener">https://github.com/hantmac/fuckdb</a></p><p>如果你的数据库在本地，那么只需要执行 <code>docker-compose up -d</code>，访问<code>localhost:8088</code>，你就会得到下面的界面：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9w1ru6tl4j31wb0u0aft.jpg" alt=""></p><p>如果你的数据库在内网服务器上，你需要先修改后端接口的ip:port,然后重新build Docker镜像，push到自己的镜像仓库，然后修改docker-compose.yaml，再执行<code>docker-compose up -d</code>。修改的位置是：<code>fuckdb/frontend/src/config/index.js</code>.</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gahgtkjlraj31000hkada.jpg" alt=""></p><p>只需要填入数据库相关信息，以及你想得到的golang代码的<code>package name</code>、<code>struct name</code>,然后点击生成，就可以得到gorm对应的结构体映射：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9w531osobj31u90u0jzq.jpg" alt=""></p><p>你只需要拷贝你的代码到项目中即可。我们都知道golang的struct的tag有很多功能，这里也提供了很多tag的可选项，比如<code>json</code>,<code>xml</code>等，后面会曾加更多的tag可选项支持。</p><p><img src="http://static.vue2.net/db.gif" alt=""></p><p>上面的GIF展示了增加了缓存功能的版本，记忆你之前填写过的数据库信息，省去了大量重复的操作，你不用再填写繁琐的数据库名，表名，等等，只需一键，就可以得到对应的代码，是不是很方便啊。ps:目前数据库信息没有做加密，所以不方便放到公网上使用，仅限于内网，后面会进行相应的开发支持。目前这个工具在我们组内已经开始使用，反馈比较好，节省了很多重复的工作，尤其是在开发的时候用到同一个库的多张表，很快就可以完成数据库表-&gt;strcut的映射。</p><p>欢迎试用&amp;反馈&amp;Contribute。代码地址：<a href="https://github.com/hantmac/fuckdb" target="_blank" rel="noopener">https://github.com/hantmac/fuckdb</a></p><hr>]]></content>
    
    <summary type="html">
    
      golang自动生成对应MySQL数据库表的struct定义
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>viper配置详解</title>
    <link href="https://cloudsjhan.github.io/2019/12/23/viper%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cloudsjhan.github.io/2019/12/23/viper配置详解/</id>
    <published>2019-12-23T02:31:52.000Z</published>
    <updated>2019-12-23T02:33:51.501Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h1 id="viper-读取配置文件"><a href="#viper-读取配置文件" class="headerlink" title="viper 读取配置文件"></a>viper 读取配置文件</h1><blockquote><p>viper</p><p>项目地址 ：github.com/spf13/viper</p></blockquote><h2 id="viper-是什么"><a href="#viper-是什么" class="headerlink" title="viper 是什么"></a>viper 是什么</h2><ul><li>go 开发工具，主要是用于处理各种格式的配置文件，简化程序配置的读取问题</li><li>viper 支持：<ul><li>设置默认配置</li><li>支持读取 JSON TOML YAML HCL 和 Java 属性配置文件</li><li>监听配置文件变化，实时读取读取配置文件内容</li><li>读取环境变量值</li><li>读取远程配置系统 (etcd Consul) 和监控配置变化</li><li>读取命令 Flag 值</li><li>读取 buffer 值</li><li>读取确切值</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/fsnotify/fsnotify</span><br><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h2 id="viper-的基本用法"><a href="#viper-的基本用法" class="headerlink" title="viper 的基本用法"></a>viper 的基本用法</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>json 配置文件 (config.json)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"port"</span>: 10666,</span><br><span class="line"><span class="string">"mysql"</span>: &#123;</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"(127.0.0.1:3306)/biezhi"</span>,</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">  <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"redis"</span>: [<span class="string">"127.0.0.1:6377"</span>, <span class="string">"127.0.0.1:6378"</span>, <span class="string">"127.0.0.1:6379"</span>],</span><br><span class="line"><span class="string">"smtp"</span>: &#123;</span><br><span class="line">  <span class="string">"enable"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"addr"</span>: <span class="string">"mail_addr"</span>,</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"mail_user"</span>,</span><br><span class="line">  <span class="string">"password"</span>: <span class="string">"mail_password"</span>,</span><br><span class="line">  <span class="string">"to"</span>: [<span class="string">"xxx@gmail.com"</span>, <span class="string">"xxx@163.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>yaml 配置文件 (config1.yaml)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">port: 10666</span><br><span class="line">mysql:</span><br><span class="line">url: <span class="string">"(127.0.0.1:3306)/biezhi"</span></span><br><span class="line">username: root</span><br><span class="line">password: 123456</span><br><span class="line">redis:</span><br><span class="line">- 127.0.0.1:6377</span><br><span class="line">- 127.0.0.1:6378</span><br><span class="line">- 127.0.0.1:6379</span><br><span class="line">smtp:</span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">addr: mail_addr</span><br><span class="line">username: mail_user</span><br><span class="line">password: mail_password</span><br><span class="line">to: </span><br><span class="line">- xxx@gmail.com</span><br><span class="line">- xxx@163.com</span><br></pre></td></tr></table></figure></li></ul><h3 id="本地配置文件读取方式"><a href="#本地配置文件读取方式" class="headerlink" title="本地配置文件读取方式"></a>本地配置文件读取方式</h3><ul><li>将上述两个配置文件和下面的 main.go 放在统一目录之下，即可实现读取配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    // viper.SetConfigName(<span class="string">"config1"</span>) // 读取yaml配置文件</span><br><span class="line">    viper.SetConfigName(<span class="string">"config"</span>) // 读取json配置文件</span><br><span class="line">    //viper.AddConfigPath(<span class="string">"/etc/appname/"</span>)   //设置配置文件的搜索目录</span><br><span class="line">    //viper.AddConfigPath(<span class="string">"<span class="variable">$HOME</span>/.appname"</span>)  // 设置配置文件的搜索目录</span><br><span class="line">    viper.AddConfigPath(<span class="string">"."</span>)      // 设置配置文件和可执行二进制文件在用一个目录</span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != nil &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">            // Config file not found; ignore error <span class="keyword">if</span> desired</span><br><span class="line">            log.Println(<span class="string">"no such config file"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // Config file was found but another error was produced</span><br><span class="line">            log.Println(<span class="string">"read config error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Fatal(err) // 读取配置文件失败致命错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的port"</span>, viper.GetInt(<span class="string">"port"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.url"</span>, viper.GetString(`mysql.url`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.username"</span>, viper.GetString(`mysql.username`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.password"</span>, viper.GetString(`mysql.password`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的redis"</span>, viper.GetStringSlice(<span class="string">"redis"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的smtp"</span>, viper.GetStringMap(<span class="string">"smtp"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码详解<ul><li>viper.SetConfigName (“config”) 设置配置文件名为 config, 不需要配置文件扩展名，配置文件的类型 viper 会自动根据扩展名自动匹配.</li><li>viper.AddConfigPath (“.”) 设置配置文件搜索的目录，. 表示和当前编译好的二进制文件在同一个目录。可以添加多个配置文件目录，如在第一个目录中找到就不不继续到其他目录中查找.</li><li>viper.ReadInConfig () 加载配置文件内容</li><li>viper.Get*** 获取配置文件中配置项的信息</li></ul></li></ul><h3 id="viper-的一些高级用法"><a href="#viper-的一些高级用法" class="headerlink" title="viper 的一些高级用法"></a>viper 的一些高级用法</h3><ul><li>viper 设置配置项的默认值</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">set</span> default config</span><br><span class="line">viper.SetDefault(<span class="string">"ContentDir"</span>, <span class="string">"content"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"LayoutDir"</span>, <span class="string">"layouts"</span>)</span><br><span class="line">viper.SetDefault(<span class="string">"Taxonomies"</span>, map[string]string&#123;<span class="string">"tag"</span>: <span class="string">"tags"</span>, <span class="string">"category"</span>: <span class="string">"categories"</span>&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(viper.GetBool(<span class="string">"ContentDir"</span>))</span><br><span class="line">fmt.Println(viper.GetString(<span class="string">"LayoutDir"</span>))</span><br><span class="line">fmt.Println(viper.GetStringMapString(<span class="string">"Taxonomies"</span>))</span><br></pre></td></tr></table></figure><ul><li>监听和重新读取配置文件<ul><li>import “github.com/fsnotify/fsnotify”</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(func(e fsnotify.Event) &#123;</span><br><span class="line">    //viper配置发生变化了 执行响应的操作</span><br><span class="line">    fmt.Println(<span class="string">"Config file changed:"</span>, e.Name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="从环境变量变量中读取"><a href="#从环境变量变量中读取" class="headerlink" title="从环境变量变量中读取"></a>从环境变量变量中读取</h3><ul><li>主要用到的是下面三个个方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AutomaticEnv has Viper check ENV variables <span class="keyword">for</span> all.</span><br><span class="line">// keys <span class="built_in">set</span> <span class="keyword">in</span> config, default &amp; flags</span><br><span class="line">AutomaticEnv()</span><br><span class="line"></span><br><span class="line">// BindEnv binds a Viper key to a ENV variable.</span><br><span class="line">// ENV variables are <span class="keyword">case</span> sensitive.</span><br><span class="line">// If only a key is provided, it will use the env key matching the key, uppercased.</span><br><span class="line">// EnvPrefix will be used when <span class="built_in">set</span> when env name is not provided.</span><br><span class="line">BindEnv(string…) : error</span><br><span class="line"></span><br><span class="line">// SetEnvPrefix defines a prefix that ENVIRONMENT variables will use.</span><br><span class="line">// E.g. <span class="keyword">if</span> your prefix is <span class="string">"spf"</span>, the env registry will look <span class="keyword">for</span> env</span><br><span class="line">// variables that start with <span class="string">"SPF_"</span>.</span><br><span class="line">SetEnvPrefix(string)</span><br></pre></td></tr></table></figure><ul><li>简单的使用 demo 如下所示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main </span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    prefix := <span class="string">"PROJECTNAME"</span></span><br><span class="line">    envs := map[string]string&#123;</span><br><span class="line">        <span class="string">"LOG_LEVEL"</span>:      <span class="string">"INFO"</span>,</span><br><span class="line">        <span class="string">"MODE"</span>:           <span class="string">"DEV"</span>,</span><br><span class="line">        <span class="string">"MYSQL_USERNAME"</span>: <span class="string">"root"</span>,</span><br><span class="line">        <span class="string">"MYSQL_PASSWORD"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := range envs &#123;</span><br><span class="line">        os.Setenv(fmt.Sprintf(<span class="string">"%s_%s"</span>, prefix, k), v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v := viper.New()</span><br><span class="line">    v.SetEnvPrefix(prefix)</span><br><span class="line">    v.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, _ := range envs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"env `%s` = %s\n"</span>, k, v.GetString(k))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取远程配置"><a href="#获取远程配置" class="headerlink" title="获取远程配置"></a>获取远程配置</h3><ul><li><p>使用 github.com/spf13/viper/remote 包 import _ “github.com/spf13/viper/remote”</p></li><li><p>Viper 可以从例如 etcd、Consul 的远程 Key/Value 存储系统的一个路径上，读取一个配置字符串（JSON, TOML, YAML 或 HCL 格式）. 这些值优先于默认值，但会被从磁盘文件、命令行 flag、环境变量的配置所覆盖.</p></li><li><p>本人对 consul 比较熟悉，用它来做例子</p><ul><li><p>首先在本地启动 consul</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure></li><li><p>并在 consul 上设置名为 config 的 json 配置文件</p><p><a href="https://cdn.learnku.com/uploads/images/201909/12/48679/ILyDXtfCXG.png!large" target="_blank" rel="noopener"><img src="https://cdn.learnku.com/uploads/images/201909/12/48679/ILyDXtfCXG.png!large" alt="viper"></a></p></li></ul></li></ul><ul><li><p>代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/spf13/viper"</span></span><br><span class="line">    _ <span class="string">"github.com/spf13/viper/remote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    v := viper.New()</span><br><span class="line">    v.AddRemoteProvider(<span class="string">"consul"</span>, <span class="string">"localhost:8500"</span>, <span class="string">"config"</span>)</span><br><span class="line">    v.SetConfigType(<span class="string">"json"</span>) // Need to explicitly <span class="built_in">set</span> this to json</span><br><span class="line">    <span class="keyword">if</span> err := v.ReadRemoteConfig(); err != nil &#123;</span><br><span class="line">          log.Println(err)</span><br><span class="line">          <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的port"</span>, v.GetInt(<span class="string">"port"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.url"</span>, v.GetString(`mysql.url`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.username"</span>, v.GetString(`mysql.username`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.password"</span>, v.GetString(`mysql.password`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的redis"</span>, v.GetStringSlice(<span class="string">"redis"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的smtp"</span>, v.GetStringMap(<span class="string">"smtp"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="从-io-Reader-中读取配置信息"><a href="#从-io-Reader-中读取配置信息" class="headerlink" title="从 io.Reader 中读取配置信息"></a>从 io.Reader 中读取配置信息</h3><ul><li>首先给大家来段例子</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/spf13/viper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    v := viper.New()</span><br><span class="line">    v.SetConfigType(<span class="string">"json"</span>) // 设置配置文件的类型</span><br><span class="line"></span><br><span class="line">    // 配置文件内容</span><br><span class="line">    var jsonExample = []byte(`</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"port"</span>: 10666,</span><br><span class="line">  <span class="string">"mysql"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"(127.0.0.1:3306)/biezhi"</span>,</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"redis"</span>: [<span class="string">"127.0.0.1:6377"</span>, <span class="string">"127.0.0.1:6378"</span>, <span class="string">"127.0.0.1:6379"</span>],</span><br><span class="line">  <span class="string">"smtp"</span>: &#123;</span><br><span class="line">    <span class="string">"enable"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"addr"</span>: <span class="string">"mail_addr"</span>,</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">"mail_user"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"mail_password"</span>,</span><br><span class="line">    <span class="string">"to"</span>: [<span class="string">"xxx@gmail.com"</span>, <span class="string">"xxx@163.com"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`)</span><br><span class="line">    //创建io.Reader</span><br><span class="line">    v.ReadConfig(bytes.NewBuffer(jsonExample))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的port"</span>, v.GetInt(<span class="string">"port"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.url"</span>, v.GetString(`mysql.url`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.username"</span>, v.GetString(`mysql.username`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的mysql.password"</span>, v.GetString(`mysql.password`))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的redis"</span>, v.GetStringSlice(<span class="string">"redis"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"获取配置文件的smtp"</span>, v.GetStringMap(<span class="string">"smtp"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个功能日常的使用情况较少，例如这样的一个情景：<ul><li>配置文件放在 oss 上或者 github 某个私有仓库上，viper 并没有提供直接的接口去获取，这样我们可以基于第三方托管平台的 sdk 写一套获取配置文件 bytes 的工具，将结果放入 io.Reader 中，再进行配置文件的解析。</li></ul></li><li>上述流程感觉好像比较鸡肋，复杂了整个流程：我既然可以通过第三方的 sdk 直接拿到 bytes，为何不自己直接进行解析呢？而要借助 viper 来解析。可能有人会说，配置文件如果格式不同呢？确实，viper 的出现就是为了针对多种格式的配置文件。但是在正式的项目中，配置文件的格式一般不会变，可以自己写一套解析的工具，也就没有使用 viper 的需求了。而且对于某一种特定格式的配置文件（JSON，YAML…），Golang 已经有足够强大的包来进行解析了。</li><li>但是不得不承认 viper 的实现确实是很流弊的。在一般的快速开发过程中，直接使用 viper 确实可以帮助我们省去很多的麻烦，让我们集中精力针对于业务逻辑的实现。</li><li>个人觉得可以根据实际需求在 viper 再进行一层封装，接入一些常用的第三方平台的 sdk（github，aliyun oss…）, 这样即可以读取本地配置文件，也可以读取远端的配置文件，可以通过命令行参数来实现 dev 模式和 deploy 模式的切换。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      golang配置文件viper详解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>使用swaggo自动生成API文档</title>
    <link href="https://cloudsjhan.github.io/2019/12/10/%E4%BD%BF%E7%94%A8swaggo%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/"/>
    <id>https://cloudsjhan.github.io/2019/12/10/使用swaggo自动生成API文档/</id>
    <published>2019-12-10T07:16:23.000Z</published>
    <updated>2019-12-10T07:19:03.588Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>本文转载自： <a href="https://razeencheng.com/post/go-swagger.html" target="_blank" rel="noopener">https://razeencheng.com/post/go-swagger.html</a></p><p>相信很多程序猿和我一样不喜欢写API文档。写代码多舒服，写文档不仅要花费大量的时间，有时候还不能做到面面具全。但API文档是必不可少的，相信其重要性就不用我说了，一份含糊的文档甚至能让前后端人员打起来。 而今天这篇博客介绍的swaggo就是让你只需要专注于代码就可以生成完美API文档的工具。废话说的有点多，我们直接看文章。</p><p>大概最后文档效果是这样的：</p><h3 id="关于Swaggo"><a href="#关于Swaggo" class="headerlink" title="关于Swaggo"></a>关于Swaggo</h3><p>或许你使用过<a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a>, 而 swaggo就是代替了你手动编写yaml的部分。只要通过一个命令就可以将注释转换成文档，这让我们可以更加专注于代码。</p><p>目前swaggo主要实现了swagger 2.0 的以下部分功能：</p><ul><li><p>基本结构（Basic Structure）</p></li><li><p>API 地址与基本路径（API Host and Base Path）</p></li><li><p>路径与操作 （Paths and Operations）</p></li><li><p>参数描述（Describing Parameters）</p></li><li><p>请求参数描述（Describing Request Body）</p></li><li><p>返回描述（Describing Responses）</p></li><li><p>MIME 类型（MIME Types）</p></li><li><p>认证（Authentication）</p><ul><li>Basic Authentication</li><li>API Keys</li></ul></li><li><p>添加实例（Adding Examples）</p></li><li><p>文件上传（File Upload）</p></li><li><p>枚举（Enums）</p></li><li><p>按标签分组（Grouping Operations With Tags）</p></li><li><p>扩展（Swagger Extensions）</p></li></ul><p><em>下文内容均以gin-swaggo为例</em></p><p><em><a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin" target="_blank" rel="noopener">这里是demo地址</a></em></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="安装swag-cli-及下载相关包"><a href="#安装swag-cli-及下载相关包" class="headerlink" title="安装swag cli 及下载相关包"></a>安装<code>swag cli</code> 及下载相关包</h4><p>要使用swaggo,首先需要安装<code>swag cli</code>。</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/swaggo/swag/cmd/swag</span><br></pre></td></tr></table></figure><p>然后我们还需要两个包。</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># gin-swagger 中间件</span><br><span class="line">go get github.com/swaggo/gin-swagger</span><br><span class="line"># swagger 内置文件</span><br><span class="line">go get github.com/swaggo/gin-swagger/swaggerFiles</span><br></pre></td></tr></table></figure><h4 id="在main-go内添加注释"><a href="#在main-go内添加注释" class="headerlink" title="在main.go内添加注释"></a>在<code>main.go</code>内添加注释</h4><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// @title Swagger Example API</span><br><span class="line">// @version 1.0</span><br><span class="line">// @description This is a sample server celler server.</span><br><span class="line">// @termsOfService https://razeen.me</span><br><span class="line"></span><br><span class="line">// @contact.name Razeen</span><br><span class="line">// @contact.url https://razeen.me</span><br><span class="line">// @contact.email me@razeen.me</span><br><span class="line"></span><br><span class="line">// @license.name Apache 2.0</span><br><span class="line">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><br><span class="line"></span><br><span class="line">// @host 127.0.0.1:8080</span><br><span class="line">// @BasePath /api/v1</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">r := gin.Default()</span><br><span class="line">    store := sessions.NewCookieStore([]byte(&quot;secret&quot;))</span><br><span class="line">r.Use(sessions.Sessions(&quot;mysession&quot;, store))</span><br><span class="line"></span><br><span class="line">r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line">v1 := r.Group(&quot;/api/v1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">v1.GET(&quot;/hello&quot;, HandleHello)</span><br><span class="line">v1.POST(&quot;/login&quot;, HandleLogin)</span><br><span class="line">v1Auth := r.Use(HandleAuth)</span><br><span class="line">&#123;</span><br><span class="line">v1Auth.POST(&quot;/upload&quot;, HandleUpload)</span><br><span class="line">v1Auth.GET(&quot;/list&quot;, HandleList)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.Run(&quot;:8080&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们需要导入</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br></pre></td></tr></table></figure><p>同时，添加注释。其中：</p><ul><li><code>titile</code>: 文档标题</li><li><code>version</code>: 版本</li><li><code>description,termsOfService,contact ...</code> 这些都是一些声明，可不写。</li><li><code>license.name</code> 额，这个是必须的。</li><li><code>host</code>,<code>BasePath</code>: 如果你想直接swagger调试API，这两项需要填写正确。前者为服务文档的端口，ip。后者为基础路径，像我这里就是“/api/v1”。</li><li>在原文档中还有<code>securityDefinitions.basic</code>,<code>securityDefinitions.apikey</code>等，这些都是用来做认证的，我这里暂不展开。</li></ul><p>到这里，我们在<code>mian.go</code>同目录下执行<code>swag init</code>就可以自动生成文档，如下：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ swag init</span><br><span class="line">2019/01/12 21:29:14 Generate swagger docs....</span><br><span class="line">2019/01/12 21:29:14 Generate general API Info</span><br><span class="line">2019/01/12 21:29:14 create docs.go at  docs/docs.go</span><br></pre></td></tr></table></figure><p>然后我们导入这个自动生成的<code>docs</code>包，运行：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><span class="line"></span><br><span class="line">_ &quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// @title Swagger Example API</span><br><span class="line">// @version 1.0</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ go build</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ./swaggo-gin</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:   export GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /api/v1/hello             --&gt; main.HandleHello (3 handlers)</span><br><span class="line">[GIN-debug] POST   /api/v1/login             --&gt; main.HandleLogin (3 handlers)</span><br><span class="line">[GIN-debug] POST   /upload                   --&gt; main.HandleUpload (4 handlers)</span><br><span class="line">[GIN-debug] GET    /list                     --&gt; main.HandleList (4 handlers)</span><br><span class="line">[GIN-debug] GET    /swagger/*any             --&gt; github.com/swaggo/gin-swagger.WrapHandler.func1 (4 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure><p>浏览器打开<a href="http://127.0.0.1:8080/swagger/index.html" target="_blank" rel="noopener">http://127.0.0.1:8080/swagger/index.html</a>, 我们可以看到如下文档标题已经生成。</p><p><img src="https://st.razeen.cn/bcj/201901/jietu20190112-213823.png" alt="img"></p><h4 id="在Handle函数上添加注释"><a href="#在Handle函数上添加注释" class="headerlink" title="在Handle函数上添加注释"></a>在Handle函数上添加注释</h4><p>接下来，我们需要在每个路由处理函数上加上注释，如：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// @Summary 测试SayHello</span><br><span class="line">// @Description 向你说Hello</span><br><span class="line">// @Tags 测试</span><br><span class="line">// @Accept mpfd</span><br><span class="line">// @Produce json</span><br><span class="line">// @Param who query string true &quot;人名&quot;</span><br><span class="line">// @Success 200 &#123;string&#125; json &quot;&#123;&quot;msg&quot;: &quot;hello Razeen&quot;&#125;&quot;</span><br><span class="line">// @Failure 400 &#123;string&#125; json &quot;&#123;&quot;msg&quot;: &quot;who are you&quot;&#125;&quot;</span><br><span class="line">// @Router /hello [get]</span><br><span class="line">func HandleHello(c *gin.Context) &#123;</span><br><span class="line">who := c.Query(&quot;who&quot;)</span><br><span class="line"></span><br><span class="line">if who == &quot;&quot; &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;who are u?&quot;&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;hello &quot; + who&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次<code>swag init</code>, 运行一下。</p><p><img src="https://st.razeen.cn/bcj/201901/jietu20190112-220025.png" alt="img"></p><p>此时，该API的相关描述已经生成了，我们点击<code>Try it out</code>还可以直接测试该API。</p><p><img src="https://st.razeen.cn/bcj/201901/jietu20190112-220515.png" alt="img"></p><p>是不是很好用，当然这并没有结束，这些注释字段，我们一个个解释。</p><p><img src="https://st.razeen.cn/bcj/201901/jietu20190112-223012.png" alt="img"></p><p>这些注释对应出现在API文档的位置，我在上图中已经标出，这里我们主要详细说说下面参数：</p><h5 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h5><p>Tags 是用来给API分组的。</p><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p>接收的参数类型，支持表单(<code>mpfd</code>) 和 JSON(<code>json</code>)</p><h5 id="Produce"><a href="#Produce" class="headerlink" title="Produce"></a>Produce</h5><p>返回的数据结构，一般都是<code>json</code>, 其他支持如下表：</p><table><thead><tr><th style="text-align:left">Mime Type</th><th style="text-align:left">声明</th></tr></thead><tbody><tr><td style="text-align:left">application/json</td><td style="text-align:left">json</td></tr><tr><td style="text-align:left">text/xml</td><td style="text-align:left">xml</td></tr><tr><td style="text-align:left">text/plain</td><td style="text-align:left">plain</td></tr><tr><td style="text-align:left">html</td><td style="text-align:left">html</td></tr><tr><td style="text-align:left">multipart/form-data</td><td style="text-align:left">mpfd</td></tr><tr><td style="text-align:left">application/x-www-form-urlencoded</td><td style="text-align:left">x-www-form-urlencoded</td></tr><tr><td style="text-align:left">application/vnd.api+json</td><td style="text-align:left">json-api</td></tr><tr><td style="text-align:left">application/x-json-stream</td><td style="text-align:left">json-stream</td></tr><tr><td style="text-align:left">application/octet-stream</td><td style="text-align:left">octet-stream</td></tr><tr><td style="text-align:left">image/png</td><td style="text-align:left">png</td></tr><tr><td style="text-align:left">image/jpeg</td><td style="text-align:left">jpeg</td></tr><tr><td style="text-align:left">image/gif</td><td style="text-align:left">gif</td></tr></tbody></table><h5 id="Param"><a href="#Param" class="headerlink" title="Param"></a>Param</h5><p>参数，从前往后分别是：</p><blockquote><p>@Param <code>1.参数名</code> <code>2.参数类型</code> <code>3.参数数据类型</code> <code>4.是否必须</code> <code>5.参数描述</code> <code>6.其他属性</code></p></blockquote><ul><li><p>1.参数名</p><p>参数名就是我们解释参数的名字。</p></li><li><p>2.参数类型</p><p>参数类型主要有四种：</p><ul><li><p><code>path</code> 该类型参数直接拼接在URL中，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleGetFile</code>：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param id path integer true &quot;文件ID&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>query</code> 该类型参数一般是组合在URL中的，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleHello</code></p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param who query string true &quot;人名&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>formData</code> 该类型参数一般是<code>POST,PUT</code>方法所用，如<a href="https://github.com/razeencheng/demo-go/blob/master/swaggo-gin/handle.go" target="_blank" rel="noopener">Demo</a>中<code>HandleLogin</code></p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param user formData string true &quot;用户名&quot; default(admin)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>body</code> 当<code>Accept</code>是<code>JSON</code>格式时，我们使用该字段指定接收的JSON类型</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param param body main.JSONParams true &quot;需要上传的JSON&quot;</span><br></pre></td></tr></table></figure></li><li><p>3.参数数据类型</p><p>数据类型主要支持一下几种：</p><ul><li>string (string)</li><li>integer (int, uint, uint32, uint64)</li><li>number (float32)</li><li>boolean (bool)</li></ul><p>注意，如果你是上传文件可以使用<code>file</code>, 但参数类型一定是<code>formData</code>, 如下：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param file formData file true &quot;文件&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.是否是必须</p><p>表明该参数是否是必须需要的，必须的在文档中会黑体标出，测试时必须填写。</p></li><li><p>5.参数描述</p><p>就是参数的一些说明</p></li><li><p>6.其他属性</p><p>除了上面这些属性外，我们还可以为该参数填写一些额外的属性，如枚举，默认值，值范围等。如下：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">枚举</span><br><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C)</span><br><span class="line">// @Param enumint query int false &quot;int enums&quot; Enums(1, 2, 3)</span><br><span class="line">// @Param enumnumber query number false &quot;int enums&quot; Enums(1.1, 1.2, 1.3)</span><br><span class="line"></span><br><span class="line">值添加范围</span><br><span class="line">// @Param string query string false &quot;string valid&quot; minlength(5) maxlength(10)</span><br><span class="line">// @Param int query int false &quot;int valid&quot; mininum(1) maxinum(10)</span><br><span class="line"></span><br><span class="line">设置默认值</span><br><span class="line">// @Param default query string false &quot;string default&quot; default(A)</span><br></pre></td></tr></table></figure><p>而且这些参数是可以组合使用的，如：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Param enumstring query string false &quot;string enums&quot; Enums(A, B, C) default(A)</span><br></pre></td></tr></table></figure></li></ul><h5 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h5><p>指定成功响应的数据。格式为：</p><blockquote><p>// @Success <code>1.HTTP响应码</code> <code>{2.响应参数类型}</code> <code>3.响应数据类型</code> <code>4.其他描述</code></p></blockquote><ul><li><p>1.HTTP响应码</p><p>也就是200，400，500那些。</p></li><li><p>2.响应参数类型 / 3.响应数据类型</p><p>返回的数据类型，可以是自定义类型，可以是json。</p><ul><li>自定义类型</li></ul><p>在平常的使用中，我都会返回一些指定的模型序列化JSON的数据，这时，就可以这么写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;object&#125; main.File</span><br></pre></td></tr></table></figure><p>其中，模型直接用<code>包名.模型</code>即可。你会说，假如我返回模型数组怎么办？这时你可以这么写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;anrry&#125; main.File</span><br></pre></td></tr></table></figure><ul><li>json</li></ul><p>将如你只是返回其他的json数据可如下写：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @Success 200 &#123;string&#125; json &quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>4.其他描述</p><p>可以添加一些说明。</p></li></ul><h5 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h5><p> 同Success。</p><h5 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h5><p> 指定路由与HTTP方法。格式为：</p><blockquote><p>// @Router <code>/path/to/handle</code> [<code>HTTP方法</code>]</p></blockquote><p> 不用加基础路径哦。</p><h3 id="生成文档与测试"><a href="#生成文档与测试" class="headerlink" title="生成文档与测试"></a>生成文档与测试</h3><p>其实上面已经穿插的介绍了。</p><p>在<code>main.go</code>下运行<code>swag init</code>即可生成和更新文档。</p><p>点击文档中的<code>Try it out</code>即可测试。 如果部分API需要登陆，可以Try登陆接口即可。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>看到这里，基本可以使用了。但文档一般只是我们测试的时候需要，当我的产品上线后，接口文档是不应该给用户的，而且带有接口文档的包也会大很多（swaggo是直接build到二进制里的）。</p><p>想要处理这种情况，我们可以在编译的时候优化一下，如利用<code>build tag</code>来控制是否编译文档。</p><p>在<code>main.go</code>声明<code>swagHandler</code>,并在该参数不为空时才加入路由：</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">var swagHandler gin.HandlerFunc</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    if swagHandler != nil &#123;</span><br><span class="line">r.GET(&quot;/swagger/*any&quot;, swagHandler)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时,我们将该参数在另外加了<code>build tag</code>的包中初始化。</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// +build doc</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">_ &quot;github.com/razeencheng/demo-go/swaggo-gin/docs&quot;</span><br><span class="line"></span><br><span class="line">ginSwagger &quot;github.com/swaggo/gin-swagger&quot;</span><br><span class="line">&quot;github.com/swaggo/gin-swagger/swaggerFiles&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">swagHandler = ginSwagger.WrapHandler(swaggerFiles.Handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以使用<code>go build -tags &quot;doc&quot;</code>来打包带文档的包，直接<code>go build</code>来打包不带文档的包。</p><p>你会发现，即使我这么小的Demo,编译后的大小也要相差19M !</p><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  swaggo-gin git:(master) ✗ go build</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    15M Jan 13 00:23 swaggo-gin</span><br><span class="line">➜  swaggo-gin git:(master) ✗ go build -tags &quot;doc&quot;</span><br><span class="line">➜  swaggo-gin git:(master) ✗ ll swaggo-gin</span><br><span class="line">-rwxr-xr-x  1 xxx  staff    34M Jan 13 00:24 swaggo-gin</span><br></pre></td></tr></table></figure><p>文章到这里也就结束了，完整的<a href="https://github.com/razeencheng/demo-go/tree/master/swaggo-gin" target="_blank" rel="noopener">Demo地址在这里</a>。</p><p>相关链接</p><ul><li><a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">Swaggo Github</a></li><li><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      使用swaggo自动生成API文档
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="swagger" scheme="https://cloudsjhan.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>golang开发效率神奇汇总</title>
    <link href="https://cloudsjhan.github.io/2019/12/06/golang%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%A5%9E%E5%A5%87%E6%B1%87%E6%80%BB/"/>
    <id>https://cloudsjhan.github.io/2019/12/06/golang开发效率神奇汇总/</id>
    <published>2019-12-06T09:46:58.000Z</published>
    <updated>2019-12-06T11:03:09.961Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>一. 开发工具<br>1)sql2go<br>用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。<br>例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。<br><a href="http://stming.cn/tool/sql2go.html" target="_blank" rel="noopener">http://stming.cn/tool/sql2go.html</a></p><p>2)toml2go<br>用于将编码后的 toml 文本转换问 golang 的 struct.<br><a href="https://xuri.me/toml-to-go/" target="_blank" rel="noopener">https://xuri.me/toml-to-go/</a></p><p>3)curl2go<br>用来将 curl 命令转化为具体的 golang 代码.<br><a href="https://mholt.github.io/curl-to-go/" target="_blank" rel="noopener">https://mholt.github.io/curl-to-go/</a></p><p>4)json2go<br>用于将 json 文本转换为 struct.<br><a href="https://mholt.github.io/json-to-go/" target="_blank" rel="noopener">https://mholt.github.io/json-to-go/</a></p><p>5)mysql 转 ES 工具<br><a href="http://www.ischoolbar.com/EsParser/" target="_blank" rel="noopener">http://www.ischoolbar.com/EsParser/</a></p><p>6)golang<br>模拟模板的工具，在支持泛型之前，可以考虑使用。<br><a href="https://github.com/cheekybits/genny" target="_blank" rel="noopener">https://github.com/cheekybits/genny</a></p><p>7)查看某一个库的依赖情况，类似于 go list 功能<br><a href="https://github.com/KyleBanks/depth" target="_blank" rel="noopener">https://github.com/KyleBanks/depth</a></p><p>8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。<br><a href="https://github.com/mholt/archiver" target="_blank" rel="noopener">https://github.com/mholt/archiver</a></p><p>9)go 内置命令<br>go list 可以查看某一个包的依赖关系.<br>go vet 可以检查代码不符合 golang 规范的地方。</p><p>10)热编译工具<br><a href="https://github.com/silenceper/gowatch" target="_blank" rel="noopener">https://github.com/silenceper/gowatch</a></p><p>11)revive<br>golang 代码质量检测工具<br><a href="https://github.com/mgechev/revive" target="_blank" rel="noopener">https://github.com/mgechev/revive</a></p><p>12)Go Callvis<br>golang 的代码调用链图工具<br><a href="https://github.com/TrueFurby/go-callvis" target="_blank" rel="noopener">https://github.com/TrueFurby/go-callvis</a></p><p>13)Realize<br>开发流程改进工具<br><a href="https://github.com/oxequa/realize" target="_blank" rel="noopener">https://github.com/oxequa/realize</a></p><p>14)Gotests<br>自动生成测试用例工具<br><a href="https://github.com/cweill/gotests" target="_blank" rel="noopener">https://github.com/cweill/gotests</a></p><p>二.调试工具<br>1)perf<br>代理工具，支持内存，cpu，堆栈查看，并支持火焰图.<br>perf 工具和 go-torch 工具，快捷定位程序问题.<br><a href="https://github.com/uber-archive/go-torch" target="_blank" rel="noopener">https://github.com/uber-archive/go-torch</a><br><a href="https://github.com/google/gops" target="_blank" rel="noopener">https://github.com/google/gops</a></p><p>2)dlv 远程调试<br>基于 goland+dlv 可以实现远程调式的能力.<br><a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">https://github.com/go-delve/delve</a><br>提供了对 golang 原生的支持，相比 gdb 调试，简单太多。</p><p>3)网络代理工具<br>goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.<br><a href="https://github.com/snail007/goproxy" target="_blank" rel="noopener">https://github.com/snail007/goproxy</a></p><p>4)抓包工具<br>go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.<br>基于这个工具，我们开发了 qapp 协议的抓包。<br><a href="https://github.com/40t/go-sniffer" target="_blank" rel="noopener">https://github.com/40t/go-sniffer</a></p><p>5)反向代理工具，快捷开放内网端口供外部使用。<br>ngrok 可以让内网服务外部调用<br><a href="https://ngrok.com/" target="_blank" rel="noopener">https://ngrok.com/</a><br><a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a></p><p>6)配置化生成证书<br>从根证书，到业务侧证书一键生成.<br><a href="https://github.com/cloudflare/cfssl" target="_blank" rel="noopener">https://github.com/cloudflare/cfssl</a></p><p>7)免费的证书获取工具<br>基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。<br><a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">https://github.com/Neilpang/acme.sh</a></p><p>8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。<br>vagrant常被拿来同 docker 相比，值得拥有。<br><a href="https://github.com/hashicorp/vagrant" target="_blank" rel="noopener">https://github.com/hashicorp/vagrant</a></p><p>9)轻量级容器调度工具<br>nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.<br><a href="https://github.com/hashicorp/nomad" target="_blank" rel="noopener">https://github.com/hashicorp/nomad</a></p><p>10)敏感信息和密钥管理工具<br><a href="https://github.com/hashicorp/vault" target="_blank" rel="noopener">https://github.com/hashicorp/vault</a></p><p>11)高度可配置化的 http 转发工具，基于 etcd 配置。<br><a href="https://github.com/gojek/weaver" target="_blank" rel="noopener">https://github.com/gojek/weaver</a></p><p>12)进程监控工具 supervisor<br><a href="https://www.jianshu.com/p/39b476e808d8" target="_blank" rel="noopener">https://www.jianshu.com/p/39b476e808d8</a></p><p>13)基于procFile进程管理工具. 相比 supervisor 更加简单。<br><a href="https://github.com/ddollar/foreman" target="_blank" rel="noopener">https://github.com/ddollar/foreman</a></p><p>14)基于 http，https，websocket 的调试代理工具，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.<br><a href="https://github.com/avwo/whistle" target="_blank" rel="noopener">https://github.com/avwo/whistle</a></p><p>15)分布式调度工具<br><a href="https://github.com/shunfei/cronsun/blob/master/README_ZH.md" target="_blank" rel="noopener">https://github.com/shunfei/cronsun/blob/master/README_ZH.md</a><br><a href="https://github.com/ouqiang/gocron" target="_blank" rel="noopener">https://github.com/ouqiang/gocron</a></p><p>16)自动化运维平台 Gaia<br><a href="https://github.com/gaia-pipeline/gaia" target="_blank" rel="noopener">https://github.com/gaia-pipeline/gaia</a></p><p>三. 网络工具</p><p>四. 常用网站<br>go 百科全书: <a href="https://awesome-go.com/" target="_blank" rel="noopener">https://awesome-go.com/</a></p><p>json 解析: <a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></p><p>出口 IP: <a href="https://ipinfo.io/" target="_blank" rel="noopener">https://ipinfo.io/</a></p><p>redis 命令: <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p><p>ES 命令首页:</p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>UrlEncode: <a href="http://tool.chinaz.com/Tools/urlencode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/urlencode.aspx</a></p><p>Base64: <a href="https://tool.oschina.net/encrypt?type=3" target="_blank" rel="noopener">https://tool.oschina.net/encrypt?type=3</a></p><p>Guid: <a href="https://www.guidgen.com/" target="_blank" rel="noopener">https://www.guidgen.com/</a></p><p>常用工具: <a href="http://www.ofmonkey.com/" target="_blank" rel="noopener">http://www.ofmonkey.com/</a></p><p>五. golang 常用库<br>日志<br><a href="https://github.com/Sirupsen/logrus" target="_blank" rel="noopener">https://github.com/Sirupsen/logrus</a><br><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">https://github.com/uber-go/zap</a></p><p>配置<br>兼容 json，toml，yaml，hcl 等格式的日志库.<br><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a></p><p>存储<br>mysql: <a href="https://github.com/go-xorm/xorm" target="_blank" rel="noopener">https://github.com/go-xorm/xorm</a><br>es: <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a><br>redis: <a href="https://github.com/gomodule/redigo" target="_blank" rel="noopener">https://github.com/gomodule/redigo</a><br>mongo: <a href="https://github.com/mongodb/mongo-go-driver" target="_blank" rel="noopener">https://github.com/mongodb/mongo-go-driver</a><br>kafka: <a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">https://github.com/Shopify/sarama</a></p><p>数据结构<br><a href="https://github.com/emirpasic/gods" target="_blank" rel="noopener">https://github.com/emirpasic/gods</a></p><p>命令行<br><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a></p><p>框架<br><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">https://github.com/grpc/grpc-go</a><br><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">https://github.com/gin-gonic/gin</a></p><p>并发<br><a href="https://github.com/Jeffail/tunny" target="_blank" rel="noopener">https://github.com/Jeffail/tunny</a><br><a href="https://github.com/benmanns/goworker" target="_blank" rel="noopener">https://github.com/benmanns/goworker</a><br>现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.<br><a href="https://github.com/rafaeldias/async" target="_blank" rel="noopener">https://github.com/rafaeldias/async</a></p><p>工具<br>定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.<br><a href="https://github.com/asaskevich/govalidator" target="_blank" rel="noopener">https://github.com/asaskevich/govalidator</a><br><a href="https://github.com/bytedance/go-tagexpr" target="_blank" rel="noopener">https://github.com/bytedance/go-tagexpr</a></p><p>protobuf 文件动态解析的接口，可以实现反射相关的能力。<br><a href="https://github.com/jhump/protoreflect" target="_blank" rel="noopener">https://github.com/jhump/protoreflect</a></p><p>表达式引擎工具<br><a href="https://github.com/Knetic/govaluate" target="_blank" rel="noopener">https://github.com/Knetic/govaluate</a><br><a href="https://github.com/google/cel-go" target="_blank" rel="noopener">https://github.com/google/cel-go</a></p><p>字符串处理<br><a href="https://github.com/huandu/xstrings" target="_blank" rel="noopener">https://github.com/huandu/xstrings</a></p><p>ratelimit 工具<br><a href="https://github.com/uber-go/ratelimit" target="_blank" rel="noopener">https://github.com/uber-go/ratelimit</a><br><a href="https://blog.csdn.net/chenchongg/article/details/85342086" target="_blank" rel="noopener">https://blog.csdn.net/chenchongg/article/details/85342086</a><br><a href="https://github.com/juju/ratelimit" target="_blank" rel="noopener">https://github.com/juju/ratelimit</a></p><p>golang 熔断的库<br>熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.<br><a href="https://github.com/afex/hystrix-go" target="_blank" rel="noopener">https://github.com/afex/hystrix-go</a><br><a href="https://github.com/sony/gobreaker" target="_blank" rel="noopener">https://github.com/sony/gobreaker</a></p><p>表格<br><a href="https://github.com/chenjiandongx/go-echarts" target="_blank" rel="noopener">https://github.com/chenjiandongx/go-echarts</a></p><p>tail 工具库<br><a href="https://github.com/hpcloud/taglshi" target="_blank" rel="noopener">https://github.com/hpcloud/taglshi</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang设计模式之装饰器模式</title>
    <link href="https://cloudsjhan.github.io/2019/11/30/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cloudsjhan.github.io/2019/11/30/golang设计模式之装饰器模式/</id>
    <published>2019-11-30T07:21:30.000Z</published>
    <updated>2019-11-30T07:34:02.841Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器结构模式允许动态地扩展现有对象的功能，而不改变其内部结构。</p><p>装饰器提供了一种灵活的方法来扩展对象的功能。</p><h3 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h3><p>下面的LogDecorate用signature func（int）int修饰函数，该函数操作整数并添加输入/输出日志记录功能。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Object <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LogDecorate</span><span class="params">(fn Object)</span> <span class="title">Object</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"Starting the execution with the integer"</span>, n)</span><br><span class="line"></span><br><span class="line">result := fn(n)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">"Execution is completed with the result"</span>, result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">f := LogDecorate(Double)</span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//参数为5，开始执行</span></span><br><span class="line"><span class="comment">//执行的结果是10</span></span><br></pre></td></tr></table></figure><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li><p>与适配器模式不同，要修饰的对象是通过注入获得的。</p></li><li><p>装饰器不应更改对象的接口。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      golang设计模式之装饰器模式
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="设计模式" scheme="https://cloudsjhan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>github&amp;Daocloud演讲稿整理与总结</title>
    <link href="https://cloudsjhan.github.io/2019/11/23/githubXDaocloud%E6%BC%94%E8%AE%B2%E7%A8%BF%E6%95%B4%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93-md/"/>
    <id>https://cloudsjhan.github.io/2019/11/23/githubXDaocloud演讲稿整理与总结-md/</id>
    <published>2019-11-23T14:27:40.000Z</published>
    <updated>2019-11-23T14:37:12.828Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>大家下午好，今天给大家带来的分享主题是 golang 的内存分析以及优化，主要分为两部分内容，一是 以开源项目crawlab的内存分析与优化为例，讲解golang内存调优的一些工具和分析的过程；</p><p>第二部分是介绍平时开发中容易忽略的和容易带来性能问题的点，以及如何去优化。</p><p>当时这个话题的灵感来自一个开源项目 crawlab, crawlab是一个分布式任务调度平台，这里不展开详细解释了，大家有兴趣可以到GitHub主页看一下，<a href="https://github.com/crawlab-team/crawlab" target="_blank" rel="noopener">https://github.com/crawlab-team/crawlab</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98bvonxkzj305k05kmx1.jpg" alt="crawlab_pic"></p><p>当时是有用户报出crawlab启动一段时间后，主节点机器会出现内存占用过高的问题，一台4G内存的服务器在运行crawlab后竟然能占用3G以的内存，然后整个master就会down掉，于是我开始对crawlab的后端服务进行性能的分析，下面将带大家回顾这一过程。</p><p>首先介绍，Golang的性能分析主要分为两种方式，<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98ckayzwxj323f0u0wui.jpg" alt="截屏2019-11-2322.14.47"></p><p>一种是通过文件方式输出profile，特点是灵活性高，适用于特定代码片段的分析，我们通过调用/runtime包中的/pprof的API生成相应的pprof文件，然后使用 pprof就可以进入类似GDB的窗口。在这个窗口中你就可以用top,list function等命令去查看cpu,memory的状况以及goroutine运行情况。</p><p>第二种方式就是通过HTTP输出profile，</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98ckr5ve9j31cz0u07h2.jpg" alt="截屏2019-11-2322.17.33"></p><p>这种方式就适合于你还不清楚到底哪一段代码出现问题，而且你的应用要持续运行的情况。在分析crawlab的时候，采用的是这种方式。首先，我们在crawlab项目中嵌入如下几行代码，将crawlab后端服务启动后，浏览器中输入<a href="http://ip:8899/debug/pprof/就可以看到一个汇总分析页面，显示如下信息，点击heap，在汇总分析页面的最上方可以看到如下图所示，" target="_blank" rel="noopener">http://ip:8899/debug/pprof/就可以看到一个汇总分析页面，显示如下信息，点击heap，在汇总分析页面的最上方可以看到如下图所示，</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98cjvmammj311k06w0t6.jpg" alt="heap_server"></p><p>红色箭头所指的就是当前已经使用的堆内存是25M,！在我只上传一个爬虫文件，而且这个文件还不是特别打大的情况下，一个后端服务所用的内存使用竟然能达到25M。</p><p>我们再用这个命令进入命令行详细看一下，这个命令进入后，输入top命令可以显示前10的内存分配，flat是堆栈中当前层的inuse内存值，cum是堆栈中本层级的累计inuse内存值。</p><p>可以看到，bytes.makeSlice这个内置方法竟然使用了24M内存，那么我们就考虑谁会用到makeslice呢，<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c5dze47j31fq0mu79j.jpg" alt="heap_gdb"></p><p>继续往下看，可以看到ReadFrom这个方法，看下源码，发现 ioutil.ReadAll() 里会调用 bytes.Buffer.ReadFrom, </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c67o6udj30hi0b40ur.jpg" alt="image-20191123222106249"></p><p>而 ReadFrom 会进行 makeSlice。让我们再回头看一下readAll的代码实现：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c6oud5sj30i709zq57.jpg" alt="image-20191123222129984"></p><p>这个函数主要作用就是从 io.Reader 里读取的数据放入 buffer 中，如果 buffer 空间不够，就按照每次 2x 所读取内容的大小+ MinRead 的算法递增，这里 MinRead 的大小是 512 个字节，也就是说如果我们一次性读取的内容过大，就会导致所使用的内存倍增，假设我们的所有任务文件总共有500M,那么所用的内存就有500M * 2 + 512B，所以我们分析很可能是这个原因导致的，那看看crawlab源码中是哪一段使用ReadAll读了文件，定位到了这里</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c734tyjj30hq07dtae.jpg" alt="image-20191123222147655">     </p><p>这段代码直接将全部的文件内容，以二进制的形式读了进来，导致内存倍增，令人窒息的操作。至此，问题已经发现，那么如何去优化呢，其实在读大文件的时候，把文件内容全部读到内存，直接就翻车了，正确是处理方法有两种，一种是流式处理 ，如代码所示</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c74vzzdj30dp09zwfp.jpg" alt="image-20191123222203534"></p><p>第二种方案就是分片处理，当读取的是二进制文件，没有换行符的时候，使用这种方案比较合适。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c7fsg21j30cx09z0u6.jpg" alt="image-20191123222215908"></p><p>我们这里采用的第二种方式来优化，优化后再来看下内存占用情况</p><p>我们采样程序运行30s的平均内存，并且在此期间访问上传文件的接口后，看到内存占用已经降到正常的水平了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c7uw1iij30ou09f77c.jpg" alt="image-20191123222231369">v</p><p>刚刚我用一个实际案例介绍了如何去一步一步的分析及优化go程序的内存问题，大家可以在平时开发中多去探索，多使用。</p><p>接下来介绍一些go 开发中的小技巧，从细节上提高你的golang应用程序的性能。</p><p>众所周知Json 作为一种重要的数据格式，大家开发者经常用到。Go 语言里面原生支持了json的序列化以及反序列化，内部使用反射机制实现，我们都知道，反射的性能有点差，在高度依赖 json 解析的接口里，这往往会成为性能瓶颈，好在已有很多第三方库帮我们解决了这个问题，但是这么多库，到底要怎么选择呢，下面就给大家来一一分析一下，这里介绍4个json序列化反序列化的库,</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c8lsud5j31uo0u0h6c.jpg" alt="截屏2019-11-2322.23.03"></p><p>看完这些你可能不知道到底该用哪一个，让我们来看下benchmark.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98c8l87rlj30qo07m776.jpg" alt="image-20191123222330976"></p><ul><li><p>​    •easyjson 无论是序列化还是反序列化都是最优的，序列化提升了1倍，反序列化提升了3倍</p></li><li><p>​    •jsoniter 性能也很好，接近于easyjson，关键是没有预编译过程，100%兼容原生库</p></li><li><p>​    •ffjson 的序列化提升并不明显，反序列化提升了1倍</p></li><li><p>所以综合考虑，建议大家使用 jsoniter，如果追求极致的性能，考虑 easyjson</p><p>字符串拼接在开发中肯定是经常用到的，当你的应用中的某一部分大量用到字符串拼接，你最好留意一下下面的内容。我们列举4中字符串拼接的方式，看看你经常用的是哪个？</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98cab6m7nj31n30u0tmk.jpg" alt="截屏2019-11-2322.24.48"></p></li></ul><p>第一种 + 号运算符，第二种是golang特有的一种方式，第三中是 strings.builder, 最后一种是strings.buffer。</p><p>看下benchmark你就会做出你最终的选择。性能最好的是strings.builder,而sprintf性能最差，+ 号运算符也没好到哪里去。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g98cabpls3j30qo07y764.jpg" alt="image-20191123222511309"></p><p>以上就是我今天分享的全部内容，希望能帮助到大家，下面是我的联系方式，有问题的可以线下继续交流。谢谢！</p><hr>]]></content>
    
    <summary type="html">
    
      github&amp;Daocloud演讲总结
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="生活" scheme="https://cloudsjhan.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>golang cron使用</title>
    <link href="https://cloudsjhan.github.io/2019/10/29/golang-cron%E4%BD%BF%E7%94%A8/"/>
    <id>https://cloudsjhan.github.io/2019/10/29/golang-cron使用/</id>
    <published>2019-10-29T11:10:03.000Z</published>
    <updated>2019-10-29T11:12:04.488Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h1 id="Go定时器cron的使用详解"><a href="#Go定时器cron的使用详解" class="headerlink" title="Go定时器cron的使用详解"></a>Go定时器cron的使用详解</h1><p> 更新时间：2018年01月11日 10:51:02  作者：骑头猪逛街  <a href="https://www.jb51.net/article/132655.htm#comments" target="_blank" rel="noopener"><img src="https://www.jb51.net/skin/2018/images/text-message.png" alt="img"> 我要评论</a></p><p>本篇文章主要介绍了Go定时器cron的使用详解，小编觉得挺不错的，现在分享给大家，也给大家做个参考。一起跟随小编过来看看吧</p><p><strong>cron是什么</strong></p><p>cron的意思就是：计划任务，说白了就是定时任务。我和系统约个时间，你在几点几分几秒或者每隔几分钟跑一个任务(job)，就那么简单。</p><p><strong>cron表达式</strong>　　</p><p>cron表达式是一个好东西，这个东西不仅Java的quartZ能用到，Go语言中也可以用到。我没有用过Linux的cron，但网上说Linux也是可以用crontab -e 命令来配置定时任务。Go语言和Java中都是可以精确到秒的，但是Linux中不行。</p><p>cron表达式代表一个时间的集合，使用6个空格分隔的字段表示：</p><table><thead><tr><th>字段名</th><th>是否必须</th><th>允许的值</th><th>允许的特定字符</th></tr></thead><tbody><tr><td>秒(Seconds)</td><td>是</td><td>0-59</td><td>* / , -</td></tr><tr><td>分(Minute)</td><td>是</td><td>0-59</td><td>* / , -</td></tr><tr><td>时(Hours)</td><td>是</td><td>0-23</td><td>* / , -</td></tr><tr><td>日(Day of month)</td><td>是</td><td>1-31</td><td>* / , - ?</td></tr><tr><td>月(Month)</td><td>是</td><td>1-12 或 JAN-DEC</td><td>* / , -</td></tr><tr><td>星期(Day of week)</td><td>否</td><td>0-6 或 SUM-SAT</td><td>* / , - ?</td></tr></tbody></table><p>1.月(Month)和星期(Day of week)字段的值不区分大小写，如：SUN、Sun 和 sun 是一样的。</p><p>2.星期(Day of week)字段如果没提供，相当于是 *</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`# ┌───────────── min (0 - 59)``# │ ┌────────────── hour (0 - 23)``# │ │ ┌─────────────── day of month (1 - 31)``# │ │ │ ┌──────────────── month (1 - 12)``# │ │ │ │ ┌───────────────── day of week (0 - 6) (0 to 6 are Sunday to``# │ │ │ │ │     Saturday, or use names; 7 is also Sunday)``# │ │ │ │ │``# │ │ │ │ │``# * * * * * command to execute`</span><br></pre></td></tr></table></figure><p>cron特定字符说明</p><p>1）星号(*)</p><p>表示 cron 表达式能匹配该字段的所有值。如在第5个字段使用星号(month)，表示每个月</p><p>2）斜线(/)</p><p>表示增长间隔，如第1个字段(minutes) 值是 3-59/15，表示每小时的第3分钟开始执行一次，之后每隔 15 分钟执行一次（即 3、18、33、48 这些时间点执行），这里也可以表示为：3/15</p><p>3）逗号(,)</p><p>用于枚举值，如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行</p><p>4）连字号(-)</p><p>表示一个范围，如第3个字段的值为 9-17 表示 9am 到 5pm 直接每个小时（包括9和17）</p><p>5）问号(?)</p><p>只用于 日(Day of month) 和 星期(Day of week)，表示不指定值，可以用于代替 *</p><p>6）L，W，#</p><p>Go中没有L，W，#的用法，下文作解释。</p><p><strong>cron举例说明</strong></p><p>每隔5秒执行一次：<em>/5 </em> <em> </em> * ?</p><p>每隔1分钟执行一次：0 <em>/1 </em> <em> </em> ?</p><p>每天23点执行一次：0 0 23 <em> </em> ?</p><p>每天凌晨1点执行一次：0 0 1 <em> </em> ?</p><p>每月1号凌晨1点执行一次：0 0 1 1 * ?</p><p>在26分、29分、33分执行一次：0 26,29,33 <em> </em> * ?</p><p>每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 <em> </em> ?</p><p><strong>下载安装</strong></p><p>控制台输入 <code>go get github.com/robfig/cron</code>去下载定时任务的Go包，前提是你的<code>$GOPATH</code>已经配置好</p><p>源码解析</p><p>文件目录讲解　</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`constantdelay.go  #一个最简单的秒级别定时系统。与cron无关``constantdelay_test.go #测试``cron.go    #Cron系统。管理一系列的cron定时任务（Schedule Job）``cron_test.go   #测试``doc.go    #说明文档``LICENSE    #授权书 ``parser.go    #解析器，解析cron格式字符串城一个具体的定时器（Schedule）``parser_test.go  #测试``README.md    #README``spec.go    #单个定时器（Schedule）结构体。如何计算自己的下一次触发时间``spec_test.go   #测试`</span><br></pre></td></tr></table></figure><p><strong>cron.go</strong></p><p>结构体：</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`// Cron keeps track of any number of entries, invoking the associated func as``// specified by the schedule. It may be started, stopped, and the entries may``// be inspected while running. ``// Cron保持任意数量的条目的轨道，调用相关的func时间表指定。它可以被启动，停止和条目，可运行的同时进行检查。``type Cron struct &#123;`` ``entries []*Entry 　　　　// 任务`` ``stop  chan struct&#123;&#125;  // 叫停止的途径`` ``add  chan *Entry  // 添加新任务的方式`` ``snapshot chan []*Entry  // 请求获取任务快照的方式`` ``running bool    // 是否在运行`` ``ErrorLog *log.Logger  // 出错日志(新增属性)`` ``location *time.Location  // 所在地区(新增属性)  ``&#125;`</span><br></pre></td></tr></table></figure><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`// Entry consists of a schedule and the func to execute on that schedule.``// 入口包括时间表和可在时间表上执行的func``type Entry struct &#123;``  ``// 计时器`` ``Schedule Schedule`` ``// 下次执行时间`` ``Next time.Time`` ``// 上次执行时间`` ``Prev time.Time`` ``// 任务`` ``Job Job``&#125;`</span><br></pre></td></tr></table></figure><p>关键方法：</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`// 开始任务``// Start the cron scheduler in its own go-routine, or no-op if already started.``func (c *Cron) Start() &#123;`` ``if c.running &#123;``  ``return`` ``&#125;`` ``c.running = true`` ``go c.run()``&#125;``// 结束任务``// Stop stops the cron scheduler if it is running; otherwise it does nothing.``func (c *Cron) Stop() &#123;`` ``if !c.running &#123;``  ``return`` ``&#125;`` ``c.stop &lt;- struct&#123;&#125;&#123;&#125;`` ``c.running = false``&#125;` `// 执行定时任务``// Run the scheduler.. this is private just due to the need to synchronize``// access to the &apos;running&apos; state variable.``func (c *Cron) run() &#123;`` ``// Figure out the next activation times for each entry.`` ``now := time.Now().In(c.location)`` ``for _, entry := range c.entries &#123;``  ``entry.Next = entry.Schedule.Next(now)`` ``&#125;``  ``// 无限循环`` ``for &#123;``   ``//通过对下一个执行时间进行排序，判断那些任务是下一次被执行的，防在队列的前面.sort是用来做排序的``  ``sort.Sort(byTime(c.entries))` `  ``var effective time.Time``  ``if len(c.entries) == 0 || c.entries[0].Next.IsZero() &#123;``   ``// If there are no entries yet, just sleep - it still handles new entries``   ``// and stop requests.``   ``effective = now.AddDate(10, 0, 0)``  ``&#125; else &#123;``   ``effective = c.entries[0].Next``  ``&#125;` `  ``timer := time.NewTimer(effective.Sub(now))``  ``select &#123;``  ``case now = &lt;-timer.C: // 执行当前任务``   ``now = now.In(c.location)``   ``// Run every entry whose next time was this effective time.``   ``for _, e := range c.entries &#123;``    ``if e.Next != effective &#123;``     ``break``    ``&#125;``    ``go c.runWithRecovery(e.Job)``    ``e.Prev = e.Next``    ``e.Next = e.Schedule.Next(now)``   ``&#125;``   ``continue` `  ``case newEntry := &lt;-c.add: // 添加新的任务``   ``c.entries = append(c.entries, newEntry)``   ``newEntry.Next = newEntry.Schedule.Next(time.Now().In(c.location))` `  ``case &lt;-c.snapshot: // 获取快照``   ``c.snapshot &lt;- c.entrySnapshot()` `  ``case &lt;-c.stop: // 停止任务``   ``timer.Stop()``   ``return``  ``&#125;` `  ``// &apos;now&apos; should be updated after newEntry and snapshot cases.``  ``now = time.Now().In(c.location)``  ``timer.Stop()`` ``&#125;``&#125;`</span><br></pre></td></tr></table></figure><p>spec.go</p><p>结构体及关键方法：</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`// SpecSchedule specifies a duty cycle (to the second granularity), based on a``// traditional crontab specification. It is computed initially and stored as bit sets.``type SpecSchedule struct &#123;`` ``// 表达式中锁表明的，秒，分，时，日，月，周，每个都是uint64`` ``// Dom:Day of Month,Dow:Day of week`` ``Second, Minute, Hour, Dom, Month, Dow uint64``&#125;` `// bounds provides a range of acceptable values (plus a map of name to value).``// 定义了表达式的结构体``type bounds struct &#123;`` ``min, max uint`` ``names map[string]uint``&#125;` `// The bounds for each field.``// 这样就能看出各个表达式的范围``var (``  ``seconds = bounds&#123;0, 59, nil&#125;``  ``minutes = bounds&#123;0, 59, nil&#125;``  ``hours = bounds&#123;0, 23, nil&#125;``  ``dom  = bounds&#123;1, 31, nil&#125;``  ``months = bounds&#123;1, 12, map[string]uint&#123;``    ``&quot;jan&quot;: 1,``    ``&quot;feb&quot;: 2,``    ``&quot;mar&quot;: 3,``    ``&quot;apr&quot;: 4,``    ``&quot;may&quot;: 5,``    ``&quot;jun&quot;: 6,``    ``&quot;jul&quot;: 7,``    ``&quot;aug&quot;: 8,``    ``&quot;sep&quot;: 9,``    ``&quot;oct&quot;: 10,``    ``&quot;nov&quot;: 11,``    ``&quot;dec&quot;: 12,``  ``&#125;&#125;``  ``dow = bounds&#123;0, 6, map[string]uint&#123;``    ``&quot;sun&quot;: 0,``    ``&quot;mon&quot;: 1,``    ``&quot;tue&quot;: 2,``    ``&quot;wed&quot;: 3,``    ``&quot;thu&quot;: 4,``    ``&quot;fri&quot;: 5,``    ``&quot;sat&quot;: 6,``  ``&#125;&#125;``)` `const (``  ``// Set the top bit if a star was included in the expression.``  ``starBit = 1 &lt;&lt; 63``)`</span><br></pre></td></tr></table></figure><p>看了上面的东西肯定有人疑惑为什么秒分时这些都是定义了unit64,以及定义了一个常量starBit = 1 &lt;&lt; 63这种写法，这是逻辑运算符。表示二进制1向左移动63位。原因如下：</p><p>cron表达式是用来表示一系列时间的，而时间是无法逃脱自己的区间的 ， 分，秒 0 - 59 ， 时 0 - 23 ， 天/月 0 - 31 ， 天/周 0 - 6 ， 月0 - 11 。 这些本质上都是一个点集合，或者说是一个整数区间。 那么对于任意的整数区间 ， 可以描述cron的如下部分规则。</p><ol><li>* | ? 任意 ， 对应区间上的所有点。 （ 额外注意 日/周 ， 日 / 月 的相互干扰。）</li><li>纯数字 ， 对应一个具体的点。</li><li>/ 分割的两个数字 a , b， 区间上符合 a + n * b 的所有点 （ n &gt;= 0 )。</li><li>- 分割的两个数字， 对应这两个数字决定的区间内的所有点。</li><li>L | W 需要对于特定的时间特殊判断， 无法通用的对应到区间上的点。</li></ol><p>至此， robfig/cron为什么不支持 L | W的原因已经明了了。去除这两条规则后， 其余的规则其实完全可以使用点的穷举来通用表示。 考虑到最大的区间也不过是60个点，那么使用一个uint64的整数的每一位来表示一个点便很合适了。所以定义unit64不为过</p><p>下面是go中cron表达式的方法：</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/* `` ``------------------------------------------------------------`` ``第64位标记任意 ， 用于 日/周 ， 日 / 月 的相互干扰。`` ``63 - 0 为 表示区间 [63 , 0] 的 每一个点。`` ``------------------------------------------------------------` ` ``假设区间是 0 - 63 ， 则有如下的例子 ：` ` ``比如 0/3 的表示如下 ： (表示每隔两位为1)`` ``* / ?  `` ``+---+--------------------------------------------------------+`` ``| 0 | 1 0 0 1 0 0 1 ~~ ~~     1 0 0 1 0 0 1 |`` ``+---+--------------------------------------------------------+ ``  ``63 ~ ~           ~~ 0` ` ``比如 2-5 的表示如下 ： (表示从右往左2-5位上都是1)`` ``* / ?  `` ``+---+--------------------------------------------------------+`` ``| 0 | 0 0 0 0 ~ ~  ~~   ~ 0 0 0 1 1 1 1 0 0 |`` ``+---+--------------------------------------------------------+ ``  ``63 ~ ~           ~~ 0` ` ``比如 * 的表示如下 ： (表示所有位置上都为1)`` ``* / ?  `` ``+---+--------------------------------------------------------+`` ``| 1 | 1 1 1 1 1 ~ ~     ~ 1 1 1 1 1 1 1 1 1 |`` ``+---+--------------------------------------------------------+ ``  ``63 ~ ~           ~~ 0 ``*/`</span><br></pre></td></tr></table></figure><p>parser.go</p><p>将字符串解析为SpecSchedule的类。</p><p><a href="https://www.jb51.net/article/132655.htm#" target="_blank" rel="noopener">?</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`package cron` `import (`` ``&quot;fmt&quot;`` ``&quot;math&quot;`` ``&quot;strconv&quot;`` ``&quot;strings&quot;`` ``&quot;time&quot;``)` `// Configuration options for creating a parser. Most options specify which``// fields should be included, while others enable features. If a field is not``// included the parser will assume a default value. These options do not change``// the order fields are parse in.``type ParseOption int` `const (`` ``Second  ParseOption = 1 &lt;&lt; iota // Seconds field, default 0`` ``Minute        // Minutes field, default 0`` ``Hour        // Hours field, default 0`` ``Dom         // Day of month field, default *`` ``Month        // Month field, default *`` ``Dow         // Day of week field, default *`` ``DowOptional       // Optional day of week field, default *`` ``Descriptor       // Allow descriptors such as @monthly, @weekly, etc.``)` `var places = []ParseOption&#123;`` ``Second,`` ``Minute,`` ``Hour,`` ``Dom,`` ``Month,`` ``Dow,``&#125;` `var defaults = []string&#123;`` ``&quot;0&quot;,`` ``&quot;0&quot;,`` ``&quot;0&quot;,`` ``&quot;*&quot;,`` ``&quot;*&quot;,`` ``&quot;*&quot;,``&#125;` `// A custom Parser that can be configured.``type Parser struct &#123;`` ``options ParseOption`` ``optionals int``&#125;` `// Creates a custom Parser with custom options.``//``// // Standard parser without descriptors``// specParser := NewParser(Minute | Hour | Dom | Month | Dow)``// sched, err := specParser.Parse(&quot;0 0 15 */3 *&quot;)``//``// // Same as above, just excludes time fields``// subsParser := NewParser(Dom | Month | Dow)``// sched, err := specParser.Parse(&quot;15 */3 *&quot;)``//``// // Same as above, just makes Dow optional``// subsParser := NewParser(Dom | Month | DowOptional)``// sched, err := specParser.Parse(&quot;15 */3&quot;)``//``func NewParser(options ParseOption) Parser &#123;`` ``optionals := 0`` ``if options&amp;DowOptional &gt; 0 &#123;``  ``options |= Dow``  ``optionals++`` ``&#125;`` ``return Parser&#123;options, optionals&#125;``&#125;` `// Parse returns a new crontab schedule representing the given spec.``// It returns a descriptive error if the spec is not valid.``// It accepts crontab specs and features configured by NewParser.``// 将字符串解析成为SpecSchedule 。 SpecSchedule符合Schedule接口` `func (p Parser) Parse(spec string) (Schedule, error) &#123;``　　// 直接处理特殊的特殊的字符串`` ``if spec[0] == &apos;@&apos; &amp;&amp; p.options&amp;Descriptor &gt; 0 &#123;``  ``return parseDescriptor(spec)`` ``&#125;` ` ``// Figure out how many fields we need`` ``max := 0`` ``for _, place := range places &#123;``  ``if p.options&amp;place &gt; 0 &#123;``   ``max++``  ``&#125;`` ``&#125;`` ``min := max - p.optionals` ` ``// cron利用空白拆解出独立的items。`` ``fields := strings.Fields(spec)` ` ``// 验证表达式取值范围`` ``if count := len(fields); count &lt; min || count &gt; max &#123;``  ``if min == max &#123;``   ``return nil, fmt.Errorf(&quot;Expected exactly %d fields, found %d: %s&quot;, min, count, spec)``  ``&#125;``  ``return nil, fmt.Errorf(&quot;Expected %d to %d fields, found %d: %s&quot;, min, max, count, spec)`` ``&#125;` ` ``// Fill in missing fields`` ``fields = expandFields(fields, p.options)` ` ``var err error`` ``field := func(field string, r bounds) uint64 &#123;``  ``if err != nil &#123;``   ``return 0``  ``&#125;``  ``var bits uint64``  ``bits, err = getField(field, r)``  ``return bits`` ``&#125;` ` ``var (``  ``second  = field(fields[0], seconds)``  ``minute  = field(fields[1], minutes)``  ``hour  = field(fields[2], hours)``  ``dayofmonth = field(fields[3], dom)``  ``month  = field(fields[4], months)``  ``dayofweek = field(fields[5], dow)`` ``)`` ``if err != nil &#123;``  ``return nil, err`` ``&#125;`` ``// 返回所需要的SpecSchedule`` ``return &amp;SpecSchedule&#123;``  ``Second: second,``  ``Minute: minute,``  ``Hour: hour,``  ``Dom: dayofmonth,``  ``Month: month,``  ``Dow: dayofweek,`` ``&#125;, nil``&#125;` `func expandFields(fields []string, options ParseOption) []string &#123;`` ``n := 0`` ``count := len(fields)`` ``expFields := make([]string, len(places))`` ``copy(expFields, defaults)`` ``for i, place := range places &#123;``  ``if options&amp;place &gt; 0 &#123;``   ``expFields[i] = fields[n]``   ``n++``  ``&#125;``  ``if n == count &#123;``   ``break``  ``&#125;`` ``&#125;`` ``return expFields``&#125;` `var standardParser = NewParser(`` ``Minute | Hour | Dom | Month | Dow | Descriptor,``)` `// ParseStandard returns a new crontab schedule representing the given standardSpec``// (https://en.wikipedia.org/wiki/Cron). It differs from Parse requiring to always``// pass 5 entries representing: minute, hour, day of month, month and day of week,``// in that order. It returns a descriptive error if the spec is not valid.``//``// It accepts``// - Standard crontab specs, e.g. &quot;* * * * ?&quot;``// - Descriptors, e.g. &quot;@midnight&quot;, &quot;@every 1h30m&quot;``// 这里表示不仅可以使用cron表达式，也可以使用@midnight @every等方法` `func ParseStandard(standardSpec string) (Schedule, error) &#123;`` ``return standardParser.Parse(standardSpec)``&#125;` `var defaultParser = NewParser(`` ``Second | Minute | Hour | Dom | Month | DowOptional | Descriptor,``)` `// Parse returns a new crontab schedule representing the given spec.``// It returns a descriptive error if the spec is not valid.``//``// It accepts``// - Full crontab specs, e.g. &quot;* * * * * ?&quot;``// - Descriptors, e.g. &quot;@midnight&quot;, &quot;@every 1h30m&quot;``func Parse(spec string) (Schedule, error) &#123;`` ``return defaultParser.Parse(spec)``&#125;` `// getField returns an Int with the bits set representing all of the times that``// the field represents or error parsing field value. A &quot;field&quot; is a comma-separated``// list of &quot;ranges&quot;.``func getField(field string, r bounds) (uint64, error) &#123;`` ``var bits uint64`` ``ranges := strings.FieldsFunc(field, func(r rune) bool &#123; return r == &apos;,&apos; &#125;)`` ``for _, expr := range ranges &#123;``  ``bit, err := getRange(expr, r)``  ``if err != nil &#123;``   ``return bits, err``  ``&#125;``  ``bits |= bit`` ``&#125;`` ``return bits, nil``&#125;` `// getRange returns the bits indicated by the given expression:``// number | number &quot;-&quot; number [ &quot;/&quot; number ]``// or error parsing range.``func getRange(expr string, r bounds) (uint64, error) &#123;`` ``var (``  ``start, end, step uint``  ``rangeAndStep  = strings.Split(expr, &quot;/&quot;)``  ``lowAndHigh  = strings.Split(rangeAndStep[0], &quot;-&quot;)``  ``singleDigit  = len(lowAndHigh) == 1``  ``err    error`` ``)` ` ``var extra uint64`` ``if lowAndHigh[0] == &quot;*&quot; || lowAndHigh[0] == &quot;?&quot; &#123;``  ``start = r.min``  ``end = r.max``  ``extra = starBit`` ``&#125; else &#123;``  ``start, err = parseIntOrName(lowAndHigh[0], r.names)``  ``if err != nil &#123;``   ``return 0, err``  ``&#125;``  ``switch len(lowAndHigh) &#123;``  ``case 1:``   ``end = start``  ``case 2:``   ``end, err = parseIntOrName(lowAndHigh[1], r.names)``   ``if err != nil &#123;``    ``return 0, err``   ``&#125;``  ``default:``   ``return 0, fmt.Errorf(&quot;Too many hyphens: %s&quot;, expr)``  ``&#125;`` ``&#125;` ` ``switch len(rangeAndStep) &#123;`` ``case 1:``  ``step = 1`` ``case 2:``  ``step, err = mustParseInt(rangeAndStep[1])``  ``if err != nil &#123;``   ``return 0, err``  ``&#125;` `  ``// Special handling: &quot;N/step&quot; means &quot;N-max/step&quot;.``  ``if singleDigit &#123;``   ``end = r.max``  ``&#125;`` ``default:``  ``return 0, fmt.Errorf(&quot;Too many slashes: %s&quot;, expr)`` ``&#125;` ` ``if start &lt; r.min &#123;``  ``return 0, fmt.Errorf(&quot;Beginning of range (%d) below minimum (%d): %s&quot;, start, r.min, expr)`` ``&#125;`` ``if end &gt; r.max &#123;``  ``return 0, fmt.Errorf(&quot;End of range (%d) above maximum (%d): %s&quot;, end, r.max, expr)`` ``&#125;`` ``if start &gt; end &#123;``  ``return 0, fmt.Errorf(&quot;Beginning of range (%d) beyond end of range (%d): %s&quot;, start, end, expr)`` ``&#125;`` ``if step == 0 &#123;``  ``return 0, fmt.Errorf(&quot;Step of range should be a positive number: %s&quot;, expr)`` ``&#125;` ` ``return getBits(start, end, step) | extra, nil``&#125;` `// parseIntOrName returns the (possibly-named) integer contained in expr.``func parseIntOrName(expr string, names map[string]uint) (uint, error) &#123;`` ``if names != nil &#123;``  ``if namedInt, ok := names[strings.ToLower(expr)]; ok &#123;``   ``return namedInt, nil``  ``&#125;`` ``&#125;`` ``return mustParseInt(expr)``&#125;` `// mustParseInt parses the given expression as an int or returns an error.``func mustParseInt(expr string) (uint, error) &#123;`` ``num, err := strconv.Atoi(expr)`` ``if err != nil &#123;``  ``return 0, fmt.Errorf(&quot;Failed to parse int from %s: %s&quot;, expr, err)`` ``&#125;`` ``if num &lt; 0 &#123;``  ``return 0, fmt.Errorf(&quot;Negative number (%d) not allowed: %s&quot;, num, expr)`` ``&#125;` ` ``return uint(num), nil``&#125;` `// getBits sets all bits in the range [min, max], modulo the given step size.``func getBits(min, max, step uint) uint64 &#123;`` ``var bits uint64` ` ``// If step is 1, use shifts.`` ``if step == 1 &#123;``  ``return ^(math.MaxUint64 &lt;&lt; (max + 1)) &amp; (math.MaxUint64 &lt;&lt; min)`` ``&#125;` ` ``// Else, use a simple loop.`` ``for i := min; i &lt;= max; i += step &#123;``  ``bits |= 1 &lt;&lt; i`` ``&#125;`` ``return bits``&#125;` `// all returns all bits within the given bounds. (plus the star bit)``func all(r bounds) uint64 &#123;`` ``return getBits(r.min, r.max, 1) | starBit``&#125;` `// parseDescriptor returns a predefined schedule for the expression, or error if none matches.``func parseDescriptor(descriptor string) (Schedule, error) &#123;`` ``switch descriptor &#123;`` ``case &quot;@yearly&quot;, &quot;@annually&quot;:``  ``return &amp;SpecSchedule&#123;``   ``Second: 1 &lt;&lt; seconds.min,``   ``Minute: 1 &lt;&lt; minutes.min,``   ``Hour: 1 &lt;&lt; hours.min,``   ``Dom: 1 &lt;&lt; dom.min,``   ``Month: 1 &lt;&lt; months.min,``   ``Dow: all(dow),``  ``&#125;, nil` ` ``case &quot;@monthly&quot;:``  ``return &amp;SpecSchedule&#123;``   ``Second: 1 &lt;&lt; seconds.min,``   ``Minute: 1 &lt;&lt; minutes.min,``   ``Hour: 1 &lt;&lt; hours.min,``   ``Dom: 1 &lt;&lt; dom.min,``   ``Month: all(months),``   ``Dow: all(dow),``  ``&#125;, nil` ` ``case &quot;@weekly&quot;:``  ``return &amp;SpecSchedule&#123;``   ``Second: 1 &lt;&lt; seconds.min,``   ``Minute: 1 &lt;&lt; minutes.min,``   ``Hour: 1 &lt;&lt; hours.min,``   ``Dom: all(dom),``   ``Month: all(months),``   ``Dow: 1 &lt;&lt; dow.min,``  ``&#125;, nil` ` ``case &quot;@daily&quot;, &quot;@midnight&quot;:``  ``return &amp;SpecSchedule&#123;``   ``Second: 1 &lt;&lt; seconds.min,``   ``Minute: 1 &lt;&lt; minutes.min,``   ``Hour: 1 &lt;&lt; hours.min,``   ``Dom: all(dom),``   ``Month: all(months),``   ``Dow: all(dow),``  ``&#125;, nil` ` ``case &quot;@hourly&quot;:``  ``return &amp;SpecSchedule&#123;``   ``Second: 1 &lt;&lt; seconds.min,``   ``Minute: 1 &lt;&lt; minutes.min,``   ``Hour: all(hours),``   ``Dom: all(dom),``   ``Month: all(months),``   ``Dow: all(dow),``  ``&#125;, nil`` ``&#125;` ` ``const every = &quot;@every &quot;`` ``if strings.HasPrefix(descriptor, every) &#123;``  ``duration, err := time.ParseDuration(descriptor[len(every):])``  ``if err != nil &#123;``   ``return nil, fmt.Errorf(&quot;Failed to parse duration %s: %s&quot;, descriptor, err)``  ``&#125;``  ``return Every(duration), nil`` ``&#125;` ` ``return nil, fmt.Errorf(&quot;Unrecognized descriptor: %s&quot;, descriptor)``&#125;`</span><br></pre></td></tr></table></figure><p>项目中应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`package main``import (`` ``&quot;github.com/robfig/cron&quot;`` ``&quot;log&quot;``)` `func main() &#123;`` ``i := 0`` ``c := cron.New()`` ``spec := &quot;*/5 * * * * ?&quot;`` ``c.AddFunc(spec, func() &#123;``  ``i++``  ``log.Println(&quot;cron running:&quot;, i)`` ``&#125;)`` ``c.AddFunc(&quot;@every 1h1m&quot;, func() &#123;``  ``i++``  ``log.Println(&quot;cron running:&quot;, i)`` ``&#125;)`` ``c.Start()``&#125;`</span><br></pre></td></tr></table></figure><p>注： @every 用法比较特殊，这是Go里面比较特色的用法。同样的还有 @yearly @annually @monthly @weekly @daily @midnight @hourly 这里面就不一一赘述了。希望大家能够自己探索。</p><hr>]]></content>
    
    <summary type="html">
    
      Go定时器cron的使用详解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker compose 网络设置</title>
    <link href="https://cloudsjhan.github.io/2019/10/27/Docker-compose-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/"/>
    <id>https://cloudsjhan.github.io/2019/10/27/Docker-compose-网络设置/</id>
    <published>2019-10-27T12:00:22.000Z</published>
    <updated>2019-10-27T12:21:28.385Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h1 id="Docker-Compose-网络设置"><a href="#Docker-Compose-网络设置" class="headerlink" title="Docker Compose 网络设置"></a>Docker Compose 网络设置</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>默认情况下，Compose会为我们的应用创建一个网络，服务的每个容器都会加入该网络中。这样，容器就可被该网络中的其他容器访问，不仅如此，该容器还能以服务名称作为hostname被其他容器访问。</p><p>默认情况下，应用程序的网络名称基于Compose的工程名称，而项目名称基于docker-compose.yml所在目录的名称。如需修改工程名称，可使用–project-name标识或COMPOSE_PORJECT_NAME环境变量。</p><p>举个例子，假如一个应用程序在名为myapp的目录中，并且docker-compose.yml如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><p>当我们运行docker-compose up时，将会执行以下几步：</p><ul><li>创建一个名为myapp_default的网络；</li><li>使用web服务的配置创建容器，它以“web”这个名称加入网络myapp_default；</li><li>使用db服务的配置创建容器，它以“db”这个名称加入网络myapp_default。</li></ul><p>容器间可使用服务名称（web或db）作为hostname相互访问。例如，web这个服务可使用<code>postgres://db:5432</code> 访问db容器。</p><h3 id="更新容器"><a href="#更新容器" class="headerlink" title="更新容器"></a>更新容器</h3><p>当服务的配置发生更改时，可使用docker-compose up命令更新配置。</p><p>此时，Compose会删除旧容器并创建新容器。新容器会以不同的IP地址加入网络，名称保持不变。任何指向旧容器的连接都会被关闭，容器会重新找到新容器并连接上去。</p><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>前文讲过，默认情况下，服务之间可使用服务名称相互访问。links允许我们定义一个别名，从而使用该别名访问其他服务。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    links:</span><br><span class="line">      - &quot;db:database&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><p>这样web服务就可使用db或database作为hostname访问db服务了。</p><h3 id="指定自定义网络"><a href="#指定自定义网络" class="headerlink" title="指定自定义网络"></a>指定自定义网络</h3><p>一些场景下，默认的网络配置满足不了我们的需求，此时我们可使用networks命令自定义网络。networks命令允许我们创建更加复杂的网络拓扑并指定自定义网络驱动和选项。不仅如此，我们还可使用networks将服务连接到不是由Compose管理的、外部创建的网络。</p><p>如下，我们在其中定义了两个自定义网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - back</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  back:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: &quot;1&quot;</span><br><span class="line">      bar: &quot;2&quot;</span><br></pre></td></tr></table></figure><p>其中，proxy服务与db服务隔离，两者分别使用自己的网络；app服务可与两者通信。</p><p>由本例不难发现，使用networks命令，即可方便实现服务间的网络隔离与连接。</p><h3 id="配置默认网络"><a href="#配置默认网络" class="headerlink" title="配置默认网络"></a>配置默认网络</h3><p>除自定义网络外，我们也可为默认网络自定义配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br></pre></td></tr></table></figure><p>这样，就可为该应用指定自定义的网络驱动。</p><h3 id="使用已存在的网络"><a href="#使用已存在的网络" class="headerlink" title="使用已存在的网络"></a>使用已存在的网络</h3><p>一些场景下，我们并不需要创建新的网络，而只需加入已存在的网络，此时可使用external选项。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: my-pre-existing-network</span><br></pre></td></tr></table></figure><h3 id="Docker-Compose-链接外部容器的几种方式"><a href="#Docker-Compose-链接外部容器的几种方式" class="headerlink" title="Docker Compose 链接外部容器的几种方式"></a>Docker Compose 链接外部容器的几种方式</h3><p>在Docker中，容器之间的链接是一种很常见的操作：它提供了访问其中的某个容器的网络服务而不需要将所需的端口暴露给Docker Host主机的功能。Docker Compose中对该特性的支持同样是很方便的。然而，如果需要链接的容器没有定义在同一个<code>docker-compose.yml</code>中的时候，这个时候就稍微麻烦复杂了点。</p><p>在不使用Docker Compose的时候，将两个容器链接起来使用<code>—link</code>参数，相对来说比较简单，以<code>nginx</code>镜像为例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --name test1 -d nginx  #开启一个实例test1</span><br><span class="line">docker run --rm --name test2 --link test1 -d nginx #开启一个实例test2并与test1建立链接</span><br></pre></td></tr></table></figure><p>这样，<code>test2</code>与<code>test1</code>便建立了链接，就可以在<code>test2</code>中使用访问<code>test1</code>中的服务了。</p><p>如果使用Docker Compose，那么这个事情就更简单了，还是以上面的<code>nginx</code>镜像为例子，编辑<code>docker-compose.yml</code>文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    depends_on:</span><br><span class="line">      - test1</span><br><span class="line">    links:</span><br><span class="line">      - test1</span><br><span class="line">  test1:</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure><p>最终效果与使用普通的Docker命令<code>docker run xxxx</code>建立的链接并无区别。这只是一种最为理想的情况。</p><ol><li>如果容器没有定义在同一个<code>docker-compose.yml</code>文件中，应该如何链接它们呢？</li><li>又如果定义在<code>docker-compose.yml</code>文件中的容器需要与<code>docker run xxx</code>启动的容器链接，需要如何处理？</li></ol><p>针对这两种典型的情况，下面给出我个人测试可行的办法：</p><h3 id="方式一：让需要链接的容器同属一个外部网络"><a href="#方式一：让需要链接的容器同属一个外部网络" class="headerlink" title="方式一：让需要链接的容器同属一个外部网络"></a>方式一：让需要链接的容器同属一个外部网络</h3><p>我们还是使用nginx镜像来模拟这样的一个情景：假设我们需要将两个使用Docker Compose管理的nignx容器（<code>test1</code>和<code>test2</code>）链接起来，使得<code>test2</code>能够访问<code>test1</code>中提供的服务，这里我们以能ping通为准。</p><p>首先，我们定义容器<code>test1</code>的<code>docker-compose.yml</code>文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: test1</span><br><span class="line">    networks:</span><br><span class="line">      - default</span><br><span class="line">      - app_net</span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure><p>容器<code>test2</code>内容与<code>test1</code>基本一样，只是多了一个<code>external_links</code>,需要特别说明的是：<strong>最近发布的Docker版本已经不需要使用external_links来链接容器，容器的DNS服务可以正确的作出判断</strong>，因此如果你你需要兼容较老版本的Docker的话，那么容器<code>test2</code>的<code>docker-compose.yml</code>文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  test2:</span><br><span class="line">    image: nginx</span><br><span class="line">    networks:</span><br><span class="line">      - default</span><br><span class="line">      - app_net</span><br><span class="line">    external_links:</span><br><span class="line">      - test1</span><br><span class="line">    container_name: test2</span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure><p>否则的话，<code>test2</code>的<code>docker-compose.yml</code>和<code>test1</code>的定义完全一致，不需要额外多指定一个<code>external_links</code>。相关的问题请参见stackoverflow上的相关问题：<a href="https://stackoverflow.com/questions/39067295/docker-compose-external-container" target="_blank" rel="noopener">docker-compose + external container</a></p><p>正如你看到的那样，这里两个容器的定义里都使用了同一个外部网络<code>app_net</code>,因此，我们需要在启动这两个容器之前通过以下命令再创建外部网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create app_net</span><br></pre></td></tr></table></figure><p>之后，通过<code>docker-compose up -d</code>命令启动这两个容器，然后执行<code>docker exec -it test2 ping test1</code>,你将会看到如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it test2 ping test1</span><br><span class="line">PING test1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.146 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.150 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.145 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.126 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=5 ttl=64 time=0.147 ms</span><br></pre></td></tr></table></figure><p>证明这两个容器是成功链接了，反过来在<code>test1</code>中ping<code>test2</code>也是能够正常ping通的。</p><p>如果我们通过<code>docker run --rm --name test3 -d nginx</code>这种方式来先启动了一个容器(<code>test3</code>)并且没有指定它所属的外部网络，而需要将其与<code>test1</code>或者<code>test2</code>链接的话，这个时候手动链接外部网络即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect app_net test3</span><br></pre></td></tr></table></figure><p>这样，三个容器都可以相互访问了。</p><h3 id="方式二：更改需要链接的容器的网络模式"><a href="#方式二：更改需要链接的容器的网络模式" class="headerlink" title="方式二：更改需要链接的容器的网络模式"></a>方式二：更改需要链接的容器的网络模式</h3><p>通过更改你想要相互链接的容器的网络模式为<code>bridge</code>,并指定需要链接的外部容器（<code>external_links</code>)即可。与同属外部网络的容器可以相互访问的链接方式一不同，这种方式的访问是单向的。</p><p>还是以nginx容器镜像为例子，如果容器实例<code>nginx1</code>需要访问容器实例<code>nginx2</code>，那么<code>nginx2</code>的<code>doker-compose.yml</code>定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx2:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx2</span><br><span class="line">    network_mode: bridge</span><br></pre></td></tr></table></figure><p>与其对应的，<code>nginx1</code>的<code>docker-compose.yml</code>定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx1:</span><br><span class="line">    image: nginx</span><br><span class="line">    external_links:</span><br><span class="line">      - nginx2</span><br><span class="line">    container_name: nginx1</span><br><span class="line">    network_mode: bridge</span><br></pre></td></tr></table></figure><blockquote><p>需要特别说明的是，这里的<code>external_links</code>是不能省略的，而且<code>nginx1</code>的启动必须要在<code>nginx2</code>之后，否则可能会报找不到容器<code>nginx2</code>的错误。</p></blockquote><p>接着我们使用ping来测试下连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it nginx1 ping nginx2  # nginx1 to nginx2</span><br><span class="line">PING nginx2 (172.17.0.4): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=0 ttl=64 time=0.141 ms</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.139 ms</span><br><span class="line">64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.145 ms</span><br><span class="line"></span><br><span class="line">$ docker exec -it nginx2 ping nginx1 #nginx2 to nginx1</span><br><span class="line">ping: unknown host</span><br></pre></td></tr></table></figure><p>以上也能充分证明这种方式是属于单向联通的。</p><p>在实际应用中根据自己的需要灵活的选择这两种链接方式，如果想偷懒的话，大可选择第二种。不过我更推荐第一种，不难看出无论是联通性还是灵活性，第一种都比较好。</p><p>附docker-compose.yml文件详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line">Compose和Docker兼容性：</span><br><span class="line">    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x</span><br><span class="line">    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本</span><br><span class="line"></span><br><span class="line">常用参数：</span><br><span class="line">    version           # 指定 compose 文件的版本</span><br><span class="line">    services          # 定义所有的 service 信息, services 下面的第一级别的 key 是一个 service 的名称</span><br><span class="line"></span><br><span class="line">        build                 # 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span><br><span class="line">            context               # context: 指定 Dockerfile 文件所在的路径</span><br><span class="line">            dockerfile            # dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span><br><span class="line">            args                  # args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span><br><span class="line">            cache_from            # v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span><br><span class="line">            labels                # v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span><br><span class="line">            shm_size              # v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span><br><span class="line"></span><br><span class="line">        command               # 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span><br><span class="line"></span><br><span class="line">        configs               # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        cgroup_parent         # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        container_name        # 指定容器的名称 (等同于 docker run --name 的作用)</span><br><span class="line"></span><br><span class="line">        credential_spec       # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        deploy                # v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span><br><span class="line">            endpoint_mode         # v3.3 版本中新增的功能, 指定服务暴露的方式</span><br><span class="line">                vip                   # Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span><br><span class="line">                dnsrr                 # DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span><br><span class="line">            labels                # 指定服务的标签，这些标签仅在服务上设置</span><br><span class="line">            mode                  # 指定 deploy 的模式</span><br><span class="line">                global                # 每个集群节点都只有一个容器</span><br><span class="line">                replicated            # 用户可以指定集群中容器的数量(默认)</span><br><span class="line">            placement             # 不知道怎么用</span><br><span class="line">            replicas              # deploy 的 mode 为 replicated 时, 指定容器副本的数量</span><br><span class="line">            resources             # 资源限制</span><br><span class="line">                limits                # 设置容器的资源限制</span><br><span class="line">                    cpus: &quot;0.5&quot;           # 设置该容器最多只能使用 50% 的 CPU </span><br><span class="line">                    memory: 50M           # 设置该容器最多只能使用 50M 的内存空间 </span><br><span class="line">                reservations          # 设置为容器预留的系统资源(随时可用)</span><br><span class="line">                    cpus: &quot;0.2&quot;           # 为该容器保留 20% 的 CPU</span><br><span class="line">                    memory: 20M           # 为该容器保留 20M 的内存空间</span><br><span class="line">            restart_policy        # 定义容器重启策略, 用于代替 restart 参数</span><br><span class="line">                condition             # 定义容器重启策略(接受三个参数)</span><br><span class="line">                    none                  # 不尝试重启</span><br><span class="line">                    on-failure            # 只有当容器内部应用程序出现问题才会重启</span><br><span class="line">                    any                   # 无论如何都会尝试重启(默认)</span><br><span class="line">                delay                 # 尝试重启的间隔时间(默认为 0s)</span><br><span class="line">                max_attempts          # 尝试重启次数(默认一直尝试重启)</span><br><span class="line">                window                # 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span><br><span class="line">            update_config         # 用于配置滚动更新配置</span><br><span class="line">                parallelism           # 一次性更新的容器数量</span><br><span class="line">                delay                 # 更新一组容器之间的间隔时间</span><br><span class="line">                failure_action        # 定义更新失败的策略</span><br><span class="line">                    continue              # 继续更新</span><br><span class="line">                    rollback              # 回滚更新</span><br><span class="line">                    pause                 # 暂停更新(默认)</span><br><span class="line">                monitor               # 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br><span class="line">                max_failure_ratio     # 回滚期间容忍的失败率(默认值为0)</span><br><span class="line">                order                 # v3.4 版本中新增的参数, 回滚期间的操作顺序</span><br><span class="line">                    stop-first            #旧任务在启动新任务之前停止(默认)</span><br><span class="line">                    start-first           #首先启动新任务, 并且正在运行的任务暂时重叠</span><br><span class="line">            rollback_config       # v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span><br><span class="line">                parallelism           # 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span><br><span class="line">                delay                 # 每个组回滚之间的时间间隔(默认为0)</span><br><span class="line">                failure_action        # 定义回滚失败的策略</span><br><span class="line">                    continue              # 继续回滚</span><br><span class="line">                    pause                 # 暂停回滚</span><br><span class="line">                monitor               # 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br><span class="line">                max_failure_ratio     # 回滚期间容忍的失败率(默认值0)</span><br><span class="line">                order                 # 回滚期间的操作顺序</span><br><span class="line">                    stop-first            # 旧任务在启动新任务之前停止(默认)</span><br><span class="line">                    start-first           # 首先启动新任务, 并且正在运行的任务暂时重叠</span><br><span class="line"></span><br><span class="line">            注意：</span><br><span class="line">                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项</span><br><span class="line">                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent</span><br><span class="line">                network_mode  external_links  restart  build  userns_mode  sysctls</span><br><span class="line"></span><br><span class="line">        devices               # 指定设备映射列表 (等同于 docker run --device 的作用)</span><br><span class="line"></span><br><span class="line">        depends_on            # 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span><br><span class="line">            示例：</span><br><span class="line">                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动</span><br><span class="line">                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系</span><br><span class="line">                version: &apos;3&apos;</span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        build: .</span><br><span class="line">                        depends_on:</span><br><span class="line">                            - db      </span><br><span class="line">                            - redis  </span><br><span class="line">                    redis:</span><br><span class="line">                        image: redis</span><br><span class="line">                    db:</span><br><span class="line">                        image: postgres                             </span><br><span class="line"></span><br><span class="line">        dns                   # 设置 DNS 地址(等同于 docker run --dns 的作用)</span><br><span class="line"></span><br><span class="line">        dns_search            # 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span><br><span class="line"></span><br><span class="line">        tmpfs                 # v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        entrypoint            # 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span><br><span class="line"></span><br><span class="line">        env_file              # 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span><br><span class="line">            文件格式：</span><br><span class="line">                RACK_ENV=development </span><br><span class="line"></span><br><span class="line">        environment           # 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span><br><span class="line"></span><br><span class="line">        expose                # 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span><br><span class="line"></span><br><span class="line">        external_links        # 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        extra_hosts           # 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span><br><span class="line"></span><br><span class="line">        healthcheck           # v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span><br><span class="line">            test                  # 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span><br><span class="line">                NONE                  # 禁用容器的健康状态检测</span><br><span class="line">                CMD                   # test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">                CMD-SHELL             # test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1</span><br><span class="line">            interval: 1m30s       # 每次检查之间的间隔时间</span><br><span class="line">            timeout: 10s          # 运行命令的超时时间</span><br><span class="line">            retries: 3            # 重试次数</span><br><span class="line">            start_period: 40s     # v3.4 以上新增的选项, 定义容器启动时间间隔</span><br><span class="line">            disable: true         # true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span><br><span class="line"></span><br><span class="line">        image                 # 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span><br><span class="line"></span><br><span class="line">        init                  # v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span><br><span class="line"></span><br><span class="line">        isolation             # 隔离容器技术, 在 Linux 中仅支持 default 值</span><br><span class="line"></span><br><span class="line">        labels                # 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span><br><span class="line"></span><br><span class="line">        links                 # 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        logging               # 设置容器日志服务</span><br><span class="line">            driver                # 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span><br><span class="line">            options               # 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span><br><span class="line">                max-size              # 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span><br><span class="line">                max-file              # 日志文件保留的数量</span><br><span class="line"></span><br><span class="line">        network_mode          # 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span><br><span class="line"></span><br><span class="line">        networks              # 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span><br><span class="line">            aliases               # 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span><br><span class="line">            ipv4_address      # IP V4 格式</span><br><span class="line">            ipv6_address      # IP V6 格式</span><br><span class="line"></span><br><span class="line">            示例:</span><br><span class="line">                version: &apos;3.7&apos;</span><br><span class="line">                services: </span><br><span class="line">                    test: </span><br><span class="line">                        image: nginx:1.14-alpine</span><br><span class="line">                        container_name: mynginx</span><br><span class="line">                        command: ifconfig</span><br><span class="line">                        networks: </span><br><span class="line">                            app_net:                                # 调用下面 networks 定义的 app_net 网络</span><br><span class="line">                            ipv4_address: 172.16.238.10</span><br><span class="line">                networks:</span><br><span class="line">                    app_net:</span><br><span class="line">                        driver: bridge</span><br><span class="line">                        ipam:</span><br><span class="line">                            driver: default</span><br><span class="line">                            config:</span><br><span class="line">                                - subnet: 172.16.238.0/24</span><br><span class="line"></span><br><span class="line">        pid: &apos;host&apos;           # 共享宿主机的 进程空间(PID)</span><br><span class="line"></span><br><span class="line">        ports                 # 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                - &quot;3000&quot;                            # 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span><br><span class="line">                - &quot;3000-3005&quot;                       # 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span><br><span class="line">                - &quot;8000:8000&quot;                       # 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span><br><span class="line">                - &quot;9090-9091:8080-8081&quot;</span><br><span class="line">                - &quot;127.0.0.1:8001:8001&quot;             # 指定映射宿主机的指定地址的</span><br><span class="line">                - &quot;127.0.0.1:5000-5010:5000-5010&quot;   </span><br><span class="line">                - &quot;6060:6060/udp&quot;                   # 指定协议</span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                ports:</span><br><span class="line">                    - target: 80                    # 容器端口</span><br><span class="line">                      published: 8080               # 宿主机端口</span><br><span class="line">                      protocol: tcp                 # 协议类型</span><br><span class="line">                      mode: host                    # host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span><br><span class="line"></span><br><span class="line">        secrets               # 不知道怎么用</span><br><span class="line"></span><br><span class="line">        security_opt          # 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        stop_grace_period     # 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span><br><span class="line"></span><br><span class="line">        stop_signal           # 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        sysctls               # 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        ulimits               # 设置容器的 limit</span><br><span class="line"></span><br><span class="line">        userns_mode           # 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span><br><span class="line"></span><br><span class="line">        volumes               # 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span><br><span class="line">            SHORT 语法格式示例:</span><br><span class="line">                volumes:</span><br><span class="line">                    - /var/lib/mysql                # 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span><br><span class="line">                    - /opt/data:/var/lib/mysql      # 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span><br><span class="line">                    - ./cache:/tmp/cache            # 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span><br><span class="line">                    - ~/configs:/etc/configs/:ro    # 映射容器宿主机的目录到容器中去, 权限只读</span><br><span class="line">                    - datavolume:/var/lib/mysql     # datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span><br><span class="line"></span><br><span class="line">            LONG 语法格式示例:(v3.2 新增的语法格式)</span><br><span class="line">                version: &quot;3.2&quot;</span><br><span class="line">                services:</span><br><span class="line">                    web:</span><br><span class="line">                        image: nginx:alpine</span><br><span class="line">                        ports:</span><br><span class="line">                            - &quot;80:80&quot;</span><br><span class="line">                        volumes:</span><br><span class="line">                            - type: volume                  # mount 的类型, 必须是 bind、volume 或 tmpfs</span><br><span class="line">                                source: mydata              # 宿主机目录</span><br><span class="line">                                target: /data               # 容器目录</span><br><span class="line">                                volume:                     # 配置额外的选项, 其 key 必须和 type 的值相同</span><br><span class="line">                                    nocopy: true                # volume 额外的选项, 在创建卷时禁用从容器复制数据</span><br><span class="line">                            - type: bind                    # volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span><br><span class="line">                                source: ./static</span><br><span class="line">                                target: /opt/app/static</span><br><span class="line">                                read_only: true             # 设置文件系统为只读文件系统</span><br><span class="line">                volumes:</span><br><span class="line">                    mydata:                                 # 定义在 volume, 可在所有服务中调用</span><br><span class="line"></span><br><span class="line">        restart               # 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span><br><span class="line">            no                    # 禁止自动重启容器(默认)</span><br><span class="line">            always                # 无论如何容器都会重启</span><br><span class="line">            on-failure            # 当出现 on-failure 报错时, 容器重新启动</span><br><span class="line"></span><br><span class="line">        其他选项：</span><br><span class="line">            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir</span><br><span class="line">            上面这些选项都只接受单个值和 docker run 的对应参数类似</span><br><span class="line"></span><br><span class="line">        对于值为时间的可接受的值：</span><br><span class="line">            2.5s</span><br><span class="line">            10s</span><br><span class="line">            1m30s</span><br><span class="line">            2h32m</span><br><span class="line">            5h34m56s</span><br><span class="line">            时间单位: us, ms, s, m， h</span><br><span class="line">        对于值为大小的可接受的值：</span><br><span class="line">            2b</span><br><span class="line">            1024kb</span><br><span class="line">            2048k</span><br><span class="line">            300m</span><br><span class="line">            1gb</span><br><span class="line">            单位: b, k, m, g 或者 kb, mb, gb</span><br><span class="line">    networks          # 定义 networks 信息</span><br><span class="line">        driver                # 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span><br><span class="line">            bridge                # Docker 默认使用 bridge 连接单个主机上的网络</span><br><span class="line">            overlay               # overlay 驱动程序创建一个跨多个节点命名的网络</span><br><span class="line">            host                  # 共享主机网络名称空间(等同于 docker run --net=host)</span><br><span class="line">            none                  # 等同于 docker run --net=none</span><br><span class="line">        driver_opts           # v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span><br><span class="line">        attachable            # driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span><br><span class="line">        ipam                  # 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span><br><span class="line">            driver                # IPAM 驱动程序, bridge 或者 default</span><br><span class="line">            config                # 配置项</span><br><span class="line">                subnet                # CIDR格式的子网，表示该网络的网段</span><br><span class="line">        external              # 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span><br><span class="line">        name                  # v3.5 以上版本, 为此网络设置名称</span><br><span class="line">文件格式示例：</span><br><span class="line">    version: &quot;3&quot;</span><br><span class="line">    services:</span><br><span class="line">      redis:</span><br><span class="line">        image: redis:alpine</span><br><span class="line">        ports:</span><br><span class="line">          - &quot;6379&quot;</span><br><span class="line">        networks:</span><br><span class="line">          - frontend</span><br><span class="line">        deploy:</span><br><span class="line">          replicas: 2</span><br><span class="line">          update_config:</span><br><span class="line">            parallelism: 2</span><br><span class="line">            delay: 10s</span><br><span class="line">          restart_policy:</span><br><span class="line">            condition: on-failure</span><br><span class="line">      db:</span><br><span class="line">        image: postgres:9.4</span><br><span class="line">        volumes:</span><br><span class="line">          - db-data:/var/lib/postgresql/data</span><br><span class="line">        networks:</span><br><span class="line">          - backend</span><br><span class="line">        deploy:</span><br><span class="line">          placement:</span><br><span class="line">            constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      Docker compose 网络设置以打通同一宿主机的多个容器
    
    </summary>
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>python with的原理及在异常处理中的应用</title>
    <link href="https://cloudsjhan.github.io/2019/09/11/python-with%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://cloudsjhan.github.io/2019/09/11/python-with的原理及在异常处理中的应用/</id>
    <published>2019-09-11T03:37:54.000Z</published>
    <updated>2019-09-11T03:39:08.498Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>只要对象内实现 <strong>enter</strong>() 和 <strong>exit</strong>() 方法，就能兼容 with 语句，触发上下文管理。 </p><p>一、上下文管理的简单执行流程<br>with 工作原理 （１）紧跟with后面的语句被求值后，返回对象的“<strong>enter</strong>()”方法被调用，这个方法的返回值将被赋值给as后面的变量； （２）当with后面的代码块全部被执行完之后，将调用前面返回对象的“<strong>exit</strong>()”方法。</p><p>class Sample:<br>    def <strong>enter</strong>(self):<br>        print “in <strong>enter</strong>“<br>        return “Foo”<br>    def <strong>exit</strong>(self, exc_type, exc_val, exc_tb):<br>        ‘’’<br>        若在执行流程中因为错误而退出，调用exit时，会自动捕获错误信息<br>        exc_type：　错误的类型(异常类型)<br>        exc_val：　错误类型对应的值 (异常值)<br>        exc_tb：　代码中错误发生的位置 (错误栈)<br>        ‘’’<br>        print “in <strong>exit</strong>“</p><p>def get_sample():<br>    return Sample()</p><p>with get_sample() as sample:<br>    print “Sample: “, sample<br>‘’’<br>流程总结：<br>1- 执行get_sample()函数<br>2- 函数内实例化Sample对象，执行<strong>enter</strong>返回字符串赋予sample变量<br>3- 执行with内的代码块，输出sample变量值<br>4- 执行Sample对象内的<strong>exit</strong>方法<br>‘’’<br>二、错误执行流程<br>class Sample():<br>    def <strong>enter</strong>(self):<br>        print(‘in enter’)<br>        return self</p><pre><code>def __exit__(self, exc_type, exc_val, exc_tb):    print &quot;type: &quot;, exc_type    print &quot;val: &quot;, exc_val    print &quot;tb: &quot;, exc_tbdef do_something(self):    bar = 1 / 0    return bar + 10</code></pre><p>with Sample() as sample:<br>    sample.do_something()</p><p>‘’’<br>in enter<br>Traceback (most recent call last):<br>type:  <type 'exceptions.zerodivisionerror'=""><br>val:  integer division or modulo by zero<br>  File “/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py”, line 36, in <module><br>tb:  <traceback object="" at="" 0x7f9e13fc6050=""><br>    sample.do_something()<br>  File “/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py”, line 32, in do_something<br>    bar = 1 / 0<br>ZeroDivisionError: integer division or modulo by zero</traceback></module></type></p><p>Process finished with exit code 1</p><p>‘’’<br>三、异常处理 with 应用<br>异常处理逻辑太多，以至于扰乱了代码核心逻辑。具体表现就是，代码里充斥着大量的 try、except、raise 语句，让核心逻辑变得难以辨识。</p><p>def upload_avatar(request):<br>    “””用户上传新头像”””<br>    try:<br>        avatar_file = request.FILES[‘avatar’]<br>    except KeyError:<br>        raise error_codes.AVATAR_FILE_NOT_PROVIDED</p><pre><code>try:   resized_avatar_file = resize_avatar(avatar_file)except FileTooLargeError as e:    raise error_codes.AVATAR_FILE_TOO_LARGEexcept ResizeAvatarError as e:    raise error_codes.AVATAR_FILE_INVALIDtry:    request.user.avatar = resized_avatar_file    request.user.save()except Exception:    raise error_codes.INTERNAL_SERVER_ERRORreturn HttpResponse({})</code></pre><p>这是一个处理用户上传头像的视图函数。这个函数内做了三件事情，并且针对每件事都做了异常捕获。如果做某件事时发生了异常，就返回对用户友好的错误到前端。</p><p>这样的处理流程纵然合理，但是显然代码里的异常处理逻辑有点“喧宾夺主”了。一眼看过去全是代码缩进，很难提炼出代码的核心逻辑。</p><p>早在 2.5 版本时，Python 语言就已经提供了对付这类场景的工具：“上下文管理器（context manager）”。上下文管理器是一种配合 with 语句使用的特殊 Python 对象，通过它，可以让异常处理工作变得更方便。</p><p>class raise_api_error:<br>    “””<br>    captures specified exception and raise ApiErrorCode instead<br>    捕获指定的异常并改为引发ApiErrorCode<br>    :raises: AttributeError if code_name is not valid<br>    “””<br>    def <strong>init</strong>(self, captures, code_name):<br>        self.captures = captures<br>        self.code = getattr(error_codes, code_name)</p><pre><code>def __enter__(self):    # 刚方法将在进入上下文时调用    return selfdef __exit__(self, exc_type, exc_val, exc_tb):    # 该方法将在退出上下文时调用    # exc_type, exc_val, exc_tb 分别表示该上下文内抛出的    # 异常类型、异常值、错误栈    if exc_type is None:        return False    if exc_type == self.captures:        raise self.code from exc_val    return False</code></pre><p>在上面的代码里，我们定义了一个名为 raise_api_error 的上下文管理器，它在进入上下文时什么也不做。但是在退出上下文时，会判断当前上下文中是否抛出了类型为 self.captures 的异常，如果有，就用 APIErrorCode 异常类替代它。</p><p>使用该上下文管理器后，整个函数可以变得更清晰简洁：</p><p>def upload_avatar(request):<br>    “””用户上传新头像”””<br>    with raise_api_error(KeyError, ‘AVATAR_FILE_NOT_PROVIDED’):<br>        avatar_file = request.FILES[‘avatar’]</p><pre><code>with raise_api_error(ResizeAvatarError, &apos;AVATAR_FILE_INVALID&apos;),\        raise_api_error(FileTooLargeError, &apos;AVATAR_FILE_TOO_LARGE&apos;):    resized_avatar_file = resize_avatar(avatar_file)with raise_api_error(Exception, &apos;INTERNAL_SERVER_ERROR&apos;):    request.user.avatar = resized_avatar_file    request.user.save()return HttpResponse({})</code></pre><p>四、raies 和 raise……from 的区别</p><blockquote><blockquote><blockquote><p>try:<br>…     print(1 / 0)<br>… except:<br>…     raise RuntimeError(“Something bad happened”)<br>…</p></blockquote></blockquote></blockquote><p>Traceback (most recent call last):<br>  File “<stdin>“, line 2, in <module><br>ZeroDivisionError: division by zero</module></stdin></p><h1 id="在处理上述异常期间，发生了另一个异常："><a href="#在处理上述异常期间，发生了另一个异常：" class="headerlink" title="在处理上述异常期间，发生了另一个异常："></a>在处理上述异常期间，发生了另一个异常：</h1><p>During handling of the above exception, another exception occurred:</p><p>Traceback (most recent call last):<br>  File “<stdin>“, line 4, in <module><br>RuntimeError: Something bad happened</module></stdin></p><blockquote><blockquote><blockquote><p>try:<br>…     print(1 / 0)<br>… except Exception as exc:<br>…     raise RuntimeError(“Something bad happened”) from exc<br>…</p></blockquote></blockquote></blockquote><p>Traceback (most recent call last):<br>  File “<stdin>“, line 2, in <module><br>ZeroDivisionError: division by zero</module></stdin></p><h1 id="上述异常是以下异常的直接原因："><a href="#上述异常是以下异常的直接原因：" class="headerlink" title="上述异常是以下异常的直接原因："></a>上述异常是以下异常的直接原因：</h1><p>The above exception was the direct cause of the following exception:</p><p>Traceback (most recent call last):<br>  File “<stdin>“, line 4, in <module><br>RuntimeError: Something bad happened<br>不同之处在于，from 会为异常对象设置 <em>cause</em> 属性表明异常的是由谁直接引起的。</module></stdin></p><p>处理异常时发生了新的异常，在不使用 from 时更倾向于新异常与正在处理的异常没有关联。而 from 则是能指出新异常是因旧异常直接引起的。这样的异常之间的关联有助于后续对异常的分析和排查。from 语法会有个限制，就是第二个表达式必须是另一个异常类或实例。</p><p>如果在异常处理程序或 finally 块中引发异常，默认情况下，异常机制会隐式工作会将先前的异常附加为新异常的 _context _属性。</p><p>当然，也可以通过 with_traceback() 方法为异常设置上下文 <em>context</em> 属性，这也能在 traceback 更好的显示异常信息。</p><hr>]]></content>
    
    <summary type="html">
    
      python with的原理及在异常处理中的应用
    
    </summary>
    
      <category term="Python" scheme="https://cloudsjhan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://cloudsjhan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP详解--TCP连接中time_wait状态过多</title>
    <link href="https://cloudsjhan.github.io/2019/09/10/TCP-IP%E8%AF%A6%E8%A7%A3-TCP%E8%BF%9E%E6%8E%A5%E4%B8%ADtime-wait%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A/"/>
    <id>https://cloudsjhan.github.io/2019/09/10/TCP-IP详解-TCP连接中time-wait状态过多/</id>
    <published>2019-09-10T06:00:46.000Z</published>
    <updated>2019-09-10T06:02:48.381Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>本文链接：<a href="https://blog.csdn.net/yusiguyuan/article/details/21445883" target="_blank" rel="noopener">https://blog.csdn.net/yusiguyuan/article/details/21445883</a><br>TIMEWAIT状态本身和应用层的客户端或者服务器是没有关系的。仅仅是主动关闭的一方，在使用FIN|ACK|FIN|ACK四分组正常关闭TCP连接的时候会出现这个TIMEWAIT。服务器在处理客户端请求的时候，如果你的程序设计为服务器主动关闭，那么你才有可能需要关注这个TIMEWAIT状态过多的问题。如果你的服务器设计为被动关闭，那么你首先要关注的是CLOSE_WAIT。</p><p>原则<br>TIMEWAIT并不是多余的。在TCP协议被创造，经历了大量的实际场景实践之后，TIMEWAIT出现了，因为TCP主动关闭连接的一方需要TIMEWAIT状态，它是我们的朋友。这是《UNIX网络编程》的作者—-Steven对TIMEWAIT的态度。</p><p>TIMEWAIT是友好的<br>    TCP要保证在所有可能的情况下使得所有的数据都能够被正确送达。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态，这的确能够保证所有的数据都被传输。当一个socket关闭的时候，是通过两端四次握手完成的，当一端调用close()时，就说明本端没有数据要发送了。这好似看来在握手完成以后，socket就都可以处于初始的CLOSED状态了，其实不然。原因是这样安排状态有两个问题， 首先，我们没有任何机制保证最后的一个ACK能够正常传输，第二，网络上仍然有可能有残余的数据包(wandering duplicates)，我们也必须能够正常处理。<br>TIMEWAIT就是为了解决这两个问题而生的。<br>1.假设最后一个ACK丢失了，被动关闭一方会重发它的FIN。主动关闭一方必须维持一个有效状态信息（TIMEWAIT状态下维持），以便能够重发ACK。如果主动关闭的socket不维持这种状态而进入CLOSED状态，那么主动关闭的socket在处于CLOSED状态时，接收到FIN后将会响应一个RST。被动关闭一方接收到RST后会认为出错了。如果TCP协议想要正常完成必要的操作而终止双方的数据流传输，就必须完全正确的传输四次握手的四个节，不能有任何的丢失。这就是为什么socket在关闭后，仍然处于TIME_WAIT状态的第一个原因，因为他要等待以便重发ACK。</p><p>2.假设目前连接的通信双方都已经调用了close()，双方同时进入CLOSED的终结状态，而没有走TIME_WAIT状态。会出现如下问题，现在有一个新的连接被建立起来，使用的IP地址与端口与先前的完全相同，后建立的连接是原先连接的一个完全复用。还假定原先的连接中有数据报残存于网络之中，这样新的连接收到的数据报中有可能是先前连接的数据报。为了防止这一点，TCP不允许新连接复用TIME_WAIT状态下的socket。处于TIME_WAIT状态的socket在等待两倍的MSL时间以后（之所以是两倍的MSL，是由于MSL是一个数据报在网络中单向发出到认定丢失的时间，一个数据报有可能在发送途中或是其响应过程中成为残余数据报，确认一个数据报及其响应的丢弃的需要两倍的MSL），将会转变为CLOSED状态。这就意味着，一个成功建立的连接，必然使得先前网络中残余的数据报都丢失了。</p><p>大量TIMEWAIT在某些场景中导致的令人头疼的业务问题<br>大量TIMEWAIT出现，并且需要解决的场景<br>      在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。。。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。<br>我来解释下这个场景。主动正常关闭TCP连接，都会出现TIMEWAIT。为什么我们要关注这个高并发短连接呢？有两个方面需要注意：</p><ol><li>高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</li><li>在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。这里有个相对长短的概念，比如，取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高）<br>综合这两个方面，持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。同时，这些端口都是服务器临时分配，无法用SO_REUSEADDR选项解决这个问题:(</li></ol><p>一对矛盾<br>TIMEWAIT既友好，又令人头疼。<br>但是我们还是要抱着一个友好的态度来看待它，因为它尽它的能力保证了服务器的健壮性。</p><p>可行而且必须存在，但是不符合原则的解决方式</p><ol><li>linux没有在sysctl或者proc文件系统暴露修改这个TIMEWAIT超时时间的接口，可以修改内核协议栈代码中关于这个TIMEWAIT的超时时间参数，重编内核，让它缩短超时时间，加快回收；</li><li>利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。详见我的博文《TCP之选项SO_LINGER》。</li></ol><p>我如何看待这个问题<br>为什么说上述两种解决方式我觉得可行，但是不符合原则？<br>我首先认为，我要依靠TIMEWAIT状态来保证我的服务器程序健壮，网络上发生的乱七八糟的问题太多了，我先要服务功能正常。<br>那是不是就不要性能了呢？并不是。如果服务器上跑的短连接业务量到了我真的必须处理这个TIMEWAIT状态过多的问题的时候，我的原则是尽量处理，而不是跟TIMEWAIT干上，非先除之而后快：）如果尽量处理了，还是解决不了问题，仍然拒绝服务部分请求，那我会采取分机器的方法，让多台机器来抗这些高并发的短请求。持续十万并发的短连接请求，两台机器，每台5万个，应该够用了吧。一般的业务量以及国内大部分网站其实并不需要关注这个问题，一句话，达不到需要关注这个问题的访问量。<br>真正地必须使用上述我认为不合理的方式来解决这个问题的场景有没有呢？答案是有。<br>像淘宝、百度、新浪、京东商城这样的站点，由于有很多静态小图片业务，如果过度分服会导致需要上线大量机器，多买机器多花钱，得多配机房，多配备运维工程师来守护这些机器，成本增长非常严重。。。这个时候就要尽一切可能去优化。<br>题外话，服务器上的技术问题没有绝对，一切都是为业务需求服务的。</p><p>如何尽量处理TIMEWAIT过多<br>sysctl改两个内核参数就行了，如下：<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_tw_recycle = 1<br>简单来说，就是打开系统的TIMEWAIT重用和快速回收，至于怎么重用和快速回收，这个问题我没有深究，实际场景中这么做确实有效果。用netstat或者ss观察就能得出结论。<br>还有些朋友同时也会打开syncookies这个功能，如下：<br>net.ipv4.tcp_syncookies = 1<br>打开这个syncookies的目的实际上是：“在服务器资源（并非单指端口资源，拒绝服务有很多种资源不足的情况）不足的情况下，尽量不要拒绝TCP的syn（连接）请求，尽量把syn请求缓存起来，留着过会儿有能力的时候处理这些TCP的连接请求”。<br>如果并发量真的非常非常高，打开这个其实用处不大。</p><hr>]]></content>
    
    <summary type="html">
    
      TCP/IP详解--TCP连接中time_wait状态过多
    
    </summary>
    
      <category term="网络" scheme="https://cloudsjhan.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://cloudsjhan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="https://cloudsjhan.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>crawlab的golang后端内存分析及优化-基于go pprof</title>
    <link href="https://cloudsjhan.github.io/2019/08/20/crawlab%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96-%E5%9F%BA%E4%BA%8Ego-pprof/"/>
    <id>https://cloudsjhan.github.io/2019/08/20/crawlab的内存分析及优化-基于go-pprof/</id>
    <published>2019-08-20T11:09:59.000Z</published>
    <updated>2019-08-20T12:12:46.921Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Crawlab发布几个月以来，其中经历过多次迭代，在使用者们的积极反馈下，crawlab爬虫平台逐渐稳定，但是最近有用户报出crawlab启动一段时间后，主节点机器会出现内存占用过高的问题，一台4G内存的机器在运行crawlab后竟然能占用3.5G以上，几乎可以肯定后端服务的某个接口由于代码不规范导致内存占用，于是决定对crawlab进行一次内存分析。</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><p>分析内存光靠手撕代码是比较困难的，总要借助一些工具。Golang pprof是Go官方的profiling工具，非常强大，使用起来也很方便。</p><p>首先，我们在crawlab项目中嵌入如下几行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8888"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>将crawlab后端服务启动后，浏览器中输入<code>http://ip:8899/debug/pprof/</code>就可以看到一个汇总分析页面，显示如下信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line"></span><br><span class="line">profiles:</span><br><span class="line"><span class="number">0</span>    block</span><br><span class="line"><span class="number">32</span>    goroutine</span><br><span class="line"><span class="number">552</span>    heap</span><br><span class="line"><span class="number">0</span>    mutex</span><br><span class="line"><span class="number">51</span>    threadcreate</span><br><span class="line"></span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure><p>点击heap，在汇总分析页面的最上方可以看到如下图所示，红色箭头所指的就是当前已经使用的堆内存是25M,amazing！在我只上传一个爬虫文件的情况下，一个后端服务所用的内存竟然能达到25M</p><p><img src="https://s2.ax1x.com/2019/08/20/mYnJuF.jpg" alt="mYnJuF.jpg"></p><p>接下来我们需要借助<code>go tool pprof</code>来分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof -inuse_space http:<span class="comment">//本机Ip:8888/debug/pprof/heap</span></span><br></pre></td></tr></table></figure><p>这个命令进入后，是一个类似<code>gdb</code>的交互式界面，输入<code>top</code>命令可以前10大的内存分配，<code>flat</code>是堆栈中当前层的inuse内存值，cum是堆栈中本层级的累计inuse内存值（包括调用的函数的inuse内存值，上面的层级）</p><p><a href="https://imgchr.com/i/mYMF91" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/20/mYMF91.png" alt="mYMF91.png"></a></p><p>可以看到，bytes.makeSlice这个内置方法竟然使用了24M内存，继续往下看，可以看到ReadFrom这个方法，搜了一下，发现 <code>ioutil.ReadAll()</code> 里会调用 <code>bytes.Buffer.ReadFrom</code>, 而 <code>bytes.Buffer.ReadFrom</code> 会进行 <code>makeSlice</code>。再回头看一下io/ioutil.readAll的代码实现，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readAll</span><span class="params">(r io.Reader, capacity <span class="keyword">int64</span>)</span> <span class="params">(b []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">    buf := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, capacity))</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        e := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> panicErr, ok := e.(error); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123;</span><br><span class="line">            err = panicErr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    _, err = buf.ReadFrom(r)</span><br><span class="line">    <span class="keyword">return</span> buf.Bytes(), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytes.MinRead = 512</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readAll(r, bytes.MinRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>ioutil.ReadAll</code> 每次都会分配初始化一个大小为 <code>bytes.MinRead</code> 的 buffer ，<code>bytes.MinRead</code> 在 Golang 里是一个常量，值为 <code>512</code> 。就是说每次调用 <code>ioutil.ReadAll</code> 都会分配一块大小为 512 字节的内存，看起来是正常的，但我们再看一下<code>ReadFrom</code>的实现，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadFrom reads data from r until EOF and appends it to the buffer, growing</span></span><br><span class="line"><span class="comment">// the buffer as needed. The return value n is the number of bytes read. Any</span></span><br><span class="line"><span class="comment">// error except io.EOF encountered during the read is also returned. If the</span></span><br><span class="line"><span class="comment">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    b.lastRead = opInvalid</span><br><span class="line">    <span class="comment">// If buffer is empty, reset to recover space.</span></span><br><span class="line">    <span class="keyword">if</span> b.off &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">        b.Truncate(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> free := <span class="built_in">cap</span>(b.buf) - <span class="built_in">len</span>(b.buf); free &lt; MinRead &#123;</span><br><span class="line">            <span class="comment">// not enough space at end</span></span><br><span class="line">            newBuf := b.buf</span><br><span class="line">            <span class="keyword">if</span> b.off+free &lt; MinRead &#123;</span><br><span class="line">                <span class="comment">// not enough space using beginning of buffer;</span></span><br><span class="line">                <span class="comment">// double buffer capacity</span></span><br><span class="line">                newBuf = makeSlice(<span class="number">2</span>*<span class="built_in">cap</span>(b.buf) + MinRead)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">copy</span>(newBuf, b.buf[b.off:])</span><br><span class="line">            b.buf = newBuf[:<span class="built_in">len</span>(b.buf)-b.off]</span><br><span class="line">            b.off = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m, e := r.Read(b.buf[<span class="built_in">len</span>(b.buf):<span class="built_in">cap</span>(b.buf)])</span><br><span class="line">        b.buf = b.buf[<span class="number">0</span> : <span class="built_in">len</span>(b.buf)+m]</span><br><span class="line">        n += <span class="keyword">int64</span>(m)</span><br><span class="line">        <span class="keyword">if</span> e == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n, e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span> <span class="comment">// err is EOF, so return nil explicitly</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要作用就是从 <code>io.Reader</code> 里读取的数据放入 buffer 中，如果 buffer 空间不够，就按照每次 <code>2x + MinRead</code> 的算法递增，这里 <code>MinRead</code> 的大小也是 512 Bytes ，也就是说如果我们一次性读取的文件过大，就会导致所使用的内存倍增，假设我们的爬虫文件总共有500M,那么所用的内存就有500M * 2 + 512B，况且爬虫文件中还带了那么多log文件，那看看crawlab源码中是哪一段使用<code>ioutil.ReadAll</code>读了爬虫文件，定位到了这里：</p><p><a href="https://imgchr.com/i/mYQTWn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/20/mYQTWn.jpg" alt="mYQTWn.jpg"></a></p><p>这里直接将全部的文件内容，以二进制的形式读了进来，导致内存倍增，令人窒息的操作。</p><p>其实在读大文件的时候，把文件内容全部读到内存，直接就翻车了，正确是处理方法有两种，一种是流式处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filePath <span class="keyword">string</span>, handle <span class="keyword">func</span>(<span class="keyword">string</span>)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filePath)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    buf := bufio.NewReader(f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := buf.ReadLine(<span class="string">"\n"</span>)</span><br><span class="line">        line = strings.TrimSpace(line)</span><br><span class="line">        handle(line)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方案就是分片处理，当读取的是二进制文件，没有换行符的时候，使用这种方案比较合适：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadBigFile</span><span class="params">(fileName <span class="keyword">string</span>, handle <span class="keyword">func</span>([]<span class="keyword">byte</span>)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    f, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"can't opened this file"</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, err := f.Read(s[:]); <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading: %s\n"</span>, err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            handle(s[<span class="number">0</span>:nr])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这类采用的第二种方式来优化，优化后再来看下内存分析：</p><p><a href="https://imgchr.com/i/mYltYj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/20/mYltYj.png" alt="mYltYj.png"></a></p><p>占用1M内存，这才是一个正常后端服务该有的内存大小，源码已push到crawlab，可以在GitHub项目源码中阅读。</p><p>最后附上项目链接，<a href="https://github.com/tikazyq/crawlab，为crawlab打电话，欢迎大家一起贡献，让crawlab变得更好用！" target="_blank" rel="noopener">https://github.com/tikazyq/crawlab，为crawlab打电话，欢迎大家一起贡献，让crawlab变得更好用！</a></p><hr>]]></content>
    
    <summary type="html">
    
      crawlab的golang后端内存分析及优化-基于go pprof
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Python中使用正则表达式的环视功能</title>
    <link href="https://cloudsjhan.github.io/2019/08/16/Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%8E%AF%E8%A7%86%E5%8A%9F%E8%83%BD/"/>
    <id>https://cloudsjhan.github.io/2019/08/16/Python中使用正则表达式的环视功能/</id>
    <published>2019-08-16T05:28:30.000Z</published>
    <updated>2019-08-16T05:30:21.477Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><h2 id="什么是环视"><a href="#什么是环视" class="headerlink" title="什么是环视"></a>什么是环视</h2><p>环视只是进行子表达式的匹配，并不占字符，匹配到的内容不保存，因此也叫做零宽断言，环视最终的匹配结果就是一个位置。</p><p>环视按照方向可以分为顺序环视和逆序环视两种，按是否进行匹配分为肯定和否定两种，组合起来就是四种模式。</p><table><thead><tr><th>环视表达式</th><th>解释</th></tr></thead><tbody><tr><td>(?=expression)</td><td>顺序肯定环视，表示所在位置右侧能匹配expression</td></tr><tr><td>(?!rexpression)</td><td>顺序否定环视，表示所在位置右侧不匹配expression</td></tr><tr><td>(?&lt;=expression)</td><td>逆序肯定环视，表示所在位置左侧能匹配expression</td></tr><tr><td>(?&lt;!expression)</td><td>逆序否定环视，表示所在位置左侧不匹配expression</td></tr></tbody></table><p>只说概念可能有些抽象，分别举例子来演示一下具体的使用场景。</p><h3 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h3><ol><li>顺序肯定环视</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s = 'xiaomi9iphone8iphone7',需要在每个手机型号后面加上逗号，变成 s= 'xiaomi9,iphone8,iphone7'</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(re.sub(<span class="string">r'(?=iphone)'</span>,<span class="string">','</span>,s))</span><br><span class="line"><span class="comment"># 顺序肯定环视，所确定的位置右边是字符串iPhone，在此位置即可添加逗号</span></span><br></pre></td></tr></table></figure><ol start="2"><li>逆序肯定环视</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s = 'Takes Reservations:No Delivery:No Take-out:Yes Accepts Credit Cards:Yes Good for Groups:No'</span></span><br><span class="line"><span class="comment"># 需求是要在Yes，和No的后面加上逗号，使之变成</span></span><br><span class="line"><span class="comment"># s = 'Takes Reservations:No, Delivery:No, Take-out:Yes, Accepts Credit Cards:Yes, Good for Groups:No'</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.sub(<span class="string">r"(?&lt;=(No))(?=(\s+))|(?&lt;=(Yes))(?=(\s+))"</span>,<span class="string">','</span>,s)</span><br><span class="line"><span class="comment"># 逆序肯定环视，所要确定的位左边必须能匹配上No,或者Yes</span></span><br></pre></td></tr></table></figure><ol start="3"><li>顺序否定环视</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s = '123aaa',将s字符串变成 s='123,a,a,a,'</span></span><br><span class="line"><span class="comment"># 分析一下，就是在字符串右侧非数字的位置，添加逗号，即使用顺序否定环视，匹配右侧非数字位置</span></span><br><span class="line">s = <span class="string">'123aaa'</span></span><br><span class="line">re.sub(<span class="string">r'(?!\d+)'</span>,<span class="string">','</span>,s)</span><br></pre></td></tr></table></figure><ol start="4"><li>逆序否定环视</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 s= 'aaa123'变成 s=  ',a,a,a,123'</span></span><br><span class="line"><span class="comment"># 分析一下，就是在非数字左侧的位置加逗号，使用逆序否定环视，匹配左侧非数字的位置</span></span><br><span class="line">s= <span class="string">'aaa123'</span></span><br><span class="line">re.sub(<span class="string">r'(?&lt;!\d)'</span>,<span class="string">','</span>,b)</span><br></pre></td></tr></table></figure><p>有些例子不是很合理，尽量能表达清楚环视的含义即可。</p><p>总结：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环视的功能非常强大，也是正则中的一个难点，对于环视的理解，可以从应用和原理两个角度理解，如果想理解得更清晰、深入一些，还是从原理的角度理解好一些，正则匹配基本原理参考 NFA引擎匹配原理</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      正则表达式中的环视功能解析以及在Python中的使用
    
    </summary>
    
      <category term="正则表达式" scheme="https://cloudsjhan.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="https://cloudsjhan.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>centos7 编译、安装、配置、启动redis</title>
    <link href="https://cloudsjhan.github.io/2019/08/02/centos7-%E7%BC%96%E8%AF%91%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E5%90%AF%E5%8A%A8reds/"/>
    <id>https://cloudsjhan.github.io/2019/08/02/centos7-编译、安装、配置、启动reds/</id>
    <published>2019-08-02T09:00:22.000Z</published>
    <updated>2019-08-16T06:17:00.636Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><ol><li><p>下载Redis的安装包</p><p>wget <a href="http://download.redis.io/releases/redis-4.0.6.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.6.tar.gz</a></p></li><li><p>解压</p><p>tar -zxvf redis-4.0.6.tar.gz</p></li><li><p>cd redis-4.0.6</p></li><li><p>编译</p><p>make MALLOC=libc</p></li><li><p>环境配置，将配置文件以你想暴露的Redis为名，复制到/etc/redis</p><p>mkdir /etc/redis(需要root权限)</p><p>cp redis.conf /etc/redis/6379.conf</p></li><li><p>cd utils &amp; vim redis_init_script</p><p>修改 redis_init_script中如图所示的部分</p><p><a href="http://ww1.sinaimg.cn/large/006tNc79gy1g5lgb221p3j316w0j619h.jpg" target="_blank" rel="noopener"></a></p><p>配置chkconfig是为了开机配置开机自启Redis，下面的横线部分换成你自己的Redis安装路径，可选择自己想要暴露的端口</p></li><li><p>将修改后的redis_init_script拷贝至开机启动目录，并修改文件名为redisd, 一般后台服务都已d结尾</p><p>cp redis_init_script /etc/init.d/redisd</p></li><li><p>设置开机启动</p><p>chkconfig redisd on</p><p>如果之前没有在redis_init_script中添加chkconfig,就会提示不支持该命令</p></li><li><p>service redisd start 启动Redis</p></li><li><p>后台启动的话，service redis start &amp;</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      centos7 编译，安装，配置，启动Redis
    
    </summary>
    
      <category term="redis" scheme="https://cloudsjhan.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://cloudsjhan.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据去重</title>
    <link href="https://cloudsjhan.github.io/2019/07/01/mysql%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/"/>
    <id>https://cloudsjhan.github.io/2019/07/01/mysql数据去重/</id>
    <published>2019-07-01T07:40:05.000Z</published>
    <updated>2019-07-01T07:44:23.308Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><img src="https://" alt="" style="width:100%"><p></p><a id="more"></a><p>从excel中导入了一部分数据到mysql中，有很多数据是重复的，而且没有主键，需要按照其中已经存在某一列对数据进行去重。</p><h2 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h2><p>由于之前的字段中没有主键，所以需要新增一个字段，并且将其作为主键。</p><p>添加一个新的字段id，对id中的值进行递增操作，然后再设置为主键。</p><p>对id字段进行递增的赋值操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @r:=0;</span><br><span class="line">UPDATE table SET id=(@r:=@r+1);</span><br></pre></td></tr></table></figure><p>然后设置为主键即可。</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>添加递增的id字段后，就可以对数据根据某个字段进行去重操作，策略就是保存id最小的那条数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM `table`</span><br><span class="line">WHERE</span><br><span class="line">`去重字段名` IN (</span><br><span class="line">    SELECT x FROM</span><br><span class="line">    (</span><br><span class="line">        SELECT `去重字段名` AS x </span><br><span class="line">        FROM `table` </span><br><span class="line">        GROUP BY `去重字段名` </span><br><span class="line">        HAVING COUNT(`去重字段名`) &gt; 1</span><br><span class="line">    ) tmp0</span><br><span class="line">)</span><br><span class="line">AND </span><br><span class="line">`递增主键名` NOT IN (</span><br><span class="line">    SELECT y FROM</span><br><span class="line">    (</span><br><span class="line">        SELECT min(`递增主键名`) AS y </span><br><span class="line">        FROM `table` </span><br><span class="line">        GROUP BY `去重字段名` </span><br><span class="line">        HAVING COUNT(`去重字段名`) &gt; 1</span><br><span class="line">    ) tmp1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      mysql数据去重
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>dokcer.service 提示缺失bridge网络，导致Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</title>
    <link href="https://cloudsjhan.github.io/2019/06/04/dokcer-service-%E6%8F%90%E7%A4%BA%E7%BC%BA%E5%A4%B1bridge%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%AF%BC%E8%87%B4Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running/"/>
    <id>https://cloudsjhan.github.io/2019/06/04/dokcer-service-提示缺失bridge网络，导致Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running/</id>
    <published>2019-06-04T07:25:01.000Z</published>
    <updated>2019-06-06T08:39:54.660Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>操作过程：</p><ol><li><p>为CentOS7安装Docker，安装成功后，可以执行<code>docker</code>，但是<code>docker ps</code>等命令会报错：</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure></li></ol><p>分析：</p><p>一般这种错误都是由于操作者没有root权限，但是使用<code>sudo</code>执行也是同样的问题，这就纳闷了，没关系，看一下<code>docker.service</code>的执行日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker.service</span><br></pre></td></tr></table></figure><p>发现有一句很重要的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error starting daemon: Error initializing network controller: list bridge addresses failed: no available network</span><br></pre></td></tr></table></figure><p>这是由于启动Docker的时候，默认的网络模式是桥接模式，这就需要向操作系统发送信号，让它帮我们建立一个<code>bridge</code>网络命名为<code>docker0</code>, 并且分配<code>172.17.0.1/16</code>。但是出于某种原因，该网络没有建立起来，我们只要手动执行这一系列操作就可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip link add name docker0 type bridge</span><br><span class="line"></span><br><span class="line">ip addr add dev docker0 172.17.0.1/16</span><br></pre></td></tr></table></figure><p>最后重启<code>docker</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemclt restart docker</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      dokcer.service 提示缺失bridge网络，导致Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
    
    </summary>
    
      <category term="docker" scheme="https://cloudsjhan.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://cloudsjhan.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>python 正则表达式及re详解</title>
    <link href="https://cloudsjhan.github.io/2019/04/28/python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8Are%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cloudsjhan.github.io/2019/04/28/python-正则表达式及re详解/</id>
    <published>2019-04-28T06:52:31.000Z</published>
    <updated>2019-04-28T08:15:06.233Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="Python-正则表达式-re-模块"><a href="#Python-正则表达式-re-模块" class="headerlink" title="Python 正则表达式 re 模块"></a>Python 正则表达式 re 模块</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>正则表达式（regular expression）</strong>是可以匹配文本片段的模式。最简单的正则表达式就是普通字符串，可以匹配其自身。比如，正则表达式 ‘hello’ 可以匹配字符串 ‘hello’。</p><p>要注意的是，正则表达式并不是一个程序，而是用于处理字符串的一种模式，如果你想用它来处理字符串，就必须使用支持正则表达式的工具，比如 Linux 中的 awk, sed, grep，或者编程语言 Perl, Python, Java 等等。</p><p>正则表达式有多种不同的风格，下表列出了适用于 Python 或 Perl 等编程语言的部分<strong>元字符</strong>以及说明：</p><p><a href="https://ofaatpail.qnssl.com/re.png" target="_blank" rel="noopener"><img src="https://ofaatpail.qnssl.com/re.png" alt="img"></a></p><h1 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h1><p>在 Python 中，我们可以使用内置的 re 模块来使用正则表达式。</p><p>有一点需要特别注意的是，正则表达式使用 <code>\</code> 对特殊字符进行转义，比如，为了匹配字符串 ‘python.org’，我们需要使用正则表达式 <code>&#39;python\.org&#39;</code>，而 Python 的字符串本身也用 <code>\</code> 转义，所以上面的正则表达式在 Python 中应该写成 <code>&#39;python\\.org&#39;</code>，这会很容易陷入 <code>\</code> 的困扰中，因此，我们建议使用 Python 的原始字符串，只需加一个 r 前缀，上面的正则表达式可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r&apos;python\.org&apos;</span><br></pre></td></tr></table></figure><p>re 模块提供了不少有用的函数，用以匹配字符串，比如：</p><ul><li>compile 函数</li><li>match 函数</li><li>search 函数</li><li>findall 函数</li><li>finditer 函数</li><li>split 函数</li><li>sub 函数</li><li>subn 函数</li></ul><p>re 模块的一般使用步骤如下：</p><ul><li>使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象</li><li>通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象）</li><li>最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作</li></ul><h1 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h1><p><strong>compile 函数用于编译正则表达式，生成一个 Pattern 对象</strong>，它的一般使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern[, flag])</span><br></pre></td></tr></table></figure><p>其中，pattern 是一个字符串形式的正则表达式，flag 是一个可选参数，表示匹配模式，比如忽略大小写，多行模式等。</p><p>下面，让我们看看例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 将正则表达式编译成 Pattern 对象 </span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br></pre></td></tr></table></figure><p>在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。Pattern 对象的一些常用方法主要有：</p><ul><li>match 方法</li><li>search 方法</li><li>findall 方法</li><li>finditer 方法</li><li>split 方法</li><li>sub 方法</li><li>subn 方法</li></ul><h2 id="match-方法"><a href="#match-方法" class="headerlink" title="match 方法"></a>match 方法</h2><p>match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。因此，<strong>当你不指定 pos 和 endpos 时，match 方法默认匹配字符串的头部</strong>。</p><p>当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。</p><p>看看例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; pattern = re.compile(r&apos;\d+&apos;)                    # 用于匹配至少一个数字</span><br><span class="line">&gt;&gt;&gt; m = pattern.match(&apos;one12twothree34four&apos;)        # 查找头部，没有匹配</span><br><span class="line">&gt;&gt;&gt; print m</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; m = pattern.match(&apos;one12twothree34four&apos;, 2, 10) # 从&apos;e&apos;的位置开始匹配，没有匹配</span><br><span class="line">&gt;&gt;&gt; print m</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; m = pattern.match(&apos;one12twothree34four&apos;, 3, 10) # 从&apos;1&apos;的位置开始匹配，正好匹配</span><br><span class="line">&gt;&gt;&gt; print m                                         # 返回一个 Match 对象</span><br><span class="line">&lt;_sre.SRE_Match object at 0x10a42aac0&gt;</span><br><span class="line">&gt;&gt;&gt; m.group(0)   # 可省略 0</span><br><span class="line">&apos;12&apos;</span><br><span class="line">&gt;&gt;&gt; m.start(0)   # 可省略 0</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; m.end(0)     # 可省略 0</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; m.span(0)    # 可省略 0</span><br><span class="line">(3, 5)</span><br></pre></td></tr></table></figure><p>在上面，当匹配成功时返回一个 Match 对象，其中：</p><ul><li><code>group([group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code>；</li><li><code>start([group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</li><li><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</li><li><code>span([group])</code> 方法返回 <code>(start(group), end(group))</code>。</li></ul><p>再看看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; pattern = re.compile(r&apos;([a-z]+) ([a-z]+)&apos;, re.I)   # re.I 表示忽略大小写</span><br><span class="line">&gt;&gt;&gt; m = pattern.match(&apos;Hello World Wide Web&apos;)</span><br><span class="line">&gt;&gt;&gt; print m                               # 匹配成功，返回一个 Match 对象</span><br><span class="line">&lt;_sre.SRE_Match object at 0x10bea83e8&gt;</span><br><span class="line">&gt;&gt;&gt; m.group(0)                            # 返回匹配成功的整个子串</span><br><span class="line">&apos;Hello World&apos;</span><br><span class="line">&gt;&gt;&gt; m.span(0)                             # 返回匹配成功的整个子串的索引</span><br><span class="line">(0, 11)</span><br><span class="line">&gt;&gt;&gt; m.group(1)                            # 返回第一个分组匹配成功的子串</span><br><span class="line">&apos;Hello&apos;</span><br><span class="line">&gt;&gt;&gt; m.span(1)                             # 返回第一个分组匹配成功的子串的索引</span><br><span class="line">(0, 5)</span><br><span class="line">&gt;&gt;&gt; m.group(2)                            # 返回第二个分组匹配成功的子串</span><br><span class="line">&apos;World&apos;</span><br><span class="line">&gt;&gt;&gt; m.span(2)                             # 返回第二个分组匹配成功的子串</span><br><span class="line">(6, 11)</span><br><span class="line">&gt;&gt;&gt; m.groups()                            # 等价于 (m.group(1), m.group(2), ...)</span><br><span class="line">(&apos;Hello&apos;, &apos;World&apos;)</span><br><span class="line">&gt;&gt;&gt; m.group(3)                            # 不存在第三个分组</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: no such group</span><br></pre></td></tr></table></figure><h2 id="search-方法"><a href="#search-方法" class="headerlink" title="search 方法"></a>search 方法</h2><p>search 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。</p><p>当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。</p><p>让我们看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; pattern = re.compile(&apos;\d+&apos;)</span><br><span class="line">&gt;&gt;&gt; m = pattern.search(&apos;one12twothree34four&apos;)  # 这里如果使用 match 方法则不匹配</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object at 0x10cc03ac0&gt;</span><br><span class="line">&gt;&gt;&gt; m.group()</span><br><span class="line">&apos;12&apos;</span><br><span class="line">&gt;&gt;&gt; m = pattern.search(&apos;one12twothree34four&apos;, 10, 30)  # 指定字符串区间</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object at 0x10cc03b28&gt;</span><br><span class="line">&gt;&gt;&gt; m.group()</span><br><span class="line">&apos;34&apos;</span><br><span class="line">&gt;&gt;&gt; m.span()</span><br><span class="line">(13, 15)</span><br></pre></td></tr></table></figure><p>再来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"> </span><br><span class="line"># 将正则表达式编译成 Pattern 对象</span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;) </span><br><span class="line"> </span><br><span class="line"># 使用 search() 查找匹配的子串，不存在匹配的子串时将返回 None </span><br><span class="line"># 这里使用 match() 无法成功匹配 </span><br><span class="line">m = pattern.search(&apos;hello 123456 789&apos;) </span><br><span class="line"> </span><br><span class="line">if m: </span><br><span class="line">    # 使用 Match 获得分组信息 </span><br><span class="line">    print &apos;matching string:&apos;,m.group()</span><br><span class="line">    print &apos;position:&apos;,m.span()</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matching string: 123456</span><br><span class="line">position: (6, 12)</span><br></pre></td></tr></table></figure><h2 id="findall-方法"><a href="#findall-方法" class="headerlink" title="findall 方法"></a>findall 方法</h2><p>上面的 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。</p><p>findall 方法的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。</p><p>findall 以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;)   # 查找数字</span><br><span class="line">result1 = pattern.findall(&apos;hello 123456 789&apos;)</span><br><span class="line">result2 = pattern.findall(&apos;one1two2three3four4&apos;, 0, 10)</span><br><span class="line"> </span><br><span class="line">print result1</span><br><span class="line">print result2</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;123456&apos;, &apos;789&apos;]</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;]</span><br></pre></td></tr></table></figure><h2 id="finditer-方法"><a href="#finditer-方法" class="headerlink" title="finditer 方法"></a>finditer 方法</h2><p>finditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br><span class="line"></span><br><span class="line">result_iter1 = pattern.finditer(&apos;hello 123456 789&apos;)</span><br><span class="line">result_iter2 = pattern.finditer(&apos;one1two2three3four4&apos;, 0, 10)</span><br><span class="line"></span><br><span class="line">print type(result_iter1)</span><br><span class="line">print type(result_iter2)</span><br><span class="line"></span><br><span class="line">print &apos;result1...&apos;</span><br><span class="line">for m1 in result_iter1:   # m1 是 Match 对象</span><br><span class="line">    print &apos;matching string: &#123;&#125;, position: &#123;&#125;&apos;.format(m1.group(), m1.span())</span><br><span class="line"></span><br><span class="line">print &apos;result2...&apos;</span><br><span class="line">for m2 in result_iter2:</span><br><span class="line">    print &apos;matching string: &#123;&#125;, position: &#123;&#125;&apos;.format(m2.group(), m2.span())</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;type &apos;callable-iterator&apos;&gt;</span><br><span class="line">&lt;type &apos;callable-iterator&apos;&gt;</span><br><span class="line">result1...</span><br><span class="line">matching string: 123456, position: (6, 12)</span><br><span class="line">matching string: 789, position: (13, 16)</span><br><span class="line">result2...</span><br><span class="line">matching string: 1, position: (3, 4)</span><br><span class="line">matching string: 2, position: (7, 8)</span><br></pre></td></tr></table></figure><h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h2><p>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split(string[, maxsplit])</span><br></pre></td></tr></table></figure><p>其中，maxsplit 用于指定最大分割次数，不指定将全部分割。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">p = re.compile(r&apos;[\s\,\;]+&apos;)</span><br><span class="line">print p.split(&apos;a,b;; c   d&apos;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure><h2 id="sub-方法"><a href="#sub-方法" class="headerlink" title="sub 方法"></a>sub 方法</h2><p>sub 方法用于替换。它的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub(repl, string[, count])</span><br></pre></td></tr></table></figure><p>其中，repl 可以是字符串也可以是一个函数：</p><ul><li>如果 repl 是字符串，则会使用 repl 去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl 还可以使用 <code>\id</code> 的形式来引用分组，但不能使用编号 0；</li><li>如果 repl 是函数，这个方法应当只接受一个参数（Match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。</li></ul><p>count 用于指定最多替换次数，不指定时全部替换。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">p = re.compile(r&apos;(\w+) (\w+)&apos;)</span><br><span class="line">s = &apos;hello 123, hello 456&apos;</span><br><span class="line"></span><br><span class="line">def func(m):</span><br><span class="line">    return &apos;hi&apos; + &apos; &apos; + m.group(2)</span><br><span class="line"></span><br><span class="line">print p.sub(r&apos;hello world&apos;, s)  # 使用 &apos;hello world&apos; 替换 &apos;hello 123&apos; 和 &apos;hello 456&apos;</span><br><span class="line">print p.sub(r&apos;\2 \1&apos;, s)        # 引用分组</span><br><span class="line">print p.sub(func, s)</span><br><span class="line">print p.sub(func, s, 1)         # 最多替换一次</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world, hello world</span><br><span class="line">123 hello, 456 hello</span><br><span class="line">hi 123, hi 456</span><br><span class="line">hi 123, hello 456</span><br></pre></td></tr></table></figure><h2 id="subn-方法"><a href="#subn-方法" class="headerlink" title="subn 方法"></a>subn 方法</h2><p>subn 方法跟 sub 方法的行为类似，也用于替换。它的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subn(repl, string[, count])</span><br></pre></td></tr></table></figure><p>它返回一个元组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(sub(repl, string[, count]), 替换次数)</span><br></pre></td></tr></table></figure><p>元组有两个元素，第一个元素是使用 sub 方法的结果，第二个元素返回原字符串被替换的次数。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">p = re.compile(r&apos;(\w+) (\w+)&apos;)</span><br><span class="line">s = &apos;hello 123, hello 456&apos;</span><br><span class="line"></span><br><span class="line">def func(m):</span><br><span class="line">    return &apos;hi&apos; + &apos; &apos; + m.group(2)</span><br><span class="line"></span><br><span class="line">print p.subn(r&apos;hello world&apos;, s)</span><br><span class="line">print p.subn(r&apos;\2 \1&apos;, s)</span><br><span class="line">print p.subn(func, s)</span><br><span class="line">print p.subn(func, s, 1)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&apos;hello world, hello world&apos;, 2)</span><br><span class="line">(&apos;123 hello, 456 hello&apos;, 2)</span><br><span class="line">(&apos;hi 123, hi 456&apos;, 2)</span><br><span class="line">(&apos;hi 123, hello 456&apos;, 1)</span><br></pre></td></tr></table></figure><h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><p>事实上，使用 compile 函数生成的 Pattern 对象的一系列方法跟 re 模块的多数函数是对应的，但在使用上有细微差别。</p><h2 id="match-函数"><a href="#match-函数" class="headerlink" title="match 函数"></a>match 函数</h2><p>match 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string[, flags]):</span><br></pre></td></tr></table></figure><p>其中，pattern 是正则表达式的字符串形式，比如 <code>\d+</code>, <code>[a-z]+</code>。</p><p>而 Pattern 对象的 match 方法使用形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>可以看到，match 函数不能指定字符串的区间，它只能搜索头部，看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">m1 = re.match(r&apos;\d+&apos;, &apos;One12twothree34four&apos;)</span><br><span class="line">if m1:</span><br><span class="line">    print &apos;matching string:&apos;,m1.group()</span><br><span class="line">else:</span><br><span class="line">    print &apos;m1 is:&apos;,m1</span><br><span class="line">    </span><br><span class="line">m2 = re.match(r&apos;\d+&apos;, &apos;12twothree34four&apos;)</span><br><span class="line">if m2:</span><br><span class="line">    print &apos;matching string:&apos;, m2.group()</span><br><span class="line">else:</span><br><span class="line">    print &apos;m2 is:&apos;,m2</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 is: None</span><br><span class="line">matching string: 12</span><br></pre></td></tr></table></figure><h2 id="search-函数"><a href="#search-函数" class="headerlink" title="search 函数"></a>search 函数</h2><p>search 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string[, flags])</span><br></pre></td></tr></table></figure><p>search 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 search 方法类似。</p><h2 id="findall-函数"><a href="#findall-函数" class="headerlink" title="findall 函数"></a>findall 函数</h2><p>findall 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern, string[, flags])</span><br></pre></td></tr></table></figure><p>findall 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 findall 方法类似。</p><p>看看例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print re.findall(r&apos;\d+&apos;, &apos;hello 12345 789&apos;)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">[&apos;12345&apos;, &apos;789&apos;]</span><br></pre></td></tr></table></figure><h2 id="finditer-函数"><a href="#finditer-函数" class="headerlink" title="finditer 函数"></a>finditer 函数</h2><p>finditer 函数的使用方法跟 Pattern 的 finditer 方法类似，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string[, flags])</span><br></pre></td></tr></table></figure><h2 id="split-函数"><a href="#split-函数" class="headerlink" title="split 函数"></a>split 函数</h2><p>split 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit])</span><br></pre></td></tr></table></figure><h2 id="sub-函数"><a href="#sub-函数" class="headerlink" title="sub 函数"></a>sub 函数</h2><p>sub 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string[, count])</span><br></pre></td></tr></table></figure><h2 id="subn-函数"><a href="#subn-函数" class="headerlink" title="subn 函数"></a>subn 函数</h2><p>subn 函数的使用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.subn(pattern, repl, string[, count])</span><br></pre></td></tr></table></figure><h1 id="到底用哪种方式"><a href="#到底用哪种方式" class="headerlink" title="到底用哪种方式"></a>到底用哪种方式</h1><p>从上文可以看到，使用 re 模块有两种方式：</p><ul><li>使用 re.compile 函数生成一个 Pattern 对象，然后使用 Pattern 对象的一系列方法对文本进行匹配查找；</li><li>直接使用 re.match, re.search 和 re.findall 等函数直接对文本匹配查找；</li></ul><p>下面，我们用一个例子展示这两种方法。</p><p>先看第 1 种用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 将正则表达式先编译成 Pattern 对象</span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br><span class="line"></span><br><span class="line">print pattern.match(&apos;123, 123&apos;)</span><br><span class="line">print pattern.search(&apos;234, 234&apos;)</span><br><span class="line">print pattern.findall(&apos;345, 345&apos;)</span><br></pre></td></tr></table></figure><p>再看第 2 种用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">print re.match(r&apos;\d+&apos;, &apos;123, 123&apos;)</span><br><span class="line">print re.search(r&apos;\d+&apos;, &apos;234, 234&apos;)</span><br><span class="line">print re.findall(r&apos;\d+&apos;, &apos;345, 345&apos;)</span><br></pre></td></tr></table></figure><p>如果一个正则表达式需要用到多次（比如上面的 <code>\d+</code>），在多种场合经常需要被用到，出于效率的考虑，我们应该预先编译该正则表达式，生成一个 Pattern 对象，再使用该对象的一系列方法对需要匹配的文件进行匹配；而如果直接使用 re.match, re.search 等函数，每次传入一个正则表达式，它都会被编译一次，效率就会大打折扣。</p><p>因此，我们推荐使用第 1 种用法。</p><h1 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h1><p>在某些情况下，我们想匹配文本中的汉字，有一点需要注意的是，<a href="http://blog.oasisfeng.com/2006/10/19/full-cjk-unicode-range/" target="_blank" rel="noopener">中文的 unicode 编码范围</a> 主要在 <code>[\u4e00-\u9fa5]</code>，这里说主要是因为这个范围并不完整，比如没有包括全角（中文）标点，不过，在大部分情况下，应该是够用的。</p><p>假设现在想把字符串 <code>title = u&#39;你好，hello，世界&#39;</code> 中的中文提取出来，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">title = u&apos;你好，hello，世界&apos;</span><br><span class="line">pattern = re.compile(ur&apos;[\u4e00-\u9fa5]+&apos;)</span><br><span class="line">result = pattern.findall(title)</span><br><span class="line"></span><br><span class="line">print result</span><br></pre></td></tr></table></figure><p>注意到，我们在正则表达式前面加上了两个前缀 <code>ur</code>，其中 <code>r</code> 表示使用原始字符串，<code>u</code> 表示是 unicode 字符串。</p><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[u&apos;\u4f60\u597d&apos;, u&apos;\u4e16\u754c&apos;]</span><br></pre></td></tr></table></figure><h1 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h1><p>在 Python 中，正则匹配默认是<strong>贪婪匹配</strong>（在少数语言中可能是非贪婪），也就是<strong>匹配尽可能多的字符</strong>。</p><p>比如，我们想找出字符串中的所有 <code>div</code> 块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">content = &apos;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&apos;</span><br><span class="line">pattern = re.compile(r&apos;&lt;div&gt;.*&lt;/div&gt;&apos;)</span><br><span class="line">result = pattern.findall(content)</span><br><span class="line"></span><br><span class="line">print result</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;&apos;]</span><br></pre></td></tr></table></figure><p>由于正则匹配是贪婪匹配，也就是尽可能多的匹配，因此，在成功匹配到第一个 <code>&lt;/div&gt;</code> 时，它还会向右尝试匹配，查看是否还有更长的可以成功匹配的子串。</p><p>如果我们想非贪婪匹配，可以加一个 <code>?</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">content = &apos;aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc&apos;</span><br><span class="line">pattern = re.compile(r&apos;&lt;div&gt;.*?&lt;/div&gt;&apos;)    # 加上 ?</span><br><span class="line">result = pattern.findall(content)</span><br><span class="line"></span><br><span class="line">print result</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;&lt;div&gt;test1&lt;/div&gt;&apos;, &apos;&lt;div&gt;test2&lt;/div&gt;&apos;]</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>re 模块的一般使用步骤如下：<ul><li>使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象；</li><li>通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象）；</li><li>最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作；</li></ul></li><li>Python 的正则匹配默认是贪婪匹配。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      python正则表达式及re模块详解
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>vim常用命令与技巧(不定期更新).md</title>
    <link href="https://cloudsjhan.github.io/2019/04/21/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%8A%80%E5%B7%A7-md/"/>
    <id>https://cloudsjhan.github.io/2019/04/21/vim常用命令与技巧-md/</id>
    <published>2019-04-21T13:38:14.000Z</published>
    <updated>2019-04-21T14:37:49.394Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="Vim常用的命令与技巧总结："><a href="#Vim常用的命令与技巧总结：" class="headerlink" title="Vim常用的命令与技巧总结："></a>Vim常用的命令与技巧总结：</h2><ol><li>在每行行首添加相同的内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/^/要添加的内容</span><br></pre></td></tr></table></figure><ol start="2"><li>在每行行尾添加相同的内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/$/要添加的内容</span><br></pre></td></tr></table></figure><ol start="3"><li>利用正则表达式删除代码段每行的行号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:%s/^\s*[0-9]*\s*//gc</span><br><span class="line"></span><br><span class="line">其中，^表示行首，$表示行尾，\s表示空格，[0-9]表示0~9的数字，*表示0或多个，%s/^\s*[0-9]*\s*//gc的意思是将每行以0或多个空格开始中间包含0或多个数字并以0或多个空格结束的字符串替换为空。</span><br></pre></td></tr></table></figure><ol start="4"><li>指定行首添加”#”</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:447,945 s/^/#</span><br><span class="line">447-945行的行首添加 #</span><br></pre></td></tr></table></figure><ol start="5"><li>删除每行前面的内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10,15 s/^/#//gc</span><br></pre></td></tr></table></figure><ol start="6"><li>统计m到n行中”字符串”出现的次数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:m,n s/字符串//gn</span><br></pre></td></tr></table></figure><ol start="7"><li><p>统计”字符串”在当前编辑文件出现的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: %s/字符串/ng</span><br></pre></td></tr></table></figure></li><li><p>统计词语在文件中出现的行数:</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file|grep -i 字符串 |wc -l</span><br></pre></td></tr></table></figure><ol start="9"><li>pycharm中vim插件批量缩进：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:m,n &gt;</span><br><span class="line">//向右缩进4空格</span><br><span class="line"></span><br><span class="line">:m,n &lt; </span><br><span class="line">//向左缩进4空格</span><br></pre></td></tr></table></figure><ol start="10"><li>跳转到行首: ^</li><li>跳转到行尾:$</li><li>跳转到文件开头: gg</li><li>跳转到行尾：G</li></ol><hr>]]></content>
    
    <summary type="html">
    
      vim常用的命令与技巧总结
    
    </summary>
    
      <category term="vim" scheme="https://cloudsjhan.github.io/categories/vim/"/>
    
    
      <category term="vim" scheme="https://cloudsjhan.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>IRC常用命令</title>
    <link href="https://cloudsjhan.github.io/2019/04/19/IRC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://cloudsjhan.github.io/2019/04/19/IRC常用命令/</id>
    <published>2019-04-19T02:38:29.000Z</published>
    <updated>2019-04-19T02:44:55.593Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>下面是常用命令</p><p>/在不引起混淆的情况下，IRC命令允许简写。例如，/join 命令可以简写为/j，/jo或者/joi。 </p><p>/nick</p><p>更改昵称的基本方法是：/n(ick) 新的昵称</p><p>您的昵称可以包含英文字母，数字，汉字及下划线等。但是，昵称不能超过50个（每个字符和汉字都算一个字），而且不能包含$，+，！和空格。</p><p>/nick 命令等价于工具按钮中的“改变别名”。</p><p>/join</p><p>/join命令的格式是：/j(oin) 聊天室名</p><p>如果聊天室已经存在，您就进入该聊天室。此时，/join 命令等价于聊天室列表工具按钮中的“进入”。</p><p>如果聊天室不存在，您就建立了一个新的聊天室并进入。此时，/join 命令等价于工具按钮中的“建聊天室”。</p><p>聊天室的名字可以包含英文字母，数字，汉字及下划线等。但是，不能超过50个字（每个字符和汉字都算一个字），而且不能包含$，+，！和空格。</p><p>/mode +(-)i</p><p>/mode +(-)i 命令可以用来锁住（解锁）用户自建的聊天室（私人聊天室）。其命令格式是:/m(ode)</p><p>+i 或 /m(ode) -i</p><p>只有用户自建的聊天室才能加锁。</p><p>未经管理员邀请，其他用户不能进入私人聊天室。</p><p>/mode +(-)o</p><p>/mode +(-)o 命令可以让聊天室管理员赋予或者剥夺其他用户的管理员身份。其命令格式是：/m(ode)</p><p>+o 用户昵称或/m(ode)-o用户昵称只有聊天室管理员才能使用这个命令。</p><p>/knock</p><p>/knock 命令可以让您询问私人聊天室管理员是否可以进入该私人聊天室。其命令格式是：/k(nock) 房间名</p><p>消息]</p><p>/invite</p><p>/invite 命令可以让聊天室管理员邀请其他用户进入私人聊天室。其命令格式是:/i(nvite) 用户昵称</p><p>只有私人聊天室的管理员才能使用这个命令。</p><p>/privmsg</p><p>/privmsg 命令用来向在同一间聊天室的某个用户发送私人消息（悄悄话）。也就是说，您的消息只送给指定的人，而不会显示给其他用户。</p><p>/privmsg 命令的基本格式是： /p(rivmsg) 用户昵称 消息</p><p>接受您的私人消息的用户必须和您在同一间聊天室。</p><p>“用户昵称”和“消息”这两个参数是不能省略的。</p><p>如果某个用户的昵称太长，在不会产生混淆的情况下，您可以只输入用户昵称的头几个字母，系统会进行自动匹配。</p><p>例如：聊天室里除了您之外还有两个用户，他们的昵称分别是xiaobao和softman。您若想给softman发送悄悄话，可以在输入框里输入下面的命令：</p><p>/p s Have you etanged today?</p><p>由于xiaobao和softman的第一个字母就不一样，所以系统会把您输入的昵称“s”自动匹配为“softman”。另外，“/p”是“/privmsg”的缩写。</p><p>/ignore</p><p>/ignore 命令用来把某个用户加入您的“坏人黑名单”。一旦某个用户进入了您的黑名单，他说的任何话都将不会显示在您的终端上。</p><p>/ignore 命令的基本格式是：/ig(nore) 用户昵称</p><p>用户昵称所代表的用户必须和您在同一个聊天室。</p><p>/ignore 命令等价于用户列表工具按钮中的“忽略”。</p><p>如果某个用户的昵称太长，在不会产生混淆的情况下，您可以只输入用户昵称的头几个字母，系统会进行自动匹配。</p><p>在您的用户列表中，如果某个用户昵称前有一个#，表示该用户已经被您列入黑名单。</p><p>如果一个用户已经在您的黑名单中，您可以用 /ignore 用户昵称 把他从黑名单中去掉。</p><p>/away</p><p>/away 命令用来把自己设为“暂时离开”状态，并可以留言给其他用户。当其他用户和您说悄悄话时，您预先设置的留言会自动回复给其他用户。</p><p>/away 命令的基本格式是：/a(way) [留言]</p><p>“留言”这个参数是可选的。如果有这个参数，您的状态会被设置为“暂时离开”。否则，您的状态会被设置为“我回来了”。</p><p>当您暂时离开聊天室时，用户列表中您的昵称前会出现一个?，表示您处于“离开”状态。工具按钮中的“暂时离开”也会变为“我回来了”。</p><p>当您回来继续聊天时，您可以点击工具按钮中的“我回来了”，或者在输入框里输入 /away 命令，将自己设置为正常状态。</p><p>/away 命令等价于工具按钮中的“暂时离开”</p><p>/whois</p><p>/whois 命令用来查询某个用户的信息，包括用户的亿唐ID，IP地址，目前所在的聊天室和发呆时间。</p><p>/whois 命令的基本格式是：/w(hois) 用户昵称</p><p>/whois命令等价于用户列表工具按钮中的“查询”。</p><p>/names</p><p>/names 命令用来查看当前所有（或某个聊天室内）的在线聊天用户。其命令格式是：/na(mes) [聊天室]</p><p>/topic</p><p>/topic 命令用来设定当前聊天室的主题。</p><p>/topic 命令的基本格式是：/t(opic) 聊天室主题</p><p>只有当前聊天室的管理员（op）才有权利设定聊天室主题。</p><p>聊天室的创建者就是该聊天室的管理员。</p><p>管理员权限可以通过 /mode +o 命令转交。</p><p>/kick</p><p>/kick 命令用来把某个用户踢出当前聊天室。</p><p>/kick 命令的基本格式是：/ki(ck) 用户昵称 [消息]</p><p>只有当前聊天室的管理员（op）才有权利把其他用户踢出当前聊天室。</p><p>聊天室的创建者就是该聊天室的管理员。</p><p>管理员权限可以通过/mode +o命令转交。</p><p>请诸位网友慎用这个命令。“君子动口不动手”嘛！</p><p>/quit</p><p>/quit 命令用来退出聊天室。</p><p>/quit 命令的基本格式是：/q(uit) [消息]</p><p>“消息”这个参数是可选的。如果您指定退出时的消息，该消息会发送给当前聊天室中的其他用户。您可以使用这个消息向其他用户道别。</p><p>/quit 命令等价于工具按钮中的“结束聊天” </p><ul><li>详情可参考：<a href="https://www.cnblogs.com/z-books/p/5197840.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-books/p/5197840.html</a> </li></ul><hr>]]></content>
    
    <summary type="html">
    
      IRC常用命令
    
    </summary>
    
      <category term="IRC" scheme="https://cloudsjhan.github.io/categories/IRC/"/>
    
    
      <category term="IRC" scheme="https://cloudsjhan.github.io/tags/IRC/"/>
    
  </entry>
  
  <entry>
    <title>golang面试问题汇总</title>
    <link href="https://cloudsjhan.github.io/2019/04/12/golang%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://cloudsjhan.github.io/2019/04/12/golang面试问题汇总/</id>
    <published>2019-04-12T02:01:08.000Z</published>
    <updated>2019-04-12T02:02:41.696Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本文转载自：<a href="https://github.com/KeKe-Li/golang-interview-questions" target="_blank" rel="noopener">https://github.com/KeKe-Li/golang-interview-questions</a></p><h3 id="Golang面试问题汇总"><a href="#Golang面试问题汇总" class="headerlink" title="Golang面试问题汇总"></a>Golang面试问题汇总</h3><p>通常我们去面试肯定会有些不错的Golang的面试题目的，所以总结下，让其他Golang开发者也可以查看到，同时也用来检测自己的能力和提醒自己的不足之处,欢迎大家补充和提交新的面试题目.</p><p>Golang面试问题汇总:</p><h4 id="1-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"><a href="#1-Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？" class="headerlink" title="1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"></a>1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？</h4><p>Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。</p><h4 id="2-无缓冲-Chan-的发送和接收是否同步"><a href="#2-无缓冲-Chan-的发送和接收是否同步" class="headerlink" title="2. 无缓冲 Chan 的发送和接收是否同步?"></a>2. 无缓冲 Chan 的发送和接收是否同步?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步.</span><br><span class="line">ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步.</span><br></pre></td></tr></table></figure><ul><li>channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。</li><li>channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。</li></ul><h4 id="3-go语言的并发机制以及它所使用的CSP并发模型．"><a href="#3-go语言的并发机制以及它所使用的CSP并发模型．" class="headerlink" title="3. go语言的并发机制以及它所使用的CSP并发模型．"></a>3. go语言的并发机制以及它所使用的CSP并发模型．</h4><p>CSP模型是上个世纪七十年代提出的,不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p><p>Golang中channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。</p><p>Goroutine 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：</p><ul><li>用户空间 避免了内核态和用户态的切换导致的成本。</li><li>可以由语言和框架层进行调度。</li><li>更小的栈空间允许创建大量的实例。</li></ul><p>Golang中的Goroutine的特性:</p><p>Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.</p><p>正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。 所有有时候线程对象会比处理器对象多很多.</p><p>我们用如下图分别表示P、M、G:</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/59.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/59.jpg" alt="img"></a></p><p>G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息.</p><p>M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）.</p><p>P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数.</p><p>在单核情况下，所有Goroutine运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个Goroutine，其他Goroutine在runqueue中等待。</p><p>一个Goroutine运行完自己的时间片后，让出上下文，自己回到runqueue中（如下图所示）。</p><p>当正在运行的G0阻塞的时候（可以需要IO），会再创建一个线程（M1），P转到新的线程中去运行。</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/60.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/60.jpg" alt="img"></a></p><p>当M0返回时，它会尝试从其他线程中“偷”一个上下文过来，如果没有偷到，会把Goroutine放到Global runqueue中去，然后把自己放入线程缓存中。 上下文会定时检查Global runqueue。</p><p>Golang是为并发而生的语言，Go语言是为数不多的在语言层面实现并发的语言；也正是Go语言的并发特性，吸引了全球无数的开发者。</p><p>Golang的CSP并发模型，是通过Goroutine和Channel来实现的。</p><p>Goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。 Channel是Go语言中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”管道“，有点类似于Linux中的管道。</p><p>通信机制channel也很方便，传数据用channel &lt;- data，取数据用&lt;-channel。</p><p>在通信过程中，传数据channel &lt;- data和取数据&lt;-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。</p><p>而且不管传还是取，必阻塞，直到另外的goroutine传或者取为止。</p><h4 id="4-Golang-中常用的并发模型？"><a href="#4-Golang-中常用的并发模型？" class="headerlink" title="4. Golang 中常用的并发模型？"></a>4. Golang 中常用的并发模型？</h4><p>Golang 中常用的并发模型有三种:</p><ul><li>通过channel通知实现并发控制</li></ul><p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。</p><p>从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan struct&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        fmt.Println(&quot;start working&quot;)</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        ch &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    &lt;-ch</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;finished&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p><ul><li>通过sync包中的WaitGroup实现并发控制</li></ul><p>Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:</p><ul><li>Add, 可以添加或减少 goroutine的数量.</li><li>Done, 相当于Add(-1).</li><li>Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.</li></ul><p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    var urls = []string&#123;</span><br><span class="line">        &quot;http://www.golang.org/&quot;,</span><br><span class="line">        &quot;http://www.google.com/&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _, url := range urls &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(url string) &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup 第一次使用后，不能被拷贝</p><p>应用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(wg sync.WaitGroup, i int) &#123;</span><br><span class="line">            fmt.Printf(&quot;i:%d&quot;, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(wg, i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;exit&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(0xc000094018)</span><br><span class="line">        /home/keke/soft/go/src/runtime/sema.go:56 +0x39</span><br><span class="line">sync.(*WaitGroup).Wait(0xc000094010)</span><br><span class="line">        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/wait.go:17 +0xab</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done操作是在 wg 的副本执行的。</p><p>因此 Wait 就死锁了。</p><p>这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。 这个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量</p><ul><li>在Go 1.7 以后引进的强大的Context上下文，实现并发控制</li></ul><p>通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。</p><p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。</p><p>context 包的核心是 struct Context，接口声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// A Context carries a deadline, cancelation signal, and request-scoped values</span><br><span class="line">// across API boundaries. Its methods are safe for simultaneous use by multiple</span><br><span class="line">// goroutines.</span><br><span class="line">type Context interface &#123;</span><br><span class="line">    // Done returns a channel that is closed when this `Context` is canceled</span><br><span class="line">    // or times out.</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Err indicates why this Context was canceled, after the Done channel</span><br><span class="line">    // is closed.</span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    // Deadline returns the time when this Context will be canceled, if any.</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line"></span><br><span class="line">    // Value returns the value associated with key or nil if none.</span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</p><p>Err() 在Done() 之后，返回context 取消的原因。</p><p>Deadline() 设置该context cancel的时间点</p><p>Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</p><p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><p>一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。</p><h4 id="5-JSON-标准库对-nil-slice-和-空-slice-的处理是一致的吗？"><a href="#5-JSON-标准库对-nil-slice-和-空-slice-的处理是一致的吗？" class="headerlink" title="5. JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？　"></a>5. JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？　</h4><p>首先JSON 标准库对 nil slice 和 空 slice 的处理是不一致.</p><p>通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var slice []int</span><br><span class="line">slice[1] = 0</span><br></pre></td></tr></table></figure><p>此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。</p><p>empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := make([]int,0）</span><br><span class="line">slice := []int&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。</p><p>总之，nil slice 和 empty slice是不同的东西,需要我们加以区分的.</p><h4 id="6-协程，线程，进程的区别。"><a href="#6-协程，线程，进程的区别。" class="headerlink" title="6. 协程，线程，进程的区别。"></a>6. 协程，线程，进程的区别。</h4><ul><li>进程</li></ul><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><ul><li>线程</li></ul><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><ul><li>协程</li></ul><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><h4 id="7-互斥锁，读写锁，死锁问题是怎么解决。"><a href="#7-互斥锁，读写锁，死锁问题是怎么解决。" class="headerlink" title="7. 互斥锁，读写锁，死锁问题是怎么解决。"></a>7. 互斥锁，读写锁，死锁问题是怎么解决。</h4><ul><li>互斥锁</li></ul><p>互斥锁就是互斥变量mutex，用来锁住临界区的.</p><p>条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。</p><ul><li>读写锁</li></ul><p>通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/61.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/61.jpg" alt="img"></a></p><p>注意：写独占，读共享，写锁优先级高</p><ul><li>死锁</li></ul><p>一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。 另外一种情况是：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。</p><p>死锁产生的四个必要条件:</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</li></ol><p>a. 预防死锁</p><p>可以把资源一次性分配：（破坏请求和保持条件）</p><p>然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</p><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><p>b. 避免死锁</p><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p><p>c. 检测死锁</p><p>首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.</p><p>d. 解除死锁</p><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有.</p><p>e. 剥夺资源</p><p>从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.</p><p>f. 撤消进程</p><p>可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><h4 id="8-Golang的内存模型，为什么小对象多了会造成gc压力。"><a href="#8-Golang的内存模型，为什么小对象多了会造成gc压力。" class="headerlink" title="8. Golang的内存模型，为什么小对象多了会造成gc压力。"></a>8. Golang的内存模型，为什么小对象多了会造成gc压力。</h4><p>通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.</p><h4 id="9-Data-Race问题怎么解决？能不能不加锁解决这个问题？"><a href="#9-Data-Race问题怎么解决？能不能不加锁解决这个问题？" class="headerlink" title="9. Data Race问题怎么解决？能不能不加锁解决这个问题？"></a>9. Data Race问题怎么解决？能不能不加锁解决这个问题？</h4><p>同步访问共享数据是处理数据竞争的一种有效的方法.golang在1.1之后引入了竞争检测机制，可以使用 go run -race 或者 go build -race来进行静态检测。 其在内部的实现是,开启多个协程执行同一个命令， 并且记录下每个变量的状态.</p><p>竞争检测器基于C/C++的ThreadSanitizer 运行时库，该库在Google内部代码基地和Chromium找到许多错误。这个技术在2012年九月集成到Go中，从那时开始，它已经在标准库中检测到42个竞争条件。现在，它已经是我们持续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。</p><p>竞争检测器已经完全集成到Go工具链中，仅仅添加-race标志到命令行就使用了检测器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go test -race mypkg    // 测试包</span><br><span class="line">$ go run -race mysrc.go  // 编译和运行程序</span><br><span class="line">$ go build -race mycmd   // 构建程序</span><br><span class="line">$ go install -race mypkg // 安装程序</span><br></pre></td></tr></table></figure><p>要想解决数据竞争的问题可以使用互斥锁sync.Mutex,解决数据竞争(Data race),也可以使用管道解决,使用管道的效率要比互斥锁高.</p><h4 id="10-什么是channel，为什么它可以做到线程安全？"><a href="#10-什么是channel，为什么它可以做到线程安全？" class="headerlink" title="10. 什么是channel，为什么它可以做到线程安全？"></a>10. 什么是channel，为什么它可以做到线程安全？</h4><p>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。</p><p>Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的。</p><h4 id="11-Epoll原理"><a href="#11-Epoll原理" class="headerlink" title="11. Epoll原理."></a>11. Epoll原理.</h4><p>开发高性能网络程序时，windows开发者们言必称Iocp，linux开发者们则言必称Epoll。大家都明白Epoll是一种IO多路复用技术，可以非常高效的处理数以百万计的Socket句柄，比起以前的Select和Poll效率提高了很多。</p><p>先简单了解下如何使用C库封装的3个epoll系统调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);  </span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  </span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>使用起来很清晰，首先要调用<code>epoll_create</code>建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。 epoll_ctl可以操作上面建立的epoll，例如，将刚建立的<code>socket</code>加入到epoll中让其监控，或者把 epoll正在监控的某个socket句柄移出epoll，不再监控它等等。</p><p><code>epoll_wait</code>在调用时，在给定的timeout时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。</p><p>从调用方式就可以看到epoll相比select/poll的优越之处是,因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。而我们调用<code>epoll_wait</code>时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</p><p>所以，实际上在你调用<code>epoll_create</code>后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用<code>epoll_ctl</code>只是在往内核的数据结构里塞入新的socket句柄。</p><p>在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。</p><p>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，通常来讲，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int __init eventpoll_init(void)  &#123;  </span><br><span class="line">    ... ...  </span><br><span class="line">  </span><br><span class="line">    /* Allocates slab cache used to allocate &quot;struct epitem&quot; items */  </span><br><span class="line">    epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct epitem),  </span><br><span class="line">            0, SLAB_HWCACHE_ALIGN|EPI_SLAB_DEBUG|SLAB_PANIC,  </span><br><span class="line">            NULL, NULL);  </span><br><span class="line">  </span><br><span class="line">    /* Allocates slab cache used to allocate &quot;struct eppoll_entry&quot; */  </span><br><span class="line">    pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;,  </span><br><span class="line">            sizeof(struct eppoll_entry), 0,  </span><br><span class="line">            EPI_SLAB_DEBUG|SLAB_PANIC, NULL, NULL);  </span><br><span class="line"> ... ...  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>epoll的高效就在于，当我们调用<code>epoll_ctl</code>往里塞入百万个句柄时，<code>epoll_wait</code>仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。这是由于我们在调用<code>epoll_create</code>时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p><p>而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已，因此就会非常的高效！</p><p>然而,这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p><p>如此，一个红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行<code>epoll_create</code>时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p><p>最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时每次返回这个句柄，而ET模式仅在第一次返回。</p><p>当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用<code>epoll_wait</code>，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，<code>epoll_wait</code>需要做的事情，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回。而ET模式的句柄，除非有新中断到，即使socket上的事件没有处理完，也是不会每次从epoll_wait返回的。</p><p>因此epoll比select的提高实际上是一个用空间换时间思想的具体应用.对比阻塞IO的处理模型, 可以看到采用了多路复用IO之后, 程序可以自由的进行自己除了IO操作之外的工作, 只有到IO状态发生变化的时候由多路复用IO进行通知, 然后再采取相应的操作, 而不用一直阻塞等待IO状态发生变化,提高效率.</p><h4 id="12-Golang-GC-时会发生什么"><a href="#12-Golang-GC-时会发生什么" class="headerlink" title="12. Golang GC 时会发生什么?"></a>12. Golang GC 时会发生什么?</h4><p>首先我们先来了解下垃圾回收.什么是垃圾回收？</p><p>内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。如何解决这个头疼的问题呢？</p><p>过去一般采用两种办法：</p><ul><li>内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。</li><li>智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。</li></ul><p>为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。</p><p>常用的垃圾回收的方法:</p><ul><li>引用计数（reference counting）</li></ul><p>这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。</p><p>这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。</p><p>但是简单引用计数算法也有明显的缺点：</p><ol><li>频繁更新引用计数降低了性能。</li></ol><p>一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。</p><ol><li>循环引用。</li></ol><p>当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。</p><ul><li>标记-清除（mark and sweep）</li></ul><p>标记-清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&amp;sweep算法的变种（如三色标记法）优化了这个问题。</p><ul><li>分代搜集（generation）</li></ul><p>java的jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。</p><p>因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><p>Golang GC 时会发生什么?</p><p>Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。</p><p>golang 中的 gc 基本上是标记清除的过程：</p><p><a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/images/2.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/For-learning-Go-Tutorial/raw/master/src/images/2.jpg" alt="img"></a></p><p>gc的过程一共分为四个阶段：</p><ol><li>栈扫描（开始时STW）</li><li>第一次标记（并发）</li><li>第二次标记（STW）</li><li>清除（并发）</li></ol><p>整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。</p><ol><li>先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理</li><li>第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列</li><li>第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；</li><li>第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录</li></ol><p>Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。</p><p>详细的Golang的GC介绍可以参看<a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md" target="_blank" rel="noopener">Golang垃圾回收</a>.</p><h4 id="13-Golang-中-Goroutine-如何调度"><a href="#13-Golang-中-Goroutine-如何调度" class="headerlink" title="13. Golang 中 Goroutine 如何调度?"></a>13. Golang 中 Goroutine 如何调度?</h4><p>goroutine是Golang语言中最经典的设计，也是其魅力所在，goroutine的本质是协程，是实现并行计算的核心。 goroutine使用方式非常的简单，只需使用go关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func()//通过go关键字启动一个协程来运行函数</span><br></pre></td></tr></table></figure><p>协程:</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。 因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。 线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。</p><p>groutine能拥有强大的并发实现是通过GPM调度模型实现.</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/59.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/59.jpg" alt="img"></a></p><p>Go的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched未给出）.</p><ul><li>M:M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息</li><li>G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。</li><li>P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine</li><li>Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。</li></ul><p>调度实现:</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/65.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/65.jpg" alt="img"></a></p><p>从上图中可以看到，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。</p><p>图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。</p><p>当一个OS线程M0陷入阻塞时，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/60.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/60.jpg" alt="img"></a></p><p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来， 如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p><p>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/64.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/64.jpg" alt="img"></a></p><p>通常来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的使用。</p><h4 id="14-并发编程概念是什么？"><a href="#14-并发编程概念是什么？" class="headerlink" title="14. 并发编程概念是什么？"></a>14. 并发编程概念是什么？</h4><p>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。</p><p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</p><p>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。</p><p>并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h4 id="15-负载均衡原理是什么"><a href="#15-负载均衡原理是什么" class="headerlink" title="15. 负载均衡原理是什么?"></a>15. 负载均衡原理是什么?</h4><p>负载均衡Load Balance）是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。负载均衡，其核心就是网络流量分发，分很多维度。</p><p>负载均衡（Load Balance）通常是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>负载均衡是建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>通过一个例子详细介绍:</p><ul><li>没有负载均衡 web 架构</li></ul><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/66.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/66.jpg" alt="img"></a></p><p>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。 另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p><p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。 通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。</p><ul><li>有负载均衡 web 架构</li></ul><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/67.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/67.jpg" alt="img"></a></p><p>用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。 这里又可以通过引入第二个负载均衡器来缓解。</p><p>那么负载均衡器的工作方式是什么样的呢,负载均衡器又可以处理什么样的请求？</p><p>负载均衡器的管理员能主要为下面四种主要类型的请求设置转发规则：</p><ul><li>HTTP (七层)</li><li>HTTPS (七层)</li><li>TCP (四层)</li><li>UDP (四层)</li></ul><p>负载均衡器如何选择要转发的后端服务器？</p><p>负载均衡器一般根据两个因素来决定要将请求转发到哪个服务器。首先，确保所选择的服务器能够对请求做出响应，然后根据预先配置的规则从健康服务器池（healthy pool）中进行选择。</p><p>因为，负载均衡器应当只选择能正常做出响应的后端服务器，因此就需要有一种判断后端服务器是否健康的方法。为了监视后台服务器的运行状况，运行状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器。 如果，服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发到该服务器，直到其再次通过健康检查为止。</p><p>负载均衡算法</p><p>负载均衡算法决定了后端的哪些健康服务器会被选中。 其中常用的算法包括：</p><ul><li>Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。</li><li>Least Connections（最小连接）：优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。</li><li>Source：根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。</li></ul><p>如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器。可以通过 Source 算法基于客户端的 IP 信息创建关联，或者使用粘性会话（sticky sessions）。</p><p>除此之外，想要解决负载均衡器的单点故障问题，可以将第二个负载均衡器连接到第一个上，从而形成一个集群。</p><h4 id="16-LVS相关了解"><a href="#16-LVS相关了解" class="headerlink" title="16. LVS相关了解."></a>16. LVS相关了解.</h4><p>LVS是 Linux Virtual Server 的简称，也就是Linux虚拟服务器。这是一个由章文嵩博士发起的一个开源项目，它的官方网站是<a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">LinuxVirtualServer</a>现在 LVS 已经是 Linux 内核标准的一部分。使用 LVS 可以达到的技术目标是：通过 LVS 达到的负载均衡技术和 Linux 操作系统实现一个高性能高可用的 Linux 服务器集群，它具有良好的可靠性、可扩展性和可操作性。 从而以低廉的成本实现最优的性能。LVS 是一个实现负载均衡集群的开源软件项目，LVS架构从逻辑上可分为调度层、Server集群层和共享存储。</p><p>LVS的基本工作原理:</p><p><a href="https://github.com/KeKe-Li/golang-interview-questions/blob/master/src/images/68.jpg" target="_blank" rel="noopener"><img src="https://github.com/KeKe-Li/golang-interview-questions/raw/master/src/images/68.jpg" alt="img"></a></p><ol><li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间</li><li>PREROUTING链首先会接收到用户请求，判断目标IP确定是本机IP，将数据包发往INPUT链</li><li>IPVS是工作在INPUT链上的，当用户请求到达INPUT时，IPVS会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时IPVS会强行修改数据包里的目标IP地址及端口，并将新的数据包发往POSTROUTING链</li><li>POSTROUTING链接收数据包后发现目标IP地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器</li></ol><p>LVS的组成:</p><p>LVS 由2部分程序组成，包括 <code>ipvs</code> 和 <code>ipvsadm</code>。</p><ol><li>ipvs(ip virtual server)：一段代码工作在内核空间，叫ipvs，是真正生效实现调度的代码。</li><li>ipvsadm：另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)</li></ol><p>详细的LVS的介绍可以参考<a href="https://www.cnblogs.com/liqing1009/p/8763045.html" target="_blank" rel="noopener">LVS详解</a>.</p><h4 id="17-微服务架构是什么样子的"><a href="#17-微服务架构是什么样子的" class="headerlink" title="17. 微服务架构是什么样子的?"></a>17. 微服务架构是什么样子的?</h4><p>通常传统的项目体积庞大，需求、设计、开发、测试、部署流程固定。新功能需要在原项目上做修改。</p><p>但是微服务可以看做是对大项目的拆分，是在快速迭代更新上线的需求下产生的。新的功能模块会发布成新的服务组件，与其他已发布的服务组件一同协作。 服务内部有多个生产者和消费者，通常以http rest的方式调用，服务总体以一个（或几个）服务的形式呈现给客户使用。</p><p>微服务架构是一种思想对微服务架构我们没有一个明确的定义，但简单来说微服务架构是：</p><p>采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p><p>Golang的微服务框架<a href="https://gokit.io/" target="_blank" rel="noopener">kit</a>中有详细的微服务的例子,可以参考学习.</p><p>微服务架构设计包括：</p><ol><li>服务熔断降级限流机制 熔断降级的概念(Rate Limiter 限流器,Circuit breaker 断路器).</li><li>框架调用方式解耦方式 Kit 或 Istio 或 Micro 服务发现(consul zookeeper kubeneters etcd ) RPC调用框架.</li><li>链路监控,zipkin和prometheus.</li><li>多级缓存.</li><li>网关 (kong gateway).</li><li>Docker部署管理 Kubenetters.</li><li>自动集成部署 CI/CD 实践.</li><li>自动扩容机制规则.</li><li>压测 优化.</li><li>Trasport 数据传输(序列化和反序列化).</li><li>Logging 日志.</li><li>Metrics 指针对每个请求信息的仪表盘化.</li></ol><p>微服务架构介绍详细的可以参考:</p><ul><li><a href="http://www.pst.ifi.lmu.de/Lehre/wise-14-15/mse/microservice-architectures.pdf" target="_blank" rel="noopener">Microservice Architectures</a></li></ul><h4 id="18-分布式锁实现原理，用过吗？"><a href="#18-分布式锁实现原理，用过吗？" class="headerlink" title="18. 分布式锁实现原理，用过吗？"></a>18. 分布式锁实现原理，用过吗？</h4><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p><ol><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ol><p>分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>通常分布式锁以单独的服务方式实现，目前比较常用的分布式锁实现有三种：</p><ul><li>基于数据库实现分布式锁。</li><li>基于缓存（redis，memcached，tair）实现分布式锁。</li><li>基于Zookeeper实现分布式锁。</li></ul><p>尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！</p><ul><li>基于数据库的实现方式</li></ul><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><p>创建一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `method_lock`;</span><br><span class="line">CREATE TABLE `method_lock` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `method_name` varchar(64) NOT NULL COMMENT &apos;锁定的方法名&apos;,</span><br><span class="line">  `desc` varchar(255) NOT NULL COMMENT &apos;备注信息&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&apos;锁定中的方法&apos;;</span><br></pre></td></tr></table></figure><p>想要执行某个方法，就使用这个方法名向表中插入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO method_lock (method_name, desc) VALUES (&apos;methodName&apos;, &apos;测试的methodName&apos;);</span><br></pre></td></tr></table></figure><p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>成功插入则获取锁，执行完成后删除对应的行数据释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from method_lock where method_name =&apos;methodName&apos;;</span><br></pre></td></tr></table></figure><p>注意：这里只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的用法可以实现！</p><p>使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：</p><p>1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；</p><p>2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</p><p>3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</p><p>4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p><p>5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</p><ul><li>基于Redis的实现方式</li></ul><p>选用Redis实现分布式锁原因：</p><ol><li>Redis有很高的性能；</li><li>Redis命令对此支持较好，实现起来比较方便</li></ol><p>主要实现方式:</p><ol><li>SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并设置过期时间为600秒，如果成功，则获取锁；</li><li>获取锁后，如果该节点掉线，则到过期时间ock值自动失效；</li><li>释放锁时，使用del删除lock键值；</li></ol><p>使用redis单机来做分布式锁服务，可能会出现单点问题，导致服务可用性差，因此在服务稳定性要求高的场合，官方建议使用redis集群（例如5台，成功请求锁超过3台就认为获取锁），来实现redis分布式锁。详见RedLock。</p><p>优点:性能高，redis可持久化，也能保证数据不易丢失,redis集群方式提高稳定性。</p><p>缺点:使用redis主从切换时可能丢失部分数据。</p><ul><li>基于ZooKeeper的实现方式</li></ul><p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p><ol><li>创建一个目录mylock；</li><li>线程A想获取锁就在mylock目录下创建临时顺序节点；</li><li>获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><p>这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。</p><p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p><p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><p>上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。</p><p>在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。</p><h4 id="19-Etcd怎么实现分布式锁"><a href="#19-Etcd怎么实现分布式锁" class="headerlink" title="19. Etcd怎么实现分布式锁?"></a>19. Etcd怎么实现分布式锁?</h4><p>首先思考下Etcd是什么？可能很多人第一反应可能是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A highly-available key value store for shared configuration and service discovery.</span><br></pre></td></tr></table></figure><p>实际上，etcd 作为一个受到 ZooKeeper 与 doozer 启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p><ul><li>简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。</li><li>安全：可选 SSL 客户认证机制。</li><li>快速：每个实例每秒支持一千次写操作。</li><li>可信：使用 Raft 算法充分实现了分布式。</li></ul><p>但是这里我们主要讲述Etcd如何实现分布式锁?</p><p>因为 Etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p><ul><li>保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</li><li>控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</li></ul><p>在这里Ectd实现分布式锁基本实现原理为：</p><ol><li>在ectd系统里创建一个key</li><li>如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1</li><li>如果创建成功，则认为我获得了锁</li></ol><p>应用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">package etcdsync</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/coreos/etcd/client&quot;</span><br><span class="line">&quot;github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">defaultTTL = 60</span><br><span class="line">defaultTry = 3</span><br><span class="line">deleteAction = &quot;delete&quot;</span><br><span class="line">expireAction = &quot;expire&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// A Mutex is a mutual exclusion lock which is distributed across a cluster.</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">key    string</span><br><span class="line">id     string // The identity of the caller</span><br><span class="line">client client.Client</span><br><span class="line">kapi   client.KeysAPI</span><br><span class="line">ctx    context.Context</span><br><span class="line">ttl    time.Duration</span><br><span class="line">mutex  *sync.Mutex</span><br><span class="line">logger io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// New creates a Mutex with the given key which must be the same</span><br><span class="line">// across the cluster nodes.</span><br><span class="line">// machines are the ectd cluster addresses</span><br><span class="line">func New(key string, ttl int, machines []string) *Mutex &#123;</span><br><span class="line">cfg := client.Config&#123;</span><br><span class="line">Endpoints:               machines,</span><br><span class="line">Transport:               client.DefaultTransport,</span><br><span class="line">HeaderTimeoutPerRequest: time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c, err := client.New(cfg)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hostname, err := os.Hostname()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if len(key) == 0 || len(machines) == 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if key[0] != &apos;/&apos; &#123;</span><br><span class="line">key = &quot;/&quot; + key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ttl &lt; 1 &#123;</span><br><span class="line">ttl = defaultTTL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &amp;Mutex&#123;</span><br><span class="line">key:    key,</span><br><span class="line">id:     fmt.Sprintf(&quot;%v-%v-%v&quot;, hostname, os.Getpid(), time.Now().Format(&quot;20060102-15:04:05.999999999&quot;)),</span><br><span class="line">client: c,</span><br><span class="line">kapi:   client.NewKeysAPI(c),</span><br><span class="line">ctx: context.TODO(),</span><br><span class="line">ttl: time.Second * time.Duration(ttl),</span><br><span class="line">mutex:  new(sync.Mutex),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Lock locks m.</span><br><span class="line">// If the lock is already in use, the calling goroutine</span><br><span class="line">// blocks until the mutex is available.</span><br><span class="line">func (m *Mutex) Lock() (err error) &#123;</span><br><span class="line">m.mutex.Lock()</span><br><span class="line">for try := 1; try &lt;= defaultTry; try++ &#123;</span><br><span class="line">if m.lock() == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.debug(&quot;Lock node %v ERROR %v&quot;, m.key, err)</span><br><span class="line">if try &lt; defaultTry &#123;</span><br><span class="line">m.debug(&quot;Try to lock node %v again&quot;, m.key, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Mutex) lock() (err error) &#123;</span><br><span class="line">m.debug(&quot;Trying to create a node : key=%v&quot;, m.key)</span><br><span class="line">setOptions := &amp;client.SetOptions&#123;</span><br><span class="line">PrevExist:client.PrevNoExist,</span><br><span class="line">TTL:      m.ttl,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := m.kapi.Set(m.ctx, m.key, m.id, setOptions)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">m.debug(&quot;Create node %v OK [%q]&quot;, m.key, resp)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">m.debug(&quot;Create node %v failed [%v]&quot;, m.key, err)</span><br><span class="line">e, ok := err.(client.Error)</span><br><span class="line">if !ok &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if e.Code != client.ErrorCodeNodeExist &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get the already node&apos;s value.</span><br><span class="line">resp, err = m.kapi.Get(m.ctx, m.key, nil)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">m.debug(&quot;Get node %v OK&quot;, m.key)</span><br><span class="line">watcherOptions := &amp;client.WatcherOptions&#123;</span><br><span class="line">AfterIndex : resp.Index,</span><br><span class="line">Recursive:false,</span><br><span class="line">&#125;</span><br><span class="line">watcher := m.kapi.Watcher(m.key, watcherOptions)</span><br><span class="line">for &#123;</span><br><span class="line">m.debug(&quot;Watching %v ...&quot;, m.key)</span><br><span class="line">resp, err = watcher.Next(m.ctx)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.debug(&quot;Received an event : %q&quot;, resp)</span><br><span class="line">if resp.Action == deleteAction || resp.Action == expireAction &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Unlock unlocks m.</span><br><span class="line">// It is a run-time error if m is not locked on entry to Unlock.</span><br><span class="line">//</span><br><span class="line">// A locked Mutex is not associated with a particular goroutine.</span><br><span class="line">// It is allowed for one goroutine to lock a Mutex and then</span><br><span class="line">// arrange for another goroutine to unlock it.</span><br><span class="line">func (m *Mutex) Unlock() (err error) &#123;</span><br><span class="line">defer m.mutex.Unlock()</span><br><span class="line">for i := 1; i &lt;= defaultTry; i++ &#123;</span><br><span class="line">var resp *client.Response</span><br><span class="line">resp, err = m.kapi.Delete(m.ctx, m.key, nil)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">m.debug(&quot;Delete %v OK&quot;, m.key)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">m.debug(&quot;Delete %v falied: %q&quot;, m.key, resp)</span><br><span class="line">e, ok := err.(client.Error)</span><br><span class="line">if ok &amp;&amp; e.Code == client.ErrorCodeKeyNotFound &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Mutex) debug(format string, v ...interface&#123;&#125;) &#123;</span><br><span class="line">if m.logger != nil &#123;</span><br><span class="line">m.logger.Write([]byte(m.id))</span><br><span class="line">m.logger.Write([]byte(&quot; &quot;))</span><br><span class="line">m.logger.Write([]byte(fmt.Sprintf(format, v...)))</span><br><span class="line">m.logger.Write([]byte(&quot;\n&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *Mutex) SetDebugLogger(w io.Writer) &#123;</span><br><span class="line">m.logger = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实类似的实现有很多，但目前都已经过时，使用的都是被官方标记为deprecated的项目。且大部分接口都不如上述代码简单。 使用上，跟Golang官方sync包的Mutex接口非常类似，先New()，然后调用Lock()，使用完后调用Unlock()，就三个接口，就是这么简单。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/zieckey/etcdsync&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//etcdsync.SetDebug(true)</span><br><span class="line">log.SetFlags(log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line">m := etcdsync.New(&quot;/etcdsync&quot;, &quot;123&quot;, []string&#123;&quot;http://127.0.0.1:2379&quot;&#125;)</span><br><span class="line">if m == nil &#123;</span><br><span class="line">log.Printf(&quot;etcdsync.NewMutex failed&quot;)</span><br><span class="line">&#125;</span><br><span class="line">err := m.Lock()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Printf(&quot;etcdsync.Lock failed&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Printf(&quot;etcdsync.Lock OK&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;Get the lock. Do something here.&quot;)</span><br><span class="line"></span><br><span class="line">err = m.Unlock()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Printf(&quot;etcdsync.Unlock failed&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Printf(&quot;etcdsync.Unlock OK&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="20-Redis的数据结构有哪些，以及实现场景"><a href="#20-Redis的数据结构有哪些，以及实现场景" class="headerlink" title="20. Redis的数据结构有哪些，以及实现场景?"></a>20. Redis的数据结构有哪些，以及实现场景?</h4><p>Redis的数据结构有五种:</p><ul><li>string 字符串</li></ul><p>String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。</p><p>除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：</p><ol><li>LEN niushuai：O(1)获取字符串长度.</li><li>APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）.</li><li>设置和获取字符串的某一段内容.</li><li>设置及获取字符串的某一位（bit）.</li><li>批量设置一系列字符串的内容.</li><li>原子计数器.</li><li>GETSET 命令的妙用，请于清空旧值的同时设置一个新值，配合原子计数器使用.</li></ol><ul><li>Hash 字典</li></ul><p>在 Memcached 中，我们经常将一些结构化的信息打包成 hashmap，在客户端序列化后存储为一个字符串的值（一般是 JSON 格式），比如用户的昵称、年龄、性别、积分等。这时候在需要修改其中某一项时，通常需要将字符串（JSON）取出来，然后进行反序列化，修改某一项的值，再序列化成字符串（JSON）存储回去。简单修改一个属性就干这么多事情，消耗必定是很大的，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而 Redis 的 Hash 结构可以使你像在数据库中 Update 一个属性一样只修改某一项属性值。</p><p>Hash可以用来存储、读取、修改用户属性。</p><ul><li>List 列表</li></ul><p>List 说白了就是链表（redis 使用双端链表实现的 List），相信学过数据结构知识的人都应该能理解其结构。使用 List 结构，我们可以轻松地实现最新消息排行等功能（比如新浪微博的 TimeLine ）。List 的另一个应用就是消息队列，可以利用 List 的 *PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。</p><p>Redis 还提供了操作 List 中某一段元素的 API，你可以直接查询，删除 List 中某一段的元素。</p><p>List 列表应用:</p><ol><li>微博 TimeLine.</li><li>消息队列.</li></ol><ul><li>Set 集合</li></ul><p>Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p><p>Set 集合应用:</p><ol><li>共同好友、二度好友</li><li>利用唯一性，可以统计访问网站的所有独立 IP.</li><li>好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐.</li></ol><ul><li>Sorted Set有序集合</li></ul><p>和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p><p>Sorted Set有序集合应用:</p><p>1.带有权重的元素，比如一个游戏的用户得分排行榜. 2.比较复杂的数据结构，一般用到的场景不算太多.</p><p>Redis 其他功能使用场景:</p><ul><li>订阅-发布系统</li></ul><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><ul><li>事务——Transactions</li></ul><p>谁说 NoSQL 都不支持事务，虽然 Redis 的 Transactions 提供的并不是严格的 ACID 的事务（比如一串用 EXEC 提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个 Transactions 还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行。</p><h4 id="21-Mysql高可用方案有哪些"><a href="#21-Mysql高可用方案有哪些" class="headerlink" title="21. Mysql高可用方案有哪些?"></a>21. Mysql高可用方案有哪些?</h4><p>Mysql高可用方案包括:</p><ol><li>主从复制方案</li></ol><p>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。MySQL replication就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。为了达到更高的可用性，在实际的应用环境中，一般都是采用MySQL replication技术配合高可用集群软件keepalived来实现自动failover，这种方式可以实现95.000%的SLA。</p><ol><li>MMM/MHA高可用方案</li></ol><p>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。</p><ol><li>Heartbeat/SAN高可用方案</li></ol><p>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。</p><ol><li>Heartbeat/DRBD高可用方案</li></ol><p>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。</p><ol><li>NDB CLUSTER高可用方案</li></ol><p>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉。缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免。</p><h4 id="22-Go语言的栈空间管理是怎么样的"><a href="#22-Go语言的栈空间管理是怎么样的" class="headerlink" title="22. Go语言的栈空间管理是怎么样的?"></a>22. Go语言的栈空间管理是怎么样的?</h4><p>Go语言的运行环境（runtime）会在goroutine需要的时候动态地分配栈空间，而不是给每个goroutine分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小。</p><p>分块式的栈是最初Go语言组织栈的方式。当创建一个goroutine的时候，它会分配一个8KB的内存空间来给goroutine的栈使用。我们可能会考虑当这8KB的栈空间被用完的时候该怎么办?</p><p>为了处理这种情况，每个Go函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空间。如果是的话，它会调用<code>morestack</code>函数。<code>morestack</code>函数分配一块新的内存作为栈空间，并且在这块栈空间的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的函数。这个过程叫做栈分裂（stack split）。</p><p>在新分配的栈底部，还插入了一个叫做<code>lessstack</code>的函数指针。这个函数还没有被调用。这样设置是为了从刚才造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到<code>lessstack</code>。<code>lessstack</code>函数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了。</p><p><code>分块式的栈</code>让我们能够按照需求来扩展和收缩栈的大小。 Go开发者不需要花精力去估计goroutine会用到多大的栈。创建一个新的goroutine的开销也不大。当 Go开发者不知道栈会扩展到多少大时，它也能很好的处理这种情况。</p><p>这一直是之前Go语言管理栈的的方法。但这个方法有一个问题。缩减栈空间是一个开销相对较大的操作。如果在一个循环里有栈分裂，那么它的开销就变得不可忽略了。一个函数会扩展，然后分裂栈。当它返回的时候又会释放之前分配的内存块。如果这些都发生在一个循环里的话，代价是相当大的。 这就是所谓的热分裂问题（hot split problem）。它是Go语言开发者选择新的栈管理方法的主要原因。新的方法叫做<code>栈复制法（stack copying）</code>。</p><p>栈复制法一开始和分块式的栈很像。当goroutine运行并用完栈空间的时候，与之前的方法一样，栈溢出检查会被触发。但是，不像之前的方法那样分配一个新的内存块并链接到老的栈内存块，新的方法会分配一个两倍大的内存块并把老的内存块内容复制到新的内存块里。这样做意味着当栈缩减回之前大小时，我们不需要做任何事情。栈的缩减没有任何代价。而且，当栈再次扩展时，运行环境也不需要再做任何事。它可以重用之前分配的空间。</p><p>栈的复制听起来很容易，但实际操作并非那么简单。存储在栈上的变量的地址可能已经被使用到。也就是说程序使用到了一些指向栈的指针。当移动栈的时候，所有指向栈里内容的指针都会变得无效。然而，指向栈内容的指针自身也必定是保存在栈上的。这是为了保证内存安全的必要条件。否则一个程序就有可能访问一段已经无效的栈空间了。</p><p>因为垃圾回收的需要，我们必须知道栈的哪些部分是被用作指针了。当我们移动栈的时候，我们可以更新栈里的指针让它们指向新的地址。所有相关的指针都会被更新。我们使用了垃圾回收的信息来复制栈，但并不是任何使用栈的函数都有这些信息。因为很大一部分运行环境是用C语言写的，很多被调用的运行环境里的函数并没有指针的信息，所以也就不能够被复制了。当遇到这种情况时，我们只能退回到分块式的栈并支付相应的开销。</p><p>这也是为什么现在运行环境的开发者正在用Go语言重写运行环境的大部分代码。无法用Go语言重写的部分（比如调度器的核心代码和垃圾回收器）会在特殊的栈上运行。这个特殊栈的大小由运行环境的开发者设置。</p><p>这些改变除了使栈复制成为可能，它也允许我们在将来实现并行垃圾回收。</p><p>另外一种不同的栈处理方式就是在虚拟内存中分配大内存段。由于物理内存只是在真正使用时才会被分配，因此看起来好似你可以分配一个大内存段并让操 作系统处理它。下面是这种方法的一些问题</p><p>首先，32位系统只能支持4G字节虚拟内存，并且应用只能用到其中的3G空间。由于同时运行百万goroutines的情况并不少见，因此你很可 能用光虚拟内存，即便我们假设每个goroutine的stack只有8K。</p><p>第二，然而我们可以在64位系统中分配大内存，它依赖于过量内存使用。所谓过量使用是指当你分配的内存大小超出物理内存大小时，依赖操作系统保证 在需要时能够分配出物理内存。然而，允许过量使用可能会导致一些风险。由于一些进程分配了超出机器物理内存大小的内存，如果这些进程使用更多内存 时，操作系统将不得不为它们补充分配内存。这会导致操作系统将一些内存段放入磁盘缓存，这常常会增加不可预测的处理延迟。正是考虑到这个原因，一 些新系统关闭了对过量使用的支持。</p><h4 id="23-Goroutine和Channel的作用分别是什么"><a href="#23-Goroutine和Channel的作用分别是什么" class="headerlink" title="23. Goroutine和Channel的作用分别是什么?"></a>23. Goroutine和Channel的作用分别是什么?</h4><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。</p><p>那协程又是什么呢，以及与线程的差异性??</p><p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。</p><p>最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。</p><p>Go中的goroutinue就是协程,可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）。 然而,多个goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</p><p>goroutine非常简单，只需要在函数的调用前面加关键字go即可，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go elegance()</span><br></pre></td></tr></table></figure><p>我们也可以启动5个goroutines分别打印索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">for i:=1;i&lt;5;i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">// 停歇5s，保证打印全部结束</span><br><span class="line">time.Sleep(5*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析goroutine执行的随机性和并发性，启动了5个goroutine，再加上main函数的主goroutine，总共有6个goroutines。由于goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。</p><p>在Golang中channel则是goroutinues之间进行通信的渠道。</p><p>可以把channel形象比喻为工厂里的传送带,一头的生产者goroutine往传输带放东西,另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列,遵循先进先出的特点。</p><ol><li>channel的操作符号</li></ol><p>ch &lt;- data 表示data被发送给channel ch；</p><p>data &lt;- ch 表示从channel ch取一个值，然后赋给data。</p><ol><li>阻塞式channel</li></ol><p>channel默认是没有缓冲区的，也就是说，通信是阻塞的。send操作必须等到有消费者accept才算完成。</p><p>应用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ch1 := make(chan int)</span><br><span class="line">go pump(ch1) // pump hangs</span><br><span class="line">fmt.Println(&lt;-ch1) // prints only 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump(ch chan int) &#123;</span><br><span class="line">for i:= 1; ; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数pump()里的channel在接受到第一个元素后就被阻塞了，直到主goroutinue取走了数据。最终channel阻塞在接受第二个元素，程序只打印 1。</p><p>没有缓冲(buffer)的channel只能容纳一个元素，而带有缓冲(buffer)channel则可以非阻塞容纳N个元素。发送数据到缓冲(buffer) channel不会被阻塞，除非channel已满；同样的，从缓冲(buffer) channel取数据也不会被阻塞，除非channel空了。</p><h4 id="24-怎么查看Goroutine的数量"><a href="#24-怎么查看Goroutine的数量" class="headerlink" title="24. 怎么查看Goroutine的数量?"></a>24. 怎么查看Goroutine的数量?</h4><p>GOMAXPROCS中控制的是未被阻塞的所有Goroutine,可以被Multiplex到多少个线程上运行,通过GOMAXPROCS可以查看Goroutine的数量。</p><h4 id="25-说下Go中的锁有哪些-三种锁，读写锁，互斥锁，还有map的安全的锁"><a href="#25-说下Go中的锁有哪些-三种锁，读写锁，互斥锁，还有map的安全的锁" class="headerlink" title="25. 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁?"></a>25. 说下Go中的锁有哪些?三种锁，读写锁，互斥锁，还有map的安全的锁?</h4><p>Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁.</p><ul><li>互斥锁</li></ul><p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Mutex 是互斥锁， 零值是解锁的互斥锁， 首次使用后不得复制互斥锁。</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">   state int32</span><br><span class="line">   sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Locker表示可以锁定和解锁的对象。</span><br><span class="line">type Locker interface &#123;</span><br><span class="line">   Lock()</span><br><span class="line">   Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//锁定当前的互斥量</span><br><span class="line">//如果锁已被使用，则调用goroutine</span><br><span class="line">//阻塞直到互斥锁可用。</span><br><span class="line">func (m *Mutex) Lock() </span><br><span class="line"></span><br><span class="line">//对当前互斥量进行解锁</span><br><span class="line">//如果在进入解锁时未锁定m，则为运行时错误。</span><br><span class="line">//锁定的互斥锁与特定的goroutine无关。</span><br><span class="line">//允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。</span><br><span class="line">func (m *Mutex) Unlock()</span><br></pre></td></tr></table></figure><p>声明一个互斥锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br></pre></td></tr></table></figure><p>不像C或Java的锁类工具，我们可能会犯一个错误：忘记及时解开已被锁住的锁，从而导致流程异常。但Go由于存在defer，所以此类问题出现的概率极低。关于defer解锁的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br><span class="line">func Write()  &#123;</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   defer mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fpackage main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var mutex sync.Mutex</span><br><span class="line">fmt.Println(&quot;begin lock&quot;)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(&quot;get locked&quot;)</span><br><span class="line">for i := 1; i &lt;= 3; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Println(&quot;begin lock &quot;, i)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(&quot;get locked &quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(&quot;Unlock the lock&quot;)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">fmt.Println(&quot;get unlocked&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在for循环之前开始加锁，然后在每一次循环中创建一个协程，并对其加锁，但是由于之前已经加锁了，所以这个for循环中的加锁会陷入阻塞直到main中的锁被解锁， time.Sleep(time.Second) 是为了能让系统有足够的时间运行for循环，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run mutex.go </span><br><span class="line">begin lock</span><br><span class="line">get locked</span><br><span class="line">begin lock  3</span><br><span class="line">begin lock  1</span><br><span class="line">begin lock  2</span><br><span class="line">Unlock the lock</span><br><span class="line">get unlocked</span><br><span class="line">get locked  3</span><br></pre></td></tr></table></figure><p>这里可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程3获胜。</p><p>互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer。</p><p>我们知道如果遇到panic，可以使用recover方法进行恢复，但是如果对重复解锁互斥锁引发的panic却是无用的（Go 1.8及以后）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Println(&quot;Try to recover the panic&quot;)</span><br><span class="line">if p := recover(); p != nil &#123;</span><br><span class="line">fmt.Println(&quot;recover the panic : &quot;, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">var mutex sync.Mutex</span><br><span class="line">fmt.Println(&quot;begin lock&quot;)</span><br><span class="line">mutex.Lock()</span><br><span class="line">fmt.Println(&quot;get locked&quot;)</span><br><span class="line">fmt.Println(&quot;unlock lock&quot;)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">fmt.Println(&quot;lock is unlocked&quot;)</span><br><span class="line">fmt.Println(&quot;unlock lock again&quot;)</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run mutex.go </span><br><span class="line">begin lock</span><br><span class="line">get locked</span><br><span class="line">unlock lock</span><br><span class="line">lock is unlocked</span><br><span class="line">unlock lock again</span><br><span class="line">fatal error: sync: unlock of unlocked mutex</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">runtime.throw(0x4bc1a8, 0x1e)</span><br><span class="line">        /home/keke/soft/go/src/runtime/panic.go:617 +0x72 fp=0xc000084ea8 sp=0xc000084e78 pc=0x427ba2</span><br><span class="line">sync.throw(0x4bc1a8, 0x1e)</span><br><span class="line">        /home/keke/soft/go/src/runtime/panic.go:603 +0x35 fp=0xc000084ec8 sp=0xc000084ea8 pc=0x427b25</span><br><span class="line">sync.(*Mutex).Unlock(0xc00001a0c8)</span><br><span class="line">        /home/keke/soft/go/src/sync/mutex.go:184 +0xc1 fp=0xc000084ef0 sp=0xc000084ec8 pc=0x45f821</span><br><span class="line">main.main()</span><br><span class="line">        /home/keke/go/Test/mutex.go:25 +0x25f fp=0xc000084f98 sp=0xc000084ef0 pc=0x486c1f</span><br><span class="line">runtime.main()</span><br><span class="line">        /home/keke/soft/go/src/runtime/proc.go:200 +0x20c fp=0xc000084fe0 sp=0xc000084f98 pc=0x4294ec</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc000084fe8 sp=0xc000084fe0 pc=0x450ad1</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>这里试图对重复解锁引发的panic进行recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是建议将对同一个互斥锁的加锁解锁操作放在同一个层次的代码中。</p><ul><li>读写锁</li></ul><p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。</p><p>读写锁的访问控制规则如下：</p><p>① 多个写操作之间是互斥的 ② 写操作与读操作之间也是互斥的 ③ 多个读操作之间不是互斥的</p><p>在这样的控制规则下，读写锁可以大大降低性能损耗。</p><p>在Go的标准库代码包中sync中的RWMutex结构体表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// RWMutex是一个读/写互斥锁，可以由任意数量的读操作或单个写操作持有。</span><br><span class="line">// RWMutex的零值是未锁定的互斥锁。</span><br><span class="line">//首次使用后，不得复制RWMutex。</span><br><span class="line">//如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，goroutine不应该期望能够获取读锁定。 </span><br><span class="line">//特别是，这种禁止递归读锁定。 这是为了确保锁最终变得可用; 阻止的锁定会阻止新读操作获取锁定。</span><br><span class="line">type RWMutex struct &#123;</span><br><span class="line">   w           Mutex  //如果有待处理的写操作就持有</span><br><span class="line">   writerSem   uint32 // 写操作等待读操作完成的信号量</span><br><span class="line">   readerSem   uint32 //读操作等待写操作完成的信号量</span><br><span class="line">   readerCount int32  // 待处理的读操作数量</span><br><span class="line">   readerWait  int32  // number of departing readers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync中的RWMutex有以下几种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//对读操作的锁定</span><br><span class="line">func (rw *RWMutex) RLock()</span><br><span class="line">//对读操作的解锁</span><br><span class="line">func (rw *RWMutex) RUnlock()</span><br><span class="line">//对写操作的锁定</span><br><span class="line">func (rw *RWMutex) Lock()</span><br><span class="line">//对写操作的解锁</span><br><span class="line">func (rw *RWMutex) Unlock()</span><br><span class="line"></span><br><span class="line">//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.</span><br><span class="line">func (rw *RWMutex) RLocker() Locker</span><br></pre></td></tr></table></figure><p>Unlock方法会试图唤醒所有想进行读锁定而被阻塞的协程，而 RUnlock方法只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写锁定而被阻塞的协程。若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</p><p>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var rwm sync.RWMutex</span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Println(&quot;try to lock read &quot;, i)</span><br><span class="line">rwm.RLock()</span><br><span class="line">fmt.Println(&quot;get locked &quot;, i)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">fmt.Println(&quot;try to unlock for reading &quot;, i)</span><br><span class="line">rwm.RUnlock()</span><br><span class="line">fmt.Println(&quot;unlocked for reading &quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * 1000)</span><br><span class="line">fmt.Println(&quot;try to lock for writing&quot;)</span><br><span class="line">rwm.Lock()</span><br><span class="line">fmt.Println(&quot;locked for writing&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run rwmutex.go </span><br><span class="line">try to lock read  0</span><br><span class="line">get locked  0</span><br><span class="line">try to lock read  4</span><br><span class="line">get locked  4</span><br><span class="line">try to lock read  3</span><br><span class="line">get locked  3</span><br><span class="line">try to lock read  1</span><br><span class="line">get locked  1</span><br><span class="line">try to lock read  2</span><br><span class="line">get locked  2</span><br><span class="line">try to lock for writing</span><br><span class="line">try to unlock for reading  0</span><br><span class="line">unlocked for reading  0</span><br><span class="line">try to unlock for reading  2</span><br><span class="line">unlocked for reading  2</span><br><span class="line">try to unlock for reading  1</span><br><span class="line">unlocked for reading  1</span><br><span class="line">try to unlock for reading  3</span><br><span class="line">unlocked for reading  3</span><br><span class="line">try to unlock for reading  4</span><br><span class="line">unlocked for reading  4</span><br><span class="line">locked for writing</span><br></pre></td></tr></table></figure><p>这里可以看到创建了五个协程用于对读写锁的读锁定与读解锁操作。在 rwm.Lock()种会对main中协程进行写锁定，但是for循环中的读解锁尚未完成，因此会造成mian中的协程阻塞。当for循环中的读解锁操作都完成后就会试图唤醒main中阻塞的协程，main中的写锁定才会完成。</p><ul><li>sync.Map安全锁</li></ul><p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体。</p><p>应用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    //开箱即用</span><br><span class="line">    var sm sync.Map</span><br><span class="line">    //store 方法,添加元素</span><br><span class="line">    sm.Store(1,&quot;a&quot;)</span><br><span class="line">    //Load 方法，获得value</span><br><span class="line">    if v,ok:=sm.Load(1);ok&#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    //LoadOrStore方法，获取或者保存</span><br><span class="line">    //参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则store，返回该value 和false</span><br><span class="line">    if vv,ok:=sm.LoadOrStore(1,&quot;c&quot;);ok&#123;</span><br><span class="line">        fmt.Println(vv)</span><br><span class="line">    &#125;</span><br><span class="line">    if vv,ok:=sm.LoadOrStore(2,&quot;c&quot;);!ok&#123;</span><br><span class="line">        fmt.Println(vv)</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false时，遍历立刻结束。</span><br><span class="line">    sm.Range(func(k,v interface&#123;&#125;)bool&#123;</span><br><span class="line">        fmt.Print(k)</span><br><span class="line">        fmt.Print(&quot;:&quot;)</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">        fmt.Println()</span><br><span class="line">        return true</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">1:a</span><br><span class="line">2:c</span><br></pre></td></tr></table></figure><p>sync.Map的数据结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> type Map struct &#123;</span><br><span class="line">    // 该锁用来保护dirty</span><br><span class="line">    mu Mutex</span><br><span class="line">    // 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的</span><br><span class="line">    read atomic.Value // readOnly</span><br><span class="line">    //包含最新的写入的数据，并且在写的时候，会把read 中未被删除的数据拷贝到该dirty中，因为是普通的map存在并发安全问题，需要用到上面的mu字段。</span><br><span class="line">    dirty map[interface&#123;&#125;]*entry</span><br><span class="line">    // 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷贝到read中（从而提升读的性能）。</span><br><span class="line">    misses int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read的数据结构是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type readOnly struct &#123;</span><br><span class="line">    m  map[interface&#123;&#125;]*entry</span><br><span class="line">    // 如果Map.dirty的数据和m 中的数据不一样是为true</span><br><span class="line">    amended bool </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type entry struct &#123;</span><br><span class="line">    //可见value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存储的空间应该不是问题</span><br><span class="line">    p unsafe.Pointer // *interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (m *Map) Delete(key interface&#123;&#125;) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    //如果read中没有，并且dirty中有新元素，那么就去dirty中去找</span><br><span class="line">    if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        //这是双检查（上面的if判断和锁不是一个原子性操作）</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            //直接删除</span><br><span class="line">            delete(m.dirty, key)</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    if ok &#123;</span><br><span class="line">    //如果read中存在该key，则将该value 赋值nil（采用标记的方式删除！）</span><br><span class="line">        e.delete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *entry) delete() (hadValue bool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        if p == nil || p == expunged &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Store 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">func (m *Map) Store(key, value interface&#123;&#125;) &#123;</span><br><span class="line">    // 如果m.read存在这个key，并且没有被标记删除，则尝试更新。</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果read不存在或者已经被标记删除</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    if e, ok := read.m[key]; ok &#123;</span><br><span class="line">    //如果entry被标记expunge，则表明dirty没有key，可添加入dirty，并更新entry</span><br><span class="line">        if e.unexpungeLocked() &#123; </span><br><span class="line">            //加入dirty中</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        //更新value值</span><br><span class="line">        e.storeLocked(&amp;value) </span><br><span class="line">        //dirty 存在该key，更新</span><br><span class="line">    &#125; else if e, ok := m.dirty[key]; ok &#123; </span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">        //read 和dirty都没有，新添加一条</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     //dirty中没有新的数据，往dirty中增加第一个新键</span><br><span class="line">        if !read.amended &#123; </span><br><span class="line">            //将read中未删除的数据加入到dirty中</span><br><span class="line">            m.dirtyLocked() </span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: true&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value) </span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将read中未删除的数据加入到dirty中</span><br><span class="line">func (m *Map) dirtyLocked() &#123;</span><br><span class="line">    if m.dirty != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = make(map[interface&#123;&#125;]*entry, len(read.m))</span><br><span class="line">    //read如果较大的话，可能影响性能</span><br><span class="line">    for k, e := range read.m &#123;</span><br><span class="line">    //通过此次操作，dirty中的元素都是未被删除的，可见expunge的元素不在dirty中</span><br><span class="line">        if !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断entry是否被标记删除，并且将标记为nil的entry更新标记为expunge</span><br><span class="line">func (e *entry) tryExpungeLocked() (isExpunged bool) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    for p == nil &#123;</span><br><span class="line">        // 将已经删除标记为nil的数据标记为expunged</span><br><span class="line">        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    return p == expunged</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对entry 尝试更新</span><br><span class="line">func (e *entry) tryStore(i *interface&#123;&#125;) bool &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    if p == expunged &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    for &#123;</span><br><span class="line">        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        if p == expunged &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//read里 将标记为expunge的更新为nil</span><br><span class="line">func (e *entry) unexpungeLocked() (wasExpunged bool) &#123;</span><br><span class="line">    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新entry</span><br><span class="line">func (e *entry) storeLocked(i *interface&#123;&#125;) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，每次操作先检查read，因为read 并发安全，性能好些；read不满足，则加锁检查dirty，一旦是新的键值，dirty会被read更新。</p><p>Load方法:</p><p>Load方法是一个加载方法，查找key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;</span><br><span class="line">    //因read只读，线程安全，先查看是否满足条件</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    //如果read没有，并且dirty有新数据，那从dirty中查找，由于dirty是普通map，线程不安全，这个时候用到互斥锁了</span><br><span class="line">    if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        // 双重检查</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        // 如果read中还是不存在，并且dirty中有新数据</span><br><span class="line">        if !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            // mssLocked（）函数是性能是sync.Map 性能得以保证的重要函数，目的讲有锁的dirty数据，替换到只读线程安全的read里</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        return nil, false</span><br><span class="line">    &#125;</span><br><span class="line">    return e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//dirty 提升至read 关键函数，当misses 经过多次因为load之后，大小等于len（dirty）时候，讲dirty替换到read里，以此达到性能提升。</span><br><span class="line">func (m *Map) missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    if m.misses &lt; len(m.dirty) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    //原子操作，耗时很小</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = nil</span><br><span class="line">    m.misses = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Map是通过冗余的两个数据结构(read、dirty),实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除。</p><h4 id="26-读写锁或者互斥锁读的时候能写吗"><a href="#26-读写锁或者互斥锁读的时候能写吗" class="headerlink" title="26. 读写锁或者互斥锁读的时候能写吗?"></a>26. 读写锁或者互斥锁读的时候能写吗?</h4><p>Go中读写锁包括读锁和写锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的。</p><h4 id="27-怎么限制Goroutine的数量"><a href="#27-怎么限制Goroutine的数量" class="headerlink" title="27. 怎么限制Goroutine的数量."></a>27. 怎么限制Goroutine的数量.</h4><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量,这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var ch chan  int</span><br><span class="line"></span><br><span class="line">func elegance()&#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(&quot;the ch value receive&quot;,ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">ch = make(chan int,5)</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">ch &lt;-1</span><br><span class="line">fmt.Println(&quot;the ch value send&quot;,ch)</span><br><span class="line">go elegance()</span><br><span class="line">fmt.Println(&quot;the result i&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run goroutine.go </span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 0</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 1</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 2</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 3</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 4</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 5</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the result i 6</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 7</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 8</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 9</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the result i 10</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 11</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 12</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the result i 13</span><br><span class="line">the ch value send 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">the result i 14</span><br><span class="line">the ch value receive 0xc00009c000</span><br><span class="line">&gt; go run goroutine.go </span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 0</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 1</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 2</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 3</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the result i 4</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the result i 5</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the result i 6</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 7</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the ch value receive 0xc00007e000</span><br><span class="line">the result i 8</span><br><span class="line">the ch value send 0xc00007e000</span><br><span class="line">the result i 9</span><br></pre></td></tr></table></figure><p>这样每次同时运行的goroutine就被限制为5个了。但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line">// Pool Goroutine Pool</span><br><span class="line">type Pool struct &#123;</span><br><span class="line">queue chan int</span><br><span class="line">wg *sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line">// New 新建一个协程池</span><br><span class="line">func NewPool(size int) *Pool&#123;</span><br><span class="line">if size &lt;=0&#123;</span><br><span class="line">size = 1</span><br><span class="line">&#125;</span><br><span class="line">return &amp;Pool&#123;</span><br><span class="line">queue:make(chan int,size),</span><br><span class="line">wg:&amp;sync.WaitGroup&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Add 新增一个执行</span><br><span class="line">func (p *Pool)Add(delta int)&#123;</span><br><span class="line">// delta为正数就添加</span><br><span class="line">for i :=0;i&lt;delta;i++&#123;</span><br><span class="line">p.queue &lt;-1</span><br><span class="line">&#125;</span><br><span class="line">// delta为负数就减少</span><br><span class="line">for i:=0;i&gt;delta;i--&#123;</span><br><span class="line">&lt;-p.queue</span><br><span class="line">&#125;</span><br><span class="line">p.wg.Add(delta)</span><br><span class="line">&#125;</span><br><span class="line">// Done 执行完成减一</span><br><span class="line">func (p *Pool) Done()&#123;</span><br><span class="line">&lt;-p.queue</span><br><span class="line">p.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">// Wait 等待Goroutine执行完毕</span><br><span class="line">func (p *Pool) Wait()&#123;</span><br><span class="line">p.wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">// 这里限制5个并发</span><br><span class="line">pool := NewPool(5)</span><br><span class="line">fmt.Println(&quot;the NumGoroutine begin is:&quot;,runtime.NumGoroutine())</span><br><span class="line">for i:=0;i&lt;20;i++&#123;</span><br><span class="line">pool.Add(1)</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(&quot;the NumGoroutine continue is:&quot;,runtime.NumGoroutine())</span><br><span class="line">pool.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">pool.Wait()</span><br><span class="line">fmt.Println(&quot;the NumGoroutine done is:&quot;,runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">the NumGoroutine begin is: 1</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 7</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 6</span><br><span class="line">the NumGoroutine continue is: 3</span><br><span class="line">the NumGoroutine continue is: 2</span><br><span class="line">the NumGoroutine done is: 1</span><br></pre></td></tr></table></figure><p>其中，Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU,最大程度的提高我们程序的并发性能。runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。</p><p>这里需要注意下：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。</p><h4 id="28-Channel是同步的还是异步的"><a href="#28-Channel是同步的还是异步的" class="headerlink" title="28. Channel是同步的还是异步的."></a>28. Channel是同步的还是异步的.</h4><p>Channel是异步进行的。</p><p>channel存在3种状态：</p><ul><li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li><li>active，正常的channel，可读或者可写</li><li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li></ul><h4 id="29-说一下异步和非阻塞的区别"><a href="#29-说一下异步和非阻塞的区别" class="headerlink" title="29. 说一下异步和非阻塞的区别?"></a>29. 说一下异步和非阻塞的区别?</h4><ul><li>异步和非阻塞的区别:</li></ul><ol><li>异步：调用在发出之后，这个调用就直接返回，不管有无结果；异步是过程。</li><li>非阻塞：关注的是程序在等待调用结果（消息，返回值）时的状态，指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ol><ul><li>同步和异步的区别：</li></ul><ol><li>步：一个服务的完成需要依赖其他服务时，只有等待被依赖的服务完成后，才算完成，这是一种可靠的服务序列。要么成功都成功，失败都失败，服务的状态可以保持一致。</li><li>异步：一个服务的完成需要依赖其他服务时，只通知其他依赖服务开始执行，而不需要等待被依赖的服务完成，此时该服务就算完成了。被依赖的服务是否最终完成无法确定，一次它是一个不可靠的服务序列。</li></ol><ul><li>消息通知中的同步和异步：</li></ul><ol><li>同步：当一个同步调用发出后，调用者要一直等待返回消息（或者调用结果）通知后，才能进行后续的执行。</li><li>异步：当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。在调用结束之后，通过消息回调来通知调用者是否调用成功。</li></ol><ul><li>阻塞与非阻塞的区别：</li></ul><ol><li>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务,函数只有在得到结果之后才会返回。</li><li>非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li></ol><p>同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。</p><p>阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。</p><p>阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。</p><h4 id="30-Log包线程安全吗？"><a href="#30-Log包线程安全吗？" class="headerlink" title="30. Log包线程安全吗？"></a>30. Log包线程安全吗？</h4><p>Golang的标准库提供了log的机制，但是该模块的功能较为简单（看似简单，其实他有他的设计思路）。在输出的位置做了线程安全的保护。</p><h4 id="31-Goroutine和线程的区别"><a href="#31-Goroutine和线程的区别" class="headerlink" title="31. Goroutine和线程的区别?"></a>31. Goroutine和线程的区别?</h4><p>从调度上看，goroutine的调度开销远远小于线程调度开销。</p><p>OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。</p><p>Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。</p><p>从栈空间上，goroutine的栈空间更加动态灵活。</p><p>每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。</p><p>goroutine没有一个特定的标识。</p><p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。</p><p>goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。</p><h4 id="32-滑动窗口的概念以及应用"><a href="#32-滑动窗口的概念以及应用" class="headerlink" title="32. 滑动窗口的概念以及应用?"></a>32. 滑动窗口的概念以及应用?</h4><p>滑动窗口概念不仅存在于数据链路层，也存在于传输层，两者有不同的协议，但基本原理是相近的。其中一个重要区别是，一个是针对于帧的传送，另一个是字节数据的传送。</p><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。参见滑动窗口如何根据网络拥塞发送数据仿真视频。</p><p>滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。</p><p>CP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h4 id="33-怎么做弹性扩缩容，原理是什么"><a href="#33-怎么做弹性扩缩容，原理是什么" class="headerlink" title="33. 怎么做弹性扩缩容，原理是什么?"></a>33. 怎么做弹性扩缩容，原理是什么?</h4><p>弹性伸缩（Auto Scaling）根据您的业务需求和伸缩策略，为您自动调整计算资源。您可设置定时、周期或监控策略，恰到好处地增加或减少CVM实例，并完成实例配置，保证业务平稳健康运行。在需求高峰期时，弹性伸缩自动增加CVM实例的数量，以保证性能不受影响；当需求较低时，则会减少CVM实例数量以降低成本。弹性伸缩既适合需求稳定的应用程序，同时也适合每天、每周、每月使用量不停波动的应用程序。</p><h4 id="34-让你设计一个web框架，你要怎么设计，说一下步骤"><a href="#34-让你设计一个web框架，你要怎么设计，说一下步骤" class="headerlink" title="34. 让你设计一个web框架，你要怎么设计，说一下步骤."></a>34. 让你设计一个web框架，你要怎么设计，说一下步骤.</h4><h4 id="35-说一下中间件原理"><a href="#35-说一下中间件原理" class="headerlink" title="35. 说一下中间件原理."></a>35. 说一下中间件原理.</h4><p>中间件（middleware）是基础软件的一大类，属于可复用软件的范畴。中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件  IDC的定义是：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。</p><p>中间件解决的问题是：</p><p>在中间件产生以前，应用软件直接使用操作系统、网络协议和数据库等开发，这些都是计算机最底层的东西，越底层越复杂，开发者不得不面临许多很棘手的问题，如操作系统的多样性，繁杂的网络程序设计、管理，复杂多变的网络环境，数据分散处理带来的不一致性问题、性能和效率、安全，等等。这些与用户的业务没有直接关系，但又必须解决，耗费了大量有限的时间和精力。于是，有人提出能不能将应用软件所要面临的共性问题进行提炼、抽象，在操作系统之上再形成一个可复用的部分，供成千上万的应用软件重复使用。这一技术思想最终构成了中间件这类的软件。中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><h4 id="36-怎么设计orm，让你写-你会怎么写"><a href="#36-怎么设计orm，让你写-你会怎么写" class="headerlink" title="36. 怎么设计orm，让你写,你会怎么写?"></a>36. 怎么设计orm，让你写,你会怎么写?</h4><h4 id="37-用过原生的http包吗？"><a href="#37-用过原生的http包吗？" class="headerlink" title="37. 用过原生的http包吗？"></a>37. 用过原生的http包吗？</h4><h4 id="38-一个非常大的数组，让其中两个数想加等于1000怎么算"><a href="#38-一个非常大的数组，让其中两个数想加等于1000怎么算" class="headerlink" title="38. 一个非常大的数组，让其中两个数想加等于1000怎么算?"></a>38. 一个非常大的数组，让其中两个数想加等于1000怎么算?</h4><h4 id="39-各个系统出问题怎么监控报警"><a href="#39-各个系统出问题怎么监控报警" class="headerlink" title="39. 各个系统出问题怎么监控报警."></a>39. 各个系统出问题怎么监控报警.</h4><p>可以使用prometheus搭配kong网关，监控各个系统的接口转发处，进行处理报警，然后上报之后，设置阈值，报警和自恢复系统设计。</p><h4 id="40-常用测试工具，压测工具，方法"><a href="#40-常用测试工具，压测工具，方法" class="headerlink" title="40. 常用测试工具，压测工具，方法?"></a>40. 常用测试工具，压测工具，方法?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goconvey,vegeta</span><br></pre></td></tr></table></figure><h4 id="41-复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"><a href="#41-复杂的单元测试怎么测试，比如有外部接口mysql接口的情况" class="headerlink" title="41. 复杂的单元测试怎么测试，比如有外部接口mysql接口的情况"></a>41. 复杂的单元测试怎么测试，比如有外部接口mysql接口的情况</h4><h4 id="42-redis集群，哨兵，持久化，事务"><a href="#42-redis集群，哨兵，持久化，事务" class="headerlink" title="42. redis集群，哨兵，持久化，事务"></a>42. redis集群，哨兵，持久化，事务</h4><h4 id="43-mysql和redis区别是什么？"><a href="#43-mysql和redis区别是什么？" class="headerlink" title="43. mysql和redis区别是什么？"></a>43. mysql和redis区别是什么？</h4><ul><li>mysql和redis的数据库类型</li></ul><p>mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p><p>redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p><ul><li>mysql的运行机制</li></ul><p>mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。</p><ul><li>缓存</li></ul><p>缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p><p>缓存的好处就是读取速度快。</p><ul><li>redis数据库</li></ul><p>redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p><ul><li>redis和mysql的区别总结</li></ul><p>（1）类型上</p><p>从类型上来说，mysql是关系型数据库，redis是缓存数据库</p><p>（2）作用上</p><p>mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢</p><p>redis用于存储使用较为频繁的数据到缓存中，读取速度快</p><p>（3）需求上</p><p>mysql和redis因为需求的不同，一般都是配合使用。</p><h4 id="44-高可用软件是什么？"><a href="#44-高可用软件是什么？" class="headerlink" title="44. 高可用软件是什么？"></a>44. 高可用软件是什么？</h4><ul><li>Heartbeat</li></ul><p>Heartbeat是一个比较老牌的集群管理软件，最新版本是V3.0， 也称为Heartbeat 3.通过Heartbeat，可以实现对服务器资源（ip以及程序服务等资源）的监控和管理，并在出现故障的情况下，将资源集合从一台已经故障的计算机快速转移到另一台正常运转的机器上继续提供服务。</p><ul><li>Keepalived</li></ul><p>Keepalived也是一款高可用集群管理软件，其基本功能与Heartbeat非常类似。</p><p>Keepalived它的功能主要包括两方面：</p><p>1）通过IP漂移，实现服务的高可用：服务器集群共享一个虚拟IP，同一时间只有一个服务器占有虚拟IP并对外提供服务，若该服务器不可用，则虚拟IP漂移至另一台服务器并对外提供服务；</p><p>2）对LVS应用服务层的应用服务器集群进行状态监控：若应用服务器不可用，则keepalived将其从集群中摘除，若应用服务器恢复，则keepalived将其重新加入集群中。</p><p>Keepalived可以单独使用，即通过IP漂移实现服务的高可用，也可以结合LVS使用，即一方面通过IP漂移实现LVS负载均衡层的高可用，另一方面实现LVS应用服务层的状态监控。</p><h4 id="45-怎么搞一个并发服务程序？"><a href="#45-怎么搞一个并发服务程序？" class="headerlink" title="45. 怎么搞一个并发服务程序？"></a>45. 怎么搞一个并发服务程序？</h4><h4 id="46-讲解一下你做过的项目，然后找问题问实现细节。"><a href="#46-讲解一下你做过的项目，然后找问题问实现细节。" class="headerlink" title="46. 讲解一下你做过的项目，然后找问题问实现细节。"></a>46. 讲解一下你做过的项目，然后找问题问实现细节。</h4><h4 id="47-mysql事务说下"><a href="#47-mysql事务说下" class="headerlink" title="47. mysql事务说下"></a>47. mysql事务说下</h4><p>事务是一组原子性的sql命令或者说是一个独立的工作单元,如果数据库引擎能够成功的对数据库应用该组的全部sql语句,那么就执行该组命令如果其中有任何一条语句因为崩溃或者其它原因无法执行,那么该组中所有的sql语句都不会执行,如果没有显示启动事务,数据库会根据autocommit的值.默认每条sql操作都会自动提交。</p><ul><li>原子性</li></ul><p>一个事务中的所有操作,要么都完成,要么都不执行.对于一个事务来说,不可能只执行其中的一部分。</p><ul><li>一致性</li></ul><p>数据库一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在事务T开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等，当事务T提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等，但此时，约束，数据，索引，日志等MySQL各种对象还是要保持一致性（正确性）。 这就是 从一个一致性的状态，变到另一个一致性的状态。也就是事务执行后，并没有破坏数据库的完整性约束（一切都是对的）。</span><br></pre></td></tr></table></figure><ul><li>隔离性</li></ul><p>隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</span><br></pre></td></tr></table></figure><ul><li>持久性</li></ul><p>持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在使用连接池操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</span><br></pre></td></tr></table></figure><h4 id="48-怎么做一个自动化配置平台系统？"><a href="#48-怎么做一个自动化配置平台系统？" class="headerlink" title="48. 怎么做一个自动化配置平台系统？"></a>48. 怎么做一个自动化配置平台系统？</h4><h4 id="49-grpc遵循什么协议？"><a href="#49-grpc遵循什么协议？" class="headerlink" title="49. grpc遵循什么协议？"></a>49. grpc遵循什么协议？</h4><h4 id="50-grpc内部原理是什么？"><a href="#50-grpc内部原理是什么？" class="headerlink" title="50. grpc内部原理是什么？"></a>50. grpc内部原理是什么？</h4><h4 id="51-http2的特点是什么，与http1-1的对比。"><a href="#51-http2的特点是什么，与http1-1的对比。" class="headerlink" title="51. http2的特点是什么，与http1.1的对比。"></a>51. http2的特点是什么，与http1.1的对比。</h4><table><thead><tr><th>HTTP1.1</th><th>HTTP2</th><th>QUIC</th></tr></thead><tbody><tr><td>持久连接</td><td>二进制分帧</td><td>基于UDP的多路传输（单连接下）</td></tr><tr><td>请求管道化</td><td>多路复用（或连接共享）</td><td>极低的等待时延（相比于TCP的三次握手）</td></tr><tr><td>增加缓存处理（新的字段如cache-control）</td><td>头部压缩</td><td>QUIC为 传输层 协议 ，成为更多应用层的高性能选择</td></tr><tr><td>增加Host字段、支持断点传输等（把文件分成几部分）</td><td>服务器推送</td></tr></tbody></table><h4 id="52-Go的调度原理"><a href="#52-Go的调度原理" class="headerlink" title="52. Go的调度原理."></a>52. Go的调度原理.</h4><ul><li><a href="https://colobu.com/2017/05/04/go-scheduler/" target="_blank" rel="noopener">Go调度器: M, P 和 G</a></li><li><a href="http://www.flysnow.org/2017/04/11/go-in-action-go-goroutine.html" target="_blank" rel="noopener">Go语言实战笔记（十二）| Go goroutine</a></li><li><a href="http://ga0.github.io/golang/2015/09/20/golang-runtime-scheduler.html" target="_blank" rel="noopener">Golang调度器源码分析</a></li><li><a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/chapter10/01.0.md" target="_blank" rel="noopener">Goroutine调度过程</a></li></ul><h4 id="53-go-struct能不能比较"><a href="#53-go-struct能不能比较" class="headerlink" title="53. go struct能不能比较"></a>53. go struct能不能比较</h4><ul><li>相同struct类型的可以比较</li><li>不同struct类型的不可以比较,编译都不过，类型不匹配</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    type A struct &#123;</span><br><span class="line">        a int</span><br><span class="line">    &#125;</span><br><span class="line">    type B struct &#123;</span><br><span class="line">        a int</span><br><span class="line">    &#125;</span><br><span class="line">    a := A&#123;1&#125;</span><br><span class="line">    //b := A&#123;1&#125;</span><br><span class="line">    b := B&#123;1&#125;</span><br><span class="line">    if a == b &#123;</span><br><span class="line">        fmt.Println(&quot;a == b&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        fmt.Println(&quot;a != b&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">// output</span><br><span class="line">// command-line-arguments [command-line-arguments.test]</span><br><span class="line">// ./.go:14:7: invalid operation: a == b (mismatched types A and B)</span><br></pre></td></tr></table></figure><ol><li>go defer（for defer）</li></ol><ul><li><a href="https://deepzz.com/post/how-to-use-defer-in-golang.html" target="_blank" rel="noopener">Go 关键字 defer 的一些坑</a></li></ul><ol><li>select可以用于什么?</li></ol><p>Go的select主要是处理多个channel的操作.</p><ul><li><a href="https://segmentfault.com/a/1190000006815341" target="_blank" rel="noopener">Go语言并发模型：使用 select</a></li></ul><ol><li>context包的用途是什么?</li></ol><p>godoc: <a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">https://golang.org/pkg/context/</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/34417106" target="_blank" rel="noopener">Go Context的踩坑经历</a></li><li><a href="http://www.flysnow.org/2017/05/12/go-in-action-go-context.html" target="_blank" rel="noopener">Go语言实战笔记（二十）| Go Context</a></li></ul><ol><li>client如何实现长连接?</li></ol><ul><li><a href="http://www.nowamagic.net/academy/detail/23350382#" target="_blank" rel="noopener">TCP协议的KeepAlive机制与HeartBeat心跳包</a></li><li><a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">HTTP Keep-Alive是什么？如何工作？</a></li></ul><ol><li>主协程如何等其余协程完再操作?</li></ol><ul><li><a href="https://blog.csdn.net/u011304970/article/details/72722044" target="_blank" rel="noopener">Go并发：利用sync.WaitGroup实现协程同步</a></li><li><a href="http://yoojia.xyz/2018/04/13/golang-waitgroup/" target="_blank" rel="noopener">Go语言重点笔记-深入了解sync.WaitGroup</a></li></ul><ol><li>slice，len，cap，共享，扩容.</li><li>map如何顺序读取?</li></ol><p>可以通过sort中的排序包进行对map中的key进行排序</p><ul><li><a href="https://www.jianshu.com/p/6e52bad56e06" target="_blank" rel="noopener">golang:使用 sort 来排序</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var m = map[string]int&#123;</span><br><span class="line">        &quot;hello&quot;:         0,</span><br><span class="line">        &quot;morning&quot;:       1,</span><br><span class="line">        &quot;my&quot;:            2,</span><br><span class="line">        &quot;girl&quot;:   3,</span><br><span class="line">    &#125;</span><br><span class="line">    var keys []string</span><br><span class="line">    for k := range m &#123;</span><br><span class="line">        keys = append(keys, k)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    for _, k := range keys &#123;</span><br><span class="line">        fmt.Println(&quot;Key:&quot;, k, &quot;Value:&quot;, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现set</li></ol><p>根据go中map的keys的无序性和唯一性，可以将其作为set</p><ul><li><a href="https://studygolang.com/articles/3291" target="_blank" rel="noopener">golang实现set集合,变相实现切片去重</a></li></ul><ol><li>实现消息队列（多生产者，多消费者）</li></ol><p>根据Goroutine和channel的读写可以实现消息队列，</p><ul><li><a href="https://blog.csdn.net/phpduang/article/details/80143626" target="_blank" rel="noopener">golang channel多生产者和多消费者实例</a></li></ul><ol><li>大文件排序</li></ol><ul><li><a href="https://blog.csdn.net/michellechouu/article/details/47002393" target="_blank" rel="noopener">【算法】对一个20GB大的文件排序</a></li></ul><p>64.基本排序，哪些是稳定的</p><p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，</p><p>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</p><ul><li><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a></li></ul><ol><li>Http get跟head</li></ol><p>get:获取由Request-URI标识的任何信息(以实体的形式)，如果Request-URI引用某个数据处理过程，则应该以它产生的数据作为在响应中的实体，而不是该过程的源代码文本，除非该过程碰巧输出该文本。</p><p>head: 除了服务器不能在响应中返回消息体，HEAD方法与GET相同。用来获取暗示实体的元信息，而不需要传输实体本身。常用于测试超文本链接的有效性、可用性和最近的修改。</p><ul><li><a href="https://github.com/xuelangZF/CS_Offer/blob/master/Network/HTTP.md" target="_blank" rel="noopener">Http介绍</a></li></ul><ol><li>Http 401,403</li></ol><p><strong>401 Unauthorized</strong>： 该HTTP状态码表示认证错误，它是为了认证设计的，而不是为了授权设计的。收到401响应，<strong>表示请求没有被认证—压根没有认证或者认证不正确—但是请重新认证和重试。</strong>（一般在响应头部包含一个<em>WWW-Authenticate</em>来描述如何认证）。通常由web服务器返回，而不是web应用。从性质上来说是临时的东西。（服务器要求客户端重试）</p><p><strong>403 Forbidden</strong>：该HTTP状态码是关于授权方面的。从性质上来说是永久的东西，和应用的业务逻辑相关联。它比401更具体，更实际。收到403响应表示<strong>服务器完成认证过程，但是客户端请求没有权限去访问要求的资源。</strong></p><p>总的来说，<strong>401 Unauthorized</strong>响应应该用来表示缺失或错误的认证；<strong>403 Forbidden</strong>响应应该在这之后用，当用户被认证后，但用户没有被授权在特定资源上执行操作。</p><ul><li><a href="https://www.jianshu.com/p/6dceeebbde5b" target="_blank" rel="noopener">HTTP响应码403 Forbidden和401 Unauthorized对比</a></li></ul><p>67.Http keep-alive</p><ol><li>Http能不能一次连接多次请求，不等后端返回</li><li>TCP 和 UDP 有什么区别,适用场景</li></ol><ul><li>TCP 是面向连接的，UDP 是面向无连接的；故 TCP 需要建立连接和断开连接，UDP 不需要。</li><li>TCP 是流协议，UDP 是数据包协议；故 TCP 数据没有大小限制，UDP 数据报有大小限制（UDP 协议本身限制、数据链路层的 MTU、缓存区大小）。</li><li>TCP 是可靠协议，UDP 是不可靠协议；故 TCP 会处理数据丢包重发以及乱序等情况，UDP 则不会处理。</li></ul><p><code>UDP 的特点及使用场景</code>:</p><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效，经常用于以下场景：</p><p>包总量较小的通信（DNS、SNMP）</p><p>视频、音频等多媒体通信（即时通信）</p><p>广播通信</p><p><code>TCP 的特点及使用场景</code>:</p><p>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP。</p><ul><li><a href="https://mp.weixin.qq.com/s/jLkhjM7wOpZuWgJdAXis1A" target="_blank" rel="noopener">iOS 面试题 TCP UDP 有什么区别？TCP 为什么要三次握手，四次挥手？</a></li></ul><ol><li>time-wait的作用</li></ol><ul><li><a href="https://www.iteblog.com/archives/169.html" target="_blank" rel="noopener">TCP/IP状态图的TIME_WAIT作用</a></li></ul><ol><li>数据库如何建索引</li></ol><ul><li><a href="https://blog.csdn.net/nanaMasuda/article/details/52358114" target="_blank" rel="noopener">正确合理的建立MySQL数据库索引</a></li></ul><ol><li>孤儿进程，僵尸进程</li></ol><ul><li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li></ul><ol><li>死锁条件，如何避免</li><li>linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</li><li>git文件版本，使用顺序，merge跟rebase</li><li>通常一般会用到哪些数据结构?</li><li>链表和数组相比, 有什么优缺点?</li><li>如何判断两个无环单链表有没有交叉点?</li><li>如何判断一个单链表有没有环, 并找出入环点?</li><li>描述一下 TCP 四次挥手的过程中</li><li>TCP 有哪些状态?</li><li>TCP 的 LISTEN 状态是什么?</li><li>TCP 的 CLOSE_WAIT 状态是什么?</li><li>建立一个 socket 连接要经过哪些步骤?</li><li>常见的 HTTP 状态码有哪些?</li><li>301和302有什么区别?</li><li>504和500有什么区别?</li><li>HTTPS 和 HTTP 有什么区别?</li><li>算法题: 手写一个快速排序</li></ol><p>快速排序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var arr = []int&#123;19,8,16,15,23,34,6,3,1,0,2,9,7&#125;</span><br><span class="line">quickAscendingSort(arr, 0, len(arr)-1)</span><br><span class="line">fmt.Println(&quot;quickAscendingSort:&quot;,arr)</span><br><span class="line"></span><br><span class="line">quickDescendingSort(arr, 0, len(arr)-1)</span><br><span class="line">fmt.Println(&quot;quickDescendingSort:&quot;,arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//升序</span><br><span class="line">func quickAscendingSort(arr []int, start, end int) &#123;</span><br><span class="line">if (start &lt; end) &#123;</span><br><span class="line">i, j := start, end</span><br><span class="line">key := arr[(start + end)/2]</span><br><span class="line">for i &lt;= j &#123;</span><br><span class="line">for arr[i] &lt; key &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">for arr[j] &gt; key &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">if i &lt;= j &#123;</span><br><span class="line">arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if start &lt; j &#123;</span><br><span class="line">quickAscendingSort(arr, start, j)</span><br><span class="line">&#125;</span><br><span class="line">if end &gt; i &#123;</span><br><span class="line">quickAscendingSort(arr, i, end)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//降序</span><br><span class="line">func quickDescendingSort(arr []int, start, end int) &#123;</span><br><span class="line">if (start &lt; end) &#123;</span><br><span class="line">i, j := start, end</span><br><span class="line">key := arr[(start + end)/2]</span><br><span class="line">for i &lt;= j &#123;</span><br><span class="line">for arr[i] &gt; key &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">for arr[j] &lt; key &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">if i &lt;= j &#123;</span><br><span class="line">arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if start &lt; j &#123;</span><br><span class="line">quickDescendingSort(arr, start, j)</span><br><span class="line">&#125;</span><br><span class="line">if end &gt; i &#123;</span><br><span class="line">quickDescendingSort(arr, i, end)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Golang 里的逃逸分析是什么？怎么避免内存逃逸？</li><li>配置中心如何保证一致性？</li><li>Golang 的GC触发时机是什么?</li><li>Redis 里数据结构的实现熟悉吗?</li><li>Etcd的Raft一致性算法原理?</li><li>微服务概念.</li><li>SLB原理.</li><li>分布式一直性原则.</li><li>如何保证服务宕机造成的分布式服务节点处理问题?</li><li>服务发现怎么实现的.</li><li>Go中切片，map，struct 在64位机器中占用字节是多少?</li></ol><p>在64位系统下，Golang的切片占用字节是24位，map和struct都是8位.</p><ol><li>Go中的defer函数使用下面的两种情况下结果是多少，为什么?</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := 1</span><br><span class="line">defer fmt.Println(&quot;the value of a1:&quot;,a)</span><br><span class="line">a++</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Println(&quot;the value of a2:&quot;,a)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the value of a1: 1</span><br><span class="line">the value of a1: 2</span><br></pre></td></tr></table></figure><p>第一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer fmt.Println(&quot;the value of a1:&quot;,a)</span><br></pre></td></tr></table></figure><p>defer延迟函数调用的fmt.Println(a)函数的参数值在defer语句出现时就已经确定了，所以无论后面如何修改a变量都不会影响延迟函数。</p><p>第二种情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">fmt.Println(&quot;the value of a2:&quot;,a)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>defer延迟函数调用的函数参数的值在defer定义时候就确定了，而defer延迟函数内部所使用的值需要在这个函数运行时候才确定。</p><h4 id="Golang面试参考"><a href="#Golang面试参考" class="headerlink" title="Golang面试参考"></a>Golang面试参考</h4><ul><li><a href="http://m.nowcoder.com/discuss/145338?type=2&amp;order=0&amp;pos=6&amp;page=1&amp;headNav=www&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">Golang面试</a></li><li><a href="http://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">Golang调度</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      golang面试问题汇总
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mongodb 命令行登录操作</title>
    <link href="https://cloudsjhan.github.io/2019/04/11/mongodb-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
    <id>https://cloudsjhan.github.io/2019/04/11/mongodb-命令行登录操作/</id>
    <published>2019-04-11T07:07:14.000Z</published>
    <updated>2019-04-22T02:55:05.331Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="Mac-OS下载安装及配置"><a href="#Mac-OS下载安装及配置" class="headerlink" title="Mac OS下载安装及配置"></a>Mac OS下载安装及配置</h2><p>使用brew可以直接搞定，简单方便！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb</span><br></pre></td></tr></table></figure><p>安装完成后会提示启动的方式，安装位置等等信息。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4218662-435c85a12eae4a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/958/format/webp" alt="img"></p><p>安装完成</p><p>安装完成后，按照提示启动MongoDB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure><p>配置文件已修改fork=true，因此启动后将以后台进程方式存在。</p><p><img src="https:////upload-images.jianshu.io/upload_images/4218662-7842d5837475c137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>MongoDB启动</p><p>终端输入mongo连接MongoDB数据库(默认连接本机的27017端口)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/4218662-8f368a1234b354cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>客户端连接</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>MongoDB引入一个YAML-based格式的配置文件。<br> 现在的配置文件/usr/local/etc/mongod.conf显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 日志</span><br><span class="line">systemLog:</span><br><span class="line"># 日志为文件</span><br><span class="line">  destination: file</span><br><span class="line"># 文件位置</span><br><span class="line">  path: /usr/local/var/log/mongodb/mongo.log</span><br><span class="line"># 是否追加</span><br><span class="line">  logAppend: true</span><br><span class="line">#进程</span><br><span class="line">processManagement:</span><br><span class="line"># 守护进程方式</span><br><span class="line">  fork: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: /usr/local/var/mongodb</span><br><span class="line">net:</span><br><span class="line"># 绑定IP，默认127.0.0.1，只能本机访问</span><br><span class="line">  bindIp: 127.0.0.1</span><br><span class="line"># 端口</span><br><span class="line">  port: 27017</span><br></pre></td></tr></table></figure><h2 id="CentOS-7-安装MongoDB详细步骤"><a href="#CentOS-7-安装MongoDB详细步骤" class="headerlink" title="CentOS 7 安装MongoDB详细步骤"></a><a href="https://segmentfault.com/a/1190000016877915" target="_blank" rel="noopener">CentOS 7 安装MongoDB详细步骤</a></h2><p>创建<code>/etc/yum.repos.d/mongodb-org-4.0.repo</code>文件，编辑内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-4.0]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure><p>运行以下命令安装最新版的mongodb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure><p>配置<code>mongod.conf</code>允许远程连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mongod.conf</span><br><span class="line"></span><br><span class="line"># Listen to all ip address</span><br><span class="line">bind_ip = 0.0.0.0</span><br></pre></td></tr></table></figure><p>启动mongodb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure><p>创建管理员用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">&gt;use admin</span><br><span class="line"> db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;myUserAdmin&quot;,</span><br><span class="line">    pwd: &quot;abc123&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125;, &quot;readWriteAnyDatabase&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>启用权限管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mongod.conf</span><br><span class="line"></span><br><span class="line">#security </span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br></pre></td></tr></table></figure><p>重启mongodb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><h3 id="Mongodb-用户验证登陆"><a href="#Mongodb-用户验证登陆" class="headerlink" title="Mongodb 用户验证登陆"></a>Mongodb 用户验证登陆</h3><p>启动带访问控制的 Mongodb<br> 新建终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --auth --port 27017 --dbpath /data/db1</span><br></pre></td></tr></table></figure><p>现在有两种方式进行用户身份的验证<br> 第一种 （类似 MySql）<br> 客户端连接时，指定用户名，密码，db名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017 -u &quot;adminUser&quot; -p &quot;adminPass&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure><p>第二种<br> 客户端连接后，再进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongo --port 27017</span><br><span class="line"></span><br><span class="line">use admin</span><br><span class="line">db.auth(&quot;adminUser&quot;, &quot;adminPass&quot;)</span><br><span class="line"></span><br><span class="line">// 输出 1 表示验证成功</span><br></pre></td></tr></table></figure><h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p>过程类似创建管理员账户，只是 role 有所不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use foo</span><br><span class="line"></span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;simpleUser&quot;,</span><br><span class="line">    pwd: &quot;simplePass&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;foo&quot; &#125;,</span><br><span class="line">             &#123; role: &quot;read&quot;, db: &quot;bar&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在我们有了一个普通用户<br> 用户名：simpleUser<br> 密码：simplePass<br> 权限：读写数据库 foo， 只读数据库 bar。</p><p><strong>注意</strong><br> <strong>NOTE</strong><br> <strong>WARN</strong><br> <code>use foo</code>表示用户在 foo 库中创建，就一定要 foo 库验证身份，即用户的信息跟随随数据库。比如上述 simpleUser 虽然有 bar 库的读取权限，但是一定要先在 foo 库进行身份验证，直接访问会提示验证失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use foo</span><br><span class="line">db.auth(&quot;simpleUser&quot;, &quot;simplePass&quot;)</span><br><span class="line"></span><br><span class="line">use bar</span><br><span class="line">show collections</span><br></pre></td></tr></table></figure><p>还有一点需要注意，如果 admin 库没有任何用户的话，即使在其他数据库中创建了用户，启用身份验证，默认的连接方式依然会有超级权限</p><hr>]]></content>
    
    <summary type="html">
    
      mongodb 命令行登录操作
    
    </summary>
    
      <category term="MongoDB" scheme="https://cloudsjhan.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://cloudsjhan.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy 解决URL被重定向无法抓取到数据问题301和302</title>
    <link href="https://cloudsjhan.github.io/2019/04/10/Scrapy-%E8%A7%A3%E5%86%B3URL%E8%A2%AB%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%A0%E6%B3%95%E6%8A%93%E5%8F%96%E5%88%B0%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98301%E5%92%8C302/"/>
    <id>https://cloudsjhan.github.io/2019/04/10/Scrapy-解决URL被重定向无法抓取到数据问题301和302/</id>
    <published>2019-04-10T08:48:20.000Z</published>
    <updated>2019-04-10T08:50:53.627Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>1.什么是状态码301,302</p><p>301 Moved Permanently（永久重定向） 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。</p><p>解决（一）</p><p>1.在Request中将scrapy的dont_filter=True，因为scrapy是默认过滤掉重复的请求URL，添加上参数之后即使被重定向了也能请求到正常的数据了</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>Request(url, callback=self.next_parse, dont_filter=True)<br>解决（二）</p><p>在scrapy框架中的 settings.py文件里添加</p><p>HTTPERROR_ALLOWED_CODES = [301]<br>解决（三）</p><p>使用requests模块遇到301和302问题时</p><p>def website():<br>    ‘url’<br>    headers = {‘Accept’:     ‘text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8’,<br>           ‘Accept-Encoding’: ‘gzip, deflate, sdch, br’,<br>           ‘Accept-Language’: ‘zh-CN,zh;q=0.8’,<br>           ‘Connection’: ‘keep-alive’,<br>           ‘Host’: ‘pan.baidu.com’,<br>           ‘Upgrade-Insecure-Requests’: ‘1’,<br>           ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36’}</p><pre><code>url = &apos;https://www.baidu.com/&apos;html = requests.get(url, headers=headers, allow_redirects=False)return html.headers[&apos;Location&apos;]</code></pre><p>allow_redirects=False的意义为拒绝默认的301/302重定向从而可以通过html.headers[‘Location’]拿到重定向的URL。</p><hr>]]></content>
    
    <summary type="html">
    
      Scrapy 解决URL被重定向无法抓取到数据问题301和302
    
    </summary>
    
      <category term="Scrapy" scheme="https://cloudsjhan.github.io/categories/Scrapy/"/>
    
    
      <category term="Scrapy" scheme="https://cloudsjhan.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>scrapy 源码分析之retry中间件与应用</title>
    <link href="https://cloudsjhan.github.io/2019/03/29/scrapy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bretry%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://cloudsjhan.github.io/2019/03/29/scrapy-源码分析之retry中间件/</id>
    <published>2019-03-29T11:33:40.000Z</published>
    <updated>2019-03-29T13:57:34.558Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><code>这次让我们分析scrapy重试机制的源码，学习其中的思想，编写定制化middleware,捕捉爬取失败的URL等信息。</code></p><h2 id="scrapy简介"><a href="#scrapy简介" class="headerlink" title="scrapy简介"></a>scrapy简介</h2><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>其最初是为了 <a href="http://en.wikipedia.org/wiki/Screen_scraping" target="_blank" rel="noopener">页面抓取</a> (更确切来说, <a href="http://en.wikipedia.org/wiki/Web_scraping" target="_blank" rel="noopener">网络抓取</a> )所设计的， 也可以应用在获取API所返回的数据(例如 <a href="http://aws.amazon.com/associates/" target="_blank" rel="noopener">Amazon Associates Web Services</a> ) 或者通用的网络爬虫。</p><p>一张图可看清楚scrapy中数据的流向：</p><p><img src="https://scrapy-chs.readthedocs.io/zh_CN/0.24/_images/scrapy_architecture.png" alt=""></p><p>简单了解一下各个部分的功能，可以看下面简化版数据流：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1jwn7d37aj30tg0iy0v1.jpg" alt=""></p><h2 id="总有漏网之鱼"><a href="#总有漏网之鱼" class="headerlink" title="总有漏网之鱼"></a>总有漏网之鱼</h2><p>不管你的主机配置多么吊炸天，还是网速多么给力，在scrapy的大规模任务中，最终爬取的item数量都不会等于期望爬取的数量，也就是说总有那么一些爬取失败的漏网之鱼，通过分析scrapy的日志，可以知道造成失败的原因有以下两种情况：</p><ol><li>exception_count</li><li>httperror</li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1jyf6bmcfj314w0kqq97.jpg" alt=""></p><p>以上的不管是exception还是httperror, scrapy中都有对应的retry机制，在<code>settings.py</code>文件中我们可以设置有关重试的参数，等运行遇到异常和错误时候，scrapy就会自动处理这些问题，其中最关键的部分就是重试中间件，下面让我们看一下scrapy的retry middleware。</p><h2 id="RetryMiddle源码分析"><a href="#RetryMiddle源码分析" class="headerlink" title="RetryMiddle源码分析"></a>RetryMiddle源码分析</h2><p>在scrapy项目的<code>middlewares.py</code>文件中 敲如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.downloadermiddlewares.retry <span class="keyword">import</span> RetryMiddleware</span><br></pre></td></tr></table></figure><p>按住ctrl键（Mac是command键），鼠标左键点击RetryMiddleware进入该中间件所在的项目文件的位置，也可以通过查看文件的形式找到该该中间件的位置，路径是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site-packages/scrapy/downloadermiddlewares/retry.RetryMiddleware</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetryMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># IOError is raised by the HttpCompression middleware when trying to</span></span><br><span class="line">    <span class="comment"># decompress an empty response</span></span><br><span class="line">    <span class="comment"># 需要重试的异常状态，可以看出，其中有些是上面log中的异常</span></span><br><span class="line">    EXCEPTIONS_TO_RETRY = (defer.TimeoutError, TimeoutError, DNSLookupError,</span><br><span class="line">                           ConnectionRefusedError, ConnectionDone, ConnectError,</span><br><span class="line">                           ConnectionLost, TCPTimedOutError, ResponseFailed,</span><br><span class="line">                           IOError, TunnelError)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, settings)</span>:</span></span><br><span class="line">      <span class="comment"># 读取 settings.py 中关于重试的配置信息，如果没有配置重试的话，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> settings.getbool(<span class="string">'RETRY_ENABLED'</span>):</span><br><span class="line">            <span class="keyword">raise</span> NotConfigured</span><br><span class="line">        self.max_retry_times = settings.getint(<span class="string">'RETRY_TIMES'</span>)</span><br><span class="line">        self.retry_http_codes = set(int(x) <span class="keyword">for</span> x <span class="keyword">in</span> settings.getlist(<span class="string">'RETRY_HTTP_CODES'</span>))</span><br><span class="line">        self.priority_adjust = settings.getint(<span class="string">'RETRY_PRIORITY_ADJUST'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(crawler.settings)</span><br><span class="line"><span class="comment"># 如果response的状态码，是我们要重试的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.meta.get(<span class="string">'dont_retry'</span>, <span class="keyword">False</span>):</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">if</span> response.status <span class="keyword">in</span> self.retry_http_codes:</span><br><span class="line">            reason = response_status_message(response.status)</span><br><span class="line">            <span class="keyword">return</span> self._retry(request, reason, spider) <span class="keyword">or</span> response</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"><span class="comment"># 出现了需要重试的异常状态，</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(exception, self.EXCEPTIONS_TO_RETRY) \</span><br><span class="line">                <span class="keyword">and</span> <span class="keyword">not</span> request.meta.get(<span class="string">'dont_retry'</span>, <span class="keyword">False</span>):</span><br><span class="line">            <span class="keyword">return</span> self._retry(request, exception, spider)</span><br><span class="line"><span class="comment"># 重试操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_retry</span><span class="params">(self, request, reason, spider)</span>:</span></span><br><span class="line">        retries = request.meta.get(<span class="string">'retry_times'</span>, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        retry_times = self.max_retry_times</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'max_retry_times'</span> <span class="keyword">in</span> request.meta:</span><br><span class="line">            retry_times = request.meta[<span class="string">'max_retry_times'</span>]</span><br><span class="line"></span><br><span class="line">        stats = spider.crawler.stats</span><br><span class="line">        <span class="keyword">if</span> retries &lt;= retry_times:</span><br><span class="line">            logger.debug(<span class="string">"Retrying %(request)s (failed %(retries)d times): %(reason)s"</span>,</span><br><span class="line">                         &#123;<span class="string">'request'</span>: request, <span class="string">'retries'</span>: retries, <span class="string">'reason'</span>: reason&#125;,</span><br><span class="line">                         extra=&#123;<span class="string">'spider'</span>: spider&#125;)</span><br><span class="line">            retryreq = request.copy()</span><br><span class="line">            retryreq.meta[<span class="string">'retry_times'</span>] = retries</span><br><span class="line">            retryreq.dont_filter = <span class="keyword">True</span></span><br><span class="line">            retryreq.priority = request.priority + self.priority_adjust</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isinstance(reason, Exception):</span><br><span class="line">                reason = global_object_name(reason.__class__)</span><br><span class="line"></span><br><span class="line">            stats.inc_value(<span class="string">'retry/count'</span>)</span><br><span class="line">            stats.inc_value(<span class="string">'retry/reason_count/%s'</span> % reason)</span><br><span class="line">            <span class="keyword">return</span> retryreq</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stats.inc_value(<span class="string">'retry/max_reached'</span>)</span><br><span class="line">            logger.debug(<span class="string">"Gave up retrying %(request)s (failed %(retries)d times): %(reason)s"</span>,</span><br><span class="line">                         &#123;<span class="string">'request'</span>: request, <span class="string">'retries'</span>: retries, <span class="string">'reason'</span>: reason&#125;,</span><br><span class="line">                         extra=&#123;<span class="string">'spider'</span>: spider&#125;)</span><br></pre></td></tr></table></figure><p>查看源码我们可以发现，对于返回http code的response，该中间件会通过process_response方法来处理，处理办法比较简单，判断response.status是否在retry_http_codes集合中，这个集合是读取的配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RETRY_ENABLED = <span class="keyword">True</span>                  <span class="comment"># 默认开启失败重试，一般关闭</span></span><br><span class="line">RETRY_TIMES = <span class="number">3</span>                         <span class="comment"># 失败后重试次数，默认两次</span></span><br><span class="line">RETRY_HTTP_CODES = [<span class="number">500</span>, <span class="number">502</span>, <span class="number">503</span>, <span class="number">504</span>, <span class="number">522</span>, <span class="number">524</span>, <span class="number">408</span>]    <span class="comment"># 碰到这些验证码，才开启重试</span></span><br></pre></td></tr></table></figure><p>对于httperror的处理也是同样的道理，定义了一个 EXCEPTIONS_TO_RETRY的列表，里面存放所有的异常类型，然后判断传入的异常是否存在于该集合中，如果在就进入retry逻辑，不在就忽略。</p><h2 id="源码思想的应用"><a href="#源码思想的应用" class="headerlink" title="源码思想的应用"></a>源码思想的应用</h2><p>了解scrapy如何处理异常后，就可以利用这种思想，写一个middleware，对爬取失败的漏网之鱼进行捕获，方便以后做补爬。</p><ol><li>在middlewares.py中 from scrapy.downloadermiddlewares.retry import RetryMiddleware, 写一个class，继承自RetryMiddleware；</li><li>对父类的<code>process_response()</code>和<code>process_exception()</code>方法进行重写；</li><li>将该middleware加入setting.py;</li><li>注意事项：该中间件的Order_code不能过大，如果过大就会越接近下载器，就会优先于RetryMiddleware处理response，但这个中间件是用来处理最终的错误的，即当一个response 500进入中间件链路时，需要先经过retry中间件处理，不能先由我们写的中间件来处理，它不具有retry的功能，接收到500的response就直接放弃掉该request直接return了，这是不合理的。只有经过retry后仍然有异常的request才应当由我们写的中间件来处理，这时候你想怎么处理都可以，比如再次retry、return一个重新构造的response，但是如果你为了加快爬虫速度，不设置retry也是可以的。</li></ol><p>Talk is cheap, show the code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFailedUrl</span><span class="params">(RetryMiddleware)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, settings)</span>:</span></span><br><span class="line">        self.max_retry_times = settings.getint(<span class="string">'RETRY_TIMES'</span>)</span><br><span class="line">        self.retry_http_codes = set(int(x) <span class="keyword">for</span> x <span class="keyword">in</span> settings.getlist(<span class="string">'RETRY_HTTP_CODES'</span>))</span><br><span class="line">        self.priority_adjust = settings.getint(<span class="string">'RETRY_PRIORITY_ADJUST'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> response.status <span class="keyword">in</span> self.retry_http_codes:</span><br><span class="line">        <span class="comment"># 将爬取失败的URL存下来，你也可以存到别的存储</span></span><br><span class="line">            <span class="keyword">with</span> open(str(spider.name) + <span class="string">".txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.url + <span class="string">"\n"</span>)</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception, spider)</span>:</span></span><br><span class="line">    <span class="comment"># 出现异常的处理</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(exception, self.EXCEPTIONS_TO_RETRY):</span><br><span class="line">            <span class="keyword">with</span> open(str(spider.name) + <span class="string">".txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(str(request) + <span class="string">"\n"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>setting.py中添加该中间件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   <span class="string">'myspider.middlewares.TabelogDownloaderMiddleware'</span>: <span class="number">543</span>,</span><br><span class="line">    <span class="string">'myspider.middlewares.RandomProxy'</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">'myspider.middlewares.GetFailedUrl'</span>: <span class="number">220</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试，我们故意写错URL，或者将download_delay缩短，就会出现各种异常，但是我们现在能够捕获它们了：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1k09zlxtzj30ua076128.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      分析scrapy的retry源码，定制化重试机制
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
      <category term="scrapy" scheme="https://cloudsjhan.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Go Modules使用方法</title>
    <link href="https://cloudsjhan.github.io/2019/03/29/Go-Modules%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://cloudsjhan.github.io/2019/03/29/Go-Modules使用方法/</id>
    <published>2019-03-29T11:14:26.000Z</published>
    <updated>2019-03-29T11:17:02.471Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="Go-Modules使用教程"><a href="#Go-Modules使用教程" class="headerlink" title="Go Modules使用教程"></a>Go Modules使用教程</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1</a></p><h2 id="Go-Modules介绍"><a href="#Go-Modules介绍" class="headerlink" title="Go Modules介绍"></a>Go Modules介绍</h2><p>Modules是Go 1.11中新增的实验性功能，基于vgo演变而来，是一个新型的包管理工具。</p><h2 id="常见的包管理工具"><a href="#常见的包管理工具" class="headerlink" title="常见的包管理工具"></a>常见的包管理工具</h2><ul><li>govendor</li><li>dep</li><li>glide</li><li>godep</li></ul><p>这些包管理工具都是基于<code>GOPATH</code>或者<code>vendor</code>目录，并不能很好的解决不同版本依赖问题。Modules是在<code>GOPATH</code>之外一套新的包管理方式。</p><h2 id="如何激活Modules"><a href="#如何激活Modules" class="headerlink" title="如何激活Modules"></a>如何激活Modules</h2><p>首先要把go升级到1.11。</p><p>升级后，可以设置通过一个环境变量<code>GO111MODULE</code>来激活modules：</p><ul><li>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。</li><li>GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。</li><li>GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：当前目录在GOPATH/src之外且该目录包含go.mod文件，或者当前文件在包含go.mod文件的目录下面。</li></ul><p>当module功能启用时，<code>GOPATH</code>在项目构建过程中不再担当import的角色，但它仍然存储下载的依赖包，具体位置在<code>$GOPATH/pkg/mod</code>。</p><h2 id="初始化Modules"><a href="#初始化Modules" class="headerlink" title="初始化Modules"></a>初始化Modules</h2><p>Go1.11新增了命令<code>go mod</code>来支持Modules的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; go help mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">    go mod &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">    download    download modules to local cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       print module requirement graph</span><br><span class="line">    init        initialize new module in current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use &quot;go help mod &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure><p>首先创建一个项目helloworld：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &amp;&amp; mkdir helloworld &amp;&amp; cd helloworld</span><br></pre></td></tr></table></figure><p>然后创建文件<code>main.go</code>并写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    log &quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    log.WithFields(log.Fields&#123;</span><br><span class="line">        &quot;animal&quot;: &quot;walrus&quot;,</span><br><span class="line">    &#125;).Info(&quot;A walrus appears&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化mod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init helloworld</span><br></pre></td></tr></table></figure><p>系统生成了一个<code>go.mod</code>的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br></pre></td></tr></table></figure><p>然后执行go build，再次查看go.mod文件发现多了一些内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module helloworld</span><br><span class="line"></span><br><span class="line">require github.com/sirupsen/logrus v1.1.1</span><br></pre></td></tr></table></figure><p>同时多了一个<code>go.sum</code>的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.com/konsorten/go-windows-terminal-sequences v0.0.0-20180402223658-b729f2633dfe/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=</span><br><span class="line">github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=</span><br><span class="line">github.com/sirupsen/logrus v1.1.1 h1:VzGj7lhU7KEB9e9gMpAV/v5XT2NVSvLJhJLCWbnkgXg=</span><br><span class="line">github.com/sirupsen/logrus v1.1.1/go.mod h1:zrgwTnHtNr00buQ1vSptGe8m1f/BbgsPukg8qsT7A+A=</span><br><span class="line">github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=</span><br><span class="line">golang.org/x/crypto v0.0.0-20180904163835-0709b304e793 h1:u+LnwYTOOW7Ukr/fppxEb1Nwz0AtPflrblfvUudpo+I=</span><br><span class="line">golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=</span><br><span class="line">golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33 h1:I6FyU15t786LL7oL/hn43zqTuEGr4PN7F4XJ1p4E3Y8=</span><br><span class="line">golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=</span><br></pre></td></tr></table></figure><p>go.sum不是一个锁文件，是一个模块版本内容的校验值，用来验证当前缓存的模块。go.sum包含了直接依赖和间接依赖的包的信息，比go.mod要多一些。</p><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p>有四种指令：module，require，exclude，replace。</p><ul><li>module：模块名称</li><li>require：依赖包列表以及版本</li><li>exclude：禁止依赖包列表（仅在当前模块为主模块时生效）</li><li>replace：替换依赖包列表 （仅在当前模块为主模块时生效）</li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy //拉取缺少的模块，移除不用的模块。</span><br><span class="line">go mod download //下载依赖包</span><br><span class="line">go mod graph //打印模块依赖图</span><br><span class="line">go mod vendor //将依赖复制到vendor下</span><br><span class="line">go mod verify //校验依赖</span><br><span class="line">go mod why //解释为什么需要依赖</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m -json all //依赖详情</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      Go modules 使用
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="Golang" scheme="https://cloudsjhan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Python的map/reduce/filter</title>
    <link href="https://cloudsjhan.github.io/2019/03/27/Python%E7%9A%84map-reduce-filter/"/>
    <id>https://cloudsjhan.github.io/2019/03/27/Python的map-reduce-filter/</id>
    <published>2019-03-27T03:06:12.000Z</published>
    <updated>2019-03-27T03:09:29.569Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="转载自explore-python"><a href="#转载自explore-python" class="headerlink" title="转载自explore_python"></a>转载自<a href="http://funhacks.net/explore-python/" target="_blank" rel="noopener">explore_python</a></h3><ul><li><a href="http://funhacks.net/explore-python/Functional/map_reduce_filter.html" target="_blank" rel="noopener">http://funhacks.net/explore-python/Functional/map_reduce_filter.html</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      python的Map、reduce、filter解析
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>golang的多态实现</title>
    <link href="https://cloudsjhan.github.io/2019/03/18/golang%E7%9A%84%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cloudsjhan.github.io/2019/03/18/golang的多态实现/</id>
    <published>2019-03-18T07:57:27.000Z</published>
    <updated>2019-03-18T08:14:30.423Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="多态（polymorphism）"><a href="#多态（polymorphism）" class="headerlink" title="多态（polymorphism）"></a>多态（polymorphism）</h3><p>多态是接口的一个关键功能和Go语言的一个重要特性。</p><p>当非接口类型<code>T</code>的一个值<code>t</code>被包裹在接口类型<code>I</code>的一个接口值<code>i</code>中，通过<code>i</code>调用接口类型<code>I</code>指定的一个方法时，事实上为非接口类型<code>T</code>声明的对应方法将通过非接口值<code>t</code>被调用。 换句话说，<strong>调用一个接口值的方法实际上将调用此接口值的动态值的对应方法</strong>。 比如，当方法<code>i.m</code>被调用时，其实被调用的是方法<code>t.m</code>。 一个接口值可以通过包裹不同动态类型的动态值来表现出各种不同的行为，这称为多态。</p><p>当方法<code>i.m</code>被调用时，<code>i</code>存储的实现关系信息的方法表中的方法<code>t.m</code>将被找到并被调用。 此方法表是一个切片，所以此寻找过程只不过是一个切片元素访问操作，不会消耗很多时间。</p><p>注意，在nil接口值上调用方法将产生一个恐慌，因为没有具体的方法可被调用。</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">About() <span class="keyword">string</span></span><br><span class="line">Process([]<span class="keyword">int</span>) []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UniqueFilter用来删除重复的数字。</span></span><br><span class="line"><span class="keyword">type</span> UniqueFilter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UniqueFilter)</span> <span class="title">About</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"删除重复的数字"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UniqueFilter)</span> <span class="title">Process</span><span class="params">(inputs []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">outs := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(inputs))</span><br><span class="line">pusheds := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> inputs &#123;</span><br><span class="line"><span class="keyword">if</span> !pusheds[n] &#123;</span><br><span class="line">pusheds[n] = <span class="literal">true</span></span><br><span class="line">outs = <span class="built_in">append</span>(outs, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> outs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultipleFilter用来只保留某个整数的倍数数字。</span></span><br><span class="line"><span class="keyword">type</span> MultipleFilter <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf MultipleFilter)</span> <span class="title">About</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"保留%v的倍数"</span>, mf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf MultipleFilter)</span> <span class="title">Process</span><span class="params">(inputs []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> outs = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(inputs))</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> inputs &#123;</span><br><span class="line"><span class="keyword">if</span> n % <span class="keyword">int</span>(mf) == <span class="number">0</span> &#123;</span><br><span class="line">outs = <span class="built_in">append</span>(outs, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> outs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在多态特性的帮助下，只需要一个filteAndPrint函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filteAndPrint</span><span class="params">(fltr Filter, unfiltered []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 在fltr参数上调用方法其实是调用fltr的动态值的方法。</span></span><br><span class="line">filtered := fltr.Process(unfiltered)</span><br><span class="line">fmt.Println(fltr.About() + <span class="string">":\n\t"</span>, filtered)</span><br><span class="line"><span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">numbers := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">21</span>, <span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"过滤之前：\n\t"</span>, numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个非接口值被包裹在一个Filter切片的三个接口元素中。</span></span><br><span class="line">filters := []Filter&#123;</span><br><span class="line">UniqueFilter&#123;&#125;,</span><br><span class="line">MultipleFilter(<span class="number">2</span>),</span><br><span class="line">MultipleFilter(<span class="number">3</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个切片元素将被赋值给类型为Filter的循环变量fltr。</span></span><br><span class="line"><span class="comment">// 每个元素中的动态值也将被同时复制并被包裹在循环变量fltr中。</span></span><br><span class="line"><span class="keyword">for</span> _, fltr := <span class="keyword">range</span> filters &#123;</span><br><span class="line">numbers = filteAndPrint(fltr, numbers)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">过滤之前：</span><br><span class="line"> [12 7 21 12 12 26 25 21 30]</span><br><span class="line">删除重复的数字:</span><br><span class="line"> [12 7 21 26 25 30]</span><br><span class="line">保留2的倍数:</span><br><span class="line"> [12 26 30]</span><br><span class="line">保留3的倍数:</span><br><span class="line"> [12 30]</span><br></pre></td></tr></table></figure><p>在上面这个例子中，多态使得我们不必为每个过滤器类型写一个单独的<code>filteAndPrint</code>函数。</p><p>除了上述这个好处，多态也使得一个代码包的开发者可以在此代码包中声明一个接口类型并声明一个拥有此接口类型参数的函数（或者方法），从而此代码包的一个用户可以在用户包中声明一个实现了此接口类型的用户类型，并且将此用户类型的值做为实参传递给此代码包中声明的函数（或者方法）的调用。 此代码包的开发者并不用关心一个用户类型具体是如何声明的，只要此用户类型满足此代码包中声明的接口类型规定的行为即可。</p><p>事实上，多态对于一个语言来说并非一个不可或缺的特性。我们可以通过其它途径来实现多态的作用。 但是，多态可以使得我们的代码更加简洁和优雅。</p><hr>]]></content>
    
    <summary type="html">
    
      golang的多态实现与原理
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql关闭update safe mode</title>
    <link href="https://cloudsjhan.github.io/2019/03/11/mysql%E5%85%B3%E9%97%ADupdate-safe-mode/"/>
    <id>https://cloudsjhan.github.io/2019/03/11/mysql关闭update-safe-mode/</id>
    <published>2019-03-11T02:28:38.000Z</published>
    <updated>2019-03-11T02:30:18.232Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>SET SQL_SAFE_UPDATES = 0;</li></ul><hr>]]></content>
    
    <summary type="html">
    
      mysql关闭update safe mode
    
    </summary>
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git-保持fork的项目与上游同步</title>
    <link href="https://cloudsjhan.github.io/2019/02/26/git-%E4%BF%9D%E6%8C%81fork%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8E%E4%B8%8A%E6%B8%B8%E5%90%8C%E6%AD%A5/"/>
    <id>https://cloudsjhan.github.io/2019/02/26/git-保持fork的项目与上游同步/</id>
    <published>2019-02-26T01:48:38.000Z</published>
    <updated>2019-02-26T01:53:39.122Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>添加上游仓库：</li></ul><p>git remote add upstream [upstream_url]</p><ul><li>fetch 之：</li></ul><p>git fetch upstream</p><ul><li>切换到本地master分支：</li></ul><p>git checkout master</p><ul><li>将upstream/master merge到 本地master分支：</li></ul><p>git merge upstream/master  //可能会报错，如果报错就执行：git pull</p><ul><li>同时push到自己的github仓库：</li></ul><p>git push origin master</p><hr>]]></content>
    
    <summary type="html">
    
      git-保持fork的项目与上游同步
    
    </summary>
    
      <category term="git" scheme="https://cloudsjhan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://cloudsjhan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>详解Go regexp包中 ReplaceAllString 的用法</title>
    <link href="https://cloudsjhan.github.io/2019/02/01/%E8%AF%A6%E8%A7%A3Go-regexp%E5%8C%85%E4%B8%AD-ReplaceAllString-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://cloudsjhan.github.io/2019/02/01/详解Go-regexp包中-ReplaceAllString-的用法/</id>
    <published>2019-02-01T04:23:12.000Z</published>
    <updated>2019-02-01T09:37:45.426Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>昨天有同事在看k8s源码，突然问了一个看似很简单的问题，<a href="https://golang.org/pkg/regexp/#Regexp.ReplaceAllString" target="_blank" rel="noopener">https://golang.org/pkg/regexp/#Regexp.ReplaceAllString</a> 官方文档中<code>ReplaceAllString</code>的解释，到底是什么意思？到底怎么用？</p><p>官方英文原文：</p><p><code>func (re *Regexp) ReplaceAllString(src, repl string) string</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement <span class="built_in">string</span> repl. Inside repl, $ signs are interpreted as in Expand, so <span class="keyword">for</span> instance $<span class="number">1</span> represents the text of the first submatch.</span><br></pre></td></tr></table></figure><p>中文文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。在替换时，repl中的&apos;$&apos;符号会按照Expand方法的规则进行解释和替换，例如$1会被替换为第一个分组匹配结果。</span><br></pre></td></tr></table></figure><p>看上去一脸懵逼，还是不理解这个函数到底怎么用。</p><p>又去看官方的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example：</span><br><span class="line">re := regexp.MustCompile(<span class="string">"a(x*)b"</span>)</span><br><span class="line">fmt.Println(re.ReplaceAllString(<span class="string">"-ab-axxb-"</span>, <span class="string">"T"</span>))</span><br><span class="line">fmt.Println(re.ReplaceAllString(<span class="string">"-ab-axxb-"</span>, <span class="string">"$1"</span>))</span><br><span class="line">fmt.Println(re.ReplaceAllString(<span class="string">"-ab-axxb-"</span>, <span class="string">"$1W"</span>))</span><br><span class="line">fmt.Println(re.ReplaceAllString(<span class="string">"-ab-axxb-"</span>, <span class="string">"$&#123;1&#125;W"</span>))</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">-T-T-</span><br><span class="line">--xx-</span><br><span class="line">---</span><br><span class="line">-W-xxW-</span><br></pre></td></tr></table></figure><p>第一个替换勉强能看明白，是用<code>T</code>去替换<code>-ab-axxb-</code>中符合正则表达式匹配的部分；第二个中的<code>$</code>是什么意思？<code>$1</code>看起来像是匹配正则表达式分组中第一部分，那<code>$1W</code>呢？<code>${1}W</code>呢？带着这些问题，开始深入研究这个函数到底怎么用。</p><p>首先，<code>$</code>符号在<code>Expand</code>函数中有解释过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte</span><br><span class="line"></span><br><span class="line">Expand返回新生成的将template添加到dst后面的切片。在添加时，Expand会将template中的变量替换为从src匹配的结果。match应该是被FindSubmatchIndex返回的匹配结果起止位置索引。（通常就是匹配src，除非你要将匹配得到的位置用于另一个[]byte）</span><br><span class="line"></span><br><span class="line">在template参数里，一个变量表示为格式如：$name或$&#123;name&#125;的字符串，其中name是长度&gt;0的字母、数字和下划线的序列。一个单纯的数字字符名如$1会作为捕获分组的数字索引；其他的名字对应(?P&lt;name&gt;...)语法产生的命名捕获分组的名字。超出范围的数字索引、索引对应的分组未匹配到文本、正则表达式中未出现的分组名，都会被替换为空切片。</span><br><span class="line"></span><br><span class="line">$name格式的变量名，name会尽可能取最长序列：$1x等价于$&#123;1x&#125;而非$&#123;1&#125;x，$10等价于$&#123;10&#125;而非$&#123;1&#125;0。因此$name适用在后跟空格/换行等字符的情况，$&#123;name&#125;适用所有情况。</span><br><span class="line"></span><br><span class="line">如果要在输出中插入一个字面值&apos;$&apos;，在template里可以使用$$。</span><br></pre></td></tr></table></figure><p>说了这么多，其实最终要的部分可以概括为三点：</p><ol><li><code>$</code>后面只有数字，则代表正则表达式的分组索引，关于正则表达式的分组解释：</li></ol><p>捕获组可以通过从左到右计算其开括号来编号 。例如，在表达式 (A)(B(C)) 中，存在四个这样的组：</p><table><thead><tr><th><strong>0</strong></th><th>(A)(B(C))</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>(A)</td></tr><tr><td><strong>2</strong></td><td>(B(C))</td></tr><tr><td><strong>3</strong></td><td>(C)</td></tr></tbody></table><p>组零始终代表整个表达式</p><p>之所以这样命名捕获组是因为在匹配中，保存了与这些组匹配的输入序列的每个子序列。捕获的子序列稍后可以通过 Back 引用（反向引用） 在表达式中使用，也可以在匹配操作完成后从匹配器检索。</p><p>匹配正则表达式的<code>$1</code>部分，保留该部分，去掉其余部分；</p><ol start="2"><li><code>$</code>后面是字符串，即<code>$name</code>,代表匹配<strong>对应(?P<name>…)语法产生的命名捕获分组的名字</name></strong></li><li><code>${数字}字符串</code>,即<code>${1}xxx</code>，意思是匹配正则表达式的分组1，<code>src</code>中匹配分组1的保留，并删除<code>src</code>剩余部分，追加<code>xxx</code>，后面会有代码示例解释这部分，也是最难理解的部分</li><li>最简单的情况，参数<code>repl</code>是字符串，将src中所有re的匹配结果都替换为repl</li></ol><p>下面用代码来解释以上几种情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := <span class="string">"Hello World, 123 Go!"</span></span><br><span class="line"><span class="comment">//定义一个正则表达式reg，匹配Hello或者Go</span></span><br><span class="line">reg := regexp.MustCompile(<span class="string">`(Hell|G)o`</span>)</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">"2019-12-01,test"</span></span><br><span class="line"><span class="comment">//定义一个正则表达式reg2,匹配 YYYY-MM-DD 的日期格式</span></span><br><span class="line">reg2 := regexp.MustCompile(<span class="string">`(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)`</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最简单的情况，用“T替换”"-ab-axxb-"中符合正则"a(x*)b"的部分</span></span><br><span class="line">    reg3 := regexp.MustCompile(<span class="string">"a(x*)b"</span>)</span><br><span class="line">fmt.Println(re.ReplaceAllString(<span class="string">"-ab-axxb-"</span>, <span class="string">"T"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//$&#123;1&#125;匹配"Hello World, 123 Go!"中符合正则`(Hell|G)`的部分并保留，去掉"Hello"与"Go"中的'o'并用"ddd"追加</span></span><br><span class="line">rep1 := <span class="string">"$&#123;1&#125;ddd"</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, reg.ReplaceAllString(s, rep1))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先，"2019-12-01,test"中符合正则表达式`(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)`的部分是"2019-12-01",将该部分匹配'(\d&#123;4&#125;)'的'2019'保留，去掉剩余部分</span></span><br><span class="line">    rep2 := <span class="string">"$&#123;1&#125;"</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, reg2.ReplaceAllString(s2,rep2))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先，"2019-12-01,test"中符合正则表达式`(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)`的部分是"2019-12-01",将该部分匹配'(\d&#123;2&#125;)'的'12'保留，去掉剩余部分</span></span><br><span class="line">     rep3 := <span class="string">"$&#123;2&#125;"</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, reg2.ReplaceAllString(s2,rep3))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先，"2019-12-01,test"中符合正则表达式`(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)`的部分是"2019-12-01",将该部分匹配'(\d&#123;2&#125;)'的'01'保留，去掉剩余部分,并追加"13:30:12"</span></span><br><span class="line">    rep4 := <span class="string">"$&#123;3&#125;:13:30:12"</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, reg2.ReplaceAllString(s2,rep4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出依次是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line">-T-T-</span><br><span class="line">"Hellddd World, 123 Gddd!"</span><br><span class="line">"2019,test"</span><br><span class="line">"12,test"</span><br><span class="line">"01:13:30:12,test"</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go<code>regexp</code>包中的<code>ReplaceAllString</code>设计有些许反人类，理解和使用上感觉不方便，如果你有更好的理解或者示例代码，Call me!</p><hr>]]></content>
    
    <summary type="html">
    
      详解Go regexp包中 ReplaceAllString 的用法
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go语言坑之for range</title>
    <link href="https://cloudsjhan.github.io/2019/01/31/go%E8%AF%AD%E8%A8%80%E5%9D%91%E4%B9%8Bfor-range/"/>
    <id>https://cloudsjhan.github.io/2019/01/31/go语言坑之for-range/</id>
    <published>2019-01-31T01:59:59.000Z</published>
    <updated>2019-01-31T02:05:43.618Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="go语言坑之for-range"><a href="#go语言坑之for-range" class="headerlink" title="go语言坑之for range"></a>go语言坑之for range</h1><blockquote><p>这篇文章简单清晰地解释了之前遍历struct切片时遇到的一些怪异现象，这个问题当时也写了一篇文章来讨论，<a href="https://cloudsjhan.github.io/2018/10/27/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8Bgolang%E4%B8%AD%E4%BF%AE%E6%94%B9struct%E7%9A%84slice%E7%9A%84%E5%80%BC/">文章地址</a>，但是没有切中要点。昨天无意中看到这篇博客，豁然开朗。</p></blockquote><hr><p>go只提供了一种循环方式，即for循环，在使用时可以像c那样使用，也可以通过for range方式遍历容器类型如数组、切片和映射。但是在使用for range时，如果使用不当，就会出现一些问题，导致程序运行行为不如预期。比如，下面的示例程序将遍历一个切片，并将切片的值当成映射的键和值存入，切片类型是一个int型，映射的类型是键为int型，值为*int，即值是一个地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    slice := []int&#123;0, 1, 2, 3&#125;</span><br><span class="line">    myMap := make(map[int]*int)</span><br><span class="line"></span><br><span class="line">    for index, value := range slice &#123;</span><br><span class="line">        myMap[index] = &amp;value</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;=====new map=====&quot;)</span><br><span class="line">    prtMap(myMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func prtMap(myMap map[int]*int) &#123;</span><br><span class="line">    for key, value := range myMap &#123;</span><br><span class="line">        fmt.Printf(&quot;map[%v]=%v\n&quot;, key, *value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=====new map=====</span><br><span class="line">map[3]=3</span><br><span class="line">map[0]=3</span><br><span class="line">map[1]=3</span><br><span class="line">map[2]=3</span><br></pre></td></tr></table></figure><p>由输出可以知道，不是我们预期的输出，正确输出应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====new map=====</span><br><span class="line">map[0]=0</span><br><span class="line">map[1]=1</span><br><span class="line">map[2]=2</span><br><span class="line">map[3]=3</span><br><span class="line">（无序输出，但是值是0,1,2,3）</span><br></pre></td></tr></table></figure><p>但是由输出可以知道，映射的值都相同且都是3。其实可以猜测映射的值都是同一个地址，遍历到切片的最后一个元素3时，将3写入了该地址，所以导致映射所有值都相同。其实真实原因也是如此，因为for range创建了每个元素的副本，而不是直接返回每个元素的引用，如果使用该值变量的地址作为指向每个元素的指针，就会导致错误，在迭代时，返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以值的地址总是相同的，导致结果不如预期。</p><p>修正后程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    slice := []int&#123;0, 1, 2, 3&#125;</span><br><span class="line">    myMap := make(map[int]*int)</span><br><span class="line"></span><br><span class="line">    for index, value := range slice &#123;</span><br><span class="line">        num := value</span><br><span class="line">        myMap[index] = &amp;num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;=====new map=====&quot;)</span><br><span class="line">    prtMap(myMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func prtMap(myMap map[int]*int) &#123;</span><br><span class="line">    for key, value := range myMap &#123;</span><br><span class="line">        fmt.Printf(&quot;map[%v]=%v\n&quot;, key, *value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=====new map=====</span><br><span class="line">map[2]=2</span><br><span class="line">map[3]=3</span><br><span class="line">map[0]=0</span><br><span class="line">map[1]=1</span><br></pre></td></tr></table></figure><hr><p>引用声明：该博客来自于<a href="https://studygolang.com/articles/9701" target="_blank" rel="noopener">这里</a>.</p><hr>]]></content>
    
    <summary type="html">
    
      go语言坑之for range
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>记第一个Vue项目台前幕后的经历</title>
    <link href="https://cloudsjhan.github.io/2019/01/28/%E8%AE%B0%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE%E5%8F%B0%E5%89%8D%E5%B9%95%E5%90%8E%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>https://cloudsjhan.github.io/2019/01/28/记第一个Vue项目台前幕后的经历/</id>
    <published>2019-01-28T07:28:46.000Z</published>
    <updated>2019-01-28T15:32:19.505Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>0前端开发经验，初次接触Vue，从后端到前端，从开发、打包到部署，完整的历程。</p><p>首先粗略通读了一遍<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">官方文档</a>，动手用webpack搭建了一个简单的demo。</p><p>看了Echarts的官方<a href="https://echarts.baidu.com/examples/" target="_blank" rel="noopener">demo</a>，了解了几种数据图表的数据结构。因为我要做的项目就是要将后端接口的数据拿到，然后图形化的形式展示出来。</p><h1 id="对接后端，进行axios二次开发"><a href="#对接后端，进行axios二次开发" class="headerlink" title="对接后端，进行axios二次开发"></a>对接后端，进行axios二次开发</h1><p>在构建应用时需要访问一个 API 并展示其数据，调研Vue的多种方式后选择了官方推荐的axiox。</p><h1 id="从ajax到fetch、axios"><a href="#从ajax到fetch、axios" class="headerlink" title="从ajax到fetch、axios"></a>从ajax到fetch、axios</h1><p>前端是个发展迅速的领域，前端请求自然也发展迅速，从原生的XHR到jquery ajax，再到现在的axios和fetch。</p><h3 id="jquery-ajax"><a href="#jquery-ajax" class="headerlink" title="jquery ajax"></a>jquery ajax</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &apos;POST&apos;,</span><br><span class="line">    url: url,</span><br><span class="line">    data: data,</span><br><span class="line">    dataType: dataType,</span><br><span class="line">    success: function() &#123;&#125;,</span><br><span class="line">    error: function() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>它是对原生XHR的封装，还支持JSONP，非常方便；真的是用过的都说好。但是随着react，vue等前端框架的兴起，jquery早已不复当年之勇。很多情况下我们只需要使用ajax，但是却需要引入整个jquery，这非常的不合理，于是便有了fetch的解决方案。</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch号称是ajax的替代品，它的API是基于Promise设计的，旧版本的浏览器不支持Promise，需要使用polyfill es6-promise</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 原生XHR</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;, url);</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">        console.log(xhr.responseText)   // 从服务器获取数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line">// fetch</span><br><span class="line">fetch(url)</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        if (response.ok) &#123;</span><br><span class="line">            response.json()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(data =&gt; console.log(data))</span><br><span class="line">    .catch(err =&gt; console.log(err))</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看起来好像是方便点，then链就像之前熟悉的callback。</p><p>在MDN上，讲到它跟jquery ajax的区别，这也是fetch很奇怪的地方：</p><blockquote><p>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）.</p></blockquote><p>突然感觉这还不如jquery ajax好用呢？别急，再搭配上async/await将会让我们的异步代码更加优雅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">    let response = await fetch(url);</span><br><span class="line">    let data = await response.json();</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看起来是不是像同步代码一样？简直完美！好吧，其实并不完美，async/await是ES7的API，目前还在试验阶段，还需要我们使用babel进行转译成ES5代码。</p><p>还要提一下的是，fetch是比较底层的API，很多情况下都需要我们再次封装。 比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// jquery ajax</span><br><span class="line">$.post(url, &#123;name: &apos;test&apos;&#125;)</span><br><span class="line">// fetch</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    body: Object.keys(&#123;name: &apos;test&apos;&#125;).map((key) =&gt; &#123;</span><br><span class="line">        return encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(params[key]);</span><br><span class="line">    &#125;).join(&apos;&amp;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于fetch是比较底层的API，所以需要我们手动将参数拼接成’name=test’的格式，而jquery ajax已经封装好了。所以fetch并不是开箱即用的。</p><p>另外，fetch还不支持超时控制。</p><p>哎呀，感觉fetch好垃圾啊，，还需要继续成长。。</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是尤雨溪大神推荐使用的，它也是对原生XHR的封装。它有以下几大特性：</p><ul><li>可以在node.js中使用</li><li>提供了并发请求的接口</li><li>支持Promise API</li></ul><p>简单使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    url: url,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class="line">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br></pre></td></tr></table></figure><p>并发请求,官方的并发例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    // Both requests are now complete</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p>axios体积比较小，也没有上面fetch的各种问题，我认为是当前最好的请求方式 </p><p>详情参考<a href="https://cn.vuejs.org/v2/cookbook/using-axios-to-consume-apis.html" target="_blank" rel="noopener">官方文档</a></p><p>#二次封装axios</p><p>首先创建一个request.js,内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> Qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkStatus</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">""</span>, level = <span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">        msg = <span class="string">"您还没有登陆"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">        msg = <span class="string">"您没有该项权限"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">        msg = <span class="string">"资源不存在"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">        msg = <span class="string">"服务器发生了点意外"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      msg = res.data.msg;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg !== <span class="string">""</span> &amp;&amp; msg !== <span class="literal">undefined</span> &amp;&amp; msg !== <span class="literal">null</span>) &#123;</span><br><span class="line">        store.dispatch(<span class="string">'showSnackBar'</span>, &#123;<span class="attr">text</span>: msg, <span class="attr">level</span>: level&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err.response;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCode</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((res.status &gt;= <span class="number">200</span> &amp;&amp; res.status &lt; <span class="number">400</span>) &amp;&amp; (res.data.status &gt;= <span class="number">200</span> &amp;&amp; res.data.status &lt; <span class="number">400</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> msg = <span class="string">""</span>, level = <span class="string">"success"</span>;</span><br><span class="line">      <span class="keyword">switch</span> (res.data.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">201</span>:</span><br><span class="line">          msg = <span class="string">"创建成功"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">204</span>:</span><br><span class="line">          msg = <span class="string">"删除成功"</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = res.data.success;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里封装axios的get,post,put,delete等方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get(url, params) &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.get(</span><br><span class="line">        url,</span><br><span class="line">        params,</span><br><span class="line">      ).then(checkCode).catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(error)&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    post(url, data) &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.post(</span><br><span class="line">        url,</span><br><span class="line">        Qs.stringify(data),</span><br><span class="line">      ).then(checkCode).catch(checkStatus);</span><br><span class="line">    &#125;,</span><br><span class="line">    put(url, data) &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.put(</span><br><span class="line">        url,</span><br><span class="line">        Qs.stringify(data),</span><br><span class="line">      ).then(checkCode).catch(checkStatus);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">delete</span>(url, data) &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.delete(</span><br><span class="line">        url,</span><br><span class="line">        &#123;<span class="attr">data</span>: Qs.stringify(data)&#125;,</span><br><span class="line">      ).then(checkCode).catch(checkStatus);</span><br><span class="line">    &#125;,</span><br><span class="line">    patch(url, data) &#123;</span><br><span class="line">      <span class="keyword">return</span> axios.patch(</span><br><span class="line">        url,</span><br><span class="line">        data,</span><br><span class="line">      ).then(checkCode).catch(checkStatus);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>创建一个api.js,存放后端的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入上面的request模块</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'./request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明后端接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> urlUserPrefix = <span class="string">'/v1/users'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> urlProductPrefix = <span class="string">'/v1/products'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用前面封装好的方法，调用后端接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUserslInfoLast = <span class="function"><span class="params">data</span> =&gt;</span> request.get(<span class="string">`<span class="subst">$&#123;urlUserPrefix&#125;</span>`</span>, data);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getProductsInfo = <span class="function"><span class="params">data</span> =&gt;</span> request.get(<span class="string">`<span class="subst">$&#123;urlProductPrefix&#125;</span>`</span>, data);</span><br></pre></td></tr></table></figure><p>在.vue文件中使用定义的方法，获取后端接口的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  &#123;</span><br><span class="line"></span><br><span class="line">    components: &#123;</span><br><span class="line">    chart: ECharts,</span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">  store,</span><br><span class="line">    name: <span class="string">'ResourceTypeLine'</span>,</span><br><span class="line">    data: <span class="function"><span class="params">()</span> =&gt;</span>(&#123;</span><br><span class="line">       seconds: <span class="number">-1</span>,</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//define dataset</span></span><br><span class="line">   apiResponse:&#123;&#125;,</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    initOptions: &#123;</span><br><span class="line">        renderer: options.renderer || <span class="string">'canvas'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">    mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">this</span>.fTimeArray = <span class="keyword">this</span>.getFormatTime()</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用method里面的方法</span></span><br><span class="line"><span class="keyword">this</span>.getUserInfo()</span><br><span class="line">   </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="comment">//异步方式调用后端接口</span></span><br><span class="line">       <span class="keyword">async</span> getUserInfo() &#123;</span><br><span class="line">        <span class="keyword">const</span> resThis = <span class="keyword">await</span> urlUserPrefix(&#123;</span><br><span class="line">          params: &#123;</span><br><span class="line">              <span class="comment">//get的参数在这里添加</span></span><br><span class="line">            beginTime: <span class="keyword">this</span>.fTimeArray[<span class="number">0</span>],</span><br><span class="line">            endTime: <span class="keyword">this</span>.fTimeArray[<span class="number">1</span>],</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.apiResponseThisMonth = resThis.data</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h1 id="开发环境配置跨域"><a href="#开发环境配置跨域" class="headerlink" title="开发环境配置跨域"></a>开发环境配置跨域</h1><p>为了更方便地与后台联调，需要在用vue脚手架创建地项目中，在config目录地index.js设置proxytable来实现跨域请求，具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    env: <span class="built_in">require</span>(<span class="string">'./prod.env'</span>),</span><br><span class="line">    index: path.resolve(__dirname, <span class="string">'../dist/index.html'</span>),</span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'.'</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">    <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">    <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">    <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">    productionGzip: <span class="literal">false</span>,</span><br><span class="line">    productionGzipExtensions: [<span class="string">'js'</span>, <span class="string">'css'</span>],</span><br><span class="line">    <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">    <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">    <span class="comment">// `npm run build --report`</span></span><br><span class="line">    <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;,</span><br><span class="line">  dev: &#123;</span><br><span class="line">    env: <span class="built_in">require</span>(<span class="string">'./dev.env'</span>),</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// hosts:"0.0.0.0",</span></span><br><span class="line">    autoOpenBrowser: <span class="literal">true</span>,</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">    <span class="comment">//配置跨域请求,注意配置完之后需要重启编译该项目</span></span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="comment">//请求名字变量可以自己定义</span></span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://test.com'</span>, <span class="comment">// 请求的接口域名或IP地址，开头是http或https</span></span><br><span class="line">        <span class="comment">// secure: false,  // 如果是https接口，需要配置这个参数</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,<span class="comment">// 是否跨域，如果接口跨域，需要进行这个参数配置</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>:<span class="string">""</span><span class="comment">//表示需要rewrite重写路径  </span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// CSS Sourcemaps off by default because relative paths are "buggy"</span></span><br><span class="line">    <span class="comment">// with this option, according to the CSS-Loader README</span></span><br><span class="line">    <span class="comment">// (https://github.com/webpack/css-loader#sourcemaps)</span></span><br><span class="line">    <span class="comment">// In our experience, they generally work as expected,</span></span><br><span class="line">    <span class="comment">// just be aware of this issue when enabling this option.</span></span><br><span class="line">    cssSourceMap: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vue-项目打包部署，通过nginx-解决跨域问题"><a href="#vue-项目打包部署，通过nginx-解决跨域问题" class="headerlink" title="vue 项目打包部署，通过nginx 解决跨域问题"></a>vue 项目打包部署，通过nginx 解决跨域问题</h1><p>​     最近将公司vue 项目打包部署服务器时，产生了一点小插曲，开发环境中配置的跨域在将项目打包为静态文件时是没有用的 ，就想到了用 nginx 通过反向代理的方式解决这个问题，但是其中有一个巨大的坑，后面会讲到。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>liunx 下 nginx 安装配置（将不做多的阐述，请自行百度）</p><h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h4><ul><li>通过 Xshell 连接 liunx 服务器 ，打开 nginx.conf 配置文件，或通过 WinSCP 直接打开并编辑nginx.conf文件 ，这里我选择后者 。（具体配置文件的路径根据你安装时决定）</li><li>在配置文件中新增一个server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 新增的服务 </span><br><span class="line"># 新增的服务</span><br><span class="line">server &#123;</span><br><span class="line">listen       8086; # 监听的端口</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root /var/www;  # vue 打包后静态文件存放的地址</span><br><span class="line">index index.html; # 默认主页地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /v1 &#123;</span><br><span class="line">proxy_pass http://47.106.184.89:9010/v1; # 代理接口地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /testApi &#123;</span><br><span class="line">proxy_pass http://40.106.197.89:9086/testApi; # 代理接口地址</span><br><span class="line">&#125;</span><br><span class="line">error_page   500 502 503 504  /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">root   html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>解释说明</li></ul><p>/var/www是我当前将vue 文件打包后存放在 liunx下的路径 ，</p><p> 当我们启动 nginx 后 就可以通过<a href="http://ip地址:8086/访问到vue" target="_blank" rel="noopener">http://ip地址:8086/访问到vue</a> 打包的静态文件。</p><p>2.<code>location /v1 指拦截以</code>v1<code>开头的请求，http请求格式为</code><a href="http://ip地址:8086/v1/***`,这里有一个坑！一定要按照上面的配置文件**：proxy_pass" target="_blank" rel="noopener">http://ip地址:8086/v1/***`,这里有一个坑！一定要按照上面的配置文件**：proxy_pass</a> <a href="http://47.106.184.89:9010/v1" target="_blank" rel="noopener">http://47.106.184.89:9010/v1</a>; # 代理接口地址<strong>，如果你像我一开始写的</strong>proxy_pass <a href="http://47.106.184.89:9010/" target="_blank" rel="noopener">http://47.106.184.89:9010/</a>; # 代理接口地址**，你永远也匹配不到对应的接口！。</p><p>proxy_pass <a href="http://47.106.197.89:9093/v1;`" target="_blank" rel="noopener">http://47.106.197.89:9093/v1;`</a> 当拦截到需要处理的请求时，将拦截请求代理到的 接口地址。</p><h1 id="webpack打包"><a href="#webpack打包" class="headerlink" title="webpack打包"></a>webpack打包</h1><p>下面是config/index.js配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// see http://vuejs-templates.github.io/webpack for documentation.</span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    env: require(&apos;./prod.env&apos;),</span><br><span class="line">    index: path.resolve(__dirname, &apos;../dist/index.html&apos;),</span><br><span class="line">    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),</span><br><span class="line">    assetsSubDirectory: &apos;static&apos;,</span><br><span class="line">    assetsPublicPath: &apos;.&apos;,</span><br><span class="line">    productionSourceMap: false,</span><br><span class="line">    // Gzip off by default as many popular static hosts such as</span><br><span class="line">    // Surge or Netlify already gzip all static assets for you.</span><br><span class="line">    // Before setting to `true`, make sure to:</span><br><span class="line">    // npm install --save-dev compression-webpack-plugin</span><br><span class="line">    productionGzip: false,</span><br><span class="line">    productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],</span><br><span class="line">    // Run the build command with an extra argument to</span><br><span class="line">    // View the bundle analyzer report after build finishes:</span><br><span class="line">    // `npm run build --report`</span><br><span class="line">    // Set to `true` or `false` to always turn it on or off</span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;,</span><br><span class="line">  dev: &#123;</span><br><span class="line">    env: require(&apos;./dev.env&apos;),</span><br><span class="line">    port: 8080,</span><br><span class="line">    // hosts:&quot;0.0.0.0&quot;,</span><br><span class="line">    autoOpenBrowser: true,</span><br><span class="line">    assetsSubDirectory: &apos;static&apos;,</span><br><span class="line">    assetsPublicPath: &apos;/&apos;,</span><br><span class="line">    //配置跨域请求,注意配置完之后需要重启编译该项目</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      //请求名字变量可以自己定义</span><br><span class="line">      &apos;/api&apos;: &#123;</span><br><span class="line">        target: &apos;http://billing.hybrid.cloud.ctripcorp.com&apos;, // 请求的接口域名或IP地址，开头是http或https</span><br><span class="line">        // secure: false,  // 如果是https接口，需要配置这个参数</span><br><span class="line">        changeOrigin: true,// 是否跨域，如果接口跨域，需要进行这个参数配置</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/api&apos;:&quot;&quot;//表示需要rewrite重写路径  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;</span><br><span class="line">    // with this option, according to the CSS-Loader README</span><br><span class="line">    // (https://github.com/webpack/css-loader#sourcemaps)</span><br><span class="line">    // In our experience, they generally work as expected,</span><br><span class="line">    // just be aware of this issue when enabling this option.</span><br><span class="line">    cssSourceMap: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>打包Docker镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM Nginx:base</span><br><span class="line"></span><br><span class="line">MAINTAINER author &lt;hantmac@outlook.com&gt;</span><br><span class="line"></span><br><span class="line">WORKDIR /opt/workDir</span><br><span class="line">RUN mkdir /var/log/workDir</span><br><span class="line"></span><br><span class="line">COPY dist /var/www</span><br><span class="line"></span><br><span class="line">ADD  nginx/default.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"></span><br><span class="line">ENTRYPOINT nginx -g "daemon off;"</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这是首次接触前端的第一个项目，期间经历了从后端接口开发，前端框架选型（一度想要用react，后来还是放弃），熟悉Vue，到组件开发，webpack构建，Nginx部署，Docker发布的完整过程。虽然页面比较简单，但是期间的采坑无数，后面还要继续努力！</p><hr>]]></content>
    
    <summary type="html">
    
      记第一个Vue项目台前幕后的经历
    
    </summary>
    
      <category term="Frontend" scheme="https://cloudsjhan.github.io/categories/Frontend/"/>
    
    
      <category term="Vue" scheme="https://cloudsjhan.github.io/tags/Vue/"/>
    
      <category term="Frontend" scheme="https://cloudsjhan.github.io/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>20181202-Postmortem-debugging-Go-services-with-Delve[翻译]</title>
    <link href="https://cloudsjhan.github.io/2019/01/20/20181202-Postmortem-debugging-Go-services-with-Delve-%E7%BF%BB%E8%AF%91/"/>
    <id>https://cloudsjhan.github.io/2019/01/20/20181202-Postmortem-debugging-Go-services-with-Delve-翻译/</id>
    <published>2019-01-20T15:39:57.000Z</published>
    <updated>2022-07-04T01:35:34.032Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="使用Delve-调试Go服务的一次经历"><a href="#使用Delve-调试Go服务的一次经历" class="headerlink" title="使用Delve 调试Go服务的一次经历"></a>使用Delve 调试Go服务的一次经历</h1><hr><blockquote><p>Vladimir Varankin 写于 2018/12/02</p></blockquote><p>某天，我们的生产服务上的几个实例突然不能处理外部进入的流量，HTTP请求成功通过负载均衡到达实例，但是之后却hang住了。接下来记录的是一次调试在线Go服务的惊心动魄的经历。</p><p>正是下面逐步演示的操作，帮助我们定位了问题的根本原因。</p><p>简单起见，我们将起一个Go写的HTTP服务作为调试使用，这个服务实现的细节暂时不做深究（之后我们将深入分析代码）。一个真实的生产应用可能包含很多组件，这些组件实现了业务罗和服务的基础架构。我们可以确信，这些应用已经在生产环境“身经百战” :)。</p><p>源代码以及配置细节可以查看<a href="https://github.com/narqo/postmortem-debug-go" target="_blank" rel="noopener">GitHub仓库</a>。为了完成接下来的工作，你需要一台Linux系统的虚机，这里我使用<a href="https://github.com/sevos/vagrant-hostmanager" target="_blank" rel="noopener">vagrant-hostmanager</a>插件。<code>Vagrantfile</code>在GitHub仓库的根目录，可以查看更多细节。</p><p>让我们开启虚机，构建HTTP服务并且运行起来，可以看到下面的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant up</span></span><br><span class="line">Bringing machine 'server-test-1' up with 'virtualbox' provider...</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> vagrant ssh server-test-1</span></span><br><span class="line">Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-33-generic x86_64)</span><br><span class="line">···</span><br><span class="line">vagrant@server-test-1:~$ cd /vagrant/example/server</span><br><span class="line">vagrant@server-test-1:/vagrant/example/server$ go build</span><br><span class="line">vagrant@server-test-1:/vagrant/example/server$ ./server --addr=:10080</span><br><span class="line">server listening addr=:10080</span><br></pre></td></tr></table></figure><p>通过<code>curl</code>发送请求到所起的HTTP服务，可以判断其是否处于工作状态，新开一个terminal并执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl <span class="string">'http://server-test-1:10080'</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>为了模拟失败的情况，我们需要发送大量请求到HTTP服务，这里我们使用HTTP benchmark测试工具<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wrk</a>进行模拟。我的MacBook是4核的，所以使用4个线程运行wrk，能够产生1000个连接，基本能够满足需求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wrk -d1m -t4 -c1000 <span class="string">'http://server-test-1:10080'</span></span></span><br><span class="line">Running 1m test @ http://server-test-1:10080</span><br><span class="line">  4 threads and 1000 connections</span><br><span class="line">  ···</span><br></pre></td></tr></table></figure><p>一会的时间，服务器hang住了。甚至等wrk跑完之后，服务器已经不能处理任何请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl --max-time 5 <span class="string">'http://server-test-1:10080/'</span></span></span><br><span class="line">curl: (28) Operation timed out after 5001 milliseconds with 0 bytes received</span><br></pre></td></tr></table></figure><p>我们遇到麻烦了！让我们分析一下。</p><hr><p><em>在我们生产服务的真实场景中，服务器起来以后，goroutines的数量由于请求的增多而迅速增加，之后便失去响应。对pprof调试句柄的请求变得非常非常慢，看起来就像服务器“死掉了”。同样，我们也尝试使用<code>SIGQUIT</code>命令杀掉进程以<a href="https://golang.org/pkg/os/signal/#hdr-Default_behavior_of_signals_in_Go_programs" target="_blank" rel="noopener">释放所运行goroutines堆栈</a>，但是收不到任何效果。</em></p><h2 id="GDB和Coredump"><a href="#GDB和Coredump" class="headerlink" title="GDB和Coredump"></a>GDB和Coredump</h2><p>我们可以使用GDB（GNU Debugger）尝试进入正在运行的服务内部。</p><hr><p><em>在生产环境运行调试器可能需要额外的权限，所以与你的团队提前沟通是很明智的。</em></p><hr><p>在虚机上再开启一个SSH会话，找到服务器的进程id并使用调试器连接到该进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vagrant ssh server-test-1</span></span><br><span class="line">Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-33-generic x86_64)</span><br><span class="line">···</span><br><span class="line">vagrant@server-test-1:~$ pgrep server</span><br><span class="line">1628</span><br><span class="line">vagrant@server-test-1:~$ cd /vagrant</span><br><span class="line">vagrant@server-test-1:/vagrant$ sudo gdb --pid=1628 example/server/server</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>调试器连接到服务器进程之后，我们可以运行GDB的<code>bt</code>命令（aka backtrace）来检查当前线程的堆栈信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  runtime.futex () at /usr/<span class="built_in">local</span>/go/src/runtime/sys_linux_amd64.s:532</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x000000000042b08b <span class="keyword">in</span> runtime.futexsleep (addr=0xa9a160 &lt;runtime.m0+320&gt;, ns=-1, val=0) at /usr/<span class="built_in">local</span>/go/src/runtime/os_linux.go:46</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x000000000040c382 <span class="keyword">in</span> runtime.notesleep (n=0xa9a160 &lt;runtime.m0+320&gt;) at /usr/<span class="built_in">local</span>/go/src/runtime/lock_futex.go:151</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x0000000000433b4a <span class="keyword">in</span> runtime.stoplockedm () at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:2165</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000000000435279 <span class="keyword">in</span> runtime.schedule () at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:2565</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x00000000004353fe <span class="keyword">in</span> runtime.park_m (gp=0xc000066d80) at /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:2676</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x000000000045ae1b <span class="keyword">in</span> runtime.mcall () at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:299</span></span><br><span class="line"><span class="meta">#</span><span class="bash">7  0x000000000045ad39 <span class="keyword">in</span> runtime.rt0_go () at /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:201</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8  0x0000000000000000 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure><p>说实话我并不是GDB的专家，但是显而易见Go运行时似乎使线程进入睡眠状态了，为什么呢？</p><p>调试一个正在运行的进程是不明智的，不如将该线程的coredump保存下来，进行离线分析。我们可以使用GDB的<code>gcore</code>命令，该命令将core文件保存在当前工作目录并命名为<code>core.&lt;process_id&gt;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) gcore</span><br><span class="line">Saved corefile core.1628</span><br><span class="line">(gdb) quit</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">Inferior 1 [process 1628] will be detached.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) y</span><br><span class="line">Detaching from program: /vagrant/example/server/server, process 1628</span><br></pre></td></tr></table></figure><p>core文件保存后，服务器没必要继续运行，使用<code>kill -9</code>结束它。</p><p>我们能够注意到，即使是一个简单的服务器，core文件依然会很大（我这一份是1.2G）,对于生产的服务来说，可能会更加巨大。</p><p><em>如果需要了解更多使用GDB调试的技巧，可以继续阅读<a href="https://golang.org/doc/gdb" target="_blank" rel="noopener">使用GDB调试Go代码</a>。</em></p><h2 id="使用Delve调试器"><a href="#使用Delve调试器" class="headerlink" title="使用Delve调试器"></a>使用Delve调试器</h2><p><a href="https://github.com/derekparker/delve" target="_blank" rel="noopener">Delve</a>是一个针对Go程序的调试器。它类似于GDB，但是更关注Go的运行时、数据结构以及其他内部的机制。</p><p>如果你对Delve的内部实现机制很感兴趣，那么我十分推荐你阅读Alessandro Arzilli在GopherCon EU 2018所作的演讲，[<a href="https://www.youtube.com/watch?v=IKnTr7Zms1k" target="_blank" rel="noopener">Internal Architecture of Delve, a Debugger For Go</a>]。</p><p>Delve是用Go写的，所以安装起来非常简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/derekparker/delve/cmd/dlv</span></span><br></pre></td></tr></table></figure><p>Delve安装以后，我们就可以通过运行<code>dlv core &lt;path to service binary&gt; &lt;core file&gt;</code>来分析core文件。我们先列出执行coredump时正在运行的所有goroutines。Delve的<code>goroutines</code>命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dlv core example/server/server core.1628</span></span><br><span class="line"></span><br><span class="line">(dlv) goroutines</span><br><span class="line">  ···</span><br><span class="line">  Goroutine 4611 - User: /vagrant/example/server/metrics.go:113 main.(*Metrics).CountS (0x703948)</span><br><span class="line">  Goroutine 4612 - User: /vagrant/example/server/metrics.go:113 main.(*Metrics).CountS (0x703948)</span><br><span class="line">  Goroutine 4613 - User: /vagrant/example/server/metrics.go:113 main.(*Metrics).CountS (0x703948)</span><br></pre></td></tr></table></figure><p>不幸的是，在真实生产环境下，这个列表可能会很长，甚至会超出terminal的缓冲区。由于服务器为每一个请求都生成一个对应的goroutine，所以<code>goroutines</code>命令生成的列表可能会有百万条。我们假设现在已经遇到这个问题，并想一个方法来解决它。</p><p>Delve支持”headless”模式，并且能够通过<a href="https://github.com/derekparker/delve/tree/master/Documentation/api" target="_blank" rel="noopener">JSON-RPC API</a>与调试器交互。</p><p>运行<code>dlv core</code>命令，指定想要启动的Delve API server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dlv core example/server/server core.1628 --listen :44441 --headless --<span class="built_in">log</span></span></span><br><span class="line">API server listening at: [::]:44441</span><br><span class="line">INFO[0000] opening core file core.1628 (executable example/server/server)  layer=debugger</span><br></pre></td></tr></table></figure><p>调试服务器运行后，我们可以发送命令到其TCP端口并将返回结果以原生JSON的格式存储。我们以上面相同的方式得到正在运行的goroutines，不同的是我们将结果存储到文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -n <span class="string">'&#123;"method":"RPCServer.ListGoroutines","params":[],"id":2&#125;'</span> | nc -w 1 localhost 44441 &gt; server-test-1_dlv-rpc-list_goroutines.json</span></span><br></pre></td></tr></table></figure><p>现在我们拥有了一个（比较大的）JSON文件，里面存储大量原始信息。推荐使用<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq</a>命令进一步了解JSON数据的原貌，举例：这里我获取JSON数据的result字段的前三个对象：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jq <span class="string">'.result[0:3]'</span> server-test-1_dlv-rpc-list_goroutines.json</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "id": 1,</span><br><span class="line">    "currentLoc": &#123;</span><br><span class="line">      "pc": 4380603,</span><br><span class="line">      "file": "/usr/local/go/src/runtime/proc.go",</span><br><span class="line">      "line": 303,</span><br><span class="line">      "function": &#123;</span><br><span class="line">        "name": "runtime.gopark",</span><br><span class="line">        "value": 4380368,</span><br><span class="line">        "type": 0,</span><br><span class="line">        "goType": 0,</span><br><span class="line">        "optimized": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "userCurrentLoc": &#123;</span><br><span class="line">      "pc": 6438159,</span><br><span class="line">      "file": "/vagrant/example/server/main.go",</span><br><span class="line">      "line": 52,</span><br><span class="line">      "function": &#123;</span><br><span class="line">        "name": "main.run",</span><br><span class="line">        "value": 6437408,</span><br><span class="line">        "type": 0,</span><br><span class="line">        "goType": 0,</span><br><span class="line">        "optimized": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "goStatementLoc": &#123;</span><br><span class="line">      "pc": 4547433,</span><br><span class="line">      "file": "/usr/local/go/src/runtime/asm_amd64.s",</span><br><span class="line">      "line": 201,</span><br><span class="line">      "function": &#123;</span><br><span class="line">        "name": "runtime.rt0_go",</span><br><span class="line">        "value": 4547136,</span><br><span class="line">        "type": 0,</span><br><span class="line">        "goType": 0,</span><br><span class="line">        "optimized": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "startLoc": &#123;</span><br><span class="line">      "pc": 4379072,</span><br><span class="line">      "file": "/usr/local/go/src/runtime/proc.go",</span><br><span class="line">      "line": 110,</span><br><span class="line">      "function": &#123;</span><br><span class="line">        "name": "runtime.main",</span><br><span class="line">        "value": 4379072,</span><br><span class="line">        "type": 0,</span><br><span class="line">        "goType": 0,</span><br><span class="line">        "optimized": true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "threadID": 0,</span><br><span class="line">    "unreadable": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  ···</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>JSON数据中的每个对象都代表了一个goroutine。通过<a href="https://github.com/derekparker/delve/blob/master/Documentation/cli/README.md#goroutines" target="_blank" rel="noopener">命令手册</a></p><p>可知，<code>goroutines</code>命令可以获得每一个goroutines的信息。通过手册我们能够分析出<code>userCurrentLoc</code>字段是服务器源码中goroutines最后出现的地方。</p><p>为了能够了解当core file创建的时候，goroutines正在做什么，我们需要收集JSON文件中包含<code>userCurrentLoc</code>字段的函数名字以及其行号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jq -c <span class="string">'.result[] | [.userCurrentLoc.function.name, .userCurrentLoc.line]'</span> server-test-1_dlv-rpc-list_goroutines.json | sort | uniq -c</span></span><br><span class="line"></span><br><span class="line">   1 ["internal/poll.runtime_pollWait",173]</span><br><span class="line">1000 ["main.(*Metrics).CountS",95]</span><br><span class="line">   1 ["main.(*Metrics).SetM",105]</span><br><span class="line">   1 ["main.(*Metrics).startOutChannelConsumer",179]</span><br><span class="line">   1 ["main.run",52]</span><br><span class="line">   1 ["os/signal.signal_recv",139]</span><br><span class="line">   6 ["runtime.gopark",303]</span><br></pre></td></tr></table></figure><p>大量的goroutines(上面是1000个)在函数<code>main.(*Metrics).CoutS</code>的95行被阻塞。现在我们回头看一下我们服务器的<a href="https://github.com/narqo/postmortem-debug-go" target="_blank" rel="noopener">源码</a>。</p><p>在<code>main</code>包中找到<code>Metrics</code>结构体并且找到它的<code>CountS</code>方法（example/server/metrics.go）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountS increments counter per second.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Metrics)</span> <span class="title">CountS</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    m.inChannel &lt;- NewCountMetric(key, <span class="number">1</span>, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的服务器在往<code>inChannel</code>通道发送的时候阻塞住了。让我们找出谁负责从这个通道读取数据，深入研究代码之后我们找到了<a href="https://github.com/narqo/postmortem-debug-go/blob/2c42ca73ebd500fe8da1c6ac8ecaf4af143aca78/example/server/metrics.go#L109" target="_blank" rel="noopener">下面的函数</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// starts a consumer for inChannel</span><br><span class="line">func (m *Metrics) startInChannelConsumer() &#123;</span><br><span class="line">    for inMetrics := range m.inChannel &#123;</span><br><span class="line">       // ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数逐个地从通道中读取数据并加以处理，那么什么情况下发送到这个通道的任务会被阻塞呢？</p><p>当处理通道的时候，根据Dave Cheney的<a href="https://dave.cheney.net/2014/03/19/channel-axioms" target="_blank" rel="noopener">通道准则</a>，只有四种情况可能导致通道有问题：</p><ul><li>向一个nil通道发送</li><li>从一个nil通道接收</li><li>向一个已关闭的通道发送</li><li>从一个已关闭的通道接收并立即返回零值</li></ul><p>第一眼就看到了“向一个nil通道发送”，这看起来像是问题的原因。但是反复检查代码后，<code>inChannel</code>是由<code>Metrics</code>初始化的，不可能为nil。</p><p>n你可能会注意到，使用<code>jq</code>命令获取到的信息中，没有<code>startInChannelConsumer</code>方法。会不会是因为在<code>main.(*Metrics).startInChannelConsumer</code>的某个地方阻塞而导致这个（可缓冲）通道满了？</p><p>Delve能够提供从开始位置到<code>userCurrentLoc</code>字段之间的初始位置信息，这个信息存储到<code>startLoc</code>字段中。使用下面的jq命令可以查询出所有goroutines,其初始位置都在函数<code>startInChannelConsumer</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jq <span class="string">'.result[] | select(.startLoc.function.name | test("startInChannelConsumer$"))'</span> server-test-1_dlv-rpc-list_goroutines.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "id": 20,</span><br><span class="line">  "currentLoc": &#123;</span><br><span class="line">    "pc": 4380603,</span><br><span class="line">    "file": "/usr/local/go/src/runtime/proc.go",</span><br><span class="line">    "line": 303,</span><br><span class="line">    "function": &#123;</span><br><span class="line">      "name": "runtime.gopark",</span><br><span class="line">      "value": 4380368,</span><br><span class="line">      "type": 0,</span><br><span class="line">      "goType": 0,</span><br><span class="line">      "optimized": true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "userCurrentLoc": &#123;</span><br><span class="line">    "pc": 6440847,</span><br><span class="line">    "file": "/vagrant/example/server/metrics.go",</span><br><span class="line">    "line": 105,</span><br><span class="line">    "function": &#123;</span><br><span class="line">      "name": "main.(*Metrics).SetM",</span><br><span class="line">      "value": 6440672,</span><br><span class="line">      "type": 0,</span><br><span class="line">      "goType": 0,</span><br><span class="line">      "optimized": true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "startLoc": &#123;</span><br><span class="line">    "pc": 6440880,</span><br><span class="line">    "file": "/vagrant/example/server/metrics.go",</span><br><span class="line">    "line": 109,</span><br><span class="line">    "function": &#123;</span><br><span class="line">      "name": "main.(*Metrics).startInChannelConsumer",</span><br><span class="line">      "value": 6440880,</span><br><span class="line">      "type": 0,</span><br><span class="line">      "goType": 0,</span><br><span class="line">      "optimized": true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中有一条信息非常振奋人心！</p><p>在<code>main.(*Metrics).startInChannelConsumer</code>，109行（看结果中的startLoc字段），有一个id为20的goroutines阻塞住了！</p><p>拿到goroutines的id能够大大降低我们搜索的范围（并且我们再也不用深入庞大的JSON文件了）。使用Delve的<code>goroutines</code>命令我们能够将当前goroutines切换到目标goroutines，然后可以使用<code>stack</code>命令打印该goroutines的堆栈信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dlv core example/server/server core.1628</span></span><br><span class="line"></span><br><span class="line">(dlv) goroutine 20</span><br><span class="line">Switched from 0 to 20 (thread 1628)</span><br><span class="line"></span><br><span class="line">(dlv) stack -full</span><br><span class="line">0  0x000000000042d7bb in runtime.gopark</span><br><span class="line">   at /usr/local/go/src/runtime/proc.go:303</span><br><span class="line">       lock = unsafe.Pointer(0xc000104058)</span><br><span class="line">       reason = waitReasonChanSend</span><br><span class="line">···</span><br><span class="line">3  0x00000000004066a5 in runtime.chansend1</span><br><span class="line">   at /usr/local/go/src/runtime/chan.go:125</span><br><span class="line">       c = (unreadable empty OP stack)</span><br><span class="line">       elem = (unreadable empty OP stack)</span><br><span class="line"></span><br><span class="line">4  0x000000000062478f in main.(*Metrics).SetM</span><br><span class="line">   at /vagrant/example/server/metrics.go:105</span><br><span class="line">       key = (unreadable empty OP stack)</span><br><span class="line">       m = (unreadable empty OP stack)</span><br><span class="line">       value = (unreadable empty OP stack)</span><br><span class="line"></span><br><span class="line">5  0x0000000000624e64 in main.(*Metrics).sendMetricsToOutChannel</span><br><span class="line">   at /vagrant/example/server/metrics.go:146</span><br><span class="line">       m = (*main.Metrics)(0xc000056040)</span><br><span class="line">       scope = 0</span><br><span class="line">       updateInterval = (unreadable could not find loclist entry at 0x89f76 for address 0x624e63)</span><br><span class="line"></span><br><span class="line">6  0x0000000000624a2f in main.(*Metrics).startInChannelConsumer</span><br><span class="line">   at /vagrant/example/server/metrics.go:127</span><br><span class="line">       m = (*main.Metrics)(0xc000056040)</span><br><span class="line">       inMetrics = main.Metric &#123;Type: TypeCount, Scope: 0, Key: "server.req-incoming",...+2 more&#125;</span><br><span class="line">       nextUpdate = (unreadable could not find loclist entry at 0x89e86 for address 0x624a2e)</span><br></pre></td></tr></table></figure><p>从下往上分析：</p><p>（6）一个来自通道的新<code>inMetrics</code>值在<code>main.(*Metrics).startInChannelConsumer</code>中被接收</p><p>（5）我们调用<code>main.(*Metrics).sendMetricsToOutChannel</code>并且在<code>example/server/metrics.go</code>的146行进行处理</p><p>（4）然后<code>main.(*Metrics).SetM</code>被调用</p><p>一直运行到<code>runtime.gopark</code>中的<code>waitReasonChanSend</code>阻塞！</p><p>一切的一切都明朗了！</p><p>单个goroutines中，一个从缓冲通道读取数据的函数，同时也在往通道中发送数据。当进入通道的值达到通道的容量时，消费函数继续往已满的通道中发送数据就会造成自身的死锁。由于单个通道的消费者死锁，那么每一个尝试往通道中发送数据的请求都会被阻塞。</p><hr><p>这就是我们的故事，使用上述调试技术帮助我们发现了问题的根源。那些代码是很多年前写的，甚至从没有人看过这些代码，也万万没有想到会导致这么大的问题。</p><p>如你所见，并不是所有问题都能由工具解决，但是工具能够帮助你更好地工作。我希望，通过此文能够激励你多多尝试这些工具。我非常乐意倾听你们处理类似问题的其它解决方案。</p><p><strong>Vladimir<em>是一个后端开发工程师，目前就职于</em>adjust.com. @tvii on Twitter, @narqo on Github</strong></p><hr><p>via: <a href="https://blog.gopheracademy.com/advent-2018/postmortem-debugging-delve/" target="_blank" rel="noopener">https://blog.gopheracademy.com/advent-2018/postmortem-debugging-delve/</a></p><p>作者：<a href="https://blog.gopheracademy.com/advent-2018/postmortem-debugging-delve/" target="_blank" rel="noopener">Vladimir Varankin</a><br>译者：<a href="https://github.com/hantmac" target="_blank" rel="noopener">hantmac</a></p><hr>]]></content>
    
    <summary type="html">
    
      Postmortem-debugging-Go-services-with-Delve[翻译]
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>自动化脚本实现go安装与升级</title>
    <link href="https://cloudsjhan.github.io/2019/01/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0go%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%87%E7%BA%A7/"/>
    <id>https://cloudsjhan.github.io/2019/01/12/自动化脚本实现go安装与升级/</id>
    <published>2019-01-12T15:55:47.000Z</published>
    <updated>2019-01-20T15:46:40.063Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="源码安装："><a href="#源码安装：" class="headerlink" title="源码安装："></a>源码安装：</h3><ul><li>下载对应的操作系统的最新的 Golang 版本：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></li></ul><p>在 home 目录下建立  installGo目录，然后在该目录下新建升级与部署文件以及下载最新的 golang 源码包： </p><p>以下是 installOrUpdate.sh 具体内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -z "$1" ]; then</span><br><span class="line">​        echo "usage: ./install.sh go-package.tar.gz"</span><br><span class="line">​        exit</span><br><span class="line">fiif [ -d "/usr/local/go" ]; then</span><br><span class="line">​        echo "Uninstalling old go version..."</span><br><span class="line">​        sudo rm -rf /usr/local/go</span><br><span class="line">fi</span><br><span class="line">echo "Installing..."</span><br><span class="line">sudo tar -C /usr/local -xzf $1</span><br><span class="line">echo export GOPATH=/go" &gt;&gt; /etc/profile</span><br><span class="line">echo export GOROOT=/usr/local/go &gt;&gt; /etc/profile</span><br><span class="line">echo export PATH=$PATH:$GOROOT/bin:$GOPATH/bin1 &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line">rm -rf $1</span><br><span class="line">echo "Done"</span><br></pre></td></tr></table></figure><p>然后运行：</p><p>sudo sh install.sh go1.10.linux-amd64.tar.gz</p><ul><li><p>或者手动设置好GOPATH，GOROOT </p><p>编辑 /etc/profile 在文件尾部加入：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/go</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin1</span><br><span class="line"></span><br><span class="line">运行 source /etc/profile 让环境变量生效</span><br></pre></td></tr></table></figure><h2 id="至此，Go-已安装成功"><a href="#至此，Go-已安装成功" class="headerlink" title="至此，Go 已安装成功"></a>至此，Go 已安装成功</h2><ul><li><p>升级</p><p>如果需要升级的话只需要将最新的源码包下载到第一步的 installGo 文件夹下，然后运行sudo sh install.sh go1.xx.linux-amd64.tar.gz 即可。</p></li><li>shell脚本更新地址<a href="https://github.com/hantmac/Install_or_Update_Go_Automatically" target="_blank" rel="noopener">github</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      自动化脚本实现go安装与升级
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>beego注解路由中@Param的参数解释</title>
    <link href="https://cloudsjhan.github.io/2019/01/03/beego%E6%B3%A8%E8%A7%A3%E8%B7%AF%E7%94%B1%E4%B8%AD-Param%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/"/>
    <id>https://cloudsjhan.github.io/2019/01/03/beego注解路由中-Param的参数解释/</id>
    <published>2019-01-03T08:56:19.000Z</published>
    <updated>2019-01-03T09:00:27.642Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>beego注解路由的注释，我们可以把我们的注释分为以下类别：</p><ul><li><p>@Title</p><p>接口的标题，用来标示唯一性，唯一，可选</p><p>格式：之后跟一个描述字符串</p></li><li><p>@Description</p><p>接口的作用，用来描述接口的用途，唯一，可选</p><p>格式：之后跟一个描述字符串</p></li><li><p><a href="http://my.oschina.net/param" target="_blank" rel="noopener">@Param</a></p><p>请求的参数，用来描述接受的参数，多个，可选</p><p>格式：变量名 传输类型 类型 是否必须 描述</p><p>传输类型：paht or body</p><p>类型：</p><p>变量名和描述是一个字符串</p><p>是否必须：true 或者false</p></li><li><ul><li>string</li><li>int</li><li>int64</li><li>对象，这个地方大家写的时候需要注意，需要是相对于当前项目的路径.对象，例如<code>models.Object</code>表示<code>models</code>目录下的Object对象，这样bee在生成文档的时候会去扫描改对象并显示给用户改对象。</li><li>query 表示带在url串里面?aa=bb&amp;cc=dd</li><li>form 表示使用表单递交数据</li><li>path 表示URL串中得字符，例如/user/{uid} 那么uid就是一个path类型的参数</li><li>body 表示使用raw body进行数据的传输</li><li>header 表示通过header进行数据的传输</li></ul></li><li></li><li><p><a href="http://my.oschina.net/u/660711" target="_blank" rel="noopener">@Success</a></p><p>成功返回的code和对象或者信息</p><p>格式：code 对象类型 信息或者对象路径</p><p>code：表示HTTP的标准status code，200 201等</p><p>对象类型：{object}表示对象，其他默认都认为是字符类型，会显示第三个参数给用户，如果是{object}类型，那么就会去扫描改对象，并显示给用户</p><p>对象路径和上面Param中得对象类型一样，使用路径.对象的方式来描述</p></li><li><p><a href="http://my.oschina.net/Failure" target="_blank" rel="noopener">@Failure</a></p><p>错误返回的信息，</p><p>格式： code 信息</p><p>code:同上Success</p><p>错误信息：字符串描述信息</p></li><li><p><a href="http://my.oschina.net/Router" target="_blank" rel="noopener">@router</a></p><p>上面已经描述过支持两个参数，第一个是路由，第二个表示支持的HTTP方法</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      beego注解路由中@Param的参数解释
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="beego" scheme="https://cloudsjhan.github.io/tags/beego/"/>
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang use reflect to judge type of variable</title>
    <link href="https://cloudsjhan.github.io/2018/12/25/golang-use-reflect-to-judge-type-of-variable/"/>
    <id>https://cloudsjhan.github.io/2018/12/25/golang-use-reflect-to-judge-type-of-variable/</id>
    <published>2018-12-25T11:38:43.000Z</published>
    <updated>2018-12-25T11:48:50.260Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>众所周知，golang中可以使用空接口即interface{}代表任何类型的数据，那么在使用的时候，我们有时需要获取返回值的具体类型</li><li>场景：beego框架中的orm.Params类型，实际上是map[string]interface{},在使用<a href="https://beego.me/docs/mvc/model/query.md" target="_blank" rel="noopener">values接口</a>的时候，需要从返回Map中获取数据，需要这样获取：<code>Id:m[&quot;Id&quot;].(string)</code>,这时m[“Id”]实际上是String类型，我们可以用reflect模块来获取实际的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(m[<span class="string">"Id"</span>])</span><br><span class="line"><span class="comment">//返回为String</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x int32 = 20</span><br><span class="line">    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      golang use reflect to judge type of variable
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql add primary key auto_increment</title>
    <link href="https://cloudsjhan.github.io/2018/12/25/mysql-add-primary-key-auto-increment/"/>
    <id>https://cloudsjhan.github.io/2018/12/25/mysql-add-primary-key-auto-increment/</id>
    <published>2018-12-25T11:08:53.000Z</published>
    <updated>2018-12-25T11:52:17.418Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>添加字段id,并将其设置为主键自增</p><ul><li>alter table TABLE_NAME add id int not null primary key Auto_increment</li></ul><p>如果想添加已经有了一列为主键，可以用：</p><ul><li><p>alter table TABLE_NAME add primary key(COL_NAME);</p></li><li><p>如果想修改一列为主键，则需要先删除原来的主键：</p></li></ul><p>alter table TABLE_NAME drop primary key;</p><p>再重新添加主键：</p><ul><li>alter table TABLE_NAME add primary key(COL_NAME);</li></ul><hr>]]></content>
    
    <summary type="html">
    
      MySQL add primary key auto_increment for established table
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Go关于time包的解析与使用</title>
    <link href="https://cloudsjhan.github.io/2018/12/16/Go%E5%85%B3%E4%BA%8Etime%E5%8C%85%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/16/Go关于time包的解析与使用/</id>
    <published>2018-12-16T15:16:34.000Z</published>
    <updated>2019-01-09T11:24:47.279Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="Go关于时间与日期的处理"><a href="#Go关于时间与日期的处理" class="headerlink" title="Go关于时间与日期的处理"></a>Go关于时间与日期的处理</h3><h4 id="关于time的数据类型"><a href="#关于time的数据类型" class="headerlink" title="关于time的数据类型"></a>关于time的数据类型</h4><ul><li><p>time包依赖的数据类型有：<strong>time.Time</strong>,<strong>time.Month</strong>,<strong>time.WeekDay</strong>,<strong>time.Duration</strong>,<strong>time.Location</strong>.</p></li><li><p>详细介绍以上几种数据类型</p><ul><li><p>time.Time</p></li><li><p><code>/usr/local/go/src/time/time.go</code> 定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    sec <span class="keyword">int64</span> <span class="comment">// 从1年1月1日 00:00:00 UTC 至今过去的秒数</span></span><br><span class="line">    nsec <span class="keyword">int32</span> <span class="comment">// 最近一秒到下一秒过去的纳秒数</span></span><br><span class="line">    loc *Location <span class="comment">// 时区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time.Time会返回纳秒时间精度的时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ti time.Time</span><br><span class="line">ti = time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"时间: %v, 时区:  %v,  时间类型: %T\n"</span>, t, t.Location(), t)</span><br><span class="line"><span class="comment">//时间: 2018-12-15 09:06:05.816187261 +0800 CST, 时区:  Local,  时间类型: time.Time</span></span><br></pre></td></tr></table></figure></li><li><p>time.Month, go中自己重新定义了month的类型，与time.year和time.day不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Month int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    January Month = 1 + iota</span><br><span class="line">    February</span><br><span class="line">    March</span><br><span class="line">    April</span><br><span class="line">    May</span><br><span class="line">    June</span><br><span class="line">    July</span><br><span class="line">    August</span><br><span class="line">    September</span><br><span class="line">    October</span><br><span class="line">    November</span><br><span class="line">    December</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota是golang语言的常量计数器,只能在常量的表达式中使用。<br> iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p></li><li><p>time.WeekDay,代表一周之中的星期几（当然是按照西方的规则，他们把周日当做是一周的开始）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WeekDay <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>time.Duration,代表两个时间点之间的纳秒差值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>time.Location,时区信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    zone []zone</span><br><span class="line">    tx   []zoneTrans</span><br><span class="line">    cacheStart <span class="keyword">int64</span></span><br><span class="line">    cacheEnd   <span class="keyword">int64</span></span><br><span class="line">    cacheZone  *zone</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//北京时间：Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="以上类型receiver的实现方法"><a href="#以上类型receiver的实现方法" class="headerlink" title="以上类型receiver的实现方法"></a>以上类型receiver的实现方法</h4><ul><li>time.Time相关方法</li></ul><p><code>func Now() Time {}</code> // 当前本地时间</p><p> <code>func Unix(sec int64, nsec int64) Time {}</code>  // 根据时间戳返回本地时间</p><p> <code>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {}</code> // 返回指定时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ 当前本地时间</span><br><span class="line">t = time.Now()</span><br><span class="line">fmt.Println(<span class="string">"'time.Now': "</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据时间戳返回本地时间</span></span><br><span class="line">t_by_unix := time.Unix(<span class="number">1487780010</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"'time.Unix': "</span>, t_by_unix)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定时间</span></span><br><span class="line">t_by_date := time.Date(<span class="number">2017</span>, time.Month(<span class="number">2</span>), <span class="number">23</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, l)</span><br><span class="line">fmt.Println(<span class="string">"'time.Date': "</span>, t_by_date)</span><br></pre></td></tr></table></figure><ul><li><p>按照时区信息显示时间</p></li><li><p><code>func (t Time) UTC() Time {}</code> // 获取指定时间在UTC 时区的时间表示</p></li><li><code>func (t Time) Local() Time {}</code> // 以本地时区表示</li><li><code>func (t Time) In(loc *Location) Time {}</code> // 时间在指定时区的表示</li><li><code>func (t Time) Format(layout string) string {}</code> // 按指定格式显示时间</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定时间在UTC 时区的时间表示</span></span><br><span class="line">t_by_utc := t.UTC()</span><br><span class="line">fmt.Println(<span class="string">"'t.UTC': "</span>, t_by_utc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地时间表示</span></span><br><span class="line">t_by_local := t.Local()</span><br><span class="line">fmt.Println(<span class="string">"'t.Local': "</span>, t_by_local)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间在指定时区的表示</span></span><br><span class="line">t_in := t.In(time.UTC)</span><br><span class="line">fmt.Println(<span class="string">"'t.In': "</span>, t_in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Format</span></span><br><span class="line">fmt.Println(<span class="string">"t.Format"</span>, t.Format(time.RFC3339))</span><br></pre></td></tr></table></figure><ul><li>获取年月日等信息</li></ul><p><code>func (t Time) Date() (year int, month Month, day int) {}</code> // 返回时间的日期信息</p><p> <code>func (t Time) Year() int {}</code> // 返回年</p><p> <code>func (t Time) Month() Month {}</code> // 月</p><p> <code>func (t Time) Day() int {}</code> // 日</p><p> <code>func (t Time) Weekday() Weekday {}</code> // 星期</p><p> <code>func (t Time) ISOWeek() (year, week int) {}</code> // 返回年，星期范围编号</p><p> <code>func (t Time) Clock() (hour, min, sec int) {}</code> // 返回时间的时分秒</p><p> <code>func (t Time) Hour() int {}</code> // 返回小时</p><p> <code>func (t Time) Minute() int {}</code> // 分钟</p><p> <code>func (t Time) Second() int {}</code> // 秒</p><p> <code>func (t Time) Nanosecond() int {}</code> // 纳秒</p><p> <code>func (t Time) YearDay() int {}</code> // 一年中对应的天</p><p> <code>func (t Time) Location() *Location {}</code> // 时间的时区</p><p> <code>func (t Time) Zone() (name string, offset int) {}</code> // 时间所在时区的规范名和想对UTC 时间偏移量</p><p> <code>func (t Time) Unix() int64 {}</code> // 时间转为时间戳</p><p> <code>func (t Time) UnixNano() int64 {}</code> // 时间转为时间戳（纳秒）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回时间的日期信息</span></span><br><span class="line">year, month, day := t.Date()</span><br><span class="line">fmt.Println(<span class="string">"'t.Date': "</span>, year, month, day)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 星期</span></span><br><span class="line">week := t.Weekday()</span><br><span class="line">fmt.Println(<span class="string">"'t.Weekday': "</span>, week)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回年，星期范围编号</span></span><br><span class="line">year, week_int := t.ISOWeek()</span><br><span class="line">fmt.Println(<span class="string">"'t.ISOWeek': "</span>, year, week_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时间的时分秒</span></span><br><span class="line">hour, min, sec := t.Clock()</span><br><span class="line">fmt.Println(<span class="string">"'t.Clock': "</span>, hour, min, sec)</span><br></pre></td></tr></table></figure><ul><li>时间运算</li></ul><p><code>func (t Time) IsZero() bool {}</code> // 是否是零时时间</p><p> <code>func (t Time) After(u Time) bool {}</code> // 时间在u 之前</p><p> <code>func (t Time) Before(u Time) bool {}</code> // 时间在u 之后</p><p> <code>func (t Time) Equal(u Time) bool {}</code> // 时间与u 相同</p><p> <code>func (t Time) Add(d Duration) Time {}</code> // 返回t +d 的时间点</p><p> <code>func (t Time) Sub(u Time) Duration {}</code> // 返回 t-u</p><p> <code>func (t Time) AddDate(years int, months int, days int) Time {}</code> 返回增加了给出的年份、月份和天数的时间点Time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 返回增加了给出的年份、月份和天数的时间点Time</span><br><span class="line">t_new := t.AddDate(0, 1, 1)</span><br><span class="line">fmt.Println(&quot;&apos;t.AddDate&apos;: &quot;, t_new)</span><br><span class="line"></span><br><span class="line">// 时间在u 之前</span><br><span class="line">is_after := t.After(t_new)</span><br><span class="line">fmt.Println(&quot;&apos;t.After&apos;: &quot;, is_after)</span><br></pre></td></tr></table></figure><ul><li>time.Duration的类型receiver实现的方法</li></ul><p><code>func (d Duration) String() string</code> // 格式化输出 Duration</p><p> <code>func (d Duration) Nanoseconds() int64</code> // 将时间段表示为纳秒</p><p> <code>func (d Duration) Seconds() float64</code> // 将时间段表示为秒</p><p> <code>func (d Duration) Minutes() float64</code> // 将时间段表示为分钟</p><p> <code>func (d Duration) Hours() float64</code> // 将时间段表示为小时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.Duration 时间段</span></span><br><span class="line">fmt.Println(<span class="string">"time.Duration 时间段"</span>)</span><br><span class="line">d = time.Duration(<span class="number">10000000000000</span>)<span class="comment">//输入参数为int64类型</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"'String: %v', 'Nanoseconds: %v', 'Seconds: %v', 'Minutes: %v', 'Hours: %v'\n"</span>, </span><br><span class="line">d.String(), d.Nanoseconds(), d.Seconds(), d.Minutes(), d.Hours())</span><br><span class="line"><span class="comment">// 'String: 2h46m40s', 'Nanoseconds: 10000000000000', 'Seconds: 10000', 'Minutes: 166.66666666666666', 'Hours: 2.7777777777777777'</span></span><br></pre></td></tr></table></figure><ul><li>time.Location的receiver实现的方法</li></ul><p><code>func (l *Location) String() string</code> // 输出时区名</p><p> <code>func FixedZone(name string, offset int) *Location</code> // FixedZone 使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location</p><p> <code>func LoadLocation(name string) (*Location, error)</code> // LoadLocation 使用给定的名字创建Location</p><p><code>func Sleep(d Duration)</code> // Sleep阻塞当前go程至少d代表的时间段。d&lt;=0时，Sleep会立刻返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d_second := time.Second</span><br><span class="line">time.Sleep(d_second)</span><br></pre></td></tr></table></figure><h3 id="一些常用的技巧与代码示例"><a href="#一些常用的技巧与代码示例" class="headerlink" title="一些常用的技巧与代码示例"></a>一些常用的技巧与代码示例</h3><ul><li><p>string与time.Time互转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">date        = <span class="string">"2006-01-02"</span></span><br><span class="line">datetime    = <span class="string">"2006-01-02 15:04:02"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">timeStamp := time.Now().Format(date) <span class="comment">//将当前时间，即time.Time类型转为string</span></span><br><span class="line"></span><br><span class="line">billTimeStamp, err := time.Parse(date,timeStamp)<span class="comment">//将String类型的时间转为time.Time类型</span></span><br></pre></td></tr></table></figure></li><li><p>unix time与String互转</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">endTime := time.Unix(time.Now().Unix(), <span class="number">0</span>)<span class="comment">//此时endTime是time.Time类型</span></span><br><span class="line">endStr := endTime.Format(datetime)<span class="comment">//将unix time 转为了String，再根据上面的例子，可转为time.Time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取时间戳</span></span><br><span class="line"></span><br><span class="line">timestamp := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">fmt.Println(timestamp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式化为字符串,tm为Time类型</span></span><br><span class="line"></span><br><span class="line">tm := time.Unix(timestamp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-01-02 03:04:05 PM"</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(tm.Format(<span class="string">"02/01/2006 15:04:05 PM"</span>))</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//从字符串转为时间戳，第一个参数是格式，第二个是要转换的时间字符串</span></span><br><span class="line"></span><br><span class="line">tm2, _ := time.Parse(<span class="string">"01/02/2006"</span>, <span class="string">"02/08/2018"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(tm2.Unix())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h4><p><a href="https://link.jianshu.com/?t=http://studygolang.com/static/pkgdoc/pkg/time.htm" target="_blank" rel="noopener">pkg/time中文翻译</a></p><p><a href="https://link.jianshu.com/?t=https://golang.org/pkg/time/" target="_blank" rel="noopener">pkg/time英文</a></p>]]></content>
    
    <summary type="html">
    
      golang time包的解析与使用
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>从冒泡排序优化到Go基准测试</title>
    <link href="https://cloudsjhan.github.io/2018/12/15/%E4%BB%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E5%88%B0Go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <id>https://cloudsjhan.github.io/2018/12/15/从冒泡排序优化到Go基准测试/</id>
    <published>2018-12-15T15:12:08.000Z</published>
    <updated>2018-12-15T16:03:47.813Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="Go的测试"><a href="#Go的测试" class="headerlink" title="Go的测试"></a>Go的测试</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试文件命名：文件命名使用 xx_test.go 保存在项目目录里即可，也可以新建个test目录，TestAll；</li><li>测试函数命名：单元测试函数名Test开头，接收一个指针型参数（*testing.T）；</li><li>运行测试程序：go run test -v -run=”函数名”，其中-v意思是输出详细的测试信息；</li></ul><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><ul><li>测试文件命名：测试文件命名：文件命名使用 xx_test.go 保存在项目目录里即可，也可以新建个test目录，TestAll；</li><li>测试函数命名：基准测试以Benchmark开头，接收一个指针型参数（*testing.B）；</li><li>运行测试程序：go test -v -bench=”函数名”；</li><li>还有一个参数是 -benchmem, -benchmem 表示分配内存的次数和字节数，-benchtime=”3s” 表示持续3秒</li></ul><h3 id="冒泡排序及其简单优化"><a href="#冒泡排序及其简单优化" class="headerlink" title="冒泡排序及其简单优化"></a>冒泡排序及其简单优化</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>前几天看一个公众号，说是有个人去美团面试，被要求手写冒泡排序算法，这人心想这还不简单的，分分钟写下了下面的代码，可以说是非常标准的冒泡排序了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(array []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i&lt;<span class="built_in">len</span>(array)<span class="number">-1</span>;i++&#123;</span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(array)-i<span class="number">-1</span>;j++&#123;</span><br><span class="line"><span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]&#123;</span><br><span class="line">swap(j, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是随之，面试官说让他优化一下这个算法，问他有没有可优化的地方，这人就懵逼了。其实冒泡排序可优化的地方很多，最简单的一种就是加一个标志位，检查是否已经排序完毕，排序已经完成的话就没有必要再比较下去，浪费时间。上面的代码添加几行，那人就很可能拿到offer了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(array []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i&lt;<span class="built_in">len</span>(array)<span class="number">-1</span>;i++&#123;</span><br><span class="line">exchanged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(array)-i<span class="number">-1</span>;j++&#123;</span><br><span class="line"><span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]&#123;</span><br><span class="line">swap(j, j+<span class="number">1</span>)</span><br><span class="line">exchanged = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> exchanged == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如何更直观的看出，优化过的代码确实有效呢，我们就可以使用go自带的基准测试，测试一下两段代码的性能，优化与否就一目了然。</p><h3 id="基准测试冒泡排序"><a href="#基准测试冒泡排序" class="headerlink" title="基准测试冒泡排序"></a>基准测试冒泡排序</h3><ul><li><p>首先我们创建一个存放测试文件的文件夹</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir testAll</span><br></pre></td></tr></table></figure></li><li><p>然后创建基准测试文件</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch benchmark_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><ul><li>编写基准测试代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sortArray = []int&#123;41, 24, 76, 11, 45, 64, 21, 69, 19, 36&#125;</span><br><span class="line">func BenchmarkBubbleSort(b *testing.B)  &#123;</span><br><span class="line"></span><br><span class="line">for i:=0;i&lt;b.N;i++ &#123;</span><br><span class="line">BubbleSort(sortArray)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试基本冒泡排序"><a href="#测试基本冒泡排序" class="headerlink" title="测试基本冒泡排序"></a>测试基本冒泡排序</h4><ul><li><p>我们首先测试最原始的冒泡排序</p></li><li><p>在testAll文件夹下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -bench=&quot;BubbleSort&quot;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy7v2wibo3j313o0bgta3.jpg" alt=""></p><p>基准测试结果如图所示，解释一下几个关键参数，</p><p>81.2ns/op 表示每次操作耗时81.2纳秒，1.725s表示程序运行的时间。</p><h3 id="测试优化的冒泡排序"><a href="#测试优化的冒泡排序" class="headerlink" title="测试优化的冒泡排序"></a>测试优化的冒泡排序</h3><ul><li>执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -bench=&quot;BubbleSort&quot;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy7v8m1tz8j31400bcmyk.jpg" alt=""></p></li></ul><p>  可以看到优化过的代码，执行时间为1.2s,而且每次操作的耗时为23.0纳秒，足足降低了60%多。可见一个很简单的优化就可以使代码提升这么多，在以后的工作中，对于代码的设计与优化还是要重视。</p><hr>]]></content>
    
    <summary type="html">
    
      从冒泡排序看Go的基准测试及其使用
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>postman 接口测试神器</title>
    <link href="https://cloudsjhan.github.io/2018/12/08/postman-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/08/postman-接口测试神器/</id>
    <published>2018-12-08T15:41:16.000Z</published>
    <updated>2018-12-08T15:54:58.525Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="Postman-接口测试神器"><a href="#Postman-接口测试神器" class="headerlink" title="Postman 接口测试神器"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e6%8e%a5%e5%8f%a3%e6%b5%8b%e8%af%95%e7%a5%9e%e5%99%a8" target="_blank" rel="noopener">Postman 接口测试神器</a></h1><p>Postman 是一个接口测试和 http 请求的神器，非常好用。</p><p>官方 github 地址: <a href="https://github.com/postmanlabs" target="_blank" rel="noopener">https://github.com/postmanlabs</a></p><p>Postman 的优点：</p><ul><li>支持各种的请求类型: get、post、put、patch、delete 等</li><li>支持在线存储数据，通过账号就可以进行迁移数据</li><li>很方便的支持请求 header 和请求参数的设置</li><li>支持不同的认证机制，包括 Basic Auth，Digest Auth，OAuth 1.0，OAuth 2.0 等</li><li>响应数据是自动按照语法格式高亮的，包括 HTML，JSON 和 XML</li></ul><blockquote><p> 以下内容主要参考： <a href="https://github.com/crifan/api_tool_postman" target="_blank" rel="noopener">Github: api_tool_postman</a>  </p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%ae%89%e8%a3%85" target="_blank" rel="noopener">安装</a></h2><p>Postman 可以单独作为一个应用安装，也可以作为 chrome 的一个插件安装。</p><ul><li>chrome 插件安装, <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener">Postman 插件地址</a>  </li><li><a href="http://files.cnblogs.com/files/mafly/postman-4.1.2.rar" target="_blank" rel="noopener">单独应用安装下载</a>  </li></ul><p>下面主要介绍下载安装独立版本app 软件的 Postman 的过程：</p><p>去主页<a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman 官网</a>找到：<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">Postman | Apps</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/c7j24uyvhy.png?imageView2/2/w/1620" alt="img"></p><p>去下载自己平台的版本：</p><ul><li>Mac</li><li>Windows（x86/x64）</li><li>Linux（x86/x64） 即可。</li></ul><h2 id="快速入门，总体使用方略"><a href="#快速入门，总体使用方略" class="headerlink" title="快速入门，总体使用方略"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e6%80%bb%e4%bd%93%e4%bd%bf%e7%94%a8%e6%96%b9%e7%95%a5" target="_blank" rel="noopener">快速入门，总体使用方略</a></h2><p>安装成功后，打开软件。</p><h3 id="新建接口"><a href="#新建接口" class="headerlink" title="新建接口"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%96%b0%e5%bb%ba%e6%8e%a5%e5%8f%a3" target="_blank" rel="noopener">新建接口</a></h3><p>对应的Request：<code>New -&gt; Request</code></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/a43avzlvvt.png?imageView2/2/w/1620" alt="img"></p><p>或，在右边的 Tab 页面中点击加号+：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/kr7zu3lg54.png?imageView2/2/w/1620" alt="img"></p><p>即可看到新建的 Tab 页：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/7x0f5ohfxq.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置-HTTP-请求的方法"><a href="#设置-HTTP-请求的方法" class="headerlink" title="设置 HTTP 请求的方法"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae-http-%e8%af%b7%e6%b1%82%e7%9a%84%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">设置 HTTP 请求的方法</a></h3><p>设置 HTTP 的 Method 方法和输入 api 的地址</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nvkjcxavj1.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置相关请求头信息"><a href="#设置相关请求头信息" class="headerlink" title="设置相关请求头信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae%e7%9b%b8%e5%85%b3%e8%af%b7%e6%b1%82%e5%a4%b4%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">设置相关请求头信息</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/sde0dugknd.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d4vmkb97c4.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置相关-GET-或-POST-等的参数"><a href="#设置相关-GET-或-POST-等的参数" class="headerlink" title="设置相关 GET 或 POST 等的参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae%e7%9b%b8%e5%85%b3-get-%e6%88%96-post-%e7%ad%89%e7%9a%84%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">设置相关 GET 或 POST 等的参数</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/qgi9b1hmbs.png?imageView2/2/w/1620" alt="img"></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82" target="_blank" rel="noopener">发送请求</a></h3><p>都填写好之后，点击 Send 去发送请求 Request：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/u4cd93numl.png?imageView2/2/w/1620" alt="img"></p><h3 id="查看响应-Response的信息"><a href="#查看响应-Response的信息" class="headerlink" title="查看响应 Response的信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%9f%a5%e7%9c%8b%e5%93%8d%e5%ba%94-response%e7%9a%84%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">查看响应 Response的信息</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/oo22jbrg8v.png?imageView2/2/w/1620" alt="img"></p><p>然后可以重复上述修改 Request 的参数，点击 Send 去发送请求的过程，以便调试到 API 接口正常工作为止。</p><h3 id="保存接口配置"><a href="#保存接口配置" class="headerlink" title="保存接口配置"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bf%9d%e5%ad%98%e6%8e%a5%e5%8f%a3%e9%85%8d%e7%bd%ae" target="_blank" rel="noopener">保存接口配置</a></h3><p>待整个接口都调试完毕后，记得点击 Save 去保存接口信息：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n2p3eq0ie6.png?imageView2/2/w/1620" alt="img"></p><p>去保存当前 API 接口，然后需要填写相关的接口信息：</p><ul><li>Request Name: 请求的名字 <ul><li>我一般习惯用保存为 接口的最后的字段名，比如<code>http://{{server_address}}/ucows/login/login</code>中的<code>/login/login</code></li></ul></li><li>Request Description: 接口的描述 <ul><li><code>可选</code> 最好写上该接口的要实现的基本功能和相关注意事项</li><li>支持 Markdown 语法</li></ul></li><li>Select a collection or folder to save: 选择要保存到哪个分组（或文件夹） <ul><li>往往保存到某个 API 接口到所属的该项目名的分组</li></ul></li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/zntknyfx6w.png?imageView2/2/w/1620" alt="img"></p><p>填写好内容，选择好分组，再点击保存：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/sb5yb8cwpi.png?imageView2/2/w/1620" alt="img"></p><p>此时，Tab 的右上角的黄色点（表示没有保存）消失了，表示已保存。</p><p>且对应的分组中可以看到对应的接口了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/x3lmlaykbk.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [warning] 默认不保存返回的 Response 数据  </p></blockquote><ul><li>直接点击 Save 去保存，只能保存 API 本身（的 Request 请求），不会保存 Response 的数据</li><li>想要保存 Response 数据，需要用后面要介绍的 <a href="http://book.crifan.com/books/api_tool_postman/website/postman_func_resp/save_multi_example.html" target="_blank" rel="noopener">多个 Example</a></li></ul><h2 id="Request-的多参数操作详解"><a href="#Request-的多参数操作详解" class="headerlink" title="Request 的多参数操作详解"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=request-%e7%9a%84%e5%a4%9a%e5%8f%82%e6%95%b0%e6%93%8d%e4%bd%9c%e8%af%a6%e8%a7%a3" target="_blank" rel="noopener">Request 的多参数操作详解</a></h2><h3 id="自动解析多个参数-Params"><a href="#自动解析多个参数-Params" class="headerlink" title="自动解析多个参数 Params"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%87%aa%e5%8a%a8%e8%a7%a3%e6%9e%90%e5%a4%9a%e4%b8%aa%e5%8f%82%e6%95%b0-params" target="_blank" rel="noopener">自动解析多个参数 Params</a></h3><p>比如，对于一个 GET 的请求的 url 是： <code>http://openapi.youdao.com/api?q=纠删码(EC)的学习&amp;from=zh_CHS&amp;to=EN&amp;appKey=152e0e77723a0026&amp;salt=4&amp;sign=6BE15F1868019AD71C442E6399DB1FE4</code></p><p>对应着其实是<code>?key=value</code>形式中包含多个 Http 的 GET 的 query string=query parameters</p><p>Postman 可以自动帮我们解析出对应参数，可以点击 Params：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9kga5uhyuq.png?imageView2/2/w/1620" alt="img"></p><p>看到展开的多个参数：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/2agjjtnusz.png?imageView2/2/w/1620" alt="img"></p><p>如此就可以很方便的修改，增删对应的参数了。</p><h3 id="临时禁用参数"><a href="#临时禁用参数" class="headerlink" title="临时禁用参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%b8%b4%e6%97%b6%e7%a6%81%e7%94%a8%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">临时禁用参数</a></h3><p>且还支持，在不删除某参数的情况下，如果想要暂时不传参数，可以方便的通过不勾选的方式去实现：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/atacmafooc.png?imageView2/2/w/1620" alt="img"></p><h3 id="批量编辑-GET-的多个参数"><a href="#批量编辑-GET-的多个参数" class="headerlink" title="批量编辑 GET 的多个参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%89%b9%e9%87%8f%e7%bc%96%e8%be%91-get-%e7%9a%84%e5%a4%9a%e4%b8%aa%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">批量编辑 GET 的多个参数</a></h3><p>当然，如果想要批量的编辑参数，可以点击右上角的Bulk Edit，去实现批量编辑。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/xn3piv6qv8.png?imageView2/2/w/1620" alt="img"></p><h2 id="接口描述与自动生成文档"><a href="#接口描述与自动生成文档" class="headerlink" title="接口描述与自动生成文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%8e%a5%e5%8f%a3%e6%8f%8f%e8%bf%b0%e4%b8%8e%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">接口描述与自动生成文档</a></h2><p>API 的描述中，也支持 Markdown，官方的接口说明文档：<a href="https://www.getpostman.com/docs/postman/api_documentation/intro_to_api_documentation" target="_blank" rel="noopener">Intro to API documentation</a>。</p><p>所以，可以很方便的添加有条理的接口描述，尤其是参数解释了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/428i64obvu.png?imageView2/2/w/1620" alt="img"></p><h3 id="描述支持-markdown-语法"><a href="#描述支持-markdown-语法" class="headerlink" title="描述支持 markdown 语法"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%8f%8f%e8%bf%b0%e6%94%af%e6%8c%81-markdown-%e8%af%ad%e6%b3%95" target="_blank" rel="noopener">描述支持 markdown 语法</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/gae7gd5ldb.png?imageView2/2/w/1620" alt="img"></p><p>而对于要解释的参数，可以通过之前的<code>Param -&gt; Bulk Edit</code>的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/k8h8cccbmy.png?imageView2/2/w/1620" alt="img"></p><p>拷贝过来，再继续去编辑：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/q3ehctbg4b.png?imageView2/2/w/1620" alt="img"></p><p>以及添加更多解释信息：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/cvxks97jg5.png?imageView2/2/w/1620" alt="img"></p><p>点击 Update 后，即可保存。</p><h3 id="发布接口并生成-markdown-的描述文件"><a href="#发布接口并生成-markdown-的描述文件" class="headerlink" title="发布接口并生成 markdown 的描述文件"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e5%b8%83%e6%8e%a5%e5%8f%a3%e5%b9%b6%e7%94%9f%e6%88%90-markdown-%e7%9a%84%e6%8f%8f%e8%bf%b0%e6%96%87%e4%bb%b6" target="_blank" rel="noopener">发布接口并生成 markdown 的描述文件</a></h3><p>去发布后：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6td22h0mcp.png?imageView2/2/w/1620" alt="img"></p><p>对应的效果：<a href="https://documenter.getpostman.com/view/669382/collection/77fd4ek" target="_blank" rel="noopener">有道翻译</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/w9r9f2lhvj.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6w93zr891f.png?imageView2/2/w/1620" alt="img"></p><h2 id="Response-深入"><a href="#Response-深入" class="headerlink" title="Response 深入"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e6%b7%b1%e5%85%a5" target="_blank" rel="noopener">Response 深入</a></h2><h3 id="Response-数据显示模式"><a href="#Response-数据显示模式" class="headerlink" title="Response 数据显示模式"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e6%95%b0%e6%8d%ae%e6%98%be%e7%a4%ba%e6%a8%a1%e5%bc%8f" target="_blank" rel="noopener">Response 数据显示模式</a></h3><p>Postman 对于返回的 Response 数据，支持三种显示模式。</p><ul><li><code>默认</code>格式化后的 Pretty 模式</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/90i3wajcea.png?imageView2/2/w/1620" alt="img"></p><ul><li>Raw 原始模式</li></ul><p>点击Raw，可以查看到返回的没有格式化之前的原始数据：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/2o5e02t9ac.png?imageView2/2/w/1620" alt="img"></p><ul><li>Preview 预览模式</li></ul><p>以及 Preview，是对应 Raw 原始格式的预览模式：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jbnnfhoye4.png?imageView2/2/w/1620" alt="img"></p><p>Preview 这种模式的显示效果，好像是对于返回的是 html 页面这类，才比较有效果。</p><h3 id="Response-的-Cookies"><a href="#Response-的-Cookies" class="headerlink" title="Response 的 Cookies"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e7%9a%84-cookies" target="_blank" rel="noopener">Response 的 Cookies</a></h3><p>很多时候普通的 API 调用，倒是没有 Cookie 的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/1srkh454hi.png?imageView2/2/w/1620" alt="img"></p><h3 id="Response-的-Headers-头信息"><a href="#Response-的-Headers-头信息" class="headerlink" title="Response 的 Headers 头信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e7%9a%84-headers-%e5%a4%b4%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">Response 的 Headers 头信息</a></h3><p>举例，此处返回的是有 Headers 头信息的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4hjkacbfao.png?imageView2/2/w/1620" alt="img"></p><p>可以从中看到服务器是 Nginx 的。</p><h2 id="保存多个-Example"><a href="#保存多个-Example" class="headerlink" title="保存多个 Example"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bf%9d%e5%ad%98%e5%a4%9a%e4%b8%aa-example" target="_blank" rel="noopener">保存多个 Example</a></h2><p>之前想要实现，让导出的 API 文档中能看到接口返回的 Response 数据。后来发现是Example这个功能去实现此效果的。</p><h3 id="如何添加-Example"><a href="#如何添加-Example" class="headerlink" title="如何添加 Example"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a6%82%e4%bd%95%e6%b7%bb%e5%8a%a0-example" target="_blank" rel="noopener">如何添加 Example</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4wjzn3wjr5.png?imageView2/2/w/1620" alt="img"></p><p>继续点击Save Example：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/pyzrhod8jg.png?imageView2/2/w/1620" alt="img"></p><p>保存后，就能看到Example(1)了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/dhmfi3mz78.png?imageView2/2/w/1620" alt="img"></p><h3 id="单个-Example-在导出的-API-文档中的效果"><a href="#单个-Example-在导出的-API-文档中的效果" class="headerlink" title="单个 Example 在导出的 API 文档中的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8d%95%e4%b8%aa-example-%e5%9c%a8%e5%af%bc%e5%87%ba%e7%9a%84-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">单个 Example 在导出的 API 文档中的效果</a></h3><p>然后再去导出文档，导出文档中的确能看到返回数据的例子： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/651td0ljtp.png?imageView2/2/w/1620" alt="img"></p><h3 id="多个-Example-在导出的-API-文档中的效果"><a href="#多个-Example-在导出的-API-文档中的效果" class="headerlink" title="多个 Example 在导出的 API 文档中的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a%e4%b8%aa-example-%e5%9c%a8%e5%af%bc%e5%87%ba%e7%9a%84-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">多个 Example 在导出的 API 文档中的效果</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6bte63z6hq.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6ckvn8fm3x.png?imageView2/2/w/1620" alt="img"></p><h2 id="其他好用的功能及工具"><a href="#其他好用的功能及工具" class="headerlink" title="其他好用的功能及工具"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%85%b6%e4%bb%96%e5%a5%bd%e7%94%a8%e7%9a%84%e5%8a%9f%e8%83%bd%e5%8f%8a%e5%b7%a5%e5%85%b7" target="_blank" rel="noopener">其他好用的功能及工具</a></h2><h3 id="分组-Collection"><a href="#分组-Collection" class="headerlink" title="分组 Collection"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%88%86%e7%bb%84-collection" target="_blank" rel="noopener">分组 Collection</a></h3><p>在刚开始一个项目时，为了后续便于组织和管理，把同属该项目的多个 API，放在一组里</p><p>所以要先去新建一个 Collection: <code>New -&gt; Collection</code></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/lokimruefe.png?imageView2/2/w/1620" alt="img"></p><p>使用了段时间后，建了多个分组的效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ggk7qt7s4f.png?imageView2/2/w/1620" alt="img"></p><p>单个分组展开后的效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/w64q4ziv08.png?imageView2/2/w/1620" alt="img"></p><h3 id="历史记录-History"><a href="#历史记录-History" class="headerlink" title="历史记录 History"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95-history" target="_blank" rel="noopener">历史记录 History</a></h3><p>Postman 支持 history 历史记录，显示出最近使用过的 API： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ui0g94c42i.png?imageView2/2/w/1620" alt="img"></p><h3 id="用环境变量实现多服务器版本"><a href="#用环境变量实现多服务器版本" class="headerlink" title="用环境变量实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">用环境变量实现多服务器版本</a></h3><h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%8e%b0%e5%ad%98%e9%97%ae%e9%a2%98" target="_blank" rel="noopener">现存问题</a></h4><p>在测试 API 期间，往往存在多种环境，对应 IP 地址（或域名也不同）</p><p>比如：</p><ul><li><p>Prod: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://116.62.25.57/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发完成发布到生产环境</li></ul></li><li><p>Dev: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://123.206.191.125/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发期间的线上的 Development 的测试环境</li></ul></li><li><p>LocalTest: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.0.140:80/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发期间配合后台开发人员的本地局域网内的本地环境，用于联合调试 API 接口</li></ul></li></ul><p>而在测试 API 期间，往往需要手动去修改 API 的地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/l7grallxhf.png?imageView2/2/w/1620" alt="img"></p><p>效率比较低，且地址更换后之前地址就没法保留了。</p><p>另外，且根据不同 IP 地址（或者域名）也不容易识别是哪套环境。</p><h3 id="Postman-支持用-Environment-环境变量去实现多服务器版本"><a href="#Postman-支持用-Environment-环境变量去实现多服务器版本" class="headerlink" title="Postman 支持用 Environment 环境变量去实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e6%94%af%e6%8c%81%e7%94%a8-environment-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%8e%bb%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">Postman 支持用 Environment 环境变量去实现多服务器版本</a></h3><p>后来发现 Postman 中，有 Environment 和 Global Variable，用于解决这个问题，实现不同环境的管理：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/rzkb6ahdi2.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> 很明显，就可以用来实现不用手动修改 url 中的服务器地址，从而动态的实现，支持不同服务器环境:  </p></blockquote><ul><li>Production 生产环境</li><li>Development 开发环境</li><li>Local 本地局域网环境</li></ul><h4 id="如何使用-Enviroment-实现多服务器版本"><a href="#如何使用-Enviroment-实现多服务器版本" class="headerlink" title="如何使用 Enviroment 实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-enviroment-%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">如何使用 Enviroment 实现多服务器版本</a></h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/pvj87t9bl9.png?imageView2/2/w/1620" alt="img"></p><p>或者：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4cqehxbdq1.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/t6gzc4ktvw.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> Environments are a group of variables &amp; values, that allow you to quickly switch the context for your requests and collections.  Learn more about environments  You can declare a variable in an environment and give it a starting value, then use it in a request by putting the variable name within curly-braces. Create an environment to get started.  </p></blockquote><p>输入 Key 和 value：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/tdph8jo5u3.png?imageView2/2/w/1620" alt="img"></p><p>点击 Add 后：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nvb1s1ht5r.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [info] 环境变量可以使用的地方  </p></blockquote><ul><li>URL</li><li>URL params</li><li>Header values</li><li>form-data/url-encoded values</li><li>Raw body content</li><li>Helper fields</li><li>写 test 测试脚本中</li><li>通过 postman 的接口，获取或设置环境变量的值。</li></ul><p>此处把之前的在 url 中的 IP 地址（或域名）换成环境变量：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/zfvm8xnp5u.png?imageView2/2/w/1620" alt="img"></p><p>鼠标移动到环境变量上，可以动态显示出具体的值：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/msdxb4rrwj.png?imageView2/2/w/1620" alt="img"></p><p>再去添加另外一个开发环境：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/rs4j9obq5m.png?imageView2/2/w/1620" alt="img"></p><p>则可添加完 2 个环境变量，表示两个服务器地址，两个版本：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/73l36ef55w.png?imageView2/2/w/1620" alt="img"></p><p>然后就可以切换不同服务器环境了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9n52eok8vu.png?imageView2/2/w/1620" alt="img"></p><p>可以看到，同样的变量 server_address，在切换后对应 IP 地址就变成希望的开发环境的 IP 了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/h487ru075j.png?imageView2/2/w/1620" alt="img"></p><h4 id="Postman-导出-API-文档中多个环境变量的效果"><a href="#Postman-导出-API-文档中多个环境变量的效果" class="headerlink" title="Postman 导出 API 文档中多个环境变量的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e5%af%bc%e5%87%ba-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e5%a4%9a%e4%b8%aa%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">Postman 导出 API 文档中多个环境变量的效果</a></h4><p>顺带也去看看，导出为 API 文档后，带了这种 Environment 的变量的接口，文档长什么样子：</p><p>发现是在发布之前，需要选择对应的环境的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/dg394n77xg.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6fqqywrz4h.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jzcgi6c3lg.png?imageView2/2/w/1620" alt="img"></p><p>发布后的文档，可以看到所选环境和对应服务器的 IP 的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/k3tppka6qg.png?imageView2/2/w/1620" alt="img"></p><p>当然发布文档后，也可以实时切换环境：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/fqnjm0392m.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6cz9xt9z7y.png?imageView2/2/w/1620" alt="img"></p><h4 id="环境变量的好处"><a href="#环境变量的好处" class="headerlink" title="环境变量的好处"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%a5%bd%e5%a4%84" target="_blank" rel="noopener">环境变量的好处</a></h4><p>当更换服务器时，直接修改变量的 IP 地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/y6virrs94v.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/udsfrqtqxg.png?imageView2/2/w/1620" alt="img"></p><p>即可实时更新，当鼠标移动到变量上即可看到效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6i5l61q5gz.png?imageView2/2/w/1620" alt="img"></p><h3 id="代码生成工具"><a href="#代码生成工具" class="headerlink" title="代码生成工具"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90%e5%b7%a5%e5%85%b7" target="_blank" rel="noopener">代码生成工具</a></h3><h4 id="查看当前请求的-HTTP-原始内容"><a href="#查看当前请求的-HTTP-原始内容" class="headerlink" title="查看当前请求的 HTTP 原始内容"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e8%af%b7%e6%b1%82%e7%9a%84-http-%e5%8e%9f%e5%a7%8b%e5%86%85%e5%ae%b9" target="_blank" rel="noopener">查看当前请求的 HTTP 原始内容</a></h4><p>对于当前的请求，还可以通过点击 Code</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/fjqiinpdmd.png?imageView2/2/w/1620" alt="img"></p><p>去查看对应的符合 HTTP 协议的原始的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ems6iaymhz.png?imageView2/2/w/1620" alt="img"></p><h4 id="各种语言的示例代码Code-Generation-Tools"><a href="#各种语言的示例代码Code-Generation-Tools" class="headerlink" title="各种语言的示例代码Code Generation Tools"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%90%84%e7%a7%8d%e8%af%ad%e8%a8%80%e7%9a%84%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81code-generation-tools" target="_blank" rel="noopener">各种语言的示例代码Code Generation Tools</a></h4><p>比如：</p><ul><li>Swift 语言</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n2mpfxcdv3.png?imageView2/2/w/1620" alt="img"></p><ul><li>Java 语言</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/r9dvvipgd1.png?imageView2/2/w/1620" alt="img"></p><ul><li>其他各种语言 还支持其他各种语言：</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n935sl95gc.png?imageView2/2/w/1620" alt="img"></p><p>目前支持的语言有：</p><ul><li>HTTP</li><li>C (LibCurl)</li><li>cURL</li><li>C#(RestSharp)</li><li>Go</li><li>Java <ul><li>OK HTTP</li><li>Unirest</li></ul></li><li>Javascript</li><li>NodeJS</li><li>Objective-C(NSURL)</li><li>OCaml(Cohttp)</li><li>PHP</li><li>Python</li><li>Ruby(NET::Http)</li><li>Shell</li><li>Swift(NSURL)</li></ul><p>代码生成工具的好处是：在写调用此 API 的代码时，就可以参考对应代码，甚至拷贝粘贴对应代码，即可。</p><h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%b5%8b%e8%af%95%e6%8e%a5%e5%8f%a3" target="_blank" rel="noopener">测试接口</a></h3><p>选中某个分组后，点击 Runner</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/p5ijm3jotv.png?imageView2/2/w/1620" alt="img"></p><p>选中某个分组后点击 Run</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d40ouxqffx.png?imageView2/2/w/1620" alt="img"></p><p>即可看到测试结果： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ynyz14nrsu.png?imageView2/2/w/1620" alt="img"></p><p>关于此功能的介绍可参考<a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman 官网</a>的<a href="https://www.getpostman.com/img/v2/postman/gifs/collection-runner.gif" target="_blank" rel="noopener">git 图</a></p><h3 id="MockServer"><a href="#MockServer" class="headerlink" title="MockServer"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=mockserver" target="_blank" rel="noopener">MockServer</a></h3><p>直接参考官网。</p><h2 id="功能界面"><a href="#功能界面" class="headerlink" title="功能界面"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8a%9f%e8%83%bd%e7%95%8c%e9%9d%a2" target="_blank" rel="noopener">功能界面</a></h2><h3 id="多-Tab-分页"><a href="#多-Tab-分页" class="headerlink" title="多 Tab 分页"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a-tab-%e5%88%86%e9%a1%b5" target="_blank" rel="noopener">多 Tab 分页</a></h3><p>Postman 支持多 tab 页，于此对比之前有些 API 调试工具就不支持多 Tab 页，比如<code>Advanced Rest Client</code></p><p>多 tab 的好处：</p><p>方便在一个 tab 中测试，得到结果后，复制粘贴到另外的 tab 中，继续测试其它接口</p><p>比如此处 tab1 中，测试了获取验证码接口后，拷贝手机号和验证码，粘贴到 tab2 中，继续测试注册的接口</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9h475eyqnd.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/f26rmodg14.png?imageView2/2/w/1620" alt="img"></p><h3 id="界面查看模式"><a href="#界面查看模式" class="headerlink" title="界面查看模式"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%95%8c%e9%9d%a2%e6%9f%a5%e7%9c%8b%e6%a8%a1%e5%bc%8f" target="_blank" rel="noopener">界面查看模式</a></h3><p>Postman 的默认的 Request 和 Response 是上下布局：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ilcrw9qu2a.png?imageView2/2/w/1620" alt="img"></p><p>此处点击右下角的<code>Two pane view</code>，就变成左右的了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ij8lqwx97b.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [info] 左右布局的用途  对于数据量很大，又想要同时看到请求和返回的数据的时候，应该比较有用。  </p></blockquote><h3 id="多颜色主题"><a href="#多颜色主题" class="headerlink" title="多颜色主题"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a%e9%a2%9c%e8%89%b2%e4%b8%bb%e9%a2%98" target="_blank" rel="noopener">多颜色主题</a></h3><p>Posman 支持两种主题：</p><ul><li>深色主题</li></ul><p>当前是深色主题，效果很不错：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jz9xmkcowa.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/u82a7psrgy.png?imageView2/2/w/1620" alt="img"></p><ul><li>浅色主题</li></ul><p>可以切换到 浅色主题：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/qu330s3pfl.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d17b0zdb4c.png?imageView2/2/w/1620" alt="img"></p><h2 id="API-文档生成"><a href="#API-文档生成" class="headerlink" title="API 文档生成"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=api-%e6%96%87%e6%a1%a3%e7%94%9f%e6%88%90" target="_blank" rel="noopener">API 文档生成</a></h2><p>在服务端后台的开发人员测试好了接口后，打算把接口的各种信息发给使用此 API 的前端的移动端人员时，往往会遇到：</p><p>要么是用复制粘贴 -&gt; 格式不友好 要么是用 Postman 中截图 -&gt; 方便看，但是不方便获得 API 接口和字段等文字内容 要么是用 Postman 中导出为 JSON -&gt; json 文件中信息太繁杂，不利于找到所需要的信息 要么是用文档，比如去编写 Markdown 文档 -&gt; 但后续 API 的变更需要实时同步修改文档，也会很麻烦 这都会导致别人查看和使用 API 时很不方便。</p><p>-&gt; 对此，Postman 提供了发布 API</p><p>预览和发布 API 文档 下面介绍 Postman 中如何预览和发布 API 文档。</p><h3 id="简要概述步骤"><a href="#简要概述步骤" class="headerlink" title="简要概述步骤"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%ae%80%e8%a6%81%e6%a6%82%e8%bf%b0%e6%ad%a5%e9%aa%a4" target="_blank" rel="noopener">简要概述步骤</a></h3><ol><li>Collection</li><li>鼠标移动到某个 Collection，点击 三个点</li><li>Publish Docs</li><li>Publish</li><li>得到 Public URL</li><li>别人打开这个 Public URL，即可查看 API 文档</li></ol><h3 id="预览-API-文档"><a href="#预览-API-文档" class="headerlink" title="预览 API 文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e9%a2%84%e8%a7%88-api-%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">预览 API 文档</a></h3><p>点击分组右边的大于号&gt;</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/s7pgyjn13y.png?imageView2/2/w/1620" alt="img"></p><p>如果只是预览，比如后台开发员自己查看 API 文档的话，可以选择：View in web</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/95ekutmlpe.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> 等价于点击Publish Docs去发布：  </p></blockquote><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ca0mw3r3x7.png?imageView2/2/w/1620" alt="img"></p><p>View in Web 后，有 Publish 的选项（见后面的截图）</p><p>View in Web 后，会打开预览页面：</p><p>比如：</p><p>奶牛云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/collection/view/669382-42273840-6237-dbae-5455-26b16f45e2b9</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/8yfixnbs9s.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6qtob43od0.png?imageView2/2/w/1620" alt="img"></p><p>而右边的示例代码，也可以从默认的 cURL 换成其他的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/gy60gkar15.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/hmptft1z7u.png?imageView2/2/w/1620" alt="img"></p><h3 id="发布-API-文档"><a href="#发布-API-文档" class="headerlink" title="发布 API 文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e5%b8%83-api-%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">发布 API 文档</a></h3><p>如果想要让其他人能看到这个文档，则点击 Publish：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nfsjy8thb8.png?imageView2/2/w/1620" alt="img"></p><p>然后会打开类似于这样的地址：</p><p>Postman Documenter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/collection/publish?meta=Y29sbGVjdGlvbl9pZD00MjI3Mzg0MC02MjM3LWRiYWUtNTQ1NS0yNmIxNmY0NWUyYjkmb3duZXI9NjY5MzgyJmNvbGxlY3Rpb25fbmFtZT0lRTUlQTUlQjYlRTclODklOUIlRTQlQkElOTE=</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/84pbk6ppzq.png?imageView2/2/w/1620" alt="img"></p><p>点击 Publish 后，可以生成对应的公开的网页地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/z3ce5w7dfv.png?imageView2/2/w/1620" alt="img"></p><p>打开 API 接口文档地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/view/669382/collection/77fd4RM</span><br></pre></td></tr></table></figure><p>即可看到（和前面预览一样效果的 API 文档了）：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/84j5ppdtoh.png?imageView2/2/w/1620" alt="img"></p><p>如此，别人即可查看对应的 API 接口文档。</p><h3 id="已发布的-API-文档支持自动更新"><a href="#已发布的-API-文档支持自动更新" class="headerlink" title="已发布的 API 文档支持自动更新"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%b7%b2%e5%8f%91%e5%b8%83%e7%9a%84-api-%e6%96%87%e6%a1%a3%e6%94%af%e6%8c%81%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" target="_blank" rel="noopener">已发布的 API 文档支持自动更新</a></h3><p>后续如果自己的 API 接口修改后：</p><p>比如：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/svcgj7qdll.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/kezpmqdfe8.png?imageView2/2/w/1620" alt="img"></p><p>（后来发现，不用再去进入此预览和发布的流程，去更新文档，而是 Postman 自动支持）</p><p>别人去刷新该文档的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/view/669382/collection/77fd4RM</span><br></pre></td></tr></table></figure><p>即可看到更新后的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/1iumgwfs2k.png?imageView2/2/w/1620" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" target="_blank" rel="noopener">参考资料</a></h2><ul><li>主要参考：Github: api_tool_postman</li><li>Manage environments</li><li>postman-变量/环境/过滤等 - 简书</li><li>Postman 使用手册 3——环境变量 - 简书</li><li>postman 使用之四：切换环境和设置读取变量 - 乔叶叶 - 博客园</li></ul><hr>]]></content>
    
    <summary type="html">
    
      postman接口测试神器使用技巧
    
    </summary>
    
      <category term="工具" scheme="https://cloudsjhan.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="postman" scheme="https://cloudsjhan.github.io/tags/postman/"/>
    
      <category term="工具" scheme="https://cloudsjhan.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之influxDB使用入门</title>
    <link href="https://cloudsjhan.github.io/2018/12/08/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8BinfluxDB%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/08/技术周刊之influxDB使用入门/</id>
    <published>2018-12-08T15:25:10.000Z</published>
    <updated>2018-12-08T15:31:29.239Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>InfluxDB是一个用于存储和分析时间序列数据的开源数据库。</p><p>主要特性有：</p><ul><li>内置HTTP接口，使用方便</li><li>数据可以打标记，查让查询可以很灵活</li><li>类SQL的查询语句</li><li>安装管理很简单，并且读写数据很高效</li><li>能够实时查询，数据在写入时被索引后就能够被立即查出</li><li>……</li></ul><p>在最新的<a href="https://db-engines.com/en/ranking/time+series+dbms" target="_blank" rel="noopener">DB-ENGINES</a>给出的时间序列数据库的排名中，InfluxDB高居第一位，可以预见，InfluxDB会越来越得到广泛的使用。</p><ul><li><p>influxDB使用go语言编写，采用了SQL like的语法，非常灵活高效，如果你的数据是与时间相关的，那么使用influxDB做数据可视化是最合适不过的，尤其是influxDB自身就提供数据库CRUD所需要的API，虽然不是RESTFul的，但是也省去了编写后端接口的力气。</p></li><li><p>下面从influxDB的安装、使用CLI的influxdb基本操作、使用API对influxdb操作及golang代码实现、经历的坑，几个方面分享influxDB的入门经历。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>本次安装的环境是：</p><ul><li>CentOS 7</li><li>内核版本：4.4.135-1.el7.elrepo.x86_64</li></ul></li><li><p>直接使用yum安装</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/influxdb.repo # 输入influxDB的repoURL地址等信息</span><br><span class="line">[influxdb]</span><br><span class="line">  name = InfluxDB Repository - RHEL \$releasever</span><br><span class="line">  baseurl = https://repos.influxdata.com/rhel/\$releasever/\$basearch/stable</span><br><span class="line">  enabled = 1</span><br><span class="line">  gpgcheck = 1</span><br><span class="line">  gpgkey = https://repos.influxdata.com/influxdb.key</span><br><span class="line">  EOF</span><br><span class="line"><span class="meta">  #</span><span class="bash">EOF是文本的结束符</span></span><br></pre></td></tr></table></figure></li></ul></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install influxdb</span><br></pre></td></tr></table></figure></li><li><p>influxd config</p><p>安装完成后使用该命令查看influxDB的配置内容，default的config文件路径在：/etc/influxdb/influxdb.conf</p></li><li><p>启动influxDB</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-m1 ~]# influx</span><br><span class="line">Connected to http://localhost:8086 version 1.7.1</span><br><span class="line">InfluxDB shell version: 1.7.1</span><br><span class="line">Enter an InfluxQL query</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>到此完成了influxDB的安装，接下来我们做基本的配置。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>用户管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个管理员用户</span><br><span class="line">CREATE USER "admin" WITH PASSWORD 'xxxx' WITH ALL PRIVILEGES</span><br><span class="line">-- 创建一个普通用户</span><br><span class="line">CREATE USER "user" WITH PASSWORD 'xxxxx'</span><br><span class="line">-- 为用户授权读权限</span><br><span class="line">GRANT READ ON [database] to "user"</span><br><span class="line">-- 为用户授权写权限</span><br><span class="line">GRANT WRITE ON [database] to "user"</span><br><span class="line">--------------------- </span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要修改InfluxDB的配置文件/etc/influxdb/influxdb.conf，设置http下的auth-enabled = <span class="literal">true</span>，重启后，使用influx命令登录数据库就需要用户名和密码了。（Influx命令实际上也是使用API来操作InfluxDB的，InfluxDB只提供了API接口）</span></span><br></pre></td></tr></table></figure><ul><li>查看用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> show users</span></span><br><span class="line">user  admin</span><br><span class="line">----  -----</span><br><span class="line">admin true</span><br><span class="line">sjhan true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>influxDB的配置项目有很多，剩下的可以根据自己的需求继续研究，这里就不展开了。</p><p>在进行数据库基本操作之前我们必须了解一下infuxDB的一些基本概念</p><h4 id="influxDB基本概念"><a href="#influxDB基本概念" class="headerlink" title="influxDB基本概念"></a>influxDB基本概念</h4><ul><li>influxDB里面最基本的概念就是，measurement，tags，fields，points。我们可以类比于MySQL来理解这几个字段：</li><li>measurement类似于SQL中的table；</li><li>tags类似SQL中的被索引的列；</li><li>fields类似于SQL中没有被索引的列；</li><li>points对应SQL的table中的每行数据。</li><li>知道了这几个概念，便可以继续往下进行，如需更加详细的文档，英文版文档<a href="https://docs.influxdata.com/influxdb/v1.7/" target="_blank" rel="noopener">猛戳这里</a>，当然也有中文版，<a href="https://jasper-zhang1.gitbooks.io/influxdb/" target="_blank" rel="noopener">猛戳这里</a>。不知为何中文版我只有番蔷才能访问。</li></ul><h3 id="influxDB基本操作"><a href="#influxDB基本操作" class="headerlink" title="influxDB基本操作"></a>influxDB基本操作</h3><ul><li>首先，跟MySQL一样，我们需要创建一个数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库，默认设置</span><br><span class="line">CREATE DATABASE &quot;first_db&quot;</span><br><span class="line">-- 创建数据库，同时创建一个Retention Policy，数据保留时间描述</span><br><span class="line">-- Retention Policy各部分描述：DURATION为数据存储时长，下面的1d即只存1天的数据；REPLICATION为数据副本，一般在使用集群的时候才会设置为&gt;1；SHARD DURATION为分区间隔，InfluxDB默认对数据分区，填写30m即对数据每隔30分钟做一个新的分区；Name是RP的名字。</span><br><span class="line">CREATE DATABASE &quot;first_db&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 30m NAME &quot;myrp&quot;</span><br></pre></td></tr></table></figure><p>我们创建了一个influxDB的数据库，名字为first_db, 数据存储时间为一天，一个副本，每30分钟做一个新的分区。</p><ul><li><p>influxDB插入数据</p><p>influx -username admin -password</p><p>我们插入一条数据到刚刚创建的数据库中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> product,productName=disk,usageType=pay,creator=zhangsan,appId=<span class="number">105</span> <span class="keyword">cost</span>=<span class="number">3421.6</span></span><br></pre></td></tr></table></figure><p>我们分析一下这条插入语句，其中product字段是influxDB中的measurement,前面讲基本概念的时候已经解释过，类似于MySQL中的table，“productName=disk,usageType=pay,creator=zhangsan,appId=105”，这一坨在influxDB中叫做tag set,可以理解为tag的一个集合，tag的类型只能是字符串的K-V，还有需要注意的是tag set与前面的measurement之间只有一个逗号，<strong>并没有空格！</strong>，一开始不知道这回事，怎么插入都是失败。“cost=3421.6”这个叫做filed set，filed的类型可以是float、boolean、integer。这样插入的一条数据，influxDB中叫做一个point。</p></li></ul><ul><li><p>查询操作</p><p>查询之前要选择你想查询的数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use first_db</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxzdysawf8j31hq0cqwgt.jpg" alt=""></p></li><li><p>可以看到influxDB自动为我们的这个point加了一个timestamp，这个是数据的UNIX时间格式的时间精度，我们在启动数据库时可以定义这个precision，像下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influx --precision rfc3339</span><br></pre></td></tr></table></figure><p>influxDB规定了很多时间精度，具体可以在命令行输出help查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">precision &lt;format&gt;    specifies the format of the timestamp: rfc3339, h, m, s, ms, u or ns</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可指定的时间精度</span></span><br></pre></td></tr></table></figure><ul><li><p>使用influxDB内置CLI执行查询操作</p><p>还是查询我们刚刚插入的那条数据,在命令行中输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode "db=first_db" --data-urlencode "q=SELECT \"cost\" FROM \"product\" WHERE \"productName\"='disk'"</span><br></pre></td></tr></table></figure><p>得到输出为json结构的查询结果<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzegqffyhj31x50u0jvr.jpg" alt=""></p><p>influxDB内置的API很大程度简化了后端的开发，使各种项目可以快速上线。</p></li><li><p>插入操作的API</p></li></ul><p>在命令行中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST 'http://localhost:8086/write?db=first_db' --data-binary 'weather,location=us-midwes temperature=125'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入一条数据，measurement=weather，tag=location，filed=temperature,时间戳为当地服务器时间</span></span><br></pre></td></tr></table></figure><ul><li>我们使用postman测试这个插入接口，以确定该接口的header，body等，为接下来使用go编写请求代码做好准备。通过分析URL，我们可知请求的param是db=first_db，–dat-binary这个参数，意味着你的request body必须是raw,而且header的content-Type=”text”,具体的postman设置参照下图：<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzq4jt9xkj31qa0qcgoc.jpg" alt=""></li><li>点击Send之后，可以在下面看到response的statusCode是204，在http协议中，这个状态码意思是返回体中没有内容。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxzqcl2pvtj31q605yq3l.jpg" alt=""></li><li>我们回到influxDB的terminal中查看一下，可以看到这条数据已经插入成功了。</li></ul><h3 id="GO操作influxDB的API实现插入数据"><a href="#GO操作influxDB的API实现插入数据" class="headerlink" title="GO操作influxDB的API实现插入数据"></a>GO操作influxDB的API实现插入数据</h3><ul><li><p>可以利用这样方便的API，编写代码，实现数据的批量采集、管理、展示，这里我用GO对插入数据的操作简单实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reqBody := <span class="string">"weather,location=us-midwes temperature=521 1475839730100400200"</span></span><br><span class="line">rb := []<span class="keyword">byte</span>(reqBody)</span><br><span class="line">    headers := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Content-type"</span>: <span class="string">"text"</span>,</span><br><span class="line">&#125;</span><br><span class="line">resp, _,err := simpleHttpClient.DoRequest(<span class="string">"POST"</span>,<span class="string">"http://10.18.5.30:8086/write?db=first_db"</span>,headers,rb,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(resp))</span><br></pre></td></tr></table></figure><ul><li><p>使用的DoRequest方法来自<a href="https://github.com/hantmac/simple-httpClient" target="_blank" rel="noopener">这里</a>，这个库对golang的http操作进行简单的封装，而且加入了错误处理，timeout异常检测等。</p></li><li><p>当然也可以使用Go自带的net/http包中的POST方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reqBody := <span class="string">"weather,location=us-midwes temperature=521 1475839730100400200"</span></span><br><span class="line"><span class="comment">//rb := []byte(reqBody)</span></span><br><span class="line">    rb := io.NewReader(reqBody)</span><br><span class="line">resp, err := http.Post(<span class="string">"http://10.18.5.30:8086/write?db=first_db"</span>,<span class="string">"text"</span>,rb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(resp))</span><br></pre></td></tr></table></figure><ul><li>需要注意的是对request body的类型处理，net/http.post方法要求该参数的类型是io.reader，所以要使用io.NewReader()进行转换。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>以上就是对influxDB的入门介绍，包括基本概念，安装，配置，基本操作（CLI，API）以及使用GO编写操作数据库的代码。但influxDB的奥秘远不止这些，<a href="https://docs.influxdata.com/influxdb/v1.7/" target="_blank" rel="noopener">如需更加深入的研究可参阅官方文档</a>。</li></ul></li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      介绍influxDB的基本概念，基本操作以及如何使用go实现influxDB的操作
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
      <category term="influxDB" scheme="https://cloudsjhan.github.io/tags/influxDB/"/>
    
  </entry>
  
  <entry>
    <title>(转载)golang语言并发与并行——goroutine和channel的详细理解(2)</title>
    <link href="https://cloudsjhan.github.io/2018/12/07/%E8%BD%AC%E8%BD%BD-golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3-2/"/>
    <id>https://cloudsjhan.github.io/2018/12/07/转载-golang语言并发与并行——goroutine和channel的详细理解-2/</id>
    <published>2018-12-07T03:48:11.000Z</published>
    <updated>2018-12-07T03:50:05.116Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://studygolang.com/articles/9533" target="_blank" rel="noopener">本文转载自</a>，版权属于原作者。</p><h1 id="Go语言的并发和并行"><a href="#Go语言的并发和并行" class="headerlink" title="Go语言的并发和并行"></a>Go语言的并发和并行</h1><p>不知道你有没有注意到一个现象，还是这段代码，如果我跑在两个goroutines里面的话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 开两个goroutine跑函数loop, loop函数负责打印10个数</span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察下输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>这是不是有什么问题？?</p><p>以前我们用线程去做类似任务的时候，系统的线程会抢占式地输出， 表现出来的是乱序地输出。而goroutine为什么是这样输出的呢？</p><h2 id="goroutine是在并行吗？"><a href="#goroutine是在并行吗？" class="headerlink" title="goroutine是在并行吗？"></a>goroutine是在并行吗？</h2><p>我们找个例子<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">var quit chan int</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">    time.Sleep(time.Second) // 停顿一秒</span><br><span class="line">    quit &lt;- 0 // 发消息：我执行完啦！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    count := 1000</span><br><span class="line">    quit = make(chan int, count) // 缓冲1000个数据</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123; //开1000个goroutine</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i :=0 ; i &lt; count; i++ &#123; // 等待所有完成消息发送完毕。</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们跑一下这个程序(之所以先编译再运行，是为了让程序跑的尽量快,测试结果更好):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build test.go</span><br><span class="line">time ./test</span><br><span class="line">./test  0.01s user 0.01s system 1% cpu 1.016 total</span><br></pre></td></tr></table></figure><p>我们看到，总计用时接近一秒。 貌似并行了！</p><p>我们需要首先考虑下什么是并发, 什么是并行</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>从概念上讲，并发和并行是不同的, 简单来说看这个图片(原图来自<a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html" target="_blank" rel="noopener">这里</a>)</p><p><img src="http://hit9.qiniudn.com/con_and_par.jpg" alt="img"></p><ul><li>两个队列，一个Coffee机器，那是并发</li><li>两个队列，两个Coffee机器，那是并行</li></ul><p>更多的资料： <a href="http://www.aqee.net/docs/Concurrency-is-not-Parallelism/" target="_blank" rel="noopener">并发不是并行</a>, 当然Google上有更多关于并行和并发的区别。</p><p>那么回到一开始的疑问上，从上面的两个例子执行后的表现来看，多个goroutine跑loop函数会挨个goroutine去进行，而sleep则是一起执行的。</p><p>这是为什么？</p><p>默认地， <a href="http://lib.csdn.net/base/go" target="_blank" rel="noopener">Go</a>所有的goroutines只能在一个线程里跑 。</p><p>也就是说， 以上两个代码都不是并行的，但是都是是并发的。</p><p>如果当前goroutine不发生阻塞，它是不会让出CPU给其他goroutine的, 所以例子一中的输出会是一个一个goroutine进行的，而sleep函数则阻塞掉了 当前goroutine, 当前goroutine主动让其他goroutine执行, 所以形成了逻辑上的并行, 也就是并发。</p><h2 id="真正的并行"><a href="#真正的并行" class="headerlink" title="真正的并行"></a>真正的并行</h2><p>为了达到真正的并行，我们需要告诉Go我们允许同时最多使用多个核。</p><p>回到起初的例子，我们设置最大开2个原生线程, 我们需要用到runtime包(runtime包是goroutine的调度器):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123; //为了观察，跑多些</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(2) // 最多使用2个核</span><br><span class="line"></span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下会看到两个goroutine会抢占式地输出数据了。</p><p>我们还可以这样显式地让出CPU时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        runtime.Gosched() // 显式地让出CPU时间给其他goroutine</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察下结果会看到这样有规律的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p>其实，这种主动让出CPU时间的方式仍然是在单核里跑。但手工地切换goroutine导致了看上去的“并行”。</p><p>其实作为一个<a href="http://lib.csdn.net/base/python" target="_blank" rel="noopener">Python</a>程序员，goroutine让我更多地想到的是gevent的协程，而不是原生线程。</p><p>关于runtime包对goroutine的调度，在stackoverflow上有一个不错的答案:<a href="http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do" target="_blank" rel="noopener">http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do</a></p><h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p>我在Segmentfault看到了这个问题: <a href="http://segmentfault.com/q/1010000000207474" target="_blank" rel="noopener">http://segmentfault.com/q/1010000000207474</a></p><p>题目说，如下的程序，按照理解应该打印下5次 <code>&quot;world&quot;</code>呀，可是为什么什么也没有打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go say(&quot;world&quot;) //开一个新的Goroutines执行</span><br><span class="line">    for &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>楼下的答案已经很棒了，这里Go仍然在使用单核，for死循环占据了单核CPU所有的资源，而main线和say两个goroutine都在一个线程里面， 所以say没有机会执行。解决方案还是两个：</p><ul><li>允许Go使用多核(<code>runtime.GOMAXPROCS</code>)</li><li>手动显式调动(<code>runtime.Gosched</code>)</li></ul><h2 id="runtime调度器"><a href="#runtime调度器" class="headerlink" title="runtime调度器"></a>runtime调度器</h2><p>runtime调度器是个很神奇的东西，但是我真是但愿它不存在，我希望显式调度能更为自然些，多核处理默认开启。</p><p>关于runtime包几个函数:</p><ul><li><code>Gosched</code> 让出cpu</li><li><code>NumCPU</code> 返回当前系统的CPU核数量</li><li><code>GOMAXPROCS</code> 设置最大的可同时使用的CPU核数</li><li><code>Goexit</code> 退出当前goroutine(但是defer语句会照常执行)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从例子中可以看到，默认的, 所有goroutine会在一个原生线程里跑，也就是只使用了一个CPU核。</p><p>在同一个原生线程里，如果当前goroutine不发生阻塞，它是不会让出CPU时间给其他同线程的goroutines的，这是Go运行时对goroutine的调度，我们也可以使用runtime包来手工调度。</p><p>本文开头的两个例子都是限制在单核CPU里执行的，所有的goroutines跑在一个线程里面，分析如下:</p><ul><li>对于代码例子一（loop函数的那个），每个goroutine没有发生堵塞(直到quit流入数据), 所以在quit之前每个goroutine不会主动让出CPU，也就发生了串行打印</li><li>对于代码例子二（time的那个），每个goroutine在sleep被调用的时候会阻塞，让出CPU, 所以例子二并发执行。</li></ul><p>那么关于我们开启多核的时候呢？Go语言对goroutine的调度行为又是怎么样的？</p><p>我们可以在Golang官方网站的<a href="http://golang.org/doc/faq#goroutines" target="_blank" rel="noopener">这里</a> 找到一句话:</p><blockquote><p>When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won’t be blocked.</p></blockquote><p>也就是说:</p><blockquote><p>当一个goroutine发生阻塞，Go会自动地把与该goroutine处于同一系统线程的其他goroutines转移到另一个系统线程上去，以使这些goroutines不阻塞</p></blockquote><h2 id="开启多核的实验"><a href="#开启多核的实验" class="headerlink" title="开启多核的实验"></a>开启多核的实验</h2><p>仍然需要做一个实验，来测试下多核支持下goroutines的对原生线程的分配, 也验证下我们所得到的结论“goroutine不阻塞不放开CPU”。</p><p>实验代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop(id int) &#123; // id: 该goroutine的标号</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123; //打印10次该goroutine的标号</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, id)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(2) // 最多同时使用2个核</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 3; i++ &#123; //开三个goroutine</span><br><span class="line">        go loop(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多跑几次会看到类似这些输出(不同机器环境不一样):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 1 1 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 1 0 1 2 1 2 1 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 2 0 2 0 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 2 2</span><br></pre></td></tr></table></figure><p>执行它我们会发现以下现象:</p><ul><li>有时会发生抢占式输出(说明Go开了不止一个原生线程，达到了真正的并行)</li><li>有时会顺序输出, 打印完0再打印1, 再打印2(说明Go开一个原生线程，单线程上的goroutine不阻塞不松开CPU)</li></ul><p>那么，我们还会观察到一个现象，无论是抢占地输出还是顺序的输出，都会有那么两个数字表现出这样的现象:</p><ul><li>一个数字的所有输出都会在另一个数字的所有输出之前</li></ul><p>原因是， 3个goroutine分配到至多2个线程上，就会至少两个goroutine分配到同一个线程里，单线程里的goroutine 不阻塞不放开CPU, 也就发生了顺序输出。</p><hr>]]></content>
    
    <summary type="html">
    
      golang语言并发与并行——goroutine和channel的详细理解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>(转载)golang语言并发与并行——goroutine和channel的详细理解(1)</title>
    <link href="https://cloudsjhan.github.io/2018/12/07/%E8%BD%AC%E8%BD%BD-golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3-1/"/>
    <id>https://cloudsjhan.github.io/2018/12/07/转载-golang语言并发与并行——goroutine和channel的详细理解-1/</id>
    <published>2018-12-07T03:38:01.000Z</published>
    <updated>2018-12-07T03:50:54.511Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本篇博文转载自<a href="https://studygolang.com/articles/9532?fr=sidebar" target="_blank" rel="noopener">go语言中文网</a>，版权属原作者所有。</p><p>如果不是我对真正并行的线程的追求，就不会认识到<a href="http://lib.csdn.net/base/go" target="_blank" rel="noopener">Go</a>有多么的迷人。</p><p>Go语言从语言层面上就支持了并发，这与其他语言大不一样，不像以前我们要用Thread库 来新建线程，还要用线程安全的队列库来共享数据。</p><p>以下是我入门的学习笔记。</p><h1 id="Go语言的goroutines、信道和死锁"><a href="#Go语言的goroutines、信道和死锁" class="headerlink" title="Go语言的goroutines、信道和死锁"></a>Go语言的goroutines、信道和死锁</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go语言中有个概念叫做goroutine, 这类似我们熟知的线程，但是更轻。</p><p>以下的程序，我们串行地去执行两次<code>loop</code>函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    loop()</span><br><span class="line">    loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，输出会是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下面我们把一个loop放在一个goroutine里跑，我们可以使用关键字<code>go</code>来定义并启动一个goroutine:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go loop() // 启动一个goroutine</span><br><span class="line">    loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出变成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>可是为什么只输出了一趟呢？明明我们主线跑了一趟，也开了一个goroutine来跑一趟啊。</p><p>原来，在goroutine还没来得及跑loop的时候，主函数已经退出了。</p><p>main函数退出地太快了，我们要想办法阻止它过早地退出，一个办法是让main等待一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go loop()</span><br><span class="line">    loop()</span><br><span class="line">    time.Sleep(time.Second) // 停顿一秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次确实输出了两趟，目的达到了。</p><p>可是采用等待的办法并不好，如果goroutine在结束的时候，告诉下主线说“Hey, 我要跑完了！”就好了， 即所谓阻塞主线的办法，回忆下我们<a href="http://lib.csdn.net/base/python" target="_blank" rel="noopener">Python</a>里面等待所有线程执行完毕的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for thread in threads:</span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure><p>是的，我们也需要一个类似<code>join</code>的东西来阻塞住主线。那就是信道</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是什么？简单说，是goroutine之间互相通讯的东西。类似我们Unix上的管道（可以在进程间传递消息）， 用来goroutine之间发消息和接收消息。其实，就是在做goroutine之间的内存共享。</p><p>使用<code>make</code>来建立一个信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var channel chan int = make(chan int)</span><br><span class="line">// 或</span><br><span class="line">channel := make(chan int)</span><br></pre></td></tr></table></figure><p>那如何向信道存消息和取消息呢？ 一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var messages chan string = make(chan string)</span><br><span class="line">    go func(message string) &#123;</span><br><span class="line">        messages &lt;- message // 存消息</span><br><span class="line">    &#125;(&quot;Ping!&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-messages) // 取消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的，信道的存消息和取消息都是阻塞的 (叫做无缓冲的信道，不过缓冲这个概念稍后了解，先说阻塞的问题)。</p><p>也就是说, 无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好。</p><p>比如以下的main函数和foo函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func foo() &#123;</span><br><span class="line">    ch &lt;- 0  // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把0这个数据拿走</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go foo()</span><br><span class="line">    &lt;- ch // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然信道可以阻塞当前的goroutine, 那么回到上一部分「goroutine」所遇到的问题「如何让goroutine告诉主线我执行完毕了」 的问题来, 使用一个信道来告诉主线即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var complete chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    complete &lt;- 0 // 执行完毕了，发个消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go loop()</span><br><span class="line">    &lt;- complete // 直到线程跑完, 取到消息. main在此阻塞住</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用信道来阻塞主线的话，主线就会过早跑完，loop线都没有机会执行、、、</p><p>其实，无缓冲的信道永远不会存储数据，只负责数据的流通，为什么这么讲呢？</p><ul><li>从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞</li><li>数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞</li></ul><p>所以，你可以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>下，无论如何，我们测试到的无缓冲信道的大小都是0 (<code>len(channel)</code>)</p><p>如果信道正有数据在流动，我们还要加入数据，或者信道干涩，我们一直向无数据流入的空信道取数据呢？ 就会引起死锁</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个死锁的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    &lt;- ch // 阻塞main goroutine, 信道c被锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个程序你会看到Go报这样的错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>何谓死锁? <a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>有讲过的，所有的线程或进程都在等待资源的释放。如上的程序中, 只有一个goroutine, 所以当你向里面加数据或者存数据的话，都会锁死信道， 并且阻塞当前 goroutine, 也就是所有的goroutine(其实就main线一个)都在等待信道的开放(没人拿走数据信道是不会开放的)，也就是死锁咯。</p><p>我发现死锁是一个很有意思的话题，这里有几个死锁的例子:</p><ol><li><p>只在单一的goroutine里操作无缓冲信道，一定死锁。比如你只在main函数里操作信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开</span><br><span class="line">    fmt.Println(&quot;This line code wont run&quot;) //在此行执行之前Go就会报死锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如下也是一个死锁的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ch1 chan int = make(chan int)</span><br><span class="line">var ch2 chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    ch1 &lt;- &lt;- ch2 // ch1 等待 ch2流出的数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go say(&quot;hello&quot;)</span><br><span class="line">    &lt;- ch1  // 堵塞主线</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中主线等ch1中的数据流出，ch1等ch2的数据流出，但是ch2等待数据流入，两个goroutine都在等，也就是死锁。</p></li><li><p>其实，总结来看，为什么会死锁？非缓冲信道上如果发生了流入无流出，或者流出无流入，也就导致了死锁。或者这样理解 Go启动的所有goroutine里的非缓冲信道一定要一个线里存数据，一个线里取数据，要成对才行 。所以下面的示例一定死锁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c, quit := make(chan int), make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">   c &lt;- 1  // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine</span><br><span class="line">   quit &lt;- 0 // quit始终没有办法写入数据</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;- quit // quit 等待数据的写</span><br></pre></td></tr></table></figure><p>仔细分析的话，是由于：主线等待quit信道的数据流出，quit等待数据写入，而func被c通道堵塞，所有goroutine都在等，所以死锁。</p><p>简单来看的话，一共两个线，func线中流入c通道的数据并没有在main线中流出，肯定死锁。</p></li></ol><p>但是，是否果真 所有不成对向信道存取数据的情况都是死锁?</p><p>如下是个反例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    c := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">       c &lt;- 1</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序正常退出了，很简单，并不是我们那个总结不起作用了，还是因为一个让人很囧的原因，main又没等待其它goroutine，自己先跑完了， 所以没有数据流入c信道，一共执行了一个goroutine, 并且没有发生阻塞，所以没有死锁错误。</p><p>那么死锁的解决办法呢？</p><p>最简单的，把没取走的数据取走，没放入的数据放入， 因为无缓冲信道不能承载数据，那么就赶紧拿走！</p><p>具体来讲，就死锁例子3中的情况，可以这么避免死锁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c, quit := make(chan int), make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">    c &lt;- 1</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;- c // 取走c的数据！</span><br><span class="line">&lt;-quit</span><br></pre></td></tr></table></figure><p>另一个解决办法是缓冲信道, 即设置c有一个数据的缓冲大小:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int, 1)</span><br></pre></td></tr></table></figure><p>这样的话，c可以缓存一个数据。也就是说，放入一个数据，c并不会挂起当前线, 再放一个才会挂起当前线直到第一个数据被其他goroutine取走, 也就是只阻塞在容量一定的时候，不达容量不阻塞。</p><p>这十分类似我们Python中的队列<code>Queue</code>不是吗？</p><h2 id="无缓冲信道的数据进出顺序"><a href="#无缓冲信道的数据进出顺序" class="headerlink" title="无缓冲信道的数据进出顺序"></a>无缓冲信道的数据进出顺序</h2><p>我们已经知道，无缓冲信道从不存储数据，流入的数据必须要流出才可以。</p><p>观察以下的程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123; //id: 这个routine的标号</span><br><span class="line">    ch &lt;- id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 开启5个routine</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取出信道中的数据</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Print(&lt;- ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们开了5个goroutine，然后又依次取数据。其实整个的执行过程细分的话，5个线的数据 依次流过信道ch, main打印之, 而宏观上我们看到的即 无缓冲信道的数据是先到先出，但是 无缓冲信道并不存储数据，只负责数据的流通</p><h2 id="缓冲信道"><a href="#缓冲信道" class="headerlink" title="缓冲信道"></a>缓冲信道</h2><p>终于到了这个话题了, 其实缓存信道用英文来讲更为达意: buffered channel.</p><p>缓冲这个词意思是，缓冲信道不仅可以流通数据，还可以缓存数据。它是有容量的，存入一个数据的话 , 可以先放在信道里，不必阻塞当前线而等待该数据取走。</p><p>当缓冲信道达到满的状态的时候，就会表现出阻塞了，因为这时再也不能承载更多的数据了，「你们必须把 数据拿走，才可以流入数据」。</p><p>在声明一个信道的时候，我们给make以第二个参数来指明它的容量(默认为0，即无缓冲):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int, 2) // 写入2个元素都不会阻塞当前goroutine, 存储个数达到2的时候会阻塞</span><br></pre></td></tr></table></figure><p>如下的例子，缓冲信道ch可以无缓冲的流入3个元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你再试图流入一个数据的话，信道ch会阻塞main线, 报死锁。</p><p>也就是说，缓冲信道会在满容量的时候加锁。</p><p>其实，缓冲信道是先进先出的，我们可以把缓冲信道看作为一个线程安全的队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch) // 1</span><br><span class="line">    fmt.Println(&lt;-ch) // 2</span><br><span class="line">    fmt.Println(&lt;-ch) // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信道数据读取和信道关闭"><a href="#信道数据读取和信道关闭" class="headerlink" title="信道数据读取和信道关闭"></a>信道数据读取和信道关闭</h2><p>你也许发现，上面的代码一个一个地去读取信道简直太费事了，Go语言允许我们使用<code>range</code>来读取信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line"></span><br><span class="line">    for v := range ch &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你执行了上面的代码，会报死锁错误的，原因是range不等到信道关闭是不会结束读取的。也就是如果 缓冲信道干涸了，那么range就会阻塞当前goroutine, 所以死锁咯。</p><p>那么，我们试着避免这种情况，比较容易想到的是读到信道为空的时候就结束读取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 3)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">ch &lt;- 2</span><br><span class="line">ch &lt;- 3</span><br><span class="line">for v := range ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    if len(ch) &lt;= 0 &#123; // 如果现有数据量为0，跳出循环</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法是可以正常输出的，但是注意检查信道大小的方法不能在信道存取都在发生的时候用于取出所有数据，这个例子 是因为我们只在ch中存了数据，现在一个一个往外取，信道大小是递减的。</p><p>另一个方式是显式地关闭信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 3)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">ch &lt;- 2</span><br><span class="line">ch &lt;- 3</span><br><span class="line"></span><br><span class="line">// 显式地关闭信道</span><br><span class="line">close(ch)</span><br><span class="line"></span><br><span class="line">for v := range ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被关闭的信道会禁止数据流入, 是只读的。我们仍然可以从关闭的信道中取出数据，但是不能再写入数据了。</p><h2 id="等待多gorountine的方案"><a href="#等待多gorountine的方案" class="headerlink" title="等待多gorountine的方案"></a>等待多gorountine的方案</h2><p>那好，我们回到最初的一个问题，使用信道堵塞主线，等待开出去的所有goroutine跑完。</p><p>这是一个模型，开出很多小goroutine, 它们各自跑各自的，最后跑完了向主线报告。</p><p>我们讨论如下2个版本的方案:</p><ol><li>只使用单个无缓冲信道阻塞主线</li><li>使用容量为goroutines数量的缓冲信道</li></ol><p>对于方案1, 示例的代码大概会是这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var quit chan int // 只开一个信道</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">    quit &lt;- 0 // ok, finished</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    count := 1000</span><br><span class="line">    quit = make(chan int) // 无缓冲</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方案2, 把信道换成缓冲1000的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit = make(chan int, count) // 容量1000</span><br></pre></td></tr></table></figure><p>其实区别仅仅在于一个是缓冲的，一个是非缓冲的。</p><p>对于这个场景而言，两者都能完成任务, 都是可以的。</p><ul><li>无缓冲的信道是一批数据一个一个的「流进流出」</li><li>缓冲信道则是一个一个存储，然后一起流出去</li></ul><hr>]]></content>
    
    <summary type="html">
    
      golang语言并发与并行——goroutine和channel的详细理解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql中字段名与保留字冲突</title>
    <link href="https://cloudsjhan.github.io/2018/12/04/mysql%E4%B8%AD%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E5%86%B2%E7%AA%81/"/>
    <id>https://cloudsjhan.github.io/2018/12/04/mysql中字段名与保留字冲突/</id>
    <published>2018-12-04T07:24:50.000Z</published>
    <updated>2018-12-04T07:51:27.453Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>在设计数据库的时候不小心将数据库的字段设置成了其内置的保留字，例如下面的这段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `test_billing` (</span><br><span class="line">`vendor` varchar(255),</span><br><span class="line">`cn` varchar(255),</span><br><span class="line">`current_date` varchar(255),</span><br><span class="line">`cost` varchar(255)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>这样你在执行类似下面的查询时：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cn, cost from test_billing where current_date like&quot;2018-10%&quot;;</span><br></pre></td></tr></table></figure><p>返回值中什么都没有，还带了一个warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>原因就是字段current_date与MySQL内置的保留字冲突了，那么这时候你还急需查看这些数据，比较快的方法就是：在冲突字段上加反引号 <code>current_date</code>,即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cn, cost from test_billing where `current_date` like&quot;2018-10%&quot;;</span><br></pre></td></tr></table></figure><p>就可以解决了。</p><hr>]]></content>
    
    <summary type="html">
    
      不小心将MySQL的字段与保留字冲突的解决方法
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>git常用操作</title>
    <link href="https://cloudsjhan.github.io/2018/12/02/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://cloudsjhan.github.io/2018/12/02/git常用操作/</id>
    <published>2018-12-02T02:38:11.000Z</published>
    <updated>2018-12-02T02:40:20.339Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>首先来一遍从fork到pull request这个过程的基础流程<br>首先，fork 一个repository，实际上是复制了一份 repository 到自己的 GitHub 账户下，然后就可以从 GitHub 将它 clone 到你的电脑上，命令如下：</p><p>git clone <urlfromgithub><br>连接到原始的Repository，因为如果原始的Repository内容有所改变时，我们希望能够pull这些变化，所以新增一个远端链接，并把它命名为’upstream’，命令如下：</urlfromgithub></p><p>git remote add upstream <urlfromupstreamgithub><br>新增branch分支，并选用新增分支。避免与主分支master造成冲突，当我们在新增分支上完成了自己的功能后再合并到主分支，命令如下：</urlfromupstreamgithub></p><p>git branch <branchname><br>git checkout <branchname><br>git checkout -b <branchname> –创建新的分支并切换到新的分支上<br>记录，在我们自己的分支上修改后，需要记录下来。</branchname></branchname></branchname></p><p>git status –查看当前状态<br>git add -A –记录修改文件，加上 -A，會將新增檔案跟刪除檔案的動作一起記錄下來<br>git commit -m “add a file” –提交全部修改<br>git checkout master –第二天开始工作前，切换到master分支<br>git pull origin master –从master的远程分支拉取代码<br>git checkout <branchname> –切换到task所在的本地分支<br>git rebase -i master –将master上的最新的代码合并到当前分支上，这里的-i的作用是将我们 当前分支之前的commit压缩成为一个commit，这样做的好处在于当我们之后创建pull request并进行相应的code review的时候，代码的改动会集中在一个commit，使得code review更直观方便<br>git push –set-upstream origin <my branch="" name=""> –最后，当task的所有编码完成之后，将代码push到远程分支<br>先获取远端，再提交，每次提交代码前，都需要先获取最新代码，防止覆盖他人代码</my></branchname></p><p>git fetch –dry-run –检查远端是否有变动<br>git pull –从远端分支更新最新代码<br>建立Pull Requests，进入你的github项目页，一般情况下 GitHub会检测到你有了新的推送，会主动提示你，点击Create pull request，写上说明，再按Send pull request就完成了，如果 Pull Request 沒有问题的话，很快就會被自动合并 merged 了哦！</p><p>本地合并分支，并删除分支，将分支合并到主分支上，并删除之</p><p>git checkout master –首先切换到主分支中<br>git merge <branchname> –合并另一个分支进来<br>git branch -d <branchname> –删掉刚刚合并的分支<br>git push <remotename> –delete <branchname> –也可以把合并分支从GitHub上的副本repository中刪除<br>其他常用命令<br>git init –将一个文件夹初始化为git仓库<br>git status –检查当前repository中的修改<br>git diff –查看对文件的修改<br>git add <filename> –准备提交对于一个文件的修改<br>git add . –准备提交对所有文件的修改<br>git commit -m “<your commit="" message="">“ –提交你所准备好的修改，并附上简短说明<br>git config –global user.username <username> –配置github账号<br>git remote add <remotename> –新增远端链接<br>git remote set-url <remotename> –对一个远端设定地址<br>git remote add <remotename> <url> –新增带地址的远端链接<br>git remote -v –查看所有远端<br>git pull <remotename> <branchname> –从一个远端收取更新（默认为主分支）<br>git push <remotename> <branchname> –提交代码到指定远端（默认为主分支）<br>git branch -M <newbranchname> –修改当前分支名字<br>git branch –列出所有分支</newbranchname></branchname></remotename></branchname></remotename></url></remotename></remotename></remotename></username></your></filename></branchname></remotename></branchname></branchname></p><hr>]]></content>
    
    <summary type="html">
    
      git常用基本操作
    
    </summary>
    
      <category term="git" scheme="https://cloudsjhan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://cloudsjhan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ionic project-Could not find module @angular-devkit/build-angular from XXX</title>
    <link href="https://cloudsjhan.github.io/2018/11/30/ionic-project-Could-not-find-module-angular-devkit-build-angular-from-XXX/"/>
    <id>https://cloudsjhan.github.io/2018/11/30/ionic-project-Could-not-find-module-angular-devkit-build-angular-from-XXX/</id>
    <published>2018-11-30T14:02:49.000Z</published>
    <updated>2018-11-30T14:45:25.088Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li><p>从GitHub上找了一个ionic的demo，准备运行一下，报错：Could not find module @angular-devkit/build-angular from XXX</p></li><li><p>操作步骤：</p><ul><li><p>git clone <a href="https://github.com/ionic-team/ionic-conference-app.git" target="_blank" rel="noopener">https://github.com/ionic-team/ionic-conference-app.git</a></p></li><li><p>ionic serve</p></li><li><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find module &quot;@angular-devkit/build-angular&quot; from</span><br></pre></td></tr></table></figure><p>解决方案：</p><ul><li>npm install –save @angular-devkit/build-angular</li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      ionic project-Could not find module @angular-devkit/build-angular from XXX
    
    </summary>
    
      <category term="frontEnd" scheme="https://cloudsjhan.github.io/categories/frontEnd/"/>
    
    
      <category term="angular" scheme="https://cloudsjhan.github.io/tags/angular/"/>
    
      <category term="ionic" scheme="https://cloudsjhan.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>快排之golang实现</title>
    <link href="https://cloudsjhan.github.io/2018/11/18/%E5%BF%AB%E6%8E%92%E4%B9%8Bgolang%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cloudsjhan.github.io/2018/11/18/快排之golang实现/</id>
    <published>2018-11-18T06:36:38.000Z</published>
    <updated>2018-11-19T02:09:59.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li></ul><p>利用分治法可将快速排序的分为三步：</p><ul><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ul><p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p><p>这里实现了两种方式的快排，第一种是单路的，实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(sortArray []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">key := sortArray[right]</span><br><span class="line">i := left - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := left; j &lt; right; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> sortArray[j] &lt;= key &#123;</span><br><span class="line">i++</span><br><span class="line">swap(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(i+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是双路的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unc partition2(arr []<span class="keyword">int</span>,left,right <span class="keyword">int</span>)(p <span class="keyword">int</span>)  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i,j,pivot := left,right ,arr[left]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i&lt;j  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; arr[j] &gt;pivot  &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; arr[i] &lt;= pivot  &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">arr[i] ,arr[j] = arr[j],arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[i],arr[left] = arr[left],arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"fmt"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sortArray = []<span class="keyword">int</span>&#123;<span class="number">41</span>, <span class="number">24</span>, <span class="number">76</span>, <span class="number">11</span>, <span class="number">45</span>, <span class="number">64</span>, <span class="number">21</span>, <span class="number">69</span>, <span class="number">19</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"before sort："</span>)</span><br><span class="line"></span><br><span class="line">quickSort(sortArray, <span class="number">0</span>, MAX<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"after sort:"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(sortArray []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">pos := partition2(sortArray, left, right)<span class="comment">//修改此处测试不同的实现方式</span></span><br><span class="line">quickSort(sortArray, left, pos<span class="number">-1</span>)</span><br><span class="line">quickSort(sortArray, pos+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BUT!</p><p>要表达快排的思想，还是使用Python比较透彻：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quickSort(less) + [pivot] + quickSort(greater)</span><br></pre></td></tr></table></figure><p>是不是将快排的分治思想表达地淋漓尽致，简洁美观。</p><p>​                                        </p><p>​                                    End！</p><hr>]]></content>
    
    <summary type="html">
    
      快速排序的go实现
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://cloudsjhan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="go 数据结构与算法" scheme="https://cloudsjhan.github.io/tags/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git如何找回被删除的分支</title>
    <link href="https://cloudsjhan.github.io/2018/11/15/git%E5%A6%82%E4%BD%95%E6%89%BE%E5%9B%9E%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E5%88%86%E6%94%AF/"/>
    <id>https://cloudsjhan.github.io/2018/11/15/git如何找回被删除的分支/</id>
    <published>2018-11-15T10:37:28.000Z</published>
    <updated>2018-11-15T10:39:44.797Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>在使用git的过程中，因为人为因素造成分支（commit)被删除，可以使用以下步骤进行恢复。</p><p>首先用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复。<br>1.创建分支 abc</p><p>git branch abc<br>1</p><p>2.查看分支列表</p><p>git branch -a<br>  abc</p><ul><li>develop<br>remotes/origin-dev/develop<br>1<br>2<br>3<br>4</li></ul><p>3.切换到abc分支，随便修改一下东西后 commit</p><p>切换分支<br>git checkout abc<br>Switched to branch ‘abc’</p><p>创建一个文件<br>echo ‘abc’ &gt; test.txt</p><p>commit<br>git add .<br>git commit -m ‘add test.txt’<br>[abc 3eac14d] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p><p>4.删除分支abc</p><p>git branch -D abc<br>Deleted branch abc (was 3eac14d).<br>1<br>2</p><p>5.查看分支列表，abc分支已不存在</p><p>git branch -a</p><ul><li>develop<br>remotes/origin-dev/develop<br>1<br>2<br>3</li></ul><p>恢复步骤如下：<br>1.使用git log -g 找回之前提交的commit<br>commit 3eac14d05bc1264cda54a7c21f04c3892f32406a<br>Reflog: HEAD@{1} (fdipzone <a href="mailto:&#102;&#100;&#105;&#x70;&#x7a;&#111;&#x6e;&#x65;&#64;&#115;&#105;&#110;&#x61;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#102;&#100;&#105;&#x70;&#x7a;&#111;&#x6e;&#x65;&#64;&#115;&#105;&#110;&#x61;&#46;&#99;&#111;&#109;</a>)<br>Reflog message: commit: add test.txt<br>Author: fdipzone <a href="mailto:&#x66;&#x64;&#105;&#x70;&#x7a;&#x6f;&#110;&#x65;&#x40;&#x73;&#x69;&#110;&#x61;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x66;&#x64;&#105;&#x70;&#x7a;&#x6f;&#110;&#x65;&#x40;&#x73;&#x69;&#110;&#x61;&#x2e;&#99;&#111;&#x6d;</a><br>Date:   Sun Jan 31 22:26:33 2016 +0800</p><pre><code>add test.txt</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p><p>2.使用git branch recover_branch[新分支] commit_id命令用这个commit创建一个分支<br>git branch recover_branch_abc 3eac14d05bc1264cda54a7c21f04c3892f32406a</p><p>git branch -a</p><ul><li>develop<br>recover_branch_abc<br>remotes/origin-dev/develop<br>1<br>2<br>3<br>4<br>5<br>6<br>可以见到recover_branch_abc已创建 </li></ul><p>3.切换到recover_branch_abc分支，检查文件是否存在<br>git checkout recover_branch_abc<br>Switched to branch ‘recover_branch_abc’</p><p>ls -lt<br>total 8<br>-rw-r–r–   1 fdipzone  staff     4  1 31 22:38 test.txt<br>1<br>2<br>3<br>4<br>5<br>6</p><h2 id="这样就可以恢复被误删的分支了"><a href="#这样就可以恢复被误删的分支了" class="headerlink" title="这样就可以恢复被误删的分支了"></a>这样就可以恢复被误删的分支了</h2><p>原文：<a href="https://blog.csdn.net/fdipzone/article/details/50616386" target="_blank" rel="noopener">https://blog.csdn.net/fdipzone/article/details/50616386</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><hr>]]></content>
    
    <summary type="html">
    
      git找回被删除的分支
    
    </summary>
    
      <category term="git" scheme="https://cloudsjhan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://cloudsjhan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>golang读取命令行传来的参数</title>
    <link href="https://cloudsjhan.github.io/2018/11/06/golang%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>https://cloudsjhan.github.io/2018/11/06/golang读取命令行传来的参数/</id>
    <published>2018-11-06T06:59:04.000Z</published>
    <updated>2018-11-06T07:13:58.650Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="Golang-使用命令行参数"><a href="#Golang-使用命令行参数" class="headerlink" title="Golang-使用命令行参数"></a>Golang-使用命令行参数</h1><p>Golang有两个标准包中都有获得命令行参数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*]os/Args可以简单地获得一个类似Ｃ语言中的argv结构</span><br><span class="line">[*]flag则提供了一个更为复杂的标志与值的方法</span><br></pre></td></tr></table></figure><p>os.Argsos.Args返回一个字符串数组[] string.</p><p>使用方法很简单：package main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令：go run test.go arg1 arg2</p><p>可见返回了一个三个元素的数组，第０个元素是程序的名字包括路径，os.Args就第一个参数，os.Args就是第二个参数。</p><hr><p>flag包flag包提供的功能非常复杂。</p><p>它将命令行参数分为非标志类参数(nonflag arguments)和Flags，标志参数是这样的-flagname=x，比如说-baudrate=1200。</p><p>非标志类参数为arg1 arg2。</p><p>flag参数处理流程由于标志类参数是参数的一部分，但又特殊，为了将标志类参数区别处理</p><p>flag包有两类方法，一类是flag处理方法，另一类是正常的参数处理方法。</p><p>正常的参数处理方法正常参数处理方法与os.Args差不多，这里是一个方法，flag.Args()，返回也是[]string.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">/*    &quot;os/exec&quot;</span><br><span class="line">    &quot;bytes&quot;*/</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">go run test.go arg1 arg2</span><br></pre></td></tr></table></figure><p>如果有标志类参数呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run test.go arg1 arg2　-baudrate=1200</span><br></pre></td></tr></table></figure><p>这里充分证明了标志类参数也是参数。</p><p>标志类参数Parse前定义如果使用标志类参数，要提前定义,定义之后再调用Parse才能解析出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>标志类参数必须在Parse之定义，否则会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br><span class="line"></span><br><span class="line">flag provided but not defined: -baudrate</span><br><span class="line"></span><br><span class="line">Usage of /tmp/go-build944578075/command-line-arguments/_obj/a.out:</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>flag.Int返回的是地址</p><p>需要注意的是这里flag.Int返回的值为一个地址，你可以随时到这个地址里去取值</p><p>但在Parse之前取值，取到的是默认值，Parse之后去随值，取到的才是真正的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>标志类参数顺序</p><p>标志类参数之间的前后顺序可以改变，但是似乎标志类参数非要放到非标志类参数之前才能正确解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>上面的命令正确解析了，调换了baudrate和databits的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run test.go arg1 -baudrate=9600 -databits=8  arg2</span><br></pre></td></tr></table></figure><p>上前这里没能正确解析，可以baudrate和databits得到的还是默认值，而非标志类参数获取到了所有的参数。</p><p>–help</p><p>flag.Int的最后一个参数是help信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go run test.go --help</span><br><span class="line"></span><br><span class="line">Usage of /tmp/go-build327358548/command-line-arguments/_obj/a.out:</span><br><span class="line">  -baudrate=1200: help message for flagname</span><br><span class="line">  -databits=10: number of data bits</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>flag.String传入的参数显然不能都是数字，实际go语言提供的类型都支持，与flag.Int类似，所有其他函数都有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.String flag.Uint flag.Float64....</span><br></pre></td></tr></table></figure><p>flag.IntVarflag.Int返回的是指针，用起来可以有点不太好，flag.IntVar可能用起来更好的些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var baudrate int</span><br><span class="line">flag.IntVar(&amp;baudrate,&quot;baudrate&quot;,1200,&quot;baudrate of serial port&quot;)</span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Println(baudrate)</span><br></pre></td></tr></table></figure><p>当前你一样可以用flag.UintVar flag.Float64Var flag.StringVar</p><p>参数个数参数个数也分为标志类参数的非标志类参数，两个方法为NArg和NFlag,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    databits:=flag.Int(<span class="string">"databits"</span>,<span class="number">10</span>,<span class="string">"number of data bits"</span>)</span><br><span class="line">    baudrate:=flag.Int(<span class="string">"baudrate"</span>,<span class="number">1200</span>, <span class="string">"help message for flagname"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">    fmt.Println(flag.NArg())</span><br><span class="line">    fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> run test.<span class="keyword">go</span> -baudrate=<span class="number">9600</span> -databits=<span class="number">8</span> arg1 arg2</span><br></pre></td></tr></table></figure><p>以上代码的执行的过程以及执行结果是：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwycwsdqmrj31ks09iq3t.jpg" alt=""></p><p>从上到下打印出的参数含义分别是：</p><p>1111：指定的标志类参数baudrate，默认值是1200，可随意更改；</p><p>1011： 指定的标志类参数databits，默认值是10，可随意更改；</p><p>[la, la]:非标志类参数为arg1 arg2；</p><p>2：非标志类参数的数量</p><p>2：标志类参数的数量</p><p>​                                                          The End!</p><hr>]]></content>
    
    <summary type="html">
    
      golang使用命令行参数
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>MySQL使用group by分组后对每组操作</title>
    <link href="https://cloudsjhan.github.io/2018/11/05/MySQL%E4%BD%BF%E7%94%A8group-by%E5%88%86%E7%BB%84%E5%90%8E%E5%AF%B9%E6%AF%8F%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://cloudsjhan.github.io/2018/11/05/MySQL使用group-by分组后对每组操作/</id>
    <published>2018-11-05T08:54:14.000Z</published>
    <updated>2018-11-06T02:07:42.708Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><a id="more"></a><p></p><h2 id="group-by-操作"><a href="#group-by-操作" class="headerlink" title="group by 操作"></a>group by 操作</h2><ul><li><p>分组能够将数据分成几个逻辑组，然后对其进行聚集操作</p></li><li><p>前几天开发的时候遇到这样的一个问题，有一个vender-cost表：</p></li></ul><p>mysql&gt; select * from vendor-cost;<br>+———+————–+————–+———–+————+———-+———-+</p><table><thead><tr><th>vendor</th><th>host</th><th>vendor_id</th><th>start_date</th><th>cost</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>+———+————–+————–+———–+————+———-+———-+<br>| Tencent | ins-m9faipc4 | 100014390 | 2018-10 | 0.015456 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-r76jxurv | 100015923 | 2018-10 | 0.284697 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-ramdkuqz | 100015923 | 2018-10 | 0.021175 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-q7o1dhsa | 100014390 | 2018-10 | 0.113501 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-5xxrgd65 | 100015923 | 2018-10 | 0.058623 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-79g28kn6 | 100015923 | 2018-10 | 0.03808 |<br>| ——- | ———— | ——— | ——- | ——- |<br>|         |              |           |         |         |<br>| Tencent | ins-rw54ka4k | 100015923 | 2018-10 | 0.150595 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-ggxrtm1v | 100015923 | 2018-10 | 0.068281 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>为了统计出每个vendor_id的cost，就需要使用分组语句，将同一个vendor_id的cost求和：</p><p>select vendor_id, sum(cost) from vendor_cost group by vendor_id;</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwy3y3ulp2j30lk0dejsn.jpg" alt=""></p><p>得出的结果就是每个vendor_id的总cost。</p><ul><li>还有一种group by的用法：<strong>GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里。</strong></li><li>举个栗子：</li></ul><p>现在有表格</p><p>Table: Subject_Selection</p><h2 id="Subject-Semester-Attendee"><a href="#Subject-Semester-Attendee" class="headerlink" title="Subject   Semester   Attendee"></a>Subject   Semester   Attendee</h2><p>ITB001    1          John<br>ITB001    1          Bob<br>ITB001    1          Mickey<br>ITB001    2          Jenny<br>ITB001    2          James<br>MKB114    1          John<br>MKB114    1          Erica</p><ul><li>我们下面再接着要求统计出每门学科每个学期有多少人选择，应用如下SQL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Subject, Semester, <span class="keyword">Count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Subject_Selection</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Subject, Semester</span><br></pre></td></tr></table></figure><ul><li>得到的结果是：</li></ul><h3 id="得到的结果是："><a href="#得到的结果是：" class="headerlink" title="得到的结果是："></a>得到的结果是：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject    Semester   Count</span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line">ITB001     1          3</span><br><span class="line">ITB001     2          2</span><br><span class="line">MKB114     1          2</span><br></pre></td></tr></table></figure><ul><li>从表中的记录我们可以看出这个分组结果是正确的有3个学生在第一学期选择了ITB001, 2个学生在第二学期选择了ITB001,还有两个学生在第一学期选择了MKB114, 没人在第二学期选择MKB114。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      在MySQL中使用group by对字段进行分组，并对每组进行统计操作
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>golang xorm 操作指南</title>
    <link href="https://cloudsjhan.github.io/2018/10/31/golang-xorm-%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>https://cloudsjhan.github.io/2018/10/31/golang-xorm-操作指南/</id>
    <published>2018-10-31T07:42:15.000Z</published>
    <updated>2018-10-31T07:44:25.132Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://www.kancloud.cn/xormplus/xorm/167077" target="_blank" rel="noopener">https://www.kancloud.cn/xormplus/xorm/167077</a></p><hr>]]></content>
    
    <summary type="html">
    
      golang xorm 操作指南 官方版
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之golang中修改struct的slice的值</title>
    <link href="https://cloudsjhan.github.io/2018/10/27/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8Bgolang%E4%B8%AD%E4%BF%AE%E6%94%B9struct%E7%9A%84slice%E7%9A%84%E5%80%BC/"/>
    <id>https://cloudsjhan.github.io/2018/10/27/技术周刊之golang中修改struct的slice的值/</id>
    <published>2018-10-27T02:30:10.000Z</published>
    <updated>2018-10-29T02:01:09.050Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>前段时间写go的时候遇到一个问题，需要修改由struct构成的slice中struct的某个字段值，类似于下面的需求：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Docker <span class="keyword">struct</span> &#123;</span><br><span class="line">Ip  <span class="keyword">string</span></span><br><span class="line">ID <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker1 := Docker&#123;</span><br><span class="line">Ip:  <span class="string">"222"</span>,</span><br><span class="line">ID: <span class="string">"aaa"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker2 := Docker&#123;</span><br><span class="line">Ip:  <span class="string">"111"</span>,</span><br><span class="line">ID: <span class="string">"bbb"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmpDocker []Docker</span><br><span class="line">tmpDocker = <span class="built_in">append</span>(tmpDocker, docker1)</span><br><span class="line">tmpDocker = <span class="built_in">append</span>(tmpDocker, docker2)</span><br><span class="line">现在需要修改tmpDocker中，Ip这个字段的值, 你可以先自己尝试修改一下，然后再往下看</span><br></pre></td></tr></table></figure><p>由这个问题我查阅很多资料，我们先从语言中经典的传值、传引用说起来</p><ul><li>对于一门语言，我们关心传递参数的过程中，是传值还是传引用，其实对于传值和传引用是一个比较古老的问题，在大学入门的时候，你可能就接触过这样的C语言代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下哪个函数能实现交换两个数？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=p;</span><br><span class="line">    p=q;</span><br><span class="line">    q=temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    *temp=*p;</span><br><span class="line">    *p=*q;</span><br><span class="line">    *q=*temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对于C语言来说，并没有传引用的概念，看似传引用的操控，实际上传的是指针的地址，也算是一种传值，先看一下传值，传引用，传指针的概念：</p><ul><li>传值：可能很多人都听说，传值无非就是实参拷贝传递给形参。这句话没有错，但是理解起来还是有点抽象。一句话，传值就是把实参赋值给形参，赋值完毕后实参就和形参没有任何联系，对形参的修改就不会影响到实参。</li><li>传地址：为什么说传地址也是一种传值呢？因为传地址是把实参地址的拷贝传递给形参。还是一句话，传地址就是把实参的地址复制给形参。复制完毕后实参的地址和形参的地址没有任何联系，对实参形参地址的修改不会影响到实参, 但是对形参地址所指向对象的修改却直接反应在实参中，因为形参指向的对象就是形参的对象。</li><li>传引用：传引用本质没有任何实参的拷贝，一句话，就是让另外一个变量也执行该实参。就是两个变量指向同一个对象。这是对形参的修改，必然反映到实参上。</li></ul><p>那么对于go语言来说，是没有引用传递的，go作为云计算时代的C语言，采用的都是值传递，即使是指针，也是将指针的地址即指针的指针，拷贝一份传递，可以参考这篇博文的讲解：Go<a href="http://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html" target="_blank" rel="noopener">语言参数传递是传值还是传引用</a></p><h3 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h3><ul><li><p>了解基本的知识背景之后，让我们回到文章开头的代码，即要修改slice中struct某字段的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type Docker struct &#123;</span><br><span class="line">Ip  string</span><br><span class="line">ID string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker1 := Docker&#123;</span><br><span class="line">Ip:  &quot;222&quot;,</span><br><span class="line">ID: &quot;aaa&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker2 := Docker&#123;</span><br><span class="line">Ip:  &quot;111&quot;,</span><br><span class="line">ID: &quot;bbb&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tmpDocker []Docker</span><br><span class="line">tmpDocker = append(tmpDocker, docker1)</span><br><span class="line">tmpDocker = append(tmpDocker, docker2)</span><br></pre></td></tr></table></figure><p>先将我最初的代码实现贴出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, dockerInfo := <span class="keyword">range</span> tmpDocker &#123;</span><br><span class="line">dockerInfo.Ip = <span class="string">"192.168,.1.1"</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(tmpDocker)</span><br></pre></td></tr></table></figure><p>让我们看一下运行结果：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwmm2z70f6j30d301ja9z.jpg" alt=""></p><p>发现struct中Ip字段的值并没有改变，是为什么呢？</p><p>原因就是：range的过程中产生了一个新的对象，即dockerInfo是temDocker中每个元素的一个副本，所以你改变的只是副本中Ip字段的值，并没有改变真实的。那么如何解决呢?</p><p>这里我提出两种解决的方法，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：赋给一个新的对象</span></span><br><span class="line">newTmpDocker := []Docker&#123;&#125;<span class="comment">//新的对象</span></span><br><span class="line"><span class="keyword">for</span> _, dockerInfo := <span class="keyword">range</span> tmpDocker &#123;</span><br><span class="line">    dockerInfo.Ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">    newTmpDocker = <span class="built_in">append</span>(newTmpDocker, dockerInfo)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(newTmpDocker)</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwmnl32x44j30dj01imx3.jpg" alt=""></p><p>可以看到最终输出的struct的slice中我们想要改变的字段已经修改成功。</p><p>第二种方法是将副本修改后赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">2</span>：修改副本后，将副本赋值给原来的</span><br><span class="line"><span class="keyword">for</span> i, dockerInfo := <span class="keyword">range</span> tmpDocker&#123;</span><br><span class="line">    dockerInfo.Ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">    tmpDocker[i] = dockerInfo</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(tmpDocker)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwmnl32x44j30dj01imx3.jpg" alt=""></p><p>可以看到同样修改成功。</p></li></ul><h3 id="总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。"><a href="#总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。" class="headerlink" title="总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。"></a>总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</h3><p>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。</p><p>这里也要记住，引用类型和传引用是两个概念。</p><p>再记住，Go里只有传值（值传递）。</p><hr>]]></content>
    
    <summary type="html">
    
      如何优雅地修改go中struct的slice的值
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>golang中string,rune,byte的关系</title>
    <link href="https://cloudsjhan.github.io/2018/10/25/golang%E4%B8%ADstring-rune-byte%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://cloudsjhan.github.io/2018/10/25/golang中string-rune-byte的关系/</id>
    <published>2018-10-25T01:55:40.000Z</published>
    <updated>2018-10-25T02:26:19.271Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ol><li>golang中String的底层是使用byte[]数组存储的，不可改变</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Golang 测试"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br></pre></td></tr></table></figure><p>这段代码按道理应该输出6+1+2.</p><p>实际运行之后输出却是13， 原因是中文字符在utf-8编码的系统中是3个字节存储的，在Unicode中是2个字节存储的，go的默认编码格式是utf-8，so。。</p><p>这时候，我们使用下标访问字符串中的中文字符是不行的，想要使用下标访问，就需要rune出马。</p><ol start="2"><li>在官方文档中，rune的定义是：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> rune is an alias for int32 and is equivalent to int32 in all ways. It is</span><br><span class="line"> used, by convention, to distinguish character values from integer values.</span><br><span class="line"></span><br><span class="line">int32的别名，几乎在所有方面等同于int32</span><br><span class="line">它用来区分字符值和整数值</span><br><span class="line">type rune int32</span><br></pre></td></tr></table></figure><p>那么我们想要得到预期字符串的长度，就要使用rune切片来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"rune:"</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br></pre></td></tr></table></figure><p>就会输出预期的rune: 9.</p><p>这时我们也可以按照下标去访问str中的字符了。即[7]rune(str) = “测”。</p><p>3.总结</p><p>string的底层是byte，byte与rune的不同之处是：</p><p>byte 等同于int8，常用来处理ascii字符<br>rune 等同于int32,常用来处理unicode或utf-8字符</p><p>或者可以这样说：</p><p>rune 能操作任何字符<br>byte 不支持中文的操作</p><p>​                                           END</p><hr>]]></content>
    
    <summary type="html">
    
      浅析golang中String，rune, byte的关系
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>上海QCon之Go专家David Cheney关于GO最佳实践的演讲</title>
    <link href="https://cloudsjhan.github.io/2018/10/21/%E4%B8%8A%E6%B5%B7QCon%E4%B9%8BGo%E4%B8%93%E5%AE%B6David-Cheney%E5%85%B3%E4%BA%8EGO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E6%BC%94%E8%AE%B2/"/>
    <id>https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/</id>
    <published>2018-10-21T14:07:15.000Z</published>
    <updated>2018-10-21T14:17:36.133Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本周六有幸参加了2018QCon上海的会议，听了David关于GO最佳实践的一些建议，下面贴出的就是David的演讲稿，内容相对来说比较基础，但是又是编程中不可避免的一些问题，希望可以给大家带来一些启发。</p><p>Table of Contents </p><p>Introduction<br> \1. Guiding principles </p><p>1.1. Simplicity 1.2. Readability 1.3. Productivity </p><p>\2. Identiers<br> 2.1. Choose identiers for clarity, not brevity 2.2. Identier length<br> 2.3. Don’t name your variables for their types 2.4. Use a consistent naming style<br> 2.5. Use a consistent declaration style<br> 2.6. Be a team player </p><p>\3. Comments<br> 3.1. Comments on variables and constants should describe their contents not their purpose 3.2. Always document public symbols </p><p>\4. Package Design<br> 4.1. A good package starts with its name<br> 4.2. Avoid package names like base , common , or util 4.3. Return early rather than nesting deeply<br> 4.4. Make the zero value useful<br> 4.5. Avoid package level state </p><p>\5. Project Structure<br> 5.1. Consider fewer, larger packages<br> 5.2. Keep package main small as small as possible </p><p>\6. API Design<br> 6.1. Design APIs that are hard to misuse.<br> 6.2. Design APIs for their default use case<br> 6.3. Let functions dene the behaviour they requires </p><p>\7. Error handling<br> 7.1. Eliminate error handling by eliminating errors 7.2. Only handle an error once </p><p>\8. Concurrency<br> 8.1. Keep yourself busy or do the work yourself<br> 8.2. Leave concurrency to the caller<br> 8.3. Never start a goroutine without when it will stop. </p><p>Introduction </p><p>Hello,<br> My goal over the next two sessions is to give you my advice for best practices writing Go code. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 1/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This is a workshop style presentation, I’m going to dispense with the usual slide deck and we’ll work directly from the document which you can take away with you today. </p><p>TIP </p><p>You can find the latest version of this presentation at <a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>\1. Guiding principles </p><p>If I’m going to talk about best practices in any programming language I need some way to define what I mean by best. If you came to my keynote yesterday you would have seen this quote from the Go team lead, Russ Cox: </p><p>“Software engineering is what happens to programming when you add time and other programmers. </p><p>— Russ Cox </p><p>Russ is making the distinction between software programming and software engineering. The former is a program you write for yourself. The latter is a product that many people will work on over time. Engineers will come and go, teams will grow and shrink over time, requirements will change, features will be added and bugs fixed. This is the nature of software engineering. </p><p>I’m possibly one of the earliest users of Go in this room, but to argue that my seniority gives my views more weight is false. Instead, the advice I’m going to present today is informed by what I believe to be the guiding principles underlying Go itself. They are: </p><p>\1. Simplicity<br> \2. Readability 3. Productivity </p><p>NOTE </p><p>You’ll note that I didn’t say performance, or concurrency. There are languages which are a bit faster than Go, but they’re certainly not as simple as Go. There are languages which make concurrency their highest goal, but they are not as readable, nor as productive. </p><p>Performance and concurrency are important attributes, but not as important as simplicity, readability, and productivity. </p><p>1.1. Simplicity </p><p>Why should we strive for simplicity? Why is important that Go programs be simple? </p><p>We’ve all been in a situation where you say “I can’t understand this code”, yes? We’ve all worked on programs where you’re scared to make a change because you’re worried it’ll break another part of the program; a part you don’t understand and don’t know how to fix. </p><p>This is complexity. Complexity turns reliable software in unreliable software. Complexity is what kills software projects. </p><p>Simplicity is the highest goal of Go. Whatever programs we write, we should be able to agree that they are simple. </p><p>1.2. Readability </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 2/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“Readability is essential for maintainability. — Mark Reinhold </p><p>JVM language summit 2018 </p><p>Why is it important that Go code be readable? Why should we strive for readability? </p><p>“Programs must be written for people to read, and only incidentally for machines to execute. — Hal Abelson and Gerald Sussman </p><p>Structure and Interpretation of Computer Programs </p><p>Readability is important because all software, not just Go programs, is written by humans to be read by other humans. The fact that software is also consumed by machines is secondary. </p><p>Code is read many more times than it is written. A single piece of code will, over its lifetime, be read hundreds, maybe thousands of times. </p><p>“The most important skill for a programmer is the ability to effectively communicate ideas. — Gastón Jorquera [1] </p><p>Readability is key to being able to understand what the program is doing. If you can’t understand what a program is doing, how can you hope to maintain it? If software cannot be maintained, then it will be rewritten; and that could be the last time your company will invest in Go. </p><p>If you’re writing a program for yourself, maybe it only has to run once, or you’re the only person who’ll ever see it, then do what ever works for you. But if this is a piece of software that more than one person will contribute to, or that will be used by people over a long enough time that requirements, features, or the environment it runs in changes, then your goal must be for your program to be maintainable. </p><p>The first step towards writing maintainable code is making sure the code is readable. </p><p>“1.3. Productivity<br> Design is the art of arranging code to work today, and be changeable forever. </p><p>— Sandi Metz </p><p>The last underlying principle I want to highlight is productivity. Developer productivity is a sprawling topic but it boils down to this; how much time do you spend doing useful work verses waiting for your tools or hopelessly lost in a foreign code-base. Go programmers should feel that they can get a lot done with Go. </p><p>The joke goes that Go was designed while waiting for a C++ program to compile. Fast compilation is a key feature of Go and a key recruiting tool to attract new developers. While compilation speed remains a constant battleground, it is fair to say that compilations which take minutes in other languages, take seconds in Go. This helps Go developers feel as productive as their counterparts working in dynamic languages without the reliability issues inherent in those languages. </p><p>More fundamental to the question of developer productivity, Go programmers realise that code is written to be read and so place the act of reading code above the act of writing it. Go goes so far as to enforce, via tooling and custom, that all code be formatted in a specific style. This removes the friction of learning a project specific dialect and helps spot mistakes because they just look incorrect. </p><p>Go programmers don’t spend days debugging inscrutable compile errors. They don’t waste days with complicated build scripts or deploying code to production. And most importantly they don’t spend their time trying to understand what their coworker wrote. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 3/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Productivity is what the Go team talk about when they say the language must scale. 2. Identiers </p><p>The first topic we’re going to discuss is identifiers. An identifier is a fancy word for a name; the name of a variable, the name of a function, the name of a method, the name of a type, the name of a package, and so on. </p><p>“Poor naming is symptomatic of poor design. — Dave Cheney </p><p>Given the limited syntax of Go, the names we choose for things in our programs have an oversized impact on the readability of our programs. Readability is the defining quality of good code thus choosing good names is crucial to the readability of Go code. </p><p>“2.1. Choose identiers for clarity, not brevity<br> Obvious code is important. What you can do in one line you should do in three. </p><p>— Ukiah Smith </p><p>Go is not a language that optimises for clever one liners. Go is not a language which optimises for the least number of lines in a program. We’re not optimising for the size of the source code on disk, nor how long it takes to type. </p><p>“Good naming is like a good joke. If you have to explain it, it’s not funny. — Dave Cheney </p><p>Key to this clarity is the names we choose for identifies in Go programs. Let’s talk about the qualities of a good name: </p><p>A good name is concise. A good name need not be the shortest it can possibly be, but a good name should waste no space on things which are extraneous. Good names have a high signal to noise ratio. </p><p>A good name is descriptive. A good name should describe the application of a variable or constant, not their contents. A good name should describe the result of a function, or behaviour of a method, not their operation. A good name should describe the purpose of a package, not its contents. The more accurately a name describes the thing it identifies, the better the name. </p><p>A good name is should be predictable. You should be able to infer the way a name will be used from its name alone. This is a function of choosing descriptive names, but it also about following tradition. This is what Go programmers talk about when they say idiomatic. </p><p>Let’s talk about each of these properties in depth. </p><p>2.2. Identier length </p><p>Sometimes people criticise the Go style for recommending short variable names. As Rob Pike said, “Go programmers want the right length identifiers”. [1] </p><p>Andrew Gerrand suggests that by using longer identifies for some things we indicate to the reader that they are of higher importance. </p><p>“The greater the distance between a name’s declaration and its uses, the longer the name should be. </p><p>— Andrew Gerrand [2] </p><p>From this we can draw some guidelines: </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 4/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Short variable names work well when the distance between their declaration and last use is short.<br> Long variable names need to justify themselves; the longer they are the more value they need to provide. Lengthy </p><p>bureaucratic names carry a low amount of signal compared to their weight on the page. </p><p>Don’t include the name of your type in the name of your variable. </p><p>Constants should describe the value they hold, not how that value is used. </p><p>Single letter variables for loops and branches, single words for parameters and return values, multiple words for functions and package level declarations </p><p>Single words for methods, interfaces, and packages.<br> Remember that the name of a package is part of the name the caller uses to to refer to it, so make use of that. </p><p>Let’s look at an example to </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br></pre></td></tr></table></figure><p>Age int } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// AverageAge returns the average age of people.</span><br><span class="line">func AverageAge(people []Person) int &#123;</span><br><span class="line">    if len(people) == 0 &#123;</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count, sum int</span><br><span class="line">for _, p := range people &#123;</span><br></pre></td></tr></table></figure><p>sum += p.Age </p><p>count += 1 } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return sum / count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>In this example, the range variable p is declared on line 10 and only referenced on the following line. p lives for a very short time both on the page, and during the execution of the function. A reader who is interested in the effect values of p have on the program need only read two lines. </p><p>By comparison people is declared in the function parameters and lives for seven lines. The same is true for sum , and count , thus they justify their longer names. The reader has to scan a wider number of lines to locate them so they are </p><p>given more distinctive names. </p><p>I could have chosen s for sum and c (or possibly n ) for but this would have reduced all the variables in the program to the same level of importance. I could have chosen                              instead of                              but that would have left the problem of what to call the for … range iteration variable. The singular                              would look odd as the loop iteration variable which lives for little time has a longer name than the slice of values it was derived from. </p><p>count </p><p>TIP </p><p>Use blank lines to break up the flow of a function in the same way you use paragraphs to break up the flow of a document. In AverageAge we have three operations occurring in sequence. The first is the precondition, checking that we don’t divide by zero if people is empty, the second is the accumulation of the sum and count, and the final is the computation of the average. </p><p>2.2.1. Context is key </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 5/45 </p><p>p </p><p>people </p><p>person </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>It’s important to recognise that most advice on naming is contextual. I like to say it is a principle, not a rule. </p><p>What is the difference between two identifiers, i , and index . We cannot say conclusively that one is better than another, for example is </p><p>fundamentally more readable than </p><p>I argue it is not, because it is likely the scope of i , and index for that matter, is limited to the body of the for loop and the extra verbosity of the latter adds little to comprehension of the program. </p><p>However, which of these functions is more readable? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(oid []int, index int) (int, error)</span><br></pre></td></tr></table></figure><p>or </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(o []int, i int) (int, error)</span><br></pre></td></tr></table></figure><p>In this example, oid is an abbreviation for SNMP Object ID, so shortening it to o would mean programmers have to translate from the common notation that they read in documentation to the shorter notation in your code. Similarly, reducing index to i obscures what i stands for as in SNMP messages a sub value of each OID is called an Index. </p><p>TIP Don’t mix and match long and short formal parameters in the same declaration. 2.3. Don’t name your variables for their types </p><p>You shouldn’t name your variables after their types for the same reason you don’t name your pets “dog” and “cat”. You also probably shouldn’t include the name of your type in the name of your variable’s name for the same reason. </p><p>The name of the variable should describe its contents, not the type of the contents. Consider this example: var usersMap map[string]*User </p><p>What’s good about this declaration? We can see that its a map, and it has something to do with the *User type, that’s probably good. But usersMap is a map, and Go being a statically typed language won’t let us accidentally use it where a scalar variable is required, so the Map suffix is redundant. </p><p>Now, consider what happens if we were to declare other variables like: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for index := 0; index &lt; len(s); index++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 6/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    companiesMap map[string]*Company</span><br><span class="line">    productsMap map[string]*Products</span><br></pre></td></tr></table></figure><p>) </p><p>Now we have three map type variables in scope, usersMap , companiesMap , and productsMap , all mapping strings to different types. We know they are maps, and we also know that their map declarations prevent us from using one in place of another—the compiler will throw an error if we try to use companiesMap where the code is expecting a </p><p>map[string]*User . In this situation it’s clear that the Map suffix does not improve the clarity of the code, its just extra boilerplate to type. </p><p>My suggestion is to avoid any suffix that resembles the type of the variable.<br> TIP If users isn’t descriptive enough, then usersMap won’t be either. </p><p>This advice also applies to function parameters. For example: </p><p>Naming the <em>Config parameter config is redundant. We know its a </em>Config , it says so right there. In this case consider conf or maybe c will do if the lifetime of the variable is short enough. </p><p>If there is more that one in scope at any one time then calling them conf1 and conf2 is less descriptive than calling them and as the latter are less likely to be mistaken for one another. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line">func WriteConfig(w io.Writer, config *Config)</span><br></pre></td></tr></table></figure><p>*Config </p><p>original </p><p>updated </p><p>Don’t let package names steal good variable names. </p><p>The name of an imported identifier includes its package name. For example the context package will be known as context.Context . This makes it impossible to use </p><p>a variable or type in your package. </p><p>type in the as </p><p>func WriteLog(context context.Context, message string)<br> Will not compile. This is why the local declaration for context.Context types is traditionally ctx . </p><p>eg. </p><p>func WriteLog(ctx context.Context, message string) </p><p>2.4. Use a consistent naming style </p><p>Another property of a good name is it should be predictable. The reader should be able to understand the use of a name when they encounter it for the first time. When they encounter a common name, they should be able to assume it has not changed meanings since the last time they saw it. </p><p>NOTE </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 7/45 </p><p>Context </p><p>context </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>For example, if your code passes around a database handle, make sure each time the parameter appears, it has the same name. Rather than a combination of d <em>sql.DB , dbase </em>sql.DB , DB <em>sql.DB , and database </em>sql.DB , instead consolidate on something like; </p><p>db <em>sql.DB<br> Doing so promotes familiarity; if you see a db , you know it’s a </em>sql.DB and that it has either been declared locally or </p><p>provided for you by the caller. </p><p>Similarly for method receivers; use the same receiver name every method on that type. This makes it easier for the reader to internalise the use of the receiver across the methods in this type. </p><p>The convention for short receiver names in Go is at odds with the advice provided so far. This is just NOTE one of the choices made early on that has become the preferred style, just like the use of CamelCase </p><p>TIP </p><p>rather than snake_case . </p><p>Go style dictates that receivers have a single letter name, or acronyms derived from their type. You may find that the name of your receiver sometimes conflicts with name of a parameter in a method. In this case, consider making the parameter name slightly longer, and don’t forget to use this new parameter name consistently. </p><p>Finally, certain single letter variables have traditionally been associated with loops and counting. For example, i , j , and k are commonly the loop induction variable for simple for loops. n is commonly associated with a counter or accumulator. v is a common shorthand for a value in a generic encoding function, k is commonly used for the key of a map, and s is often used as shorthand for parameters of type string . </p><p>As with the db example above programmers expect                              to be a loop induction variable. If you ensure that is always a loop variable, not used in other contexts outside a                              loop. When readers encounter a variable called , or j , they know that a loop is close by. </p><p>i </p><p>i </p><p>for </p><p>i </p><p>TIP </p><p>If you found yourself with so many nested loops that you exhaust your supply of i , j , and k variables, its probably time to break your function into smaller units. </p><p>2.5. Use a consistent declaration style </p><p>Go has at least six different ways to declare a variable </p><p>varxint=1 varx=1 varxint;x=1 var x = int(1) x:=1 </p><p>I’m sure there are more that I haven’t thought of. This is something that Go’s designers recognise was probably a mistake, but its too late to change it now. With all these different ways of declaring a variable, how do we avoid each Go programmer choosing their own style? </p><p>I want to present a suggestions for how I declare variables in my programs. This is the style I try to use where possible. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 8/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>When declaring, but not initialising, a variable, use var . When declaring a variable that will be explicitly initialised later in the function, use the var keyword. </p><p>The var acts as a clue to say that this variable has been deliberately declared as the zero value of the indicated type. This is also consistent with the requirement to declare variables at the package level using var as opposed to the short declaration syntax—although I’ll argue later that you shouldn’t be using package level variables at all. </p><p>When declaring and initialising, use := . When declaring and initialising the variable at the same time, that is to say we’re not letting the variable be implicitly initialised to its zero value, I recommend using the short variable declaration form. This makes it clear to the reader that the variable on the left hand side of the := is being deliberately initialised. </p><p>To explain why, Let’s look at the previous example, but this time deliberately initialising each variable: </p><p>In the first and third examples, because in Go there are no automatic conversions from one type to another; the type on the left hand side of the assignment operator must be identical to the type on the right hand side. The compiler can infer the type of the variable being declared from the type on the right hand side, to the example can be written more concisely like this: </p><p>This leaves us with explicitly initialising players to 0 which is redundant because 0 is `players’ zero value. So its better to make it clear that we’re going to use the zero value by instead writing </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var players int</span><br></pre></td></tr></table></figure><p>What about the second statement? We cannot elide the type and write </p><p>var things = nil<br> Because nil does not have a type. [2] Instead we have a choice, do we want the zero value for a slice? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var players int    // 0</span><br><span class="line">var things []Thing // an empty slice of Things</span><br><span class="line">var thing Thing    // empty Thing struct</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br><span class="line">var players int = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing *Thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br><span class="line">var players = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 9/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things []Thing</span><br></pre></td></tr></table></figure><p>or do we want to create a slice with zero elements? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things = make([]Thing, 0)</span><br></pre></td></tr></table></figure><p>If we wanted the latter then this is not the zero value for a slice so we should make it clear to the reader that we’re making this choice by using the short declaration form: </p><p>things := make([]Thing, 0)<br> Which tells the reader that we have chosen to initialise things explicitly. </p><p>This brings us to the third declaration, </p><p>var thing = new(Thing)<br> Which is both explicitly initialising a variable and introduces the uncommon use of the new keyword which some Go </p><p>programmer dislike. If we apply our short declaration syntax recommendation then the statement becomes </p><p>thing := new(Thing)<br> Which makes it clear that thing is explicitly initialised to the result of new(Thing) –a pointer to a Thing –but still </p><p>leaves us with the unusual use of new . We could address this by using the compact literal struct initialiser form, thing := &amp;Thing{} </p><p>Which does the same as<br> means we’re explicitly initialising </p><p>, hence why some Go programmers are upset by the duplication. However this with a pointer to a Thing{} , which is the zero value for a Thing . </p><p>new(Thing) </p><p>thing </p><p>Instead we should recognise that                              is being declared as its zero value and use the address of operator to pass the address of thing to </p><p>thing </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.Unmarshall</span><br><span class="line">var thing Thing</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 10/45 </p><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>NOTE </p><p>Of course, with any rule of thumb, there are exceptions. For example, sometimes two variables are closely related so writing </p><p>Would be odd. The declaration may be more readable like this </p><p>min, max := 0, 1000 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var min int</span><br><span class="line">max := 1000</span><br></pre></td></tr></table></figure><p>In summary:<br> When declaring a variable without initialisation, use the var syntax. </p><p>When declaring and explicitly initialising a variable, use := . Make tricky declarations obvious. </p><p>When something is complicated, it should look complicated. var length uint32 = 0x80 </p><p>Here length may be being used with a library which requires a specific numeric type and is more TIP explicit that length is being explicitly chosen to be uint32 than the short declaration form: </p><p>length := uint32(0x80) </p><p>In the first example I’m deliberately breaking my rule of using the var declaration form with an explicit initialiser. This decision to vary from my usual form is a clue to the reader that something unusual is happening. </p><p>2.6. Be a team player </p><p>I talked about a goal of software engineering to produce readable, maintainable, code. Therefore you will likely spend most of your career working on projects of which you are not the sole author. My advice in this situation is to follow the local style. </p><p>Changing styles in the middle of a file is jarring. Uniformity, even if its not your preferred approach, is more valuable for maintenance than your personal preference. My rule of thumb is; if it fits through gofmt then its usually not worth holding up a code review for. </p><p>If you want to do a renaming across a code-base, do not mix this into another change. If someone is TIP using git bisect they don’t want to wade through thousands of lines of renaming to find the code you </p><p>changed as well. </p><p>\3. Comments </p><p>Before we move on to larger items I want to spend a few minutes talking about comments. </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 11/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“Good code has lots of comments, bad code requires lots of comments. — Dave Thomas and Andrew Hunt </p><p>The Pragmatic Programmer </p><p>Comments are very important to the readability of a Go program. A comments should do one of three things: </p><p>\1. The comment should explain what the thing does.<br> \2. The comment should explain how the thing does what it does. 3. The comment should explain why the thing is why it is. </p><p>The first form is ideal for commentary on public symbols: </p><p>The second form is ideal for commentary inside a method: </p><p>The third form, the why , is unique as it does not displace the first two, but at the same time it’s not a replacement for the what, or the how. The why style of commentary exists to explain the external factors that drove the code you read on the page. Frequently those factors rarely make sense taken out of context, the comment exists to provide that context. </p><p>In this example it may not be immediately clear what the effect of setting HealthyPanicThreshold to zero percent will do. The comment is needed to clarify that the value of 0 will disable the panic threshold behaviour. </p><p>3.1. Comments on variables and constants should describe their contents not their purpose </p><p>I talked earlier that the name of a variable, or a constant, should describe its purpose. When you add a comment to a variable or constant, that comment should describe the variables contents, not the variables purpose. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const randomNumber = 6 // determined from an unbiased die</span><br></pre></td></tr></table></figure><p>In this example the comment describes why                              is assigned the value six, and where the six was derived from. The comment does not describe where                              will be used. Here are some more examples: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Open opens the named file for reading.</span><br><span class="line">// If successful, methods on the returned file can be used for reading.</span><br><span class="line">// queue all dependant actions</span><br><span class="line">var results []chan error</span><br><span class="line">for _, dep := range a.Deps &#123;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results = append(results, execute(seen, dep))</span><br><span class="line">return &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">    // Disable HealthyPanicThreshold</span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">            Value: 0,</span><br></pre></td></tr></table></figure><p>}, } </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>12/45 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randomNumber</span><br><span class="line">randomNumber</span><br></pre></td></tr></table></figure><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    StatusContinue           = 100 // RFC 7231, 6.2.1</span><br><span class="line">    StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2</span><br><span class="line">    StatusProcessing         = 102 // RFC 2518, 10.1</span><br><span class="line">    StatusOK                 = 200 // RFC 7231, 6.3.1</span><br></pre></td></tr></table></figure><p>In the context of HTTP the number 100 is known as StatusContinue , as defined in RFC 7231, section 6.2.1. For variables without an initial value, the comment should describe who is responsible for </p><p>// sizeCalculationDisabled indicates whether it is safe // to calculate Types’ widths and alignments. See dowidth. var sizeCalculationDisabled bool </p><p>TIP </p><p>initialising this variable. </p><p>Here the comment lets the reader know that the dowidth function is responsible for maintaining the state of sizeCalculationDisabled . </p><p>Hiding in plain sight </p><p>This is a tip from Kate Gregory. [3] Sometimes you’ll find a better name for a variable hiding in a comment. </p><p>The comment was added by the author because registry doesn’t explain enough about its purpose —it’s a registry, but a registry of what? </p><p>By renaming the variable to sqlDrivers its now clear that the purpose of this variable is to hold SQL drivers. </p><p>var sqlDrivers = make(map[string]*sql.Driver) </p><p>Now the comment is redundant and can be removed. </p><p>// registry of SQL drivers<br> var registry = make(map[string]*sql.Driver) </p><p>TIP </p><p>3.2. Always document public symbols </p><p>Because godoc is the documentation for your package, you should always add a comment for every public symbol— variable, constant, function, and method—declared in your package. </p><p>Here are two rules from the Google Style guide </p><p>Any public function that is not both obvious and short must be commented.<br> Any function in a library must be commented regardless of length or complexity </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 13/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package ioutil</span><br><span class="line">// ReadAll reads from r until an error or EOF and returns the data it read.</span><br><span class="line">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><br><span class="line">// defined to read from src until EOF, it does not treat an EOF from Read</span><br><span class="line">// as an error to be reported.</span><br><span class="line">func ReadAll(r io.Reader) ([]byte, error)</span><br></pre></td></tr></table></figure><p>There is one exception to this rule; you don’t need to document methods that implement an interface. Specifically don’t do this: </p><p>This comment says nothing. It doesn’t tell you what the method does, in fact it’s worse, it tells you to go look somewhere else for the documentation. In this situation I suggest removing the comment entirely. </p><p>Here is an example from the io package </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Read implements the io.Reader interface</span><br><span class="line">func (r *FileReader) Read(buf []byte) (int, error)</span><br><span class="line">// LimitReader returns a Reader that reads from r</span><br><span class="line">// but stops with EOF after n bytes.</span><br><span class="line">// The underlying implementation is a *LimitedReader.</span><br><span class="line">func LimitReader(r Reader, n int64) Reader &#123; return &amp;LimitedReader&#123;r, n&#125; &#125;</span><br><span class="line">// A LimitedReader reads from R but limits the amount of</span><br><span class="line">// data returned to just N bytes. Each call to Read</span><br><span class="line">// updates N to reflect the new amount remaining.</span><br><span class="line">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span><br><span class="line">type LimitedReader struct &#123;</span><br><span class="line">    R Reader // underlying reader</span><br><span class="line">    N int64  // max bytes remaining</span><br><span class="line">&#125;</span><br><span class="line">func (l *LimitedReader) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">    if l.N &lt;= 0 &#123;</span><br><span class="line">        return 0, EOF</span><br><span class="line">    &#125;</span><br><span class="line">    if int64(len(p)) &gt; l.N &#123;</span><br><span class="line">        p = p[0:l.N]</span><br><span class="line">    &#125;</span><br><span class="line">    n, err = l.R.Read(p)</span><br><span class="line">    l.N -= int64(n)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure><p>} </p><p>Note that the                              declaration is directly preceded by the function that uses it, and the declaration of follows the declaration of LimitedReader itself. Even though LimitedReader.Read has no </p><p>documentation itself, its clear from that it is an implementation of io.Reader . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LimitedReader</span><br><span class="line">LimitedReader.Read</span><br></pre></td></tr></table></figure><p>TIP </p><p>Before you write the function, write the comment describing the function. If you find it hard to write the comment, then it’s a sign that the code you’re about to write is going to be hard to understand. </p><p>3.2.1. Don’t comment bad code, rewrite it </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 14/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“ Don’t comment bad code — rewrite it — Brian Kernighan </p><p>Comments highlighting the grossness of a particular piece of code are not sufficient. If you encounter one of these comments, you should raise an issue as a reminder to refactor it later. It is okay to live with technical debt, as long as the amount of debt is known. </p><p>The tradition in the standard library is to annotate a TODO style comment with the username of the person who noticed it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO(dfc) this is O(N^2), find a faster way to do this.</span><br></pre></td></tr></table></figure><p>The username is not a promise that that person has committed to fixing the issue, but they may be the best person to ask when the time comes to address it. Other projects annotate TODOs with a date or an issue number. </p><p>“3.2.2. Rather than commenting a block of code, refactor it </p><p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer. </p><p>— Steve McConnell </p><p>Functions should do one thing only. If you find yourself commenting a piece of code because it is unrelated to the rest of the function, consider extracting it into a function of its own. </p><p>In addition to be easier to comprehend, smaller functions are easier to test in isolation, and now you’ve isolated the orthogonal code into its own function, its name may be all the documentation required. </p><p>“4. Package Design<br> Write shy code - modules that don’t reveal anything unnecessary to other modules and that </p><p>don’t rely on other modules’ implementations. </p><p>— Dave Thomas </p><p>Each Go package is in effect it’s own small Go program. Just as the implementation of a function or method is unimportant to the caller, the implementation of the functions and methods and types that make your package’s public API—its behaviour—is unimportant for the caller. </p><p>A good Go package should strive to have a low degree of source level coupling such that, as the project grows, changes to one package do not cascade across the code-base. These stop-the-world refactorings place a hard limit on the rate of change in a code base and thus the productivity of the members working in that code-base. </p><p>In this section we’ll talk about designing a package including the package’s name, naming types, and tips for writing methods and functions. </p><p>4.1. A good package starts with its name </p><p>Writing a good Go package starts with the package’s name. Think of your package’s name as an elevator pitch to describe what it does using just one word. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>15/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Just as I talked about names for variables in the previous section, the name of a package is very important. The rule of thumb I follow is not, “what types should I put in this package?”. Instead the question I ask “what does service does package provide?” Normally the answer to that question is not “this package provides the X type”, but “this package let’s you speak HTTP”. </p><p>TIP Name your package after what is provides, not what it contains. 4.1.1. Good package names should be unique. </p><p>Within your project, each package name should be unique. This advice is pretty easy to follow if the advice that a package’s name should derive from its purpose—if you find you have two packages which need the same name, it is likely either; </p><p>a. The name of the package is too generic. </p><p>b. The package overlaps another package of a similar name. In this case either you should review your design, or consider merging the packages. </p><p>4.2. Avoid package names like base , common , or util </p><p>A common cause of poor package names is what call utility packages. These are packages where common helpers and utility code congeals over time. As these packages contain an assortment of unrelated functions, their utility is hard to describe in terms of what the package provides. This often leads to the package’s name being derived from what the package contains–utilities. </p><p>Package names like utils or helpers are commonly found in larger projects which have developed deep package hierarchies and want to share helper functions without encountering import loops. By extracting utility functions to new package the import loop is broken, but because the package stems from a design problem in the project, its name doesn’t reflect its purpose, only its function of breaking the import cycle. </p><p>My recommendation to improve the name of utils or helpers packages is to analyse where they are called and if possible move the relevant functions into their caller’s package. Even if this involves duplicating some helper code this is better than introducing an import dependency between two packages. </p><p>“[A little] duplication is far cheaper than the wrong abstraction. — Sandy Metz </p><p>In the case where utility functions are used in many places prefer multiple packages, each focused on a single aspect, to a single monolithic package. </p><p>TIP Use plurals for naming utility packages. For example the strings for string handling utilities. </p><p>Packages with names like base or common are often found when functionality common to two or more implementations, or common types for a client and server, has been refactored into a separate package. I believe the solution to this is to reduce the number of packages, to combine the client, server, and common code into a single package named after the function of the package. </p><p>For example, the net/http package does not have client and                              sub packages, instead it has a client.go and server.go file, each holding their respective types, and a                              file for the common message transport code. </p><p>server </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>16/45 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport.go</span><br></pre></td></tr></table></figure><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP </p><p>An identifier’s name includes its package name. </p><p>It’s important to remember that the name of an identifier includes the name of its package. </p><p>The Get function from the net/http package becomes http.Get when referenced by another package. </p><p>The Reader type from the strings package becomes strings.Reader when imported into other packages. </p><p>The Error interface from the net package is clearly related to network errors. 4.3. Return early rather than nesting deeply </p><p>As Go does not use exceptions for control flow there is no requirement to deeply indent your code just to provide a top level structure for the try and catch blocks. Rather than the successful path nesting deeper and deeper to the right, Go code is written in a style where the success path continues down the screen as the function progresses. My friend Mat Ryer calls this practice ‘line of sight’ coding. [4] </p><p>This is achieved by using guard clauses; conditional blocks with assert preconditions upon entering a function. Here is an example from the bytes package, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &lt;= opInvalid &#123;</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">        b.off -= int(b.lastRead)</span><br><span class="line">    &#125;</span><br><span class="line">    b.lastRead = opInvalid</span><br></pre></td></tr></table></figure><p>return nil } </p><p>Upon entering UnreadRune the state of b.lastRead is checked and if the previous operation was not an error is returned immediately. From there the rest of the function proceeds with the assertion that is greater that opInvalid . </p><p>Compare this to the same function written without a guard clause, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &gt; opInvalid &#123;</span><br><span class="line">        if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">            b.off -= int(b.lastRead)</span><br><span class="line">        &#125;</span><br><span class="line">        b.lastRead = opInvalid</span><br><span class="line">        return nil</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>The body of the successful case, the most common, is nested inside the first if condition and the successful exit condition, return nil , has to be discovered by careful matching of closing braces. The final line of the function now returns an error, and the called must trace the execution of the function back to the matching opening brace to know </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 17/45 </p><p>ReadRune </p><p>b.lastRead </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>when control will reach this point. </p><p>This is more error prone for the reader, and the maintenance programmer, hence why Go prefer to use guard clauses and returning early on errors. </p><p>4.4. Make the zero value useful </p><p>Every variable declaration, assuming no explicit initialiser is provided, will be automatically initialised to a value that matches the contents of zeroed memory. This is the values zero value. The type of the value determines its zero value; for numeric types it is zero, for pointer types nil, the same for slices, maps, and channels. </p><p>This property of always setting a value to a known default is important for safety and correctness of your program and can make your Go programs simpler and more compact. This is what Go programmers talk about when they say “give your structs a useful zero value”. </p><p>Consider the sync.Mutex type. sync.Mutex contains two unexported integer fields, representing the mutex’s internal state. Thanks to the zero value those fields will be set to will be set to 0 whenever a sync.Mutex is declared. </p><p>sync.Mutex has been deliberately coded to take advantage of this property, making the type usable without explicit initialisation. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type MyInt struct &#123;</span><br><span class="line">    mu  sync.Mutex</span><br></pre></td></tr></table></figure><p>val int } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var i MyInt</span><br><span class="line">    // i.mu is usable without explicit initialisation.</span><br><span class="line">    i.mu.Lock()</span><br><span class="line">    i.val++</span><br><span class="line">    i.mu.Unlock()</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>Another example of a type with a useful zero value is bytes.Buffer . You can declare a bytes.Buffer and start writing to it without explicit initialisation. </p><p>A useful property of slices is their zero value is nil . This makes sense if we look at the runtime’s definition of a slice header. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    b.WriteString(&quot;Hello, world!\n&quot;)</span><br><span class="line">    io.Copy(os.Stdout, &amp;b)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">        array *[...]T // pointer to the underlying array</span><br><span class="line">        len   int</span><br><span class="line">        cap   int</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 18/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The zero value of this struct would imply len and cap have the value 0 , and array , the pointer to memory holding the contents of the slice’s backing array, would be nil . This means you don’t need to explicitly make a slice, you can just declare it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // s := make([]string, 0)</span><br><span class="line">    // s := []string&#123;&#125;</span><br><span class="line">    var s []string</span><br><span class="line">    s = append(s, &quot;Hello&quot;)</span><br><span class="line">    s = append(s, &quot;world&quot;)</span><br><span class="line">    fmt.Println(strings.Join(s, &quot; &quot;))</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>var s []string is similar to the two commented lines above it, but not identical. It is possible to detect the difference between a slice value that is nil and a slice value that has zero length. The following code will output false. </p><p>NOTE </p><p>A surprising, but useful, property of uninitialised pointer variables—nil pointers—is you can call methods on types that have a nil value. This can be used to provide default values simply. </p><p>func main() {<br> var s1 = []string{}<br> var s2 []string fmt.Println(reflect.DeepEqual(s1, s2)) </p><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    path string</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *Config) Path() string &#123;</span><br><span class="line">    if c == nil &#123;</span><br><span class="line">        return &quot;/usr/home&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return c.path</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var c1 *Config</span><br><span class="line">    var c2 = &amp;Config&#123;</span><br><span class="line">        path: &quot;/export&quot;,</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>4.5. Avoid package level state </p><p>The key to writing maintainable programs is that they should be loosely coupled—a change to one package should have a low probability of affecting another package that does not directly depend on the first. </p><p>There are two excellent ways to achieve loose coupling in Go </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>19/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>\1. Use interfaces to describe the behaviour your functions or methods require. 2. Avoid the use of global state. </p><p>In Go we can declare variables at the function or method scope, and also at the package scope. When the variable is public, given a identifier starting with a capital letter, then its scope is effectively global to the entire program—any package may observe the type and contents of that variable at any time. </p><p>Mutable global state introduces tight coupling between independent parts of your program as global variables become an invisible parameter to every function in your program! Any function that relies on a global variable can be broken if that variable’s type changes. Any function that relies on the state of a global variable can be broken if another part of the program changes that variable. </p><p>If you want to reduce the coupling a global variable creates, </p><p>\1. Move the relevant variables as fields on structs that need them.<br> \2. Use interfaces to reduce the coupling between the behaviour and the implementation of that behaviour. </p><p>\5. Project Structure </p><p>Let’s talk about combining packages together into a project. Commonly this will be a single git repository, but in the future Go developers will use module and project interchangeably. </p><p>Just like a package, each project should have a clear purpose. If your project is a library, it should provide one thing, say XML parsing, or logging. You should avoid combining multiple purposes into a single package, this will help avoid the dreaded common library. </p><p>In my experience, the common repo ends up tightly coupled to its biggest consumer and that makes TIP it hard to back-port fixes without upgrading both common and consumer in lock step, bringing in a </p><p>lot of unrelated changes and API breakage along the way. </p><p>If your project is an application, like your web application, Kubernetes controller, and so on, then you might have one or more                              packages inside your project. For example, the Kubernetes controller I work on has a single </p><p>package which serves as both the server deployed to a Kubernetes cluster, and a client for debugging </p><p>purposes. </p><p>5.1. Consider fewer, larger packages </p><p>One of the things I tend to pick up in code review for programmers who are transitioning from other languages to Go is they tend to overuse packages. </p><p>Go does not provide elaborate ways of establishing visibility; thing Java’s public , protected , private , and implicit default access modifiers. There is no equivalent of C++’s notion of friend classes. </p><p>In Go we have only two access modifiers, public and private, indicated by the capitalisation of the first letter of the identifier. If an identifier is public, it’s name starts with a capital letter, that identifier can be referenced by any other Go package. </p><p>NOTE You may hear people say exported and not exported as synonyms for public and private.<br> Given the limited controls available to control access to a package’s symbols, what practices should Go programmers </p><p>follow to avoid creating over-complicated package hierarchies? </p><p>main </p><p>cmd/contour </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 20/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP Every package, with the exception of cmd/ and internal/ , should contain some source code. </p><p>The advice I find myself repeating is to prefer fewer, larger packages. Your default position should be to not create a new package. That will lead to too many types being made public creating a wide, shallow, API surface for your package.. </p><p>The sections below explores this suggestion in more detail. </p><p>TIP </p><p>Coming from Java? </p><p>If you’re coming from a Java or C# background, consider this rule of thumb. - A Java package is equivalent to a single .go source file. - A Go package is equivalent to a whole Maven module or .NET assembly. </p><p>5.1.1. Arrange code into les by import statements </p><p>If you’re arranging your packages by what they provide to callers, should you do the same for files within a Go package? How do you know when you should break up a .go file into multiple ones? How do you know when you’ve gone to far and should consider consolidating .go file? </p><p>Here are the rules of thumb I use:<br> Start each package with one file. Give that file the same name as the name of the folder. eg. package http </p><p>should be placed in a file called in a directory named http . </p><p>As your package grows you may decide to split apart the various responsibilities into different files. eg,<br> contains the `Request and Response types, client.go contains the Client type, server.go </p><p>contains the type. </p><p>If you find your files have similar import declarations, consider combining them. Alternatively, identify the differences between the import sets and move those </p><p>Different files should be responsible for different areas of the package.                              may be responsible for marshalling of HTTP requests and responses on and off the network,                              may contain the low level network handling logic, client.go and server.go implement the HTTP business logic of request construction or routing, and so on. </p><p>TIP Prefer nouns for source file names. </p><p>The Go compiler compiles each package in parallel. Within a package the compiler compiles each NOTE function (methods are just fancy functions in Go) in parallel. Changing the layout of your code within </p><p>a package does not affect compilation time. </p><p>5.1.2. Prefer internal tests to external tests </p><p>The go tool supports writing your testing package tests in two places. Assuming your package is called http2 , you can write a file and use the declaration. Doing so will compile the code in </p><p>as if it were part of the package. This is known colloquially as an internal test. </p><p>The go tool also supports a special package declaration, ending in test , ie., package http_test . This allows your test files to live alongside your code in the same package, however when those tests are compiled they are not part of your package’s code, they live in their own package. This allows you to write your tests as if you were another package calling into your code. This is known as an _external test. </p><p>.go </p><p>http.go </p><p>messages.go </p><p>Server </p><p>messages.go </p><p>http.go </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure><p>package http2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure><p>http2 </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 21/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>I recommend using internal tests when writing unit tests for your package. This allows you to test each function or method directly, avoiding the bureaucracy of external testing. </p><p>However, you should place your Example test functions in an external test file. This ensures that when viewed in godoc, the examples have the appropriate package prefix and can be easily copy pasted. </p><p>TIP </p><p>Avoid elaborate package hierarchies, resist the desire to apply taxonomy </p><p>With one exception, which we’ll talk about next, the hierarchy of Go packages has no meaning to the go tool. For example, the net/http package is not a child or sub-package of the net package. </p><p>If you find you have created intermediate directories in your project which contain no .go files, you may have failed to follow this advice. </p><p>5.1.3. Use internal packages to reduce your public API surface </p><p>If your project contains multiple packages you may have some exported functions which are intended to be used by other packages in your project, but are not intended to be part of your project’s public API. If you find yourself in this situation the go tool recognises a special folder name—not package name–, internal/ which can be used to place code which is public to your project, but private to other projects. </p><p>To create such a package, place it in a directory named internal/ or in a sub-directory of a directory named internal/ . When the go command sees an import of a package with                              in its path, it verifies that the </p><p>package doing the import is within the tree rooted at the parent of the                              directory.<br> For example, a package can be imported only by code in the directory tree rooted at … </p><p>/a/b/c . It cannot be imported by code in                              or in any other repository. [5] 5.2. Keep package main small as small as possible </p><p>Your main function, and                              package should do as little as possible. This is because main.main acts as a singleton; there can only be one                              function in a program, including tests. </p><p>Because main.main is a singleton there are a lot of assumptions built into the things that main.main will call that they will only be called during main.main or main.init, and only called once. This makes it hard to write tests for code written in main.main , thus you should aim to move as much of your business logic out of your main function and ideally out of your main package. </p><p>TIP </p><p>main should parse flags, open connections to databases, loggers, and such, then hand off execution to a high level object. </p><p>\6. API Design </p><p>The last piece of design advice I’m going to give today I feel is the most important. </p><p>All of the suggestions I’ve made so far are just that, suggestions. These are the way I try to write my Go, but I’m not going to push them hard in code review. </p><p>However when it comes to reviewing APIs during code review, I am less forgiving. This is because everything I’ve talked about so far can be fixed without breaking backward compatibility; they are, for the most part, implementation details. </p><p>When it comes to the public API of a package, it pays to put considerable thought into the initial design, because changing that design later is going to be disruptive for people who are already using your API. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 22/45 </p><p>internal </p><p>main </p><p>…/a/b/g </p><p>internal </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.../a/b/c/internal/d/e/f</span><br></pre></td></tr></table></figure><p>main </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“6.1. Design APIs that are hard to misuse.<br> APIs should be easy to use and hard to misuse. </p><p>— Josh Bloch [3] </p><p>If you take anything away from this presentation, it should be this advice from Josh Bloch. If an API is hard to use for simple things, then every invocation of the API will look complicated. When the actual invocation of the API is complicated it will be less obvious and more likely to be overlooked. </p><p>6.1.1. Be wary of functions which take several parameters of the same type </p><p>A good example of a simple looking, but hard to use correctly API is one which takes two or more parameters of the same type. Let’s compare two function signatures: </p><p>What’s the difference between these two functions? Obviously one returns the maximum of two numbers, the other copies a file, but that’s not the important thing. </p><p>Max is commutative; the order of the parameters does not matter. The maximum of eight and ten is ten regardless of if I compare eight to ten or ten two eight. </p><p>However, this property does not hold true for CopyFile . </p><p>Which one of these statements made a backup of your presentation and which one overwrite your presentation with last week’s version? You can’t tell without consulting the documentation. A code reviewer cannot know if you’ve got the order correct without consulting the documentation. </p><p>One possible solution to this is to introduce a helper type which will be responsible for calling CopyFile correctly. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Max(a, b int) int</span><br><span class="line">func CopyFile(to, from string) error</span><br><span class="line">Max(8, 10) // 10</span><br><span class="line">Max(10, 8) // 10</span><br><span class="line">CopyFile(&quot;/tmp/backup&quot;, &quot;presentation.md&quot;)</span><br><span class="line">CopyFile(&quot;presentation.md&quot;, &quot;/tmp/backup&quot;)</span><br><span class="line">type Source string</span><br><span class="line">func (src Source) CopyTo(dest string) error &#123;</span><br><span class="line">    return CopyFile(dest, string(src))</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var from Source = &quot;presentation.md&quot;</span><br><span class="line">    from.CopyTo(&quot;/tmp/backup&quot;)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>In this way CopyFile is always called correctly—this can be asserted with a unit test—and can possibly be made private, further reducing the likelihood of misuse. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 23/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP APIs with multiple parameters of the same type are hard to use correctly. 6.2. Design APIs for their default use case </p><p>A few years ago I gave a talk [6] about using functional options [7] to make APIs easier to use for their default case. </p><p>The gist of this talk was you should design your APIs for the common use case. Sad another way, your API should not require the caller to provide parameters which they don’t care about. </p><p>6.2.1. Discourage the use of nil as a parameter </p><p>I opened this chapter with the suggestion that you shouldn’t force the caller of your API into providing you parameters when they don’t really care what those parameters mean. This is what I mean when I say design APIs for their default use case. </p><p>Here’s an example from the net/http package </p><p>package http </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ListenAndServe listens on the TCP network address addr and then calls</span><br><span class="line">// Serve with handler to handle requests on incoming connections.</span><br><span class="line">// Accepted connections are configured to enable TCP keep-alives.</span><br><span class="line">//</span><br><span class="line">// The handler is typically nil, in which case the DefaultServeMux is used.</span><br><span class="line">//</span><br><span class="line">// ListenAndServe always returns a non-nil error.</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br></pre></td></tr></table></figure><p>ListenAndServe takes two parameters, a TCP address to listen for incoming connections, and http.Handler to handle the incoming HTTP request. Serve allows the second parameter to be nil , and notes that usually the caller will pass nil indicating that they want to use http.DefaultServeMux as the implicit parameter. </p><p>Now the caller of Serve has two ways to do the same thing. </p><p>Both do exactly the same thing. </p><p>This                              behaviour is viral. The http package also has a http.Serve helper, which you can reasonably imagine that builds upon like this </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>nil </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">    l, err := net.Listen(&quot;tcp&quot;, addr)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    defer l.Close()</span><br><span class="line">    return Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 24/45 </p><p>http.Serve </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br></pre></td></tr></table></figure><p>nil<br> handler </p><p>DefaultServeMux`” logic. </p><p>http.Serve </p><p>Accepting `nil </p><p>nil </p><p>Serve </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.Serve(nil, nil)</span><br><span class="line">          http.ListenAndServe</span><br><span class="line">DefaultServeMux</span><br></pre></td></tr></table></figure><p>nil </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ShutdownVMs(ids []string) error</span><br></pre></td></tr></table></figure><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>Because behaviour. In fact, </p><p>permits the caller to pass for the second parameter, also supports this is the one that implements the “if is nil , use </p><p>for one parameter may lead the caller into thinking they can pass for both parameters. However calling like this, </p><p>results in an ugly panic.<br> TIP Don’t mix nil and non nil-able parameters in the same function signature. </p><p>The author of was trying to make the API user’s life easier in the common case, but possibly made the package harder to use safely. </p><p>There is no difference in line count between using explicitly, or implicitly via . </p><p>verses </p><p>and a was this confusion really worth saving one line? </p><p>TIP </p><p>Give serious consideration to how much time helper functions will save the programmer. Clear is better than concise. </p><p>Avoid public APIs with test only parameters </p><p>TIP Avoid exposing APIs with values who only differ in test scope. Instead, use Public wrappers to hide those parameters, use test scoped helpers to set the property in test scope. </p><p>6.2.2. Prefer var args to []T parameters </p><p>It’s very common to write a function or method that takes a slice of values. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>25/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This is just an example I made up, but its common to a lot of code I’ve worked on. The problem with signatures like these is they presume that they will be called with more than one entry. However, what I have found is many times these type of functions are called with only one argument, which has to be “boxed” inside a slice just to meet the requirements of the functions signature. </p><p>Additionally, because the ids parameter is a slice, you can pass an empty slice or nil to the function and the compiler will be happy. This adds extra testing load because you should cover these cases in your testing. </p><p>To give an example of this class of API, recently I was refactoring a piece of logic that required me to set some extra fields if at least one of a set of parameters was non zero. The logic looked like this: </p><p>As the if statement was getting very long I wanted to pull the logic of the check out into its own function. This is what I came up with: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if svc.MaxConnections &gt; 0 || svc.MaxPendingRequests &gt; 0 || svc.MaxRequests &gt; 0 ||</span><br><span class="line">svc.MaxRetries &gt; 0 &#123;</span><br><span class="line">    // apply the non zero parameters</span><br><span class="line">&#125;</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(values ...int) bool &#123;</span><br><span class="line">    for _, v := range values &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br></pre></td></tr></table></figure><p>return true } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>This enabled me to make the condition where the inner block will be executed clear to the reader: </p><p>However there is a problem with anyPositive , someone could accidentally invoke it like this if anyPositive() { … } </p><p>In this case anyPositive would return false because it would execute zero iterations and immediately return false . This isn’t the worst thing in the world — that would be if anyPositive returned true when passed no </p><p>arguments. </p><p>Nevertheless it would be be better if we could change the signature of anyPositive to enforce that the caller should pass at least one argument. We can do that by combining normal and vararg parameters like this: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        // apply the non zero parameters</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 26/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now anyPositive cannot be called with less than one argument. 6.3. Let functions dene the behaviour they requires </p><p>Let’s say I’ve been given a task to write a function that persists a Document structure to disk. </p><p>I could specify this function, Save, which takes an *os.File as the destination to write the Document . But this has a few problems </p><p>The signature of Save precludes the option to write the data to a network location. Assuming that network storage is likely to become requirement later, the signature of this function would have to change, impacting all its callers. </p><p>Save is also unpleasant to test, because it operates directly with files on disk. So, to verify its operation, the test would have to read the contents of the file after being written. </p><p>And I would have to ensure that f was written to a temporary location and always removed afterwards. </p><p><em>os.File also defines a lot of methods which are not relevant to , like reading directories and checking to see if a path is a symlink. It would be useful if the signature of the function could describe only the parts of </em>os.File that were relevant. </p><p>What can we do ? </p><p>Using io.ReadWriteCloser we can apply the interface segregation principle to redefine Save to take an interface that describes more general file shaped things. </p><p>With this change, any type that implements the io.ReadWriteCloser interface can be substituted for the previous *os.File . </p><p>This makes Save both broader in its application, and clarifies to the caller of Save which methods of the *os.File type are relevant to its operation. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the file f.</span><br><span class="line">func Save(f *os.File, doc *Document) error</span><br></pre></td></tr></table></figure><p>Save </p><p>Save </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// ReadWriterCloser.</span><br><span class="line">func Save(rwc io.ReadWriteCloser, doc *Document) error</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(first int, rest ...int) bool &#123;</span><br><span class="line">    if first &gt; 0 &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    for _, v := range rest &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br><span class="line">            return true</span><br></pre></td></tr></table></figure><p>} } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 27/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>And as the author of I no longer have the option to call those unrelated methods on as it is hidden behind the interface. </p><p>But we can take the interface segregation principle a bit further. </p><p>Firstly, it is unlikely that if Save follows the single responsibility principle, it will read the file it just wrote to verify its contents—that should be responsibility of another piece of code. </p><p>So we can narrow the specification for the interface we pass to Save to just writing and closing.<br> Secondly, by providing Save with a mechanism to close its stream, which we inherited in this desire to make it still </p><p>look like a file, this raises the question of under what circumstances will wc be closed.<br> Possibly Save will call Close unconditionally, or perhaps Close will be called in the case of success. </p><p>This presents a problem for the caller of Save as it may want to write additional data to the stream after the document is written. </p><p>A better solution would be to redefine Save to take only an io.Writer , stripping it completely of the responsibility to do anything but write data to a stream. </p><p>By applying the interface segregation principle to our Save function, the results has simultaneously been a function which is the most specific in terms of its requirements—it only needs a thing that is writable—and the most general in its function, we can now use Save to save our data to anything which implements io.Writer. </p><p>\7. Error handling </p><p>I’ve given several presentations about error handling [8] and written a lot about error handling on my blog. I also spoke a lot about error handling in yesterday’s session so I won’t repeat what I’ve said. </p><p><a href="https://dave.cheney.net/2014/12/24/inspecting-errors" target="_blank" rel="noopener">https://dave.cheney.net/2014/12/24/inspecting-errors</a> <a href="https://dave.cheney.net/2016/04/07/constant-errors" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/07/constant-errors</a> </p><p>Instead I want to cover two other areas related to error handling. </p><p>7.1. Eliminate error handling by eliminating errors </p><p>If you were in my presentation yesterday I talked about the draft proposals for improving error handling. But do you know what is better than an improved syntax for handling errors? Not needing to handle errors at all. </p><p>Save </p><p>*os.File </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// WriteCloser.</span><br><span class="line">func Save(wc io.WriteCloser, doc *Document) error</span><br><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// Writer.</span><br><span class="line">func Save(w io.Writer, doc *Document) error</span><br></pre></td></tr></table></figure><p>NOTE </p><p>I’m not saying “remove your error handling”. What I am suggesting is, change your code so you do not have errors to handle. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ReadWriteCloser</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 28/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This section draws inspiration from John Ousterhout’s recently book, A philosophy of Software Design [9]. One of the chapters in that book is called “Define Errors Out of Existence”. We’re going to try to apply this advice to Go. </p><p>7.1.1. Counting lines </p><p>Let’s write a function to count the number of lines in a file. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    var (</span><br><span class="line">        br    = bufio.NewReader(r)</span><br><span class="line">        lines int</span><br><span class="line">        err   error</span><br></pre></td></tr></table></figure><p>) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    _, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">    lines++</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>break } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if err != io.EOF &#123;</span><br><span class="line">    return 0, err</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>Because we’re following our advice from previous sections, CountLines takes an io.Reader, not a *File; its the job of the caller to provide the io.Reader who’s contents we want to count. </p><p>We construct a bufio.Reader , and then sit in a loop calling the ReadString method, incrementing a counter until we reach the end of the file, then we return the number of lines read. </p><p>At least that’s the code we want to write, but instead this function is made more complicated by error handling. For example, there is this strange construction, </p><p>We increment the count of lines before checking the error—that looks odd.<br> The reason we have to write it this way is ReadString will return an error if it encounters and end-of-file before </p><p>hitting a newline character. This can happen if there is no final newline in the file.<br> To try to fix this, we rearrange the logic to increment the line count, then see if we need to exit the loop. </p><p>NOTE this logic still isn’t perfect, can you spot the bug? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">lines++</span><br><span class="line">if err != nil &#123;</span><br></pre></td></tr></table></figure><p>break } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 29/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>But we’re not done checking errors yet. will return when it hits the end of the file. This is expected,                                  needs some way of saying stop, there is nothing more to read. So before we return the error to the caller of                                  , we need to check if the error was not io.EOF , and in that case propagate it up, otherwise we return nil to say that everything worked fine. </p><p>I think this is a good example of Russ Cox’s observation that error handling can obscure the operation of the function. Let’s look at an improved version. </p><p>ReadString </p><p>io.EOF </p><p>ReadString </p><p>CountLine </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    sc := bufio.NewScanner(r)</span><br><span class="line">    lines := 0</span><br><span class="line">    for sc.Scan() &#123;</span><br><span class="line">        lines++</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>This improved version switches from using bufio.Reader to bufio.Scanner . </p><p>Under the hood bufio.Scanner uses , but it adds a nice layer of abstraction which helps remove the error handling with obscured the operation of                                  . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Reader</span><br></pre></td></tr></table></figure><p>CountLines </p><p>NOTE </p><p>The method, the body of our </p><p>bufio.Scanner can scan for any pattern, but by default it looks for newlines. </p><p>returns true if the scanner has matched a line of text and has not encountered an error. So, loop will be called only when there is a line of text in the scanner’s buffer. This means our revised </p><p>sc.Scan() </p><p>for </p><p>CountLines correctly handles the case where there is no trailing newline, and also handles the case where the file was empty. </p><p>Secondly, as sc.Scan returns false once an error is encountered, our for loop will exit when the end-of-file is reached or an error is encountered. The type memoises the first error it encountered and we can recover that error once we’ve exited the loop using the method. </p><p>Lastly, sc.Err() takes care of handling io.EOF and will convert it to a nil if the end of file was reached without encountering another error. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Scanner</span><br></pre></td></tr></table></figure><p>sc.Err() </p><p>TIP </p><p>When you find yourself faced with overbearing error handling, try to extract some of the operations into a helper type. </p><p>7.1.2. WriteResponse </p><p>My second example is inspired from the Errors are values blog post [10]. </p><p>Earlier in this presentation We’ve seen examples dealing with opening, writing and closing files. The error handling is present, but not overwhelming as the operations can be encapsulated in helpers like ioutil.ReadFile and </p><p>ioutil.WriteFile . However when dealing with low level network protocols it becomes necessary to build the response directly using I/O primitives the error handling can become repetitive. Consider this fragment of a HTTP server which is constructing the HTTP response. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 30/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>First we construct the status line using fmt.Fprintf , and check the error. Then for each header we write the header key and value, checking the error each time. Lastly we terminate the header section with an additional \r\n , check the error, and copy the response body to the client. Finally, although we don’t need to check the error from io.Copy , we need to translate it from the two return value form that io.Copy returns into the single return value that </p><p>WriteResponse returns.<br> That’s a lot of repetitive work. But we can make it easier on ourselves by introducing a small wrapper type, </p><p>errWriter . </p><p>errWriter fulfils the io.Writer contract so it can be used to wrap an existing io.Writer . errWriter passes writes through to its underlying writer until an error is detected. From that point on, it discards any writes and returns the previous error. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Header struct &#123;</span><br><span class="line">    Key, Value string</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status struct &#123;</span><br><span class="line">    Code   int</span><br><span class="line">    Reason string</span><br><span class="line">&#125;</span><br><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, h := range headers &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if _, err := fmt.Fprint(w, &quot;\r\n&quot;); err != nil &#123;</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(w, body)</span><br></pre></td></tr></table></figure><p>return err } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 31/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Applying errWriter to WriteResponse dramatically improves the clarity of the code. Each of the operations no longer needs to bracket itself with an error check. Reporting the error is moved to the end of the function by inspecting the ew.err field, avoiding the annoying translation from `io.Copy’s return values. </p><p>7.2. Only handle an error once </p><p>Lastly, I want to mention that you should only handle errors once. Handling an error means inspecting the error value, and making a single decision. </p><p>If you make less than one decision, you’re ignoring the error. As we see here, the error from w.WriteAll is being discarded. </p><p>But making more than one decision in response to a single error is also problematic. The following is code that I come across frequently. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// WriteAll writes the contents of buf to the supplied writer.</span><br><span class="line">func WriteAll(w io.Writer, buf []byte) &#123;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.Write(buf)</span><br><span class="line">type errWriter struct &#123;</span><br><span class="line">    io.Writer</span><br></pre></td></tr></table></figure><p>err error } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (e *errWriter) Write(buf []byte) (int, error) &#123;</span><br><span class="line">    if e.err != nil &#123;</span><br><span class="line">        return 0, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    var n int</span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    return n, nil</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    for _, h := range headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Fprint(ew, &quot;\r\n&quot;)</span><br><span class="line">io.Copy(ew, body)</span><br><span class="line">return ew.err</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Println(&quot;unable to write:&quot;, err) // annotated error goes to log file</span><br><span class="line">        return err                           // unannotated error returned to caller</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>return nil } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 32/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>In this example if an error occurs during , a line will be written to a log file, noting the file and line that the error occurred, and the error is also returned to the caller, who possibly will log it, and return it, all the way back up to the top of the program. </p><p>The caller is probably doing the same </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">    log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><p>GO </p><p>So you get a stack of duplicate lines in your log file, </p><p>but at the top of the program you get the original error without any context. </p><p>I want to dig into this a little further because I don’t see the problems with logging and returning as just a matter of personal preference. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br><span class="line">err := WriteConfig(f, &amp;conf)</span><br><span class="line">fmt.Println(err) // io.EOF</span><br><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">        // oops, forgot to return</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">        return err</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><p>GO </p><p>The problem I see a lot is programmers forgetting to return from an error. As we talked about earlier, Go style is to use guard clauses, checking preconditions as the function progresses and returning early. </p><p>In this example the author checked the error, logged it, but forgot to return. This has caused a subtle bug. </p><p>w.Write </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 33/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The contract for error handling in Go says that you cannot make any assumptions about the contents of other return values in the presence of an error. As the JSON marshalling failed, the contents of buf are unknown, maybe it contains nothing, but worse it could contain a 1/2 written JSON fragment. </p><p>Because the programmer forgot to return after checking and logging the error, the corrupt buffer will be passed to WriteAll , which will probably succeed and so the config file will be written incorrectly. However the function will </p><p>return just fine, and the only indication that a problem happened will be a single log line complaining about marshalling JSON, not a failure to write the config. </p><p>7.2.1. Adding context to errors </p><p>The bug occurred because the author was trying to add context to the error message. They were trying to leave themselves a breadcrumb to point them back to the source of the error. </p><p>Let’s look at another way to do the same thing using fmt.Errorf . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not write config: %v&quot;, err)</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;write failed: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>return nil } </p><p>GO </p><p>By combining the annotation of the error with returning onto one line there it is harder to forget to return an error and avoid continuing accidentally. </p><p>If an I/O error occurs writing the file, the error’s `Error() method will report something like this; could not write config: write failed: input/output error </p><p>7.2.2. Wrapping errors with github.com/pkg/errors </p><p>The fmt.Errorf pattern works well for annotating the error message, but it does so at the cost of obscuring the type of the original error. I’ve argued that treating errors as opaque values is important to producing software which is loosely coupled, so the face that the type of the original error should not matter if the only thing you do with an error value is </p><p>\1. Check that it is not nil . 2. Print or log it. </p><p>However there are some cases, I believe they are infrequent, where you do need to recover the original error. In that case you can use something like my errors package to annotate errors like this </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 34/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now the error reported will be the nice K&amp;D [11] style error, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure><p>and the error value retains a reference to the original cause. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;original error: %T %v\n&quot;, errors.Cause(err), errors.Cause(err))</span><br><span class="line">        fmt.Printf(&quot;stack trace:\n%+v\n&quot;, err)</span><br><span class="line">        os.Exit(1)</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>Thus you can recover the original error and print a stack trace; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadFile(path string) ([]byte, error) &#123;</span><br><span class="line">    f, err := os.Open(path)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;open failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close()</span><br><span class="line">    buf, err := ioutil.ReadAll(f)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;read failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return buf, nil</span><br><span class="line">&#125;</span><br><span class="line">func ReadConfig() ([]byte, error) &#123;</span><br><span class="line">    home := os.Getenv(&quot;HOME&quot;)</span><br><span class="line">    config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;))</span><br><span class="line">    return config, errors.WithMessage(err, &quot;could not read config&quot;)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br></pre></td></tr></table></figure><p>os.Exit(1) } </p><p>} </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 35/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Using the errors package gives you the ability to add context to error values, in a way that is inspectable by both a human and a machine. If you came to my presentation yesterday you’ll know that wrapping is moving into the standard library in an upcoming Go release. </p><p>\8. Concurrency </p><p>Often Go is chosen for a project because of its concurrency features. The Go team have gone to great lengths to make concurrency in Go cheap (in terms of hardware resources) and performant, however it is possible to use Go’s concurrency features to write code which is neither performent or reliable. With the time I have left I want to leave you with some advice for avoid some of the pitfalls that come with Go’s concurrency features. </p><p>Go features first class support for concurrency with channels, and the select and go statements. If you’ve learnt Go formally from a book or training course, you might have noticed that the concurrency section is always one of the last you’ll cover. This workshop is no different, I have chosen to cover concurrency last, as if it is somehow additional to the regular the skills a Go programmer should master. </p><p>There is a dichotomy here; Go’s headline feature is our simple, lightweight concurrency model. As a product, our language almost sells itself on this on feature alone. On the other hand, there is a narrative that concurrency isn’t actually that easy to use, otherwise authors wouldn’t make it the last chapter in their book and we wouldn’t look back on our formative efforts with regret. </p><p>This section discusses some pitfalls of naive usage of Go’s concurrency features. </p><p>8.1. Keep yourself busy or do the work yourself </p><p>What is the problem with this program? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 36/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The program does what we intended, it serves a simple web server. However it also does something else at the same time, it wastes CPU in an infinite loop. This is because the for{} on the last line of main is going to block the main goroutine because it doesn’t do any IO, wait on a lock, send or receive on a channel, or otherwise communicate with the scheduler. </p><p>As the Go runtime is mostly cooperatively scheduled, this program is going to spin fruitlessly on a single CPU, and may eventually end up live-locked. </p><p>How could we fix this? Here’s one suggestion. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” </p><p>“runtime” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    runtime.Gosched()</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>package main </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><p>for { </p><p>} } </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 37/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This might look silly, but it’s a common common solution I see in the wild. It’s symptomatic of not understanding the underlying problem. </p><p>Now, if you’re a little more experienced with go, you might instead write something like this. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><p>select {} } </p><p>GO </p><p>An empty select statement will block forever. This is a useful property because now we’re not spinning a whole CPU just to call runtime.GoSched() . However, we’re only treating the symptom, not the cause. </p><p>I want to present to you another solution, one which has hopefully already occurred to you. Rather than run<br> in a goroutine, leaving us with the problem of what to do with the main goroutine, simply run </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe</span><br><span class="line">http.ListenAndServe</span><br></pre></td></tr></table></figure><p>TIP </p><p>on the main goroutine itself. </p><p>If the main.main function of a Go program returns then the Go program will unconditionally exit no matter what other goroutines started by the program over time are doing. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>So this is my first piece of advice: if your goroutine cannot make progress until it gets the result from another, oftentimes it is simpler to just do the work yourself rather than to delegate it. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 38/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This often eliminates a lot of state tracking and channel manipulation required to plumb a result back from a goroutine to its initiator. </p><p>TIP </p><p>Many Go programmers overuse goroutines, especially when they are starting out. As with all things in life, moderation is the key the key to success. </p><p>8.2. Leave concurrency to the caller </p><p>What is the difference between these two APIs? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ListDirectory returns the contents of dir.</span><br><span class="line">func ListDirectory(dir string) ([]string, error)</span><br><span class="line">// ListDirectory returns a channel over which</span><br><span class="line">// directory entries will be published. When the list</span><br><span class="line">// of entries is exhausted, the channel will be closed.</span><br><span class="line">func ListDirectory(dir string) chan string</span><br></pre></td></tr></table></figure><p>Firstly, the obvious differences; the first example reads a directory into a slice then returns the whole slice, or an error if something went wrong. This happens synchronously, the caller of ListDirectory blocks until all directory entries have been read. Depending on how large the directory, this could take a long time, and could potentially allocate a lot of memory building up the slide of directory entry names. </p><p>Lets look at the second example. This is a little more Go like, ListDirectory returns a channel over which directory entries will be passed. When the channel is closed, that is your indication that there are no more directory entries. As the population of the channel happens after ListDirectory returns, ListDirectory is probably starting a goroutine to populate the channel. </p><p>NOTE </p><p>Its not necessary for the second version to actually use a Go routine; it could allocate a channel sufficient to hold all the directory entries without blocking, fill the channel, close it, then return the channel to the caller. But this is unlikely, as this would have the same problems with consuming a large amount of memory to buffer all the results in a channel. </p><p>The channel version of ListDirectory has two further problems: </p><p>By using a closed channel as the signal that there are no more items to process there is no way for ListDirectory to tell the caller that the set of items returned over the channel is incomplete because an error was encountered partway through. There is no way for the caller to tell the difference between an empty directory and an error to read from the directory entirely. Both result in a channel returned from ListDirectory which appears to be closed immediately. </p><p>The caller must continue to read from the channel until it is closed because that is the only way the caller can know that the goroutine which was started to fill the channel has stopped. This is a serious limitation on the use of </p><p>ListDirectory , the caller has to spend time reading from the channel even though it may have received the answer it wanted. It is probably more efficient in terms of memory usage for medium to large directories, but this method is no faster than the original slice based method. </p><p>The solution to the problems of both implementations is to use a callback, a function that is called in the context of each directory entry as it is executed. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 39/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Not surprisingly this is how the filepath.WalkDir function works. </p><p>If your function starts a goroutine you must provide the caller with a way to explicitly stop that TIP goroutine. It is often easier to leave decision to execute a function asynchronously to the caller of </p><p>that function. </p><p>8.3. Never start a goroutine without when it will stop. </p><p>The previous example showed using a goroutine when one wasn’t really necessary. But one of the driving reasons for using Go is the first class concurrency features the language offers. Indeed there are many instances where you want to exploit the parallelism available in your hardware. To do so, you must use goroutines. </p><p>This simple application serves http traffic on two different ports, port 8080 for application traffic and port 8001 for access to the /debug/pprof endpoint. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br></pre></td></tr></table></figure><p>“net/http” </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    _ &quot;net/http/pprof&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux) // debug</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)                       // app traffic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>Although this program isn’t very complicated, it represents the basis of a real application. </p><p>There are a few problems with the application as it stands which will reveal themselves as the application grows, so lets address a few of them now. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ListDirectory(dir string, fn func(string))</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 40/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>By breaking the serveApp and serveDebug handlers out into their own functions we’ve decoupled them from main.main . We’ve also followed the advice from above and make sure that serveApp and serveDebug leave their </p><p>concurrency to the caller. </p><p>But there are some operability problems with this program. If serveApp returns then main.main will return causing the program to shutdown and be restarted by whatever process manager you’re using. </p><p>TIP </p><p>Just as functions in Go leave concurrency to the caller, applications should leave the job of monitoring their status and restarting them if they fail to the program that invoked them. Do not make your applications responsible for restarting themselves, this is a procedure best handled from outside the application. </p><p>However, serveDebug is run in a separate goroutine and if it returns just that goroutine will exit while the rest of the program continues on. Your operations staff will not be happy to find that they cannot get the statistics out of your application when they want too because the /debug handler stopped working a long time ago. </p><p>What we want to ensure is that if any of the goroutines responsible for serving this application stop, we shut down the application. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() &#123;</span><br><span class="line">    http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br></pre></td></tr></table></figure><p>serveApp() } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 41/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now serverApp and serveDebug check the error returned from ListenAndServe and call if required. Because both handlers are running in goroutines, we park the main goroutine in a . </p><p>This approach has a number of problems: </p><p>\1. If ListenAndServer returns with a nil error, log.Fatal won’t be called and the HTTP service on that port will shut down without stopping the application. </p><p>\2. log.Fatal calls os.Exit which will unconditionally exit the program; defers won’t be called, other goroutines won’t be notified to shut down, the program will just stop. This makes it difficult to write tests for those functions. </p><p>TIP Only use log.Fatal from main.main or init functions. </p><p>What we’d really like is to pass any error that occurs back to the originator of the goroutine so that it can know why the goroutine stopped, can shut down the process cleanly. </p><p>log.Fatal </p><p>select{} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure><p>} } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func serveDebug() &#123;</span><br><span class="line">    if err := http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br><span class="line">    go serveApp()</span><br></pre></td></tr></table></figure><p>select {} } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 42/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>We can use a channel to collect the return status of the goroutine. The size of the channel is equal to the number of goroutines we want to manage so that sending to the done channel will not block, as this will block the shutdown the of goroutine, causing it to leak. </p><p>As there is no way to safely close the done channel we cannot use the for range idiom to loop of the channel until all goroutines have reported in, instead we loop for as many goroutines we started, which is equal to the capacity of the channel. </p><p>Now we have a way to wait for each goroutine to exit cleanly and log any error they encounter. All that is needed is a way to forward the shutdown signal from the first goroutine that exits to the others. </p><p>It turns out that asking a http.Server to shut down is a little involved, so I’ve spun that logic out into a helper function. The serve helper takes an address and http.Handler , similar to http.ListenAndServe , and also a stop channel which we use to trigger the Shutdown method. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() error &#123;</span><br><span class="line">    return http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug()</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp()</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 43/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now, each time we receive a value on the channel, we close the stop channel which causes all the goroutines waiting on that channel to shut down their . This in turn will cause all the remaining ListenAndServe goroutines to return. Once all the goroutines we started have stopped, main.main returns and the process stops cleanly. </p><p>done </p><p>http.Server </p><p>TIP </p><p>Writing this logic yourself is repetitive and subtle. Consider something like this package, <a href="https://github.com/heptio/workgroup" target="_blank" rel="noopener">https://github.com/heptio/workgroup</a> which will do most of the work for you. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func serve(addr string, handler http.Handler, stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    s := http.Server&#123;</span><br></pre></td></tr></table></figure><p>Addr: addr, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Handler: handler,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">    &lt;-stop // wait for stop signal</span><br><span class="line">    s.Shutdown(context.Background())</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">func serveApp(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return serve(&quot;0.0.0.0:8080&quot;, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    return serve(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux, stop)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    stop := make(chan struct&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug(stop)</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp(stop)</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stopped bool</span><br><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if !stopped &#123;</span><br><span class="line">        stopped = true</span><br><span class="line">        close(stop)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><ul><li>下面是David给出的一下关于go的学习参考资料的链接：</li></ul><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 44/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><ol><li><p><a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">https://gaston.life/books/effective-programming/</a></p></li><li><p><a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">https://talks.golang.org/2014/names.slide#4</a></p></li><li><p><a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p></li><li><p><a href="https://www.lysator.liu.se/c/pikestyle.html" target="_blank" rel="noopener">https://www.lysator.liu.se/c/pikestyle.html</a></p></li><li><p><a href="https://speakerdeck.com/campoy/understanding-nil" target="_blank" rel="noopener">https://speakerdeck.com/campoy/understanding-nil</a></p></li><li><p><a href="https://www.youtube.com/watch?v=Ic2y6w8lMPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p></li><li><p><a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p></li><li><p><a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="noopener">https://golang.org/doc/go1.4#internalpackages</a></p></li><li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p></li><li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p></li><li><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p></li><li><p><a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p></li><li><p><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a></p></li><li><p><a href="http://www.gopl.io/" target="_blank" rel="noopener">http://www.gopl.io/</a></p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      博客内容为GO专家David关于Go最佳实践的一些建议
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="GO QCon 技术分享" scheme="https://cloudsjhan.github.io/tags/GO-QCon-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之改善 Python 程序的 91 个建议（转载)</title>
    <link href="https://cloudsjhan.github.io/2018/10/21/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E6%94%B9%E5%96%84-Python-%E7%A8%8B%E5%BA%8F%E7%9A%84-91-%E4%B8%AA%E5%BB%BA%E8%AE%AE%EF%BC%88%E8%BD%AC%E8%BD%BD/"/>
    <id>https://cloudsjhan.github.io/2018/10/21/技术周刊之改善-Python-程序的-91-个建议（转载/</id>
    <published>2018-10-21T13:49:17.000Z</published>
    <updated>2018-10-21T13:54:09.690Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本篇博客转载自zhuanlan.zhihu.com/p/32817459。</p><p>除了Google的Python代码规范外，从来没有类似的书籍。偶然的机会看到这么一本书，读完之后觉得还不错，所以做个简单的笔记。有想学习类似知识的朋友，又懒得去读完整本书籍，可以参考一下。</p><h3 id="1：引论"><a href="#1：引论" class="headerlink" title="1：引论"></a><strong>1：引论</strong></h3><p>建议1、理解Pythonic概念—-详见Python中的《Python之禅》</p><p>建议2、编写Pythonic代码</p><p>（1）避免不规范代码，比如只用大小写区分变量、使用容易混淆的变量名、害怕过长变量名等。有时候长的变量名会使代码更加具有可读性。</p><p>（2）深入学习Python相关知识，比如语言特性、库特性等，比如Python演变过程等。深入学习一两个业内公认的Pythonic的代码库，比如Flask等。</p><p>建议3：理解Python与C的不同之处，比如缩进与{}，单引号双引号，三元操作符？，Switch-Case语句等。</p><p>建议4：在代码中适当添加注释</p><p>建议5：适当添加空行使代码布局更加合理</p><p>建议6：编写函数的4个原则</p><p>（1）函数设计要尽量短小，嵌套层次不宜过深</p><p>（2）函数声明应该做到合理、简单、易用</p><p>（3）函数参数设计应该考虑向下兼容</p><p>（4）一个函数只做一件事，尽量保证函数粒度的一致性</p><p>建议7：将常量集中在一个文件，且常量名尽量使用全大写字母</p><h3 id="2：编程惯用法"><a href="#2：编程惯用法" class="headerlink" title="2：编程惯用法"></a><strong>2：编程惯用法</strong></h3><p>建议8：利用assert语句来发现问题，但要注意，断言assert会影响效率</p><p>建议9：数据交换值时不推荐使用临时变量，而是直接a, b = b, a</p><p>建议10：充分利用惰性计算（Lazy evaluation）的特性，从而避免不必要的计算</p><p>建议11：理解枚举替代实现的缺陷（最新版Python中已经加入了枚举特性）</p><p>建议12：不推荐使用type来进行类型检查，因为有些时候type的结果并不一定可靠。如果有需求，建议使用isinstance函数来代替</p><p>建议13：尽量将变量转化为浮点类型后再做除法（Python3以后不用考虑）</p><p>建议14：警惕eval()函数的安全漏洞，有点类似于SQL注入</p><p>建议15：使用enumerate()同时获取序列迭代的索引和值</p><p>建议16：分清==和is的适用场景，特别是在比较字符串等不可变类型变量时（详见评论）</p><p>建议17：尽量使用Unicode。在Python2中编码是很让人头痛的一件事，但Python3就不用过多考虑了</p><p>建议18：构建合理的包层次来管理Module</p><h3 id="3：基础用法"><a href="#3：基础用法" class="headerlink" title="3：基础用法"></a><strong>3：基础用法</strong></h3><p>建议19：有节制的使用from…import语句，防止污染命名空间</p><p>建议20：优先使用absolute import来导入模块（Python3中已经移除了relative import）</p><p>建议21：i+=1不等于++i，在Python中，++i前边的加号仅表示正，不表示操作</p><p>建议22：习惯使用with自动关闭资源，特别是在文件读写中</p><p>建议23：使用else子句简化循环（异常处理）</p><p>建议24：遵循异常处理的几点基本原则</p><p>（1）注意异常的粒度，try块中尽量少写代码</p><p>（2）谨慎使用单独的except语句，或except Exception语句，而是定位到具体异常</p><p>（3）注意异常捕获的顺序，在合适的层次处理异常</p><p>（4）使用更加友好的异常信息，遵守异常参数的规范</p><p>建议25：避免finally中可能发生的陷阱</p><p>建议26：深入理解None，正确判断对象是否为空。Python中下列数据会判断为空：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2nJcvp2sZwpqMdESQCm3pUhzcPcBsOyWfj6NJ0vIT3D6AVHMzZLCjmA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>建议27：连接字符串应优先使用join函数，而不是+操作</p><p>建议28：格式化字符串时尽量使用.format函数，而不是%形式</p><p>建议29：区别对待可变对象和不可变对象，特别是作为函数参数时</p><p>建议30：[], {}和()：一致的容器初始化形式。使用列表解析可以使代码更清晰，同时效率更高</p><p>建议31：函数传参数，既不是传值也不是传引用，而是传对象或者说对象的引用</p><p>建议32：警惕默认参数潜在的问题，特别是当默认参数为可变对象时</p><p>建议33：函数中慎用变长参数*args和**kargs</p><p>（1）这种使用太灵活，从而使得函数签名不够清晰，可读性较差</p><p>（2）如果因为函数参数过多而是用变长参数简化函数定义，那么一般该函数可以重构</p><p>建议34：深入理解str()和repr()的区别</p><p>（1）两者之间的目标不同：str主要面向客户，其目的是可读性，返回形式为用户友好性和可读性都比较高的字符串形式；而repr是面向Python解释器或者说Python开发人员，其目的是准确性，其返回值表示Python解释器内部的定义</p><p>（2）在解释器中直接输入变量，默认调用repr函数，而print(var)默认调用str函数</p><p>（3）repr函数的返回值一般可以用eval函数来还原对象</p><p>（4）两者分别调用对象的内建函数<strong>str__()和__repr</strong>()</p><p>建议35：分清静态方法staticmethod和类方法classmethod的使用场景</p><h3 id="4：库"><a href="#4：库" class="headerlink" title="4：库"></a><strong>4：库</strong></h3><p>建议36：掌握字符串的基本用法</p><p>建议37：按需选择sort()和sorted()函数</p><p>》sort()是列表在就地进行排序，所以不能排序元组等不可变类型。</p><p>》sorted()可以排序任意的可迭代类型，同时不改变原变量本身。</p><p>建议38：使用copy模块深拷贝对象，区分浅拷贝（shallow copy）和深拷贝（deep copy）</p><p>建议39：使用Counter进行计数统计，Counter是字典类的子类，在collections模块中</p><p>建议40：深入掌握ConfigParser</p><p>建议41：使用argparse模块处理命令行参数</p><p>建议42：使用pandas处理大型CSV文件</p><p>》Python本身提供一个CSV文件处理模块，并提供reader、writer等函数。</p><p>》Pandas可提供分块、合并处理等，适用于数据量大的情况，且对二维数据操作更方便。</p><p>建议43：使用ElementTree解析XML</p><p>建议44：理解模块pickle的优劣</p><p>》优势：接口简单、各平台通用、支持的数据类型广泛、扩展性强</p><p>》劣势：不保证数据操作的原子性、存在安全问题、不同语言之间不兼容</p><p>建议45：序列化的另一个选择JSON模块：load和dump操作</p><p>建议46：使用traceback获取栈信息</p><p>建议47：使用logging记录日志信息</p><p>建议48：使用threading模块编写多线程程序</p><p>建议49：使用Queue模块使多线程编程更安全</p><h3 id="5：设计模式"><a href="#5：设计模式" class="headerlink" title="5：设计模式"></a><strong>5：设计模式</strong></h3><p>建议50：利用模块实现单例模式</p><p>建议51：用mixin模式让程序更加灵活</p><p>建议52：用发布-订阅模式实现松耦合</p><p>建议53：用状态模式美化代码</p><h3 id="6：内部机制"><a href="#6：内部机制" class="headerlink" title="6：内部机制"></a><strong>6：内部机制</strong></h3><p>建议54：理解build-in对象</p><p>建议55：<strong>init__()不是构造方法，理解__new</strong>()与它之间的区别</p><p>建议56：理解变量的查找机制，即作用域</p><p>》局部作用域</p><p>》全局作用域</p><p>》嵌套作用域</p><p>》内置作用域</p><p>建议57：为什么需要self参数</p><p>建议58：理解MRO（方法解析顺序）与多继承</p><p>建议59：理解描述符机制</p><p>建议60：区别<strong>getattr__()与__getattribute</strong>()方法之间的区别</p><p>建议61：使用更安全的property</p><p>建议62：掌握元类metaclass</p><p>建议63：熟悉Python对象协议</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2mTYUZQBgtMVG5BQzVEnnkMDu5U9MzPJp99DzicxZ6hUjT03ib6wicwalw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>建议64：利用操作符重载实现中缀语法</p><p>建议65：熟悉Python的迭代器协议</p><p>建议66：熟悉Python的生成器</p><p>建议67：基于生成器的协程和greenlet，理解协程、多线程、多进程之间的区别</p><p>建议68：理解GIL的局限性</p><p>建议69：对象的管理和垃圾回收</p><h3 id="7：使用工具辅助项目开发"><a href="#7：使用工具辅助项目开发" class="headerlink" title="7：使用工具辅助项目开发"></a><strong>7：使用工具辅助项目开发</strong></h3><p>建议70：从PyPI安装第三方包</p><p>建议71：使用pip和yolk安装、管理包</p><p>建议72：做paster创建包</p><p>建议73：理解单元测试的概念</p><p>建议74：为包编写单元测试</p><p>建议75：利用测试驱动开发（TDD）提高代码的可测性</p><p>建议76：使用Pylint检查代码风格</p><p>》代码风格审查</p><p>》代码错误检查</p><p>》发现重复以及不合理的代码，方便重构</p><p>》高度的可配置化和可定制化</p><p>》支持各种IDE和编辑器的集成</p><p>》能够基于Python代码生成UML图</p><p>》能够与Jenkins等持续集成工具相结合，支持自动代码审查</p><p>建议77：进行高效的代码审查</p><p>建议78：将包发布到PyPI</p><h3 id="8：性能剖析与优化"><a href="#8：性能剖析与优化" class="headerlink" title="8：性能剖析与优化"></a><strong>8：性能剖析与优化</strong></h3><p>建议79：了解代码优化的基本原则</p><p>建议80：借助性能优化工具</p><p>建议81：利用cProfile定位性能瓶颈</p><p>建议82：使用memory_profiler和objgraph剖析内存使用</p><p>建议83：努力降低算法复杂度</p><p>建议84：掌握循环优化的基本技巧</p><p>》减少循环内部的计算</p><p>》将显式循环改为隐式循环，当然这会牺牲代码的可读性</p><p>》在循环中尽量引用局部变量</p><p>》关注内层嵌套循环</p><p>建议85：使用生成器提高效率</p><p>建议86：使用不同的数据结构优化性能</p><p>建议87：充分利用set的优势</p><p>建议88：使用multiprocessing模块克服GIL缺陷</p><p>建议89：使用线程池提高效率</p><p>建议90：使用C/C++模块扩展提高性能</p><p>建议91：使用Cythonb编写扩展模块</p><hr>]]></content>
    
    <summary type="html">
    
      如何写出规范优雅的Python代码
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
      <category term="编程规范" scheme="https://cloudsjhan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之基于beego web框架的RESTful API的构建之旅</title>
    <link href="https://cloudsjhan.github.io/2018/10/14/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E5%9F%BA%E4%BA%8Ebeego-web%E6%A1%86%E6%9E%B6%E7%9A%84RESTful-API%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
    <id>https://cloudsjhan.github.io/2018/10/14/技术周刊之基于beego-web框架的RESTful-API的构建之旅/</id>
    <published>2018-10-14T07:44:03.000Z</published>
    <updated>2018-10-14T10:10:09.837Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    beego是一个快速开发GO应用的http框架，作者是go语言方向的大牛，astaxie。beego可以用来快速开发API、web、后端服务等应用，是一个RESTFul风格的框架，主要的设计灵感来自于Python web开发框架tornado、flask、sinstra，很好的结合了Go语言本身的一些特性（interface，struct继承等）。</p><p>​    beego是基于八大独立模块来实现的，很好的实现了模块间的解耦，即使用户不使用http的逻辑，也可以很好的使用其中的各个模块。作者自己说，他的这种思想来自于乐高积木，设计beego的时候，这些模块就是积木，而最终搭建好的机器人就是beego。</p><p>​    这篇博文通过使用beego来构建API，讲解实现过程中的细节以及遇到的一些坑，让我们马上开始beego的API构建之旅吧！</p><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><ul><li>进入到你的$GOPATH/src</li><li>安装beego开发包自己快速开发工具bee</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/astaxie/beego</span><br><span class="line"><span class="keyword">go</span> get github.com/astaxie/beego/orm</span><br><span class="line"><span class="keyword">go</span> get github.com/beego/bee</span><br></pre></td></tr></table></figure><ul><li>使用快速开发工具bee，创建我们的API项目</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bee <span class="built_in">new</span> firstAPI</span><br></pre></td></tr></table></figure><p>我们得到的项目结构如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw7uxgc1sqj314q03gwev.jpg" alt=""></p><p>可以看出这是一个典型的MVC架构的应用，beego把我们项目所需要的一些都准备好了，例如配置文件conf，测试文件tests等，我们只需要专注于API代码的编写即可。</p><h3 id="运行项目并获得API自动化文档"><a href="#运行项目并获得API自动化文档" class="headerlink" title="运行项目并获得API自动化文档"></a>运行项目并获得API自动化文档</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bee run -gendoc=<span class="literal">true</span> -downdoc=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>运行上述代码输出如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw7v5dfquwj31kw0skn3a.jpg" alt=""></p><p>我们在浏览器中访问：本机IP：8080/swagger，就会看到swagger的API文档，我们代码更新后，该文档就会自动更新，非常方便。</p><h3 id="models设计"><a href="#models设计" class="headerlink" title="models设计"></a>models设计</h3><ul><li>对 数据库object 操作有四个方法 Read / Insert / Update / Delete</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">"slene"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(o.Insert(user))</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">"Your"</span></span><br><span class="line">fmt.Println(o.Update(user))</span><br><span class="line">fmt.Println(o.Read(user))</span><br><span class="line">fmt.Println(o.Delete(user))</span><br></pre></td></tr></table></figure><p>还有其他的方法可以参阅beego<a href="https://beego.me/docs/mvc/model/object.md" target="_blank" rel="noopener">官方文档</a>，里面对orm操作有着详细的介绍。</p><ul><li>创建一个数据库并设计一张数据库表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`Id` int(11),</span><br><span class="line">`Name` varchar(255),</span><br><span class="line">`Birthdate` varchar(255),</span><br><span class="line">`Gender` bool,</span><br><span class="line">`Score` int(11)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>在models文件夹下新建一个文件Student.go,并实现以下代码，代码中关键点都有注释</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在models模块中创建一个struct，目的是使用beego的orm框架，使struct与数据库中的字段产生对应关系</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int</span><span class="string">`orm:"column(Id)"`</span> <span class="comment">//column()括号中的字段就是在定义数据库时的相应字段，这一段必须严格填写，不然在API读写数据时就会出现读不到或者写不进去的问题</span></span><br><span class="line">Name <span class="keyword">string</span>  <span class="string">`orm:"column(Name)"`</span></span><br><span class="line">BirthDate <span class="keyword">string</span> <span class="string">`orm:"column(Birthdate)"`</span></span><br><span class="line">Gender <span class="keyword">bool</span> <span class="string">`orm:"column(Gender)"`</span></span><br><span class="line">Score <span class="keyword">int</span> <span class="string">`orm:"column(Score)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数获得数据库中所有student的信息，返回值是一个结构体数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAllStudents</span><span class="params">()</span> []*<span class="title">Student</span></span> &#123;</span><br><span class="line">o := orm.NewOrm() <span class="comment">//产生一个orm对象</span></span><br><span class="line">o.Using(<span class="string">"default"</span>) <span class="comment">//这句话的意思是使用定义的默认数据库，与main.go中的orm.RegisterDataBase()对应</span></span><br><span class="line"><span class="keyword">var</span> students []*Student <span class="comment">//定义指向结构体数组的指针</span></span><br><span class="line">q := o.QueryTable(<span class="string">"student"</span>)<span class="comment">//获得一个数据库表的请求</span></span><br><span class="line">q.All(&amp;students)<span class="comment">//取到这个表中的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> students</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数根据student中的Id，返回该学生的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStudentById</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Student</span></span> &#123;</span><br><span class="line">u := Student&#123;Id:id&#125;<span class="comment">//根据所传入的Id得到对应student的对象</span></span><br><span class="line">o := orm.NewOrm()<span class="comment">//new 一个orm对象</span></span><br><span class="line">o.Using(<span class="string">"default"</span>)<span class="comment">//使用最开始定义的default数据库</span></span><br><span class="line">err := o.Read(&amp;u)<span class="comment">//读取Id=id的student的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == orm.ErrNoRows &#123;</span><br><span class="line">fmt.Println(<span class="string">"查询不到"</span>)<span class="comment">//对应操作，不一定是print</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == orm.ErrMissPK &#123;</span><br><span class="line">fmt.Println(<span class="string">"没有主键"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个学生的信息到数据库中，参数是指向student结构题的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddStudent</span><span class="params">(student *Student)</span> <span class="title">Student</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Insert(student)<span class="comment">//插入数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateStudent</span><span class="params">(student *Student)</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Update(student)<span class="comment">//更新该student的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteStudent</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Delete(&amp;Student&#123;Id:id&#125;)<span class="comment">//删除对应id的student的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(Student))<span class="comment">//将数据库注册到orm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>model这一层主要是定义struct，并为上层编写读写数据库。处理数据的代码。</li></ul><h3 id="controller层实现"><a href="#controller层实现" class="headerlink" title="controller层实现"></a>controller层实现</h3><p>基于 beego 的 Controller 设计，只需要匿名组合 <code>beego.Controller</code> 就可以了，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> xxxController <span class="keyword">struct</span> &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beego.Controller</code> 实现了接口 <code>beego.ControllerInterface</code>，<code>beego.ControllerInterface</code> 定义了如下函数：</p><ul><li><p>Init(ct *context.Context, childName string, app interface{})</p><p>这个函数主要初始化了 Context、相应的 Controller 名称，模板名，初始化模板参数的容器 Data，app 即为当前执行的 Controller 的 reflecttype，这个 app 可以用来执行子类的方法。</p></li><li><p>Prepare()</p><p>这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。</p></li><li><p>Get()</p><p>如果用户请求的 HTTP Method 是 GET，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Get 请求。</p></li><li><p>Post()</p><p>如果用户请求的 HTTP Method 是 POST，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Post 请求。</p></li><li><p>Delete()</p><p>如果用户请求的 HTTP Method 是 DELETE，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Delete 请求。</p></li><li><p>Put()</p><p>如果用户请求的 HTTP Method 是 PUT，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Put 请求.</p></li><li><p>Head()</p><p>如果用户请求的 HTTP Method 是 HEAD，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。</p></li><li><p>Patch()</p><p>如果用户请求的 HTTP Method 是 PATCH，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Patch 请求.</p></li><li><p>Options()</p><p>如果用户请求的HTTP Method是OPTIONS，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Options 请求。</p></li><li><p>Finish()</p><p>这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。</p></li><li><p>Render() error</p><p>这个函数主要用来实现渲染模板，如果 beego.AutoRender 为 true 的情况下才会执行。</p></li></ul><p>所以通过子 struct 的方法重写，用户就可以实现自己的逻辑。</p><h3 id="routers层实现"><a href="#routers层实现" class="headerlink" title="routers层实现"></a>routers层实现</h3><p>什么是路由设置呢？前面介绍的 MVC 结构执行时，介绍过 beego 存在三种方式的路由:固定路由、正则路由、自动路由，与RESTFul API相关的就是固定路由和正则路由。</p><p>下面就是固定路由的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beego.Router(<span class="string">"/"</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin"</span>, &amp;admin.UserController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin/index"</span>, &amp;admin.ArticleController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin/addpkg"</span>, &amp;admin.AddController&#123;&#125;)</span><br></pre></td></tr></table></figure><p>下面是正则路由的例子：</p><ul><li><p>beego.Router(“/api/?:id”, &amp;controllers.RController{})</p><p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/api/:id”, &amp;controllers.RController{})</p><p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”，但URL”/api/“匹配失败</p></li><li><p>beego.Router(“/api/:id([0-9]+)“, &amp;controllers.RController{})</p><p>自定义正则匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/user/:username([\w]+)“, &amp;controllers.RController{})</p><p>正则字符串匹配 //例如对于URL”/user/astaxie”可以匹配成功，此时变量”:username”值为”astaxie”</p></li><li><p>beego.Router(“/download/<em>.</em>”, &amp;controllers.RController{})</p><p>*匹配方式 //例如对于URL”/download/file/api.xml”可以匹配成功，此时变量”:path”值为”file/api”， “:ext”值为”xml”</p></li><li><p>beego.Router(“/download/ceshi/*“, &amp;controllers.RController{})</p><p>*全匹配方式 //例如对于URL”/download/ceshi/file/api.json”可以匹配成功，此时变量”:splat”值为”file/api.json”</p></li><li><p>beego.Router(“/:id:int”, &amp;controllers.RController{})</p><p>int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)</p></li><li><p>beego.Router(“/:hi:string”, &amp;controllers.RController{})</p><p>string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)</p></li><li><p>beego.Router(“/cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</p><p>带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123</p></li></ul><p>个人觉得，最方便的还是类似于Python框架flask的注解路由，也是在这个项目中使用的：</p><ul><li><p>在routers/routers.go里面添加你所希望的API</p></li><li><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"firstAPI/controllers"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">ns := beego.NewNamespace(<span class="string">"/v1"</span>,</span><br><span class="line">beego.NSNamespace(<span class="string">"/object"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.ObjectController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">beego.NSNamespace(<span class="string">"/user"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.UserController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">beego.NSNamespace(<span class="string">"/student"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.StudentController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">beego.AddNamespace(ns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上代码实现了如下的API：</p><p>/v1/object</p><p>/v1/user</p><p>/v1/student</p><p>非常清晰明了。</p><h3 id="main-go的数据库配置"><a href="#main-go的数据库配置" class="headerlink" title="main.go的数据库配置"></a>main.go的数据库配置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"firstAPI/routers"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DRMySQL)<span class="comment">//注册MySQL的driver</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, <span class="string">"root:test@tcp(127.0.0.1:3306)/restapi_test?charset=utf8"</span>)<span class="comment">//本地数据库的账号。密码等</span></span><br><span class="line">orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> beego.BConfig.RunMode == <span class="string">"dev"</span> &#123;</span><br><span class="line">beego.BConfig.WebConfig.DirectoryIndex = <span class="literal">true</span></span><br><span class="line">beego.BConfig.WebConfig.StaticDir[<span class="string">"/swagger"</span>] = <span class="string">"swagger"</span><span class="comment">//静态文档</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点都在代码中以注释的形式展现。</p><h3 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h3><p>bee run 运行代码后，我们使用postman测试一下我们所构建的API效果如何。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw7w1tcnesj31kw0y90y6.jpg" alt=""></p><p>这里节省篇幅，只测试一个接口。</p><p>到此为止，我们基于beego就实现了简单API接口的构建，是不是既清晰又简单呢？赶快自己动手试试吧！</p><p>本期技术周刊结束，代码已上传到<a href="https://github.com/hantmac/beego_api_demo" target="_blank" rel="noopener">GitHub</a>，可以查阅，我们下期再会！</p><hr>]]></content>
    
    <summary type="html">
    
      本文介绍通过使用golang web开发框架beego搭建RESTFUL风格的API
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang beego" scheme="https://cloudsjhan.github.io/tags/golang-beego/"/>
    
  </entry>
  
  <entry>
    <title>总结版图解http</title>
    <link href="https://cloudsjhan.github.io/2018/10/12/%E6%80%BB%E7%BB%93%E7%89%88%E5%9B%BE%E8%A7%A3http/"/>
    <id>https://cloudsjhan.github.io/2018/10/12/总结版图解http/</id>
    <published>2018-10-12T02:20:37.000Z</published>
    <updated>2018-10-12T02:28:44.744Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><strong>该博客转载自公众号<a href="https://mp.weixin.qq.com/s/MvMyH1vTCsxBCdHfH7uv1w" target="_blank" rel="noopener">freeCodeCamp</a></strong></p><p>作为一个前端，如果对一个网页从发起请求到返回数据这期间具体发生了什么都不知道的话，那不是一个好前端。最近，读了图解http，以及有关http相关的文章，还有自己也下载了wireshark抓包工具，实际观察了一下这个过程，下面就此做些总结。</p><p><strong>一.从输入一个url到返回数据，中间到底发生了什么？</strong></p><p>假设，我们在浏览器输入<a href="http://www.baidu.com:80/index.html，假设解析出的ip地址是202.43.78.3" target="_blank" rel="noopener">http://www.baidu.com:80/index.html，假设解析出的ip地址是202.43.78.3</a></p><p><strong>1.浏览器解析出主机名</strong></p><p>解析出的主机名是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>2.浏览器查询这个主机名的ip地址（dns）</strong></p><p>dns解析的作用就是把域名解析成ip地址，这样才能在广域网路由器转发报文给目标ip，不然路由器不知道要把报文发给谁。下面就讲下大概的过程，不会涉及太多细节。（以chrome为例子）</p><p>（1）浏览器启动时，首先浏览器会去操作系统获取dns服务器地址，然后把这个地址缓存下来。同时浏览器还会去读取和解析hosts文件，同样放到缓存中。浏览器对解析过的域名和ip地址，都会保存着这两者的映射关系。（存到cache中）</p><p>（2）当解析域名的时候，首先浏览器会去cache中查找有没有缓存好的映射关系，如果没有的话，就去hosts文件中查找，如果也没有的话，浏览器就会发起请求去dns服务器缓存查询了，如果缓存里面也没有，那最后就是dns服务器去查询了。</p><p><strong>3.浏览器获取端口号</strong></p><p><strong>4.浏览器向目标ip地址发起一条到202.43.78.3:80的tcp连接</strong></p><p>为了传输的可靠性，tcp协议要有三次握手过程：</p><p>（1）首先浏览器会向服务器发起一个连接请求</p><p>（2）服务器会对连接请求做出响应，表示同意建立连接</p><p>（3）浏览器收到响应后，再告知对方，它知道服务器同意它建立连接了。</p><p><strong>5.数据包在ip层传输</strong></p><p>数据包在ip层传输，通过多台计算机和网络设备中转，在中转时，利用中转设备的mac地址搜索下一个中转目标（采用ARP协议，根据通信方的ip地址就可以反查出对应的mac地址），直到目标ip地址。</p><p><strong>6.数据链路层处理网络连接的硬件部分</strong></p><p>数据链路层处理网络连接的硬件部分，比如网卡，找到服务器的网卡</p><p><strong>7.浏览器向服务器发送一条http报文</strong></p><p>每一条http报文的组成：</p><p>起始行+首部+主体(可选)</p><p>起始行：http/1.0 200 ok (一般包括http版本，返回状态码，返回码原因)</p><p>首部：content-type:text/plain content-length:19</p><p>主体：name=jane</p><p><strong>8.服务器接受客户端请求，进行一些处理，返回响应报文</strong></p><p>web服务器接收到请求之后，实际上会做些什么呢？</p><p>（1）建立连接，如果接受一个客户端连接，就建立连接，如果不同意，就将其关闭。</p><p>（2）接收请求，读取http请求报文</p><p>（3）访问资源，访问报文中指定的资源</p><p>（4）构建响应，创建带有首部的http响应报文</p><p>（5）发送响应，将响应回送给客户端</p><p><strong>9.浏览器读取http响应报文</strong></p><p><strong>10.浏览器关闭连接</strong></p><p>看了上面的一个简单过程，大家会不会有这样一个问题，难道每次发起一个http请求，都要建立一次tcp连接吗，我们经常写的并发ajax请求，每条请求都是各自独立建立的tcp连接？一条tcp连接建立之后，是什么时候关闭的？带着这些问题，看看下面要讲的http的特性</p><p><strong>二.http的特性</strong></p><p><strong>1.http是不保存状态的协议</strong></p><p>http协议是一种无状态的协议，意思就是说它不会对每次的请求和响应之间的通信状态进行保存。你之前发过的任何请求的信息，没有任何记录。之所以这样设计，也是为了让http变得比较简单，可以处理大量事物。但是无状态的特性，也会导致一些问题，比如说一个用户登录一家网站之后，跳到另一个页面，应该还保持着登录状态，所以后面就出了cookie状态管理技术。相信大家应该都很熟悉了。</p><p><strong>2.请求只能从客户端开始，客户端不可以接收除响应以外的指令</strong></p><p>服务器必须等待客户端的请求，才能给客户端发送响应数据，所以说服务器是不能主动给客户端推送数据的。对于一些实时监控的功能，常常用websocket来代替</p><p><strong>3.没有用户认证，任何人都可以发起请求</strong></p><p>在http协议通信时，是不存在确认通信方的处理步骤的，任何人都可以发起请求。另外，服务器只要收到请求，无论是谁，都会返回一个响应。所以会存在伪装的隐患。后面出现的https就可以解决这个问题。</p><p><strong>4.通信使用的是明文</strong></p><p><strong>5.无法证明报文完整性</strong></p><p><strong>6.可任意选择数据压缩格式，非强制压缩发送</strong></p><p><strong>7.http持久连接和并行连接</strong></p><p>一开始，http请求是串行的，一个http请求，就会建立一条tcp连接，浏览器收到响应之后，就会断开连接。等上一个请求回来了，下一个请求才能继续请求。这样做的缺点是，比较耗时间和内存，后面就出现了下面一系列的优化连接性能的方法。</p><p>（1）并行连接</p><p>原理：通过多条tcp连接发起并发的http请求</p><p>并行连接可以同时发起多个http请求，每次发起一个http请求，就会建立一个tcp连接。每个http请求是独立的，不会相互等待，这样做，很可能会提高页面的加载速度，因为人们会看到页面上面，很多个东西会同时出现，所以感觉页面加载变快了。实际上有时候是真的变快了，因为它是并行工作的。但是有时候不是真的快了。比如说，客户端的网络带宽不足时，（浏览器是通过一个28kbps的modem连接到因特网上去的），如果并行加载多个请求，每个请求就会去竞争这个有限的带宽，每个请求就会以比较慢的速度加载。这样带来的性能提升就很小。</p><p>（2）持久连接</p><p>原理：重用tcp连接，以消除连接及关闭时延</p><p>从http1.1开始，就允许当http响应结束后，tcp连接可以保持在打开状态，以便给未来的http请求重用现在的连接。那么，这个tcp连接什么时候会关闭呢，一般情况下，40s内，如果没有新的请求，就会关闭。</p><p>（3）管道化连接</p><p>原理：通过共享的tcp连接发起并发的http请求</p><p>并行连接可以提高复合页面的传输速度，但是也有许多缺点，比如每次都会建立一次tcp连接，会耗费时间和带宽。持久连接的优势就是降低了时延和tcp的连接数量。但是持久连接可能会导致的一个问题是，可能会累积大量的空闲连接。耗费资源。</p><p>持久连接和并行连接配合使用才是最高效的方式。</p><p>一般浏览器会限制，同个域名下的并行连接的个数是4个，即打开少量的并行连接，其中每个都是持久连接。这也是现在用的最多的方式。</p><hr>]]></content>
    
    <summary type="html">
    
      对于《图解HTTP》一书进行言简意赅的总结
    
    </summary>
    
      <category term="网络" scheme="https://cloudsjhan.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://cloudsjhan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>python apscheduler - skipped: maximum number of running instances reached</title>
    <link href="https://cloudsjhan.github.io/2018/09/28/python-apscheduler-skipped-maximum-number-of-running-instances-reached/"/>
    <id>https://cloudsjhan.github.io/2018/09/28/python-apscheduler-skipped-maximum-number-of-running-instances-reached/</id>
    <published>2018-09-28T08:04:43.000Z</published>
    <updated>2018-09-28T08:14:25.410Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="出现问题的代码"><a href="#出现问题的代码" class="headerlink" title="出现问题的代码"></a>出现问题的代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line">scheduler.add_job(runsync, <span class="string">'interval'</span>, seconds=<span class="number">1</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure><h3 id="问题出现的情况"><a href="#问题出现的情况" class="headerlink" title="问题出现的情况"></a>问题出现的情况</h3><ul><li>运行一段代码，时而报错时而不报错</li><li>报错是：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING:apscheduler.scheduler:Execution of job &quot;runsync (trigger: interval[0:00:01], next run at: 2015-12-01 11:50:42 UTC)&quot; skipped: maximum number of running instances reached (1)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>apscheduler这个模块，在你的代码运行时间大于interval的时候，就会报错</p><p>也就是说，你的代码运行时间超出了你的定时任务的时间间隔。</p></li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>增大时间间隔即可</li></ul><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      python apscheduler - skipped: maximum number of running instances reached
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 的logging模块实现json格式的日志输出</title>
    <link href="https://cloudsjhan.github.io/2018/09/27/python-%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"/>
    <id>https://cloudsjhan.github.io/2018/09/27/python-的logging模块实现json格式的日志输出/</id>
    <published>2018-09-27T08:28:21.000Z</published>
    <updated>2018-09-29T01:14:39.201Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ul><li>想要让开发过程或者是上线后的bug无处可藏，最好的方式便是在程序运行过程中，不断收集重要的日志，以供分析使用。Python中内置的log收集模块是logging，该模块使用起来比较方便，但是美中不足的地方就是日志的格式转成json比较麻烦。于是我结合logging和另一个模块<a href="https://github.com/madzak/python-json-logger" target="_blank" rel="noopener">python-json-logger</a>(pip install python-json-logger) ，实现json格式的日志输出。</li></ul><h3 id="源码：以下代码可以做成模块，直接导入使用"><a href="#源码：以下代码可以做成模块，直接导入使用" class="headerlink" title="源码：以下代码可以做成模块，直接导入使用"></a>源码：以下代码可以做成模块，直接导入使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging, logging.config, os</span><br><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"><span class="keyword">from</span> structlog <span class="keyword">import</span> configure, processors, stdlib, threadlocal</span><br><span class="line"><span class="keyword">from</span> pythonjsonlogger <span class="keyword">import</span> jsonlogger</span><br><span class="line">BASE_DIR = BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DEBUG = <span class="keyword">True</span>  <span class="comment"># 标记是否在开发环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给过滤器使用的判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequireDebugTrue</span><span class="params">(logging.Filter)</span>:</span></span><br><span class="line">    <span class="comment"># 实现filter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DEBUG</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">()</span>:</span></span><br><span class="line">    LOGGING = &#123;</span><br><span class="line">    <span class="comment"># 基本设置</span></span><br><span class="line">        <span class="string">'version'</span>: <span class="number">1</span>,  <span class="comment"># 日志级别</span></span><br><span class="line">        <span class="string">'disable_existing_loggers'</span>: <span class="keyword">False</span>,  <span class="comment"># 是否禁用现有的记录器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志格式集合</span></span><br><span class="line">        <span class="string">'formatters'</span>: &#123;</span><br><span class="line">        <span class="comment"># 标准输出格式</span></span><br><span class="line">            <span class="string">'json'</span>: &#123;</span><br><span class="line">            <span class="comment"># [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span></span><br><span class="line">                <span class="string">'format'</span>: <span class="string">'[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s'</span>,</span><br><span class="line">                <span class="string">'class'</span>: <span class="string">'pythonjsonlogger.jsonlogger.JsonFormatter'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="string">'filters'</span>: &#123;</span><br><span class="line">            <span class="string">'require_debug_true'</span>: &#123;</span><br><span class="line">                <span class="string">'()'</span>: RequireDebugTrue,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 处理器集合</span></span><br><span class="line">        <span class="string">'handlers'</span>: &#123;</span><br><span class="line">        <span class="comment"># 输出到控制台</span></span><br><span class="line">        <span class="comment"># 输出到文件</span></span><br><span class="line">            <span class="string">'TimeChecklog'</span>: &#123;</span><br><span class="line">                <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">                <span class="string">'class'</span>: <span class="string">'logging.handlers.RotatingFileHandler'</span>,</span><br><span class="line">                <span class="string">'formatter'</span>: <span class="string">'json'</span>,</span><br><span class="line">                <span class="string">'filename'</span>: os.path.join(<span class="string">"./log/"</span>, <span class="string">'TimeoutCheck.log'</span>),  <span class="comment"># 输出位置</span></span><br><span class="line">                <span class="string">'maxBytes'</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>,  <span class="comment"># 文件大小 5M</span></span><br><span class="line">                <span class="string">'backupCount'</span>: <span class="number">5</span>,  <span class="comment"># 备份份数</span></span><br><span class="line">                <span class="string">'encoding'</span>: <span class="string">'utf8'</span>,  <span class="comment"># 文件编码</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 日志管理器集合</span></span><br><span class="line">        <span class="string">'loggers'</span>: &#123;</span><br><span class="line">        <span class="comment"># 管理器</span></span><br><span class="line">            <span class="string">'proxyCheck'</span>: &#123;</span><br><span class="line">                <span class="string">'handlers'</span>: [<span class="string">'TimeChecklog'</span>],</span><br><span class="line">                <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">                <span class="string">'propagate'</span>: <span class="keyword">True</span>,  <span class="comment"># 是否传递给父记录器</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configure(</span><br><span class="line">        logger_factory=stdlib.LoggerFactory(),</span><br><span class="line">        processors=[</span><br><span class="line">            stdlib.render_to_log_kwargs]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger = logging.getLogger(<span class="string">"proxyCheck"</span>)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span></span><br><span class="line">logger1 = get_logger()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger1.error(e)  <span class="comment"># 写入错误日志</span></span><br><span class="line">        <span class="comment">#如果需要添加额外的信息，使用extra关键字即可</span></span><br><span class="line">        logger1.error(e, extra=&#123;key1: value1, key2:value2&#125;)</span><br><span class="line">        <span class="comment"># 其他错误处理代码</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="### 测试结果"></a>### 测试结果</h3><ul><li>测试的结果，可以在./log/xxx.log文件中看到输出的日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;asctime&quot;: &quot;2018-09-28 09:52:12,622&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 4338656704, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;mylog&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;division by zero&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到日志是json格式，这样你就可以很方便的使用grafna和ES将日志做成看板来展示了。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      使用Python的内置logging实现json格式的日志输出
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 发送各种格式的邮件</title>
    <link href="https://cloudsjhan.github.io/2018/09/17/python-%E5%8F%91%E9%80%81%E5%90%84%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/"/>
    <id>https://cloudsjhan.github.io/2018/09/17/python-发送各种格式的邮件/</id>
    <published>2018-09-17T02:55:56.000Z</published>
    <updated>2018-09-28T02:06:31.935Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line">_user = <span class="string">"sigeken@qq.com"</span></span><br><span class="line">_pwd  = <span class="string">"***"</span></span><br><span class="line">_to   = <span class="string">"402363522@qq.com"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如名字所示Multipart就是分多个部分</span></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">"Subject"</span>] = <span class="string">"don't panic"</span></span><br><span class="line">msg[<span class="string">"From"</span>]    = _user</span><br><span class="line">msg[<span class="string">"To"</span>]      = _to</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---这是文字部分---</span></span><br><span class="line">part = MIMEText(<span class="string">"乔装打扮，不择手段"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---这是附件部分---</span></span><br><span class="line"><span class="comment">#xlsx类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.xlsx'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.xlsx"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#jpg类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.jpg'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.jpg"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#pdf类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.pdf'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.pdf"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#mp3类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.mp3'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.mp3"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line">s = smtplib.SMTP(<span class="string">"smtp.qq.com"</span>, timeout=<span class="number">30</span>)<span class="comment">#连接smtp邮件服务器,端口默认是25</span></span><br><span class="line">s.login(_user, _pwd)<span class="comment">#登陆服务器</span></span><br><span class="line">s.sendmail(_user, _to, msg.as_string())<span class="comment">#发送邮件</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      使用Python发送各种格式的邮件
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之当你ping的时候，发生了什么？</title>
    <link href="https://cloudsjhan.github.io/2018/09/16/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E5%BD%93%E4%BD%A0ping%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://cloudsjhan.github.io/2018/09/16/技术周刊之当你ping的时候，发生了什么？/</id>
    <published>2018-09-16T13:40:02.000Z</published>
    <updated>2018-09-16T13:49:36.202Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？本周就让我们深入浅出ping的机制。</p><h2 id="ping的作用和原理"><a href="#ping的作用和原理" class="headerlink" title="ping的作用和原理"></a>ping的作用和原理</h2><p>简单来说，「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。</p><p>ping 命令是基于 ICMP 协议来工作的，「 ICMP 」全称为 Internet 控制报文协议（ Internet Control Message Protocol）。ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为ICMP协议会要求目标主机在收到消息之后，必须返回ICMP应答消息给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。</p><p>举一个例子来描述「ping」命令的工作过程：</p><ol><li>假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2</li><li>此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。</li><li>IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包。</li><li>IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去。</li><li>当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A</li><li>在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。</li></ol><p>通过ping的流程可以发现，ICMP协议是这个过程的基础，是非常重要的，因此下面就把ICMP协议再详细解释一下。</p><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>我们知道，ping命令是基于ICMP协议来实现的。那么我们再来看下图，就明白了ICMP协议又是通过IP协议来发送的，即ICMP报文是封装在IP包中。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvbpqk4zgbj308b02it8q.jpg" alt=""></p><p>IP协议是一种无连接的，不可靠的数据包协议，它并不能保证数据一定被送达，那么我们要保证数据送到就需要通过其它模块来协助实现，这里就引入的是ICMP协议。</p><p>当传送的IP数据包发送异常的时候，ICMP就会将异常信息封装在包内，然后回传给源主机。</p><p>将上图再细拆一下可见：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvbps2ezmoj30b1028jr6.jpg" alt=""></p><p>将ICMP部分拆开继续分析：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvbptg9n1uj30ci047t8s.jpg" alt=""></p><p>由图可知，ICMP数据包由8bit的类型字段和8bit的代码字段以及16bit的校验字段再加上选项数据组成。</p><p>ICMP协议大致可分为两类：</p><ul><li>查询报文类型</li><li>差错报文类型</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvbpuk9vf2j30bo0bv747.jpg" alt=""></p><ol><li>查询报文类型：</li></ol><p>查询报文主要应用于：ping查询、子网掩码查询、时间戳查询等等。</p><p>上面讲到的ping命令的流程其实就对应ICMP协议查询报文类型的一种使用。在主机A构建ICMP请求数据包的时候，其ICMP的类型字段中使用的是 8 （回送请求），当主机B构建ICMP应答包的时候，其ICMP类型字段就使用的是 0 （回送应答），更多类型值参考上表。</p><p>对 查询报文类型 的理解可参考一下文章最开始讲的ping流程，这里就不做赘述。</p><ol start="2"><li>差错报文类型：</li></ol><p>差错报文主要产生于当数据传送发送错误的时候。</p><p>它包括：目标不可达（网络不可达、主机不可达、协议不可达、端口不可达、禁止分片等）、超时、参数问题、重定向（网络重定向、主机重定向等）等等。</p><p>差错报文通常包含了引起错误的IP数据包的第一个分片的IP首部，加上该分片数据部分的前8个字节。</p><p>当传送IP数据包发生错误的时候（例如 主机不可达），ICMP协议就会把错误信息封包，然后传送回源主机，那么源主机就知道该怎么处理了。</p><p>那是不是只有遇到错误的时候才能使用 差错报文类型 呢？也不一定。</p><p>Traceroute 就是一个例外，Traceroute是用来侦测源主机到目标主机之间所经过路由情况的常用工具。Traceroute 的原理就是利用ICMP的规则，制造一些错误的事件出来，然后根据错误的事件来评估网络路由情况。</p><p>具体做法就是：</p><p>Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL=1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了。</p><p>接着，源主机再给目标主机发一个 TTL=2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了。</p><p>如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。</p><p>但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢？</p><p>Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机。</p><p>traceroot的具体使用方法网上都有很多讲解，可以实际操作一下。</p><hr>]]></content>
    
    <summary type="html">
    
      我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="网络" scheme="https://cloudsjhan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7-安装docker-compose时由于pip10包管理导致的错误</title>
    <link href="https://cloudsjhan.github.io/2018/09/13/CentOS7-%E5%AE%89%E8%A3%85docker-compose%E6%97%B6%E7%94%B1%E4%BA%8Epip10%E5%8C%85%E7%AE%A1%E7%90%86%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://cloudsjhan.github.io/2018/09/13/CentOS7-安装docker-compose时由于pip10包管理导致的错误/</id>
    <published>2018-09-13T02:11:49.000Z</published>
    <updated>2018-09-13T02:15:53.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>今天在CentOS下安装docker-compose，遇到了Cannot uninstall ‘requests’. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.<br>错误的原因是requests默认版本为2.6.0，但是docker-compose要2.9以上才支持，但是无法正常卸载2.9版本，是pip10对包的管理存在变化。</li><li>解决方案：<ul><li>pip install -l requests==2.9</li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      CentOS下安装Docker-compose时出现了 Cannot uninstall &#39;requests&#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.
    
    </summary>
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之解析Python中的赋值、浅拷贝、深拷贝</title>
    <link href="https://cloudsjhan.github.io/2018/09/09/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E8%A7%A3%E6%9E%90Python%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://cloudsjhan.github.io/2018/09/09/技术周刊之解析Python中的赋值、浅拷贝、深拷贝/</id>
    <published>2018-09-09T06:39:05.000Z</published>
    <updated>2018-09-09T08:03:48.727Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><ul><li><p>本周我们分享的主题是Python中关于浅拷贝和深拷贝的特性，想要深入研究Python中的浅拷贝和深拷贝的起因在于，我想生成一个json字符串，该字符串未dumps之前是一个Python的数据结构，里面包含字典，以及List，在遍历生成dictionary时候，出现一个bug，就是每次遍历生成的dictionary都是上一次的值，现象可以看以下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我们定义一个函数get_data()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     appid_dict = &#123;&#125;</span><br><span class="line">   ...:     appid_all_dict = &#123;&#125;</span><br><span class="line">   ...:     <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">   ...:         appid_dict[<span class="string">'a'</span>] = i</span><br><span class="line">   ...:         appid_all_dict[i] = appid_dict</span><br><span class="line"><span class="comment"># 我们的初衷是想要得到</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;'a': 0&#125;, 1: &#123;'a': 1&#125;, 2: &#123;'a': 2&#125;, 3: &#123;'a': 3&#125;&#125;....这样的一个dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在调试过程中，发现得到的结果是这样的：</span></span><br><span class="line"><span class="comment"># (Pdb) appid_all_dict</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;'a': 2&#125;, 1: &#123;'a': 2&#125;, 2: &#123;'a': 2&#125;&#125;</span></span><br><span class="line"><span class="comment"># (Pdb) </span></span><br><span class="line"><span class="comment"># 即，后面的appid_dict都会把前面的覆盖掉，这是什么原因呢？</span></span><br><span class="line"><span class="comment"># 我们这里先把原因说一下：因为Python中对dict的操作默认是浅拷贝，即同样的字典，使用多次的话，每次使用都是指向同一片内存地址(引用)，所以在上面的程序中后面对appid_dict的赋值，都将前面的给覆盖掉了，导致每一个appid_dict指向同一片内存，读取的当然就是最后一次的appid_dict的值，即上面程序的执行结果：</span></span><br><span class="line">&#123;<span class="number">0</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">1</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">2</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">3</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">4</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">5</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">6</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">7</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">8</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">9</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>那么如何修改这个bug，让程序输出我们想要得到的结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0: &#123;'a': 0&#125;, 1: &#123;'a': 1&#125;, 2: &#123;'a': 2&#125;, 3: &#123;'a': 3&#125;, 4: &#123;'a': 4&#125;, 5: &#123;'a': 5&#125;, 6: &#123;'a': 6&#125;, 7: &#123;'a': 7&#125;, 8: &#123;'a': 8&#125;, 9: &#123;'a': 9&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>看完下面对于Python赋值、浅拷贝、深拷贝的解析，相信你就可以自己解决这个问题了</p></li></ul><h4 id="Python中的赋值操作"><a href="#Python中的赋值操作" class="headerlink" title="Python中的赋值操作"></a>Python中的赋值操作</h4><ul><li>赋值：就是对象的引用</li><li>举例： a = b: 赋值引用，a和b都指向同一个对象，如图所示<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fv3bo527hfj30y80lwq7i.jpg" alt=""></li></ul><h2 id="Python中浅拷贝"><a href="#Python中浅拷贝" class="headerlink" title="Python中浅拷贝"></a>Python中浅拷贝</h2><ul><li>a = b.copy(): a 是b的浅拷贝，a和b是一个独立的对象，但是它们的子对象还是指向同一片引用。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fv3btp4y4ij30zs0neq9f.jpg" alt=""></li><li>Python中对字典的默认赋值操作就是浅拷贝，所以导致了文章开头所出现的情况。</li></ul><h2 id="Python中的深拷贝"><a href="#Python中的深拷贝" class="headerlink" title="Python中的深拷贝"></a>Python中的深拷贝</h2><ul><li>首先import copy,导入copy模块（Python中自带），b = copy.deepcopy(a), 我们就说b是a的深拷贝，b拷贝了a所有的资源对象，并新开辟了一块地址空间，两者互不干涉。<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fv3bymsju4j311w0oi100.jpg" alt=""></li></ul><h2 id="实际的例子来进一步说明"><a href="#实际的例子来进一步说明" class="headerlink" title="实际的例子来进一步说明"></a>实际的例子来进一步说明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="function"><span class="keyword">def</span> <span class="title">temp</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">    ...:     b = a <span class="comment"># 赋值操作，直接传所有对象的引用</span></span><br><span class="line">    ...:     c = copy.copy(a) <span class="comment"># 浅拷贝，子对象指向同一引用</span></span><br><span class="line">    ...:     d = copy.deepcopy(a) <span class="comment"># 深拷贝，互不干涉</span></span><br><span class="line">    ...:     a.append(<span class="number">5</span>) <span class="comment"># 修改对象a</span></span><br><span class="line">    ...:     a[<span class="number">4</span>].append(<span class="string">'c'</span>) <span class="comment"># 修改a中的数组</span></span><br><span class="line">    ...:     print( <span class="string">'a = '</span>, a )</span><br><span class="line">    ...:     print( <span class="string">'b = '</span>, b )</span><br><span class="line">    ...:     print( <span class="string">'c = '</span>, c )</span><br><span class="line">    ...:     print( <span class="string">'d = '</span>, d ) </span><br><span class="line">    ...:     </span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: </span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: temp()</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决最初的问题"><a href="#解决最初的问题" class="headerlink" title="解决最初的问题"></a>解决最初的问题</h2><ul><li><p>看到这里，我们再回头看文章最初的那个问题，就可以很easy地解决了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     appid_dict = &#123;&#125;</span><br><span class="line">   ...:     appid_all_dict = &#123;&#125;</span><br><span class="line">   ...:     <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        appid_dict = copy.deepcopy(appid_dict)<span class="comment"># 只需要加上这一行，使其成为深拷贝，问题解决！</span></span><br><span class="line">   ...:         appid_dict[<span class="string">'a'</span>] = i</span><br><span class="line">   ...:         appid_all_dict[i] = appid_dict</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要对Python的dictionary进行迭代分析，一定要注意其中的深拷贝问题，出现问题后，也要多往这方面考虑。</p><p>本期技术周刊到此结束。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536489838162&amp;di=52a5d7c56631ad266740914505a80a32&amp;imgtype=0&amp;src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2F57%2FB6%2Fo4YBAFtMadCAL43RAAHzi5GNn9o475.png" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      这周让我们来看一下Python中关于赋值、浅拷贝、深拷贝的特性
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="Python" scheme="https://cloudsjhan.github.io/tags/Python/"/>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>golang 编译针对不同平台的可执行程序</title>
    <link href="https://cloudsjhan.github.io/2018/09/07/golang-%E7%BC%96%E8%AF%91%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://cloudsjhan.github.io/2018/09/07/golang-编译针对不同平台的可执行程序/</id>
    <published>2018-09-07T07:46:32.000Z</published>
    <updated>2018-09-07T07:48:43.584Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Golang 支持在一个平台下生成另一个平台可执行程序的交叉编译功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mac下编译Linux, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Linux下编译Mac, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Windows下编译Mac, Linux平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin3</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Golang version 1.5以前版本在首次交叉编译时还需要配置交叉编译环境：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 ./make.bash</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      使用go build 编译同一套代码，在不同的平台运行
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>常用的Python小模块</title>
    <link href="https://cloudsjhan.github.io/2018/09/06/%E5%B8%B8%E7%94%A8%E7%9A%84Python%E5%B0%8F%E6%A8%A1%E5%9D%97/"/>
    <id>https://cloudsjhan.github.io/2018/09/06/常用的Python小模块/</id>
    <published>2018-09-06T08:24:41.000Z</published>
    <updated>2018-09-28T02:06:00.780Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>工作或者生活中总会遇到一些常用的Python模块，为了避免重复的工作，将这些自己写过的Python模块记录下来，方便使用的时候查找。</li></ul><h3 id="Python写CSV文件，并防止中文乱码"><a href="#Python写CSV文件，并防止中文乱码" class="headerlink" title="Python写CSV文件，并防止中文乱码"></a>Python写CSV文件，并防止中文乱码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_csv</span><span class="params">(a_list,b_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'vm_data.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(codecs.BOM_UTF8.decode())</span><br><span class="line">        writer1 = csv.writer(f,  dialect=<span class="string">'excel'</span>)</span><br><span class="line">        <span class="comment">#写CVS的标题</span></span><br><span class="line">        writer1.writerow([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">        <span class="comment">#将数据写入CSV文件</span></span><br><span class="line">        writer1.writerows(zip(a_list, b_list))</span><br></pre></td></tr></table></figure><h3 id="Python将数据结构转为json-并优化json字符串的结构，处理中文乱码"><a href="#Python将数据结构转为json-并优化json字符串的结构，处理中文乱码" class="headerlink" title="Python将数据结构转为json,并优化json字符串的结构，处理中文乱码"></a>Python将数据结构转为json,并优化json字符串的结构，处理中文乱码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"appid.json"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(final, sort_keys=<span class="keyword">True</span>, indent=<span class="number">2</span>, ensure_ascii=<span class="keyword">False</span>))</span><br><span class="line"><span class="comment"># sort_keys = True: 将字典的key按照字母排序</span></span><br><span class="line"><span class="comment"># ident = 2: 优化json字符串结构，看起来更美观</span></span><br><span class="line"><span class="comment"># ensure_ascii=False: 防止json字符串中的中文乱码</span></span><br></pre></td></tr></table></figure><h3 id="使用requests包进行网络请求（以post为例）"><a href="#使用requests包进行网络请求（以post为例）" class="headerlink" title="使用requests包进行网络请求（以post为例）"></a>使用requests包进行网络请求（以post为例）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def  get_data(url):</span><br><span class="line">    final = &#123;&#125;</span><br><span class="line">    url = &quot;http://xxxx.com&quot;</span><br><span class="line">    request_body = &#123;</span><br><span class="line">        &apos;access_token&apos;: access_token,</span><br><span class="line">        &apos;request_body&apos;: &#123;&quot;params1&quot;: param1, &apos;params2&apos;: param2&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    data = requests.post(url, headers=headers, data=json.dumps(request_body))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      常用的Python模块，即查即用
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql无法连接[MySql Host is blocked because of many connection errors]</title>
    <link href="https://cloudsjhan.github.io/2018/09/01/Mysql%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cloudsjhan.github.io/2018/09/01/Mysql无法连接/</id>
    <published>2018-09-01T05:20:54.000Z</published>
    <updated>2018-09-01T05:38:58.657Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li><p>测试环境，发现数据库（MySQL数据库）无法登录，报错如下：</p><p>Host is blocked because of many connection errors; unblock with ‘mysqladmin flush-hosts’</p></li><li><p>解决方案：使用mysqladmin flush-hosts 命令清理一下hosts文件（不知道mysqladmin在哪个目录下可以使用命令查找：whereis mysqladmin）；</p></li><li><p>登录到MySQL数据库中，mysql -uroot -h host -p</p></li><li><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="keyword">flush</span>-<span class="keyword">hosts</span></span><br></pre></td></tr></table></figure><p>问题解决。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      mysql 出现[MySql Host is blocked because of many connection errors]的错误
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql 开启远程连接</title>
    <link href="https://cloudsjhan.github.io/2018/08/29/mysql-%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cloudsjhan.github.io/2018/08/29/mysql-开启远程连接/</id>
    <published>2018-08-29T03:17:20.000Z</published>
    <updated>2018-09-01T05:35:43.913Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li>背景： 建站的时候会出现数据库和网站是不同的ip，就需要开启MySQL的远程连接服务，但是MySQL由于安全原因，默认设置是不允许远程只能本地连接，要开启远程连接就需要修改某些配置文件。</li></ul><h3 id="按照下面的步骤，开启MySQL的远程连接"><a href="#按照下面的步骤，开启MySQL的远程连接" class="headerlink" title="按照下面的步骤，开启MySQL的远程连接"></a>按照下面的步骤，开启MySQL的远程连接</h3><ul><li><p>进入数据库cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -h host -p</span><br><span class="line">Enter password:***</span><br></pre></td></tr></table></figure></li><li><p>连接到默认mysql数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">use mysql;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grant all privileges on *.* to 'root'@'host' identified by 'password' with grant option;</span><br></pre></td></tr></table></figure><p>host表示你远程连接数据库设备的ip地址（如果你想让所有机器都能远程连接，host改为‘%’，<strong>不推荐这样使用</strong>），password表示MySQL的root用户密码</p></li><li><p>刷新or重启MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure></li><li><p>最后非常重要的一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim /etc/mysql/my.cnf</span><br><span class="line">屏蔽bing-server 127.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash">bing-server 127.0.0.0</span></span><br></pre></td></tr></table></figure></li><li><p>完成，可以远程连接你的数据库了</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      不管是在测试还是开发中，MySQL经常需要开启远程连接功能
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>golang factory design 引发的一系列思考</title>
    <link href="https://cloudsjhan.github.io/2018/08/29/golang-factory-design-%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%80%9D%E8%80%83/"/>
    <id>https://cloudsjhan.github.io/2018/08/29/golang-factory-design-引发的一系列思考/</id>
    <published>2018-08-29T02:21:56.000Z</published>
    <updated>2018-09-01T07:18:05.039Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li>写在前面，突然萌生一个念头，做一个技术周刊系列，将每周工作或者生活当中遇到的比较有趣的问题记录下来，一来时总结一下，二来是为了以后退役了，可以回顾自己的技术生涯。</li><li>没有什么意外的话，我会每周六晚更新。</li><li>最近在整合三家公有云（AWS，ali, ucloud）的接口，考虑到代码复用的问题，于是开始考虑使用一种设计模式，这种场景下，最合适的便是工厂模式，将三家厂商的公有接口放入工厂方法中，然后对每一家new一个实例即可，以后再有新的厂商加入，改动的代码也不会太多。但是设计模式这种东西天然适合于java，对于golang这种比较新的语言来说，实现起来相对没有那么容易，对于刚接触golang的我来说，对一些golang的特性上并不是很熟悉，所以在此期间遇到一些不解的问题，写出来分享一下。</li></ul><h3 id="首先，什么是工厂模式"><a href="#首先，什么是工厂模式" class="headerlink" title="首先，什么是工厂模式"></a>首先，什么是工厂模式</h3><ul><li>简单工厂模式就是通过传递不同的参数，生成不同的实例，工厂方法为每一个product提供一个工程类，通过不同的工厂创建不同的实例。</li></ul><h3 id="典型工厂模式的实现方式（即典型oop实现方式）"><a href="#典型工厂模式的实现方式（即典型oop实现方式）" class="headerlink" title="典型工厂模式的实现方式（即典型oop实现方式）"></a>典型工厂模式的实现方式（即典型oop实现方式）</h3><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProviderModel</span>&#123;</span></span><br><span class="line">    provider <span class="built_in">string</span></span><br><span class="line">        <span class="function">func <span class="title">factory</span><span class="params">(providerName <span class="built_in">string</span>, test <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> providerName == <span class="string">"AWS"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AWS(test)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> providerName == <span class="string">"Ali"</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ali(test)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AWS extends ProviderModel &#123;</span><br><span class="line">    func construct(test <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test</span><br><span class="line">    &#125;</span><br><span class="line">    func doRequest()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">awsmodel := ProviderModel::factory(<span class="string">"AWS"</span>)</span><br><span class="line">awsmodel.doRequest()</span><br><span class="line"></span><br><span class="line">alimodel := ProviderModel ::factory(<span class="string">"Ali"</span>)  </span><br><span class="line">alimodel.doRequest()</span><br></pre></td></tr></table></figure></li></ul><h3 id="golang实现工厂模式存在的问题"><a href="#golang实现工厂模式存在的问题" class="headerlink" title="golang实现工厂模式存在的问题"></a>golang实现工厂模式存在的问题</h3><ul><li><p>golang的特性中并没有像java一样的继承和重载，所以我们要利用golang存在的特性，透过工厂模式的表面透析其本质。</p></li><li><p>我们看一下工厂模式就知道，所谓工厂其实就是定义了一些需要去实现的方法，golang的interface正是可以做到。于是先到Google上搜了一段golang实现的工厂模式的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operater <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operate(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs + lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MultipleOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MultipleOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs * lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperateFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOperateFactory</span><span class="params">()</span> *<span class="title">OperateFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;OperateFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *OperateFactory)</span> <span class="title">CreateOperate</span><span class="params">(operatename <span class="keyword">string</span>)</span> <span class="title">Operater</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> operatename &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;AddOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;MultipleOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"无效运算符号"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Operator := NewOperateFactory().CreateOperate(<span class="string">"+"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"add result is %d\n"</span>, Operator.Operate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来没什么问题，后来又看到一种实现方式，<a href="https://www.jianshu.com/p/9de2cd9bf8f0" target="_blank" rel="noopener">来自这篇博客</a>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> site <span class="keyword">interface</span> &#123;</span><br><span class="line">    fetch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> siteModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    URL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> site1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    siteModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s site1)</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"site1 fetch data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">site</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">"site"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> site1&#123;</span><br><span class="line">            siteModel&#123;URL: <span class="string">"http://www.xxxx.com"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := factory(<span class="string">"site"</span>)</span><br><span class="line">    s.fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码初看上去跟第一个实现没什么不一样，但是当我详细阅读代码时，下面的这句代码着实把我弄晕了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">site</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">"site"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> site1&#123;</span><br><span class="line">            siteModel&#123;URL: <span class="string">"http://www.xxxx.com"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factory函数的返回值定义明明是一个interface, 但是在return的时候，却返回一个struct，查阅很多资料后，<a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">这篇博客</a>帮了我的大忙，其中对interface的解释有这么一句话：<strong>在 Golang 中，interface 是一组 method 的集合，是 duck-type programming 的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。</strong>之后又详细看了几遍这篇博文，犹如醍醐灌顶，对golanginterface的理解更深了一层。读完这篇后再去实现工厂模式，或者再去写golang的代码，对interface的使用就会更自如一些。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>本期技术周刊主要由golang工厂模式的讨论引起，之后又涉及到golang interface特性的讨论，对以后使用golang编写更加复杂的代码很有帮助。</p></li><li><p>本期结束，欲知后事如何，且看下周分解。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535796309427&amp;di=a9db53cf71b492f4dd06a57b5ec65229&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D2705270329%2C1518266531%26fm%3D214%26gp%3D0.jpg" alt=""></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      工作需要，看了一下golang如何实现工厂模式，遇到一些难以理解的知识点，查资料，写demo验证后，记录下来以供参考
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang design pattern go-interface" scheme="https://cloudsjhan.github.io/tags/golang-design-pattern-go-interface/"/>
    
  </entry>
  
  <entry>
    <title>golang中的工厂模式</title>
    <link href="https://cloudsjhan.github.io/2018/08/27/golang%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/27/golang中的工厂模式-md/</id>
    <published>2018-08-27T10:53:24.000Z</published>
    <updated>2018-08-27T11:18:09.576Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>研究go的设计模式，必须了解go的struct和interface，若不熟悉，先阅读以下内容</li><li><a href="http://blog.csdn.net/wangshubo1989/article/details/70040022" target="_blank" rel="noopener">go语言的struct</a></li><li><a href="http://blog.csdn.net/wangshubo1989/article/details/70053086" target="_blank" rel="noopener">go语言的interface</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* 简单工厂模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operater <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operate(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs + lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MultipleOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MultipleOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs * lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperateFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOperateFactory</span><span class="params">()</span> *<span class="title">OperateFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;OperateFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *OperateFactory)</span> <span class="title">CreateOperate</span><span class="params">(operatename <span class="keyword">string</span>)</span> <span class="title">Operater</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> operatename &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;AddOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;MultipleOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"无效运算符号"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Operator := NewOperateFactory().CreateOperate(<span class="string">"+"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"add result is %d\n"</span>, Operator.Operate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">* 工厂方法</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">float64</span></span><br><span class="line">    b <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperationI <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetResult() <span class="keyword">float64</span></span><br><span class="line">    SetA(<span class="keyword">float64</span>)</span><br><span class="line">    SetB(<span class="keyword">float64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *Operation)</span> <span class="title">SetA</span><span class="params">(a <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    op.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *Operation)</span> <span class="title">SetB</span><span class="params">(b <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    op.b = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a + this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a - this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MulOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MulOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a * this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DivOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a / this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateOperation() Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(AddOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(SubOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MulFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MulFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(MulOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DivFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(DivOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fac := &amp;(AddFactory&#123;&#125;)</span><br><span class="line">    oper := fac.CreateOperation()</span><br><span class="line">    oper.SetA(<span class="number">1</span>)</span><br><span class="line">    oper.SetB(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(oper.GetResult())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* 抽象工厂方法</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GirlFriend <span class="keyword">struct</span> &#123;</span><br><span class="line">    nationality <span class="keyword">string</span></span><br><span class="line">    eyesColor   <span class="keyword">string</span></span><br><span class="line">    language    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateMyLove() GirlFriend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndianGirlFriendFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KoreanGirlFriendFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a IndianGirlFriendFactory)</span> <span class="title">CreateMyLove</span><span class="params">()</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;<span class="string">"Indian"</span>, <span class="string">"Black"</span>, <span class="string">"Hindi"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a KoreanGirlFriendFactory)</span> <span class="title">CreateMyLove</span><span class="params">()</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;<span class="string">"Korean"</span>, <span class="string">"Brown"</span>, <span class="string">"Korean"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGirlFriend</span><span class="params">(typeGf <span class="keyword">string</span>)</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gffact AbstractFactory</span><br><span class="line">    <span class="keyword">switch</span> typeGf &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Indian"</span>:</span><br><span class="line">        gffact = IndianGirlFriendFactory&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> gffact.CreateMyLove()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Korean"</span>:</span><br><span class="line">        gffact = KoreanGirlFriendFactory&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> gffact.CreateMyLove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a := getGirlFriend(<span class="string">"Indian"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.eyesColor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="设计模式" scheme="https://cloudsjhan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac os 环境配置ruby on rails 及其Hello world</title>
    <link href="https://cloudsjhan.github.io/2018/08/26/Mac-os-%E9%85%8D%E7%BD%AE-ruby-on-rails-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/26/Mac-os-配置-ruby-on-rails-md/</id>
    <published>2018-08-26T15:20:33.000Z</published>
    <updated>2018-08-27T15:39:24.975Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><p>今天在Mac OS环境中倒腾ruby on rails，遇到一些坑并排坑后总结一个搭建过程，供大家参考。</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul><li><p>本着IT届能用最新的就不用前面的版本的宗旨，在进行之前必须将你的Mac升级到最新的macOS High Sierra</p></li><li><p>安装 XCode Command Line Tools</p></li><li><p>配置Git</p></li><li><p>安装Homebrew</p></li><li><p>安装GPG</p></li><li><p>安装RVM</p></li><li><p>安装ruby</p></li><li><p>升级RubyGems</p></li><li><p>安装rails</p></li><li><p>基本MVC探究之Hello world</p><h3 id="Ruby-On-rails-for-mac-os-High-Sierra"><a href="#Ruby-On-rails-for-mac-os-High-Sierra" class="headerlink" title="Ruby On rails for mac os High Sierra"></a>Ruby On rails for mac os High Sierra</h3><ul><li><p>Mac OS是自带ruby的，但是这些ruby的版本都不是最新的，我们也不要用这些过时的版本</p></li><li><p>首先，升级你的Mac OS到10.13</p></li><li><p>查看是否安装xcode command line tool：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>:xcode-select -p</span><br><span class="line">如果你看到：</span><br><span class="line">xcode-select: error: unable to get active developer directory...</span><br><span class="line">说明你没有安装xcode command line tool,需要按照下面的步骤安装。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你看到：</span><br><span class="line"><span class="meta">$</span>:/Applications/Xcode.app/Contents/Developer 或者/Library/Developer/CommandLineTools</span><br><span class="line">恭喜你，xcode command line tool你已经安装好了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">But，如果你很不幸运地看到了这句话：</span><br><span class="line">$: /Applications/Apple Dev Tools/Xcode.app/Contents/Developer</span><br><span class="line">那么你就要卸掉xcode重新安装了，具体原因看</span><br></pre></td></tr></table></figure><p><a href="http://rvm.io/support/faq#can-i-use-a-path-with-spaces" target="_blank" rel="noopener">这里</a></p></li><li><p>安装xcode</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>一路确认之后，就可以安好xcode，但是如果你的网速不好，等待时间过长，你可以从<a href="https://developer.apple.com/downloads/more" target="_blank" rel="noopener">这里</a>输入你的APPID下载。</p></li><li><p>确认一下是否安好</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xcode-select -p</span><br><span class="line">/Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><ul><li><p>在安装ruby on rails 之前，你应该配置你的Git。Git在Mac OS上使自动安装的软件</p></li><li><p>检查Git版本并确认已经安装让你放心</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git version</span><br><span class="line">git version 2.4.9 (Apple Git-60)</span><br></pre></td></tr></table></figure></li><li><p>配置Git之前，你应该到<a href="https://help.github.com/articles/signing-up-for-a-new-github-account/" target="_blank" rel="noopener">GitHub</a>上注册你的账号并记住密码和邮箱。并使用下面的命令配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config -l --global</span><br><span class="line">fatal: unable to read config file '/Users/.../.gitconfig': No such file or directory</span><br><span class="line"><span class="meta">$</span> git config --global user.name "Your Real Name"</span><br><span class="line"><span class="meta">$</span> git config --global user.email me@example.com</span><br><span class="line"><span class="meta">$</span> git config -l --global</span><br><span class="line">user.name=Your Real Name</span><br><span class="line">user.email=me@example.com</span><br></pre></td></tr></table></figure></li><li><p>Git配置完成，在你想用Git的时候，它就会蹦出来了。</p></li></ul><h3 id="安装Homebrow"><a href="#安装Homebrow" class="headerlink" title="安装Homebrow"></a>安装Homebrow</h3><ul><li><p>检查homebrow是否已经安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew</span><br><span class="line">-bash: brew: command not found</span><br></pre></td></tr></table></figure><p>RVM需要<a href="http://brew.sh/" target="_blank" rel="noopener">Homebrow</a>,其实一个Mac OS额安装包管理工具，用来下载一些软件，类似于Ubuntu的apt-get和centos的yum install.为避免安装RM出现问题，我们必须安装homebrow：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p>安装过程中可能会出现一些warning并让你输入密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Improper use of the sudo command could lead to data loss...</span><br><span class="line">To proceed, enter your password...</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure><p>尽管输入密码，忽略warning。</p><p>我们这里是使用了Mac OS内置的ruby来安装homebrow。</p></li></ul><h3 id="安装GPG"><a href="#安装GPG" class="headerlink" title="安装GPG"></a>安装GPG</h3><ul><li><p><a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard" target="_blank" rel="noopener">gpg</a>是一个用来检查RVM下载包的安全性的程序，我们使用homebrew来安装gpg:</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install gpg</span><br></pre></td></tr></table></figure></li><li><p>gpg安装之后，为RVM安装key:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> command curl -sSL https://rvm.io/mpapis.asc | gpg --import -</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装RVM"><a href="#安装RVM" class="headerlink" title="安装RVM"></a>安装RVM</h3><ul><li><p><a href="https://rvm.io/" target="_blank" rel="noopener">RVM</a>，是Ruby version manager的简写，用来安装ruby或者管理rails版本。<a href="https://rvm.io/rvm/install/" target="_blank" rel="noopener">这个网站</a>详细说明了安装ruby的方式，但是我们有一种最简便的方式：</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> \curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>“curl”前面的“\”用来避免ruby版本的冲突，不要漏掉。</p></li><li><p>安装过程中你可能会看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir: /etc/openssl: Permission denied</span><br><span class="line">mkdir -p "/etc/openssl" failed, retrying with sudo</span><br><span class="line">your password required for 'mkdir -p /etc/openssl':</span><br></pre></td></tr></table></figure><p>请输入密码并继续。</p></li><li><p>如果你已经安装过RVM，使用下面的命令update：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm get stable --autolibs=enable</span><br></pre></td></tr></table></figure></li><li><p>重启terminal窗口或者使用：使RVM生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h3><ul><li><p>在安装RVM之后，我们安装最新版本的ruby。ruby 2.5.1是写此博客时当前最新的ruby版本，还请查看ruby<a href="$ source ~/.rvm/scripts/rvm">官网</a>查看最新版本的ruby。必须指定ruby的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm install ruby-2.5.1</span><br></pre></td></tr></table></figure><p>安装后检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -v</span><br><span class="line">ruby 2.5.1...</span><br></pre></td></tr></table></figure></li></ul><h3 id="升级rubyGemset"><a href="#升级rubyGemset" class="headerlink" title="升级rubyGemset"></a>升级rubyGemset</h3><ul><li><p><a href="https://rubygems.org/gems/rubygems-update" target="_blank" rel="noopener">RubyGems</a>是一个ruby的包管理工具，用来安装ruby的工具或者额外功能的包。</p></li><li><p>查看gem版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem -v</span><br></pre></td></tr></table></figure><p>将gem升级到最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem update --system</span><br></pre></td></tr></table></figure></li><li><p>显示RVM gemsets的最初两个设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm gemset list</span><br><span class="line">gemsets for ruby-2.5.0</span><br><span class="line">=&gt; (default)</span><br><span class="line">   global</span><br></pre></td></tr></table></figure><p>一般使用global：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm gemset use global</span><br></pre></td></tr></table></figure></li><li><p>安装bundle,<a href="https://rubygems.org/gems/bundler" target="_blank" rel="noopener">Bundle</a>是一个管理gem的必须的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install Bundler</span><br></pre></td></tr></table></figure></li><li><p>安装Nokogiri，<a href="http://nokogiri.org/" target="_blank" rel="noopener">Nokogiri</a>需要编译成指定的系统，在上面的配置下，号称最难安装的包，也将安装好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install nokogiri</span><br></pre></td></tr></table></figure><p>如果你真的不幸运在安装时遇到问题，Stack <a href="http://stackoverflow.com/questions/tagged/nokogiri" target="_blank" rel="noopener">Overflow</a>能帮到你。</p></li></ul><h3 id="安装rails"><a href="#安装rails" class="headerlink" title="安装rails"></a>安装rails</h3><ul><li><p><a href="http://rubygems.org/gems/rails" target="_blank" rel="noopener">这里</a>是ruby On rail最新的版本，5.1是最新稳定版本，5.2是release版本，我们安装5.1.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install rails --version=5.1</span><br></pre></td></tr></table></figure><p>如果你喜欢尝鲜，可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install rails --pre</span><br></pre></td></tr></table></figure><p>安装release版本。</p><p>检查一下rails是否装好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rails -v</span><br><span class="line">Rails 5.2.0</span><br></pre></td></tr></table></figure></li><li><p>到此为止，ruby on rails 以及其环境配置都已妥当，可以开始你的ruby之旅了。</p></li></ul><h3 id="ruby-on-rails-的Hello-world"><a href="#ruby-on-rails-的Hello-world" class="headerlink" title="ruby on rails 的Hello world"></a>ruby on rails 的Hello world</h3><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /</span><br><span class="line"><span class="meta">$</span> mkdir worlspace</span><br><span class="line"><span class="meta">$</span> cd workspace</span><br><span class="line"><span class="meta">$</span> rails _5.1.0_ new hello_app</span><br><span class="line"><span class="meta">$</span> cd hello_app</span><br><span class="line"><span class="meta">$</span> rails server</span><br></pre></td></tr></table></figure><p>将<a href="http://localhost:3000输入浏览器，就能看到ruby" target="_blank" rel="noopener">http://localhost:3000输入浏览器，就能看到ruby</a> on rails的欢迎界面。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ruby" scheme="https://cloudsjhan.github.io/categories/ruby/"/>
    
    
      <category term="ruby on rails" scheme="https://cloudsjhan.github.io/tags/ruby-on-rails/"/>
    
      <category term="web" scheme="https://cloudsjhan.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>go实现UNIX command</title>
    <link href="https://cloudsjhan.github.io/2018/08/22/go-unix-cmd-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/22/go-unix-cmd-md/</id>
    <published>2018-08-22T11:27:41.000Z</published>
    <updated>2018-09-01T05:38:25.962Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line"><span class="comment">// 读取键盘的输入.</span></span><br><span class="line">input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行并解析command.</span></span><br><span class="line">err = execInput(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果cd命令没有路径的话，就报下面的错误</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 移除换行符.</span></span><br><span class="line">input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入分割成参数.</span></span><br><span class="line">args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对cd命令的情况进行区分.</span></span><br><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line"><span class="comment">// 暂时不支持cd加空格进入home目录.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrNoPath</span><br><span class="line">&#125;</span><br><span class="line">err := os.Chdir(args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stop further processing.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the command to execute.</span></span><br><span class="line">cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the correct output device.</span></span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the command and save it's output.</span></span><br><span class="line">err := cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行并测试</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>暂时不支持tab键自动补全命令，只是提供一种简单的思路。</p><hr>]]></content>
    
    <summary type="html">
    
      使用go实现UNIX环境下的命令行工具
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="unix" scheme="https://cloudsjhan.github.io/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>iterm2 突然报很奇怪的错误-Error  No user exists for uid 501</title>
    <link href="https://cloudsjhan.github.io/2018/08/21/iterm2-strange-err-md-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/21/iterm2-strange-err-md-md/</id>
    <published>2018-08-21T15:18:21.000Z</published>
    <updated>2018-08-21T15:33:12.206Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="http://www.qqyou.com/view.php?pic=http://p1.qqyou.com/pic/UploadPic/2014-7/9/2014070910421928610.jpg" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No user exists <span class="keyword">for</span> uid <span class="number">501</span></span><br><span class="line">fatal: Could <span class="keyword">not</span> read <span class="keyword">from</span> remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br></pre></td></tr></table></figure><ul><li>上午还好好的，刚刚连接GitHub报这个错误，排查后了解到是iterm2的神坑。</li><li>重启iterm终端就好 系统有更新的话 需要重启终端 更新。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      iterm2 突然报很奇怪的错误-Error No user exists for uid 501
    
    </summary>
    
      <category term="生活中奇怪的坑" scheme="https://cloudsjhan.github.io/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%A5%87%E6%80%AA%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="日常的坑系列" scheme="https://cloudsjhan.github.io/tags/%E6%97%A5%E5%B8%B8%E7%9A%84%E5%9D%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>golang中interface的通用设计方法</title>
    <link href="https://cloudsjhan.github.io/2018/08/21/golang%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://cloudsjhan.github.io/2018/08/21/golang通用接口设计方法/</id>
    <published>2018-08-21T14:18:58.000Z</published>
    <updated>2018-08-21T15:10:30.131Z</updated>
    
    <content type="html"><![CDATA[<p class="description">golang中接口设计的通用方法</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 接口定义</span><br><span class="line"><span class="keyword">type</span> XxxManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(args argsType) (*XxxStruct, error)</span><br><span class="line">    Get(args argsType) (**XxxStruct, error)</span><br><span class="line">    Update(args argsType) (*XxxStruct, error)</span><br><span class="line">    Delete(name <span class="keyword">string</span>, options *DeleleOptions) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 结构体定义 </span><br><span class="line"><span class="keyword">type</span> XxxManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    kubeCli *kubernetes.Clientset</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>，构造函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewXxxManagerImpl</span> <span class="params">(namespace, name <span class="keyword">string</span>, kubeCli *kubernetes.Clientset)</span> <span class="title">XxxManager</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;XxxManagerImpl&#123;</span><br><span class="line">        Name name,</span><br><span class="line">        Namespace namespace,</span><br><span class="line">        kubeCli: kubeCli,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span> 方法具体实现</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XxxManagerImpl)</span> <span class="title">Create</span><span class="params">(args argsType)</span> <span class="params">(*XxxStruct, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//具体的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>golang通用接口设计</strong></p><p>根据以上设计cdosapi封装接口：</p>]]></content>
    
    <summary type="html">
    
      golang中interface的通用设计方法
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>python3中遇到&#39;TypeError Unicode-objects must be encoded before hashing&#39;</title>
    <link href="https://cloudsjhan.github.io/2018/08/20/python-md5-err-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/20/python-md5-err-md/</id>
    <published>2018-08-20T14:18:58.000Z</published>
    <updated>2018-09-28T02:06:52.282Z</updated>
    
    <content type="html"><![CDATA[<p class="description">Python3中进行MD5加密，遇到编码问题</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode, quote_plus</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verfy_ac</span><span class="params">(private_key)</span>:</span></span><br><span class="line"></span><br><span class="line">    item = &#123;</span><br><span class="line">     <span class="string">"Action"</span>     :  <span class="string">"CreateUHostInstance"</span>,</span><br><span class="line">     <span class="string">"CPU"</span>        :  <span class="number">2</span>,</span><br><span class="line">     <span class="string">"ChargeType"</span> :  <span class="string">"Month"</span>,</span><br><span class="line">     <span class="string">"DiskSpace"</span>  :  <span class="number">10</span>,</span><br><span class="line">     <span class="string">"ImageId"</span>    :  <span class="string">"f43736e1-65a5-4bea-ad2e-8a46e18883c2"</span>,</span><br><span class="line">     <span class="string">"LoginMode"</span>  :  <span class="string">"Password"</span>,</span><br><span class="line">     <span class="string">"Memory"</span>     :  <span class="number">2048</span>,</span><br><span class="line">     <span class="string">"Name"</span>       :  <span class="string">"Host01"</span>,</span><br><span class="line">     <span class="string">"Password"</span>   :  <span class="string">"VUNsb3VkLmNu"</span>,</span><br><span class="line">     <span class="string">"PublicKey"</span>  :  <span class="string">"ucloudsomeone%40example.com1296235120854146120"</span>,</span><br><span class="line">     <span class="string">"Quantity"</span>   :  <span class="number">1</span>,</span><br><span class="line">     <span class="string">"Region"</span>     :  <span class="string">"cn-bj2"</span>,</span><br><span class="line">     <span class="string">"Zone"</span>       :  <span class="string">"cn-bj2-04"</span></span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment"># 将参数串排序</span></span><br><span class="line"></span><br><span class="line">    params_data = <span class="string">""</span></span><br><span class="line">    <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> item.items():</span><br><span class="line">        params_data = params_data + str(key) + str(value)</span><br><span class="line">    params_data = params_data + private_key</span><br><span class="line">    params_data_en = quote_plus(params_data)</span><br><span class="line"></span><br><span class="line">    sign = hashlib.sha1()</span><br><span class="line">    sign.update(params_data_en.encode(<span class="string">'utf8'</span>))</span><br><span class="line">    signature = sign.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> signature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(verfy_ac(<span class="string">"46f09bb9fab4f12dfc160dae12273d5332b5debe"</span>))</span><br></pre></td></tr></table></figure><p>这是<a href="https://docs.ucloud.cn/api/summary/signature" target="_blank" rel="noopener">ucloud官方的API教程</a>，想根据此教程生成签名，教程中的代码是基于Python2.7编写，我将其改成了Python3.但是在执行时报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Unicode-objects must be encoded before hashing</span><br></pre></td></tr></table></figure><hr><p>排错后发现python3中字符对象是unicode对象，不能直接加密，需要编码后才能进行update。</p><p>就是改成如下即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign.update(params_data_en.encode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      Python中进行md5加密时遇到的编码问题
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
      <category term="md5编码" scheme="https://cloudsjhan.github.io/tags/md5%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cloudsjhan.github.io/2018/08/18/hello-world/"/>
    <id>https://cloudsjhan.github.io/2018/08/18/hello-world/</id>
    <published>2018-08-18T14:05:08.000Z</published>
    <updated>2018-08-18T14:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cloud world</title>
  
  <subtitle>To be A geek</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cloudsjhan.github.io/"/>
  <updated>2018-12-25T11:48:50.260Z</updated>
  <id>https://cloudsjhan.github.io/</id>
  
  <author>
    <name>cloud sjhan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang use reflect to judge type of variable</title>
    <link href="https://cloudsjhan.github.io/2018/12/25/golang-use-reflect-to-judge-type-of-variable/"/>
    <id>https://cloudsjhan.github.io/2018/12/25/golang-use-reflect-to-judge-type-of-variable/</id>
    <published>2018-12-25T11:38:43.000Z</published>
    <updated>2018-12-25T11:48:50.260Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>众所周知，golang中可以使用空接口即interface{}代表任何类型的数据，那么在使用的时候，我们有时需要获取返回值的具体类型</li><li>场景：beego框架中的orm.Params类型，实际上是map[string]interface{},在使用<a href="https://beego.me/docs/mvc/model/query.md" target="_blank" rel="noopener">values接口</a>的时候，需要从返回Map中获取数据，需要这样获取：<code>Id:m[&quot;Id&quot;].(string)</code>,这时m[“Id”]实际上是String类型，我们可以用reflect模块来获取实际的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(m[<span class="string">"Id"</span>])</span><br><span class="line"><span class="comment">//返回为String</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x int32 = 20</span><br><span class="line">    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      golang use reflect to judge type of variable
    
    </summary>
    
      <category term="go" scheme="https://cloudsjhan.github.io/categories/go/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql add primary key auto_increment</title>
    <link href="https://cloudsjhan.github.io/2018/12/25/mysql-add-primary-key-auto-increment/"/>
    <id>https://cloudsjhan.github.io/2018/12/25/mysql-add-primary-key-auto-increment/</id>
    <published>2018-12-25T11:08:53.000Z</published>
    <updated>2018-12-25T11:52:17.418Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>添加字段id,并将其设置为主键自增</p><ul><li>alter table TABLE_NAME add id int not null primary key Auto_increment</li></ul><p>如果想添加已经有了一列为主键，可以用：</p><ul><li><p>alter table TABLE_NAME add primary key(COL_NAME);</p></li><li><p>如果想修改一列为主键，则需要先删除原来的主键：</p></li></ul><p>alter table TABLE_NAME drop primary key;</p><p>再重新添加主键：</p><ul><li>alter table TABLE_NAME add primary key(COL_NAME);</li></ul><hr>]]></content>
    
    <summary type="html">
    
      MySQL add primary key auto_increment for established table
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Go关于time包的解析与使用</title>
    <link href="https://cloudsjhan.github.io/2018/12/16/Go%E5%85%B3%E4%BA%8Etime%E5%8C%85%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/16/Go关于time包的解析与使用/</id>
    <published>2018-12-16T15:16:34.000Z</published>
    <updated>2018-12-16T15:26:02.748Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="Go关于时间与日期的处理"><a href="#Go关于时间与日期的处理" class="headerlink" title="Go关于时间与日期的处理"></a>Go关于时间与日期的处理</h3><h4 id="关于time的数据类型"><a href="#关于time的数据类型" class="headerlink" title="关于time的数据类型"></a>关于time的数据类型</h4><ul><li><p>time包依赖的数据类型有：<strong>time.Time</strong>,<strong>time.Month</strong>,<strong>time.WeekDay</strong>,<strong>time.Duration</strong>,<strong>time.Location</strong>.</p></li><li><p>详细介绍以上几种数据类型</p><ul><li><p>time.Time</p></li><li><p><code>/usr/local/go/src/time/time.go</code> 定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    sec <span class="keyword">int64</span> <span class="comment">// 从1年1月1日 00:00:00 UTC 至今过去的秒数</span></span><br><span class="line">    nsec <span class="keyword">int32</span> <span class="comment">// 最近一秒到下一秒过去的纳秒数</span></span><br><span class="line">    loc *Location <span class="comment">// 时区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time.Time会返回纳秒时间精度的时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ti time.Time</span><br><span class="line">ti = time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"时间: %v, 时区:  %v,  时间类型: %T\n"</span>, t, t.Location(), t)</span><br><span class="line"><span class="comment">//时间: 2018-12-15 09:06:05.816187261 +0800 CST, 时区:  Local,  时间类型: time.Time</span></span><br></pre></td></tr></table></figure></li><li><p>time.Month, go中自己重新定义了month的类型，与time.year和time.day不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Month int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    January Month = 1 + iota</span><br><span class="line">    February</span><br><span class="line">    March</span><br><span class="line">    April</span><br><span class="line">    May</span><br><span class="line">    June</span><br><span class="line">    July</span><br><span class="line">    August</span><br><span class="line">    September</span><br><span class="line">    October</span><br><span class="line">    November</span><br><span class="line">    December</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota是golang语言的常量计数器,只能在常量的表达式中使用。<br> iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p></li><li><p>time.WeekDay,代表一周之中的星期几（当然是按照西方的规则，他们把周日当做是一周的开始）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WeekDay <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>time.Duration,代表两个时间点之间的纳秒差值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>time.Location,时区信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    zone []zone</span><br><span class="line">    tx   []zoneTrans</span><br><span class="line">    cacheStart <span class="keyword">int64</span></span><br><span class="line">    cacheEnd   <span class="keyword">int64</span></span><br><span class="line">    cacheZone  *zone</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//北京时间：Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="以上类型receiver的实现方法"><a href="#以上类型receiver的实现方法" class="headerlink" title="以上类型receiver的实现方法"></a>以上类型receiver的实现方法</h4><ul><li>time.Time相关方法</li></ul><p><code>func Now() Time {}</code> // 当前本地时间</p><p> <code>func Unix(sec int64, nsec int64) Time {}</code>  // 根据时间戳返回本地时间</p><p> <code>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {}</code> // 返回指定时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ 当前本地时间</span><br><span class="line">t = time.Now()</span><br><span class="line">fmt.Println(<span class="string">"'time.Now': "</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据时间戳返回本地时间</span></span><br><span class="line">t_by_unix := time.Unix(<span class="number">1487780010</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"'time.Unix': "</span>, t_by_unix)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定时间</span></span><br><span class="line">t_by_date := time.Date(<span class="number">2017</span>, time.Month(<span class="number">2</span>), <span class="number">23</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>, l)</span><br><span class="line">fmt.Println(<span class="string">"'time.Date': "</span>, t_by_date)</span><br></pre></td></tr></table></figure><ul><li><p>按照时区信息显示时间</p></li><li><p><code>func (t Time) UTC() Time {}</code> // 获取指定时间在UTC 时区的时间表示</p></li><li><code>func (t Time) Local() Time {}</code> // 以本地时区表示</li><li><code>func (t Time) In(loc *Location) Time {}</code> // 时间在指定时区的表示</li><li><code>func (t Time) Format(layout string) string {}</code> // 按指定格式显示时间</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定时间在UTC 时区的时间表示</span></span><br><span class="line">t_by_utc := t.UTC()</span><br><span class="line">fmt.Println(<span class="string">"'t.UTC': "</span>, t_by_utc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地时间表示</span></span><br><span class="line">t_by_local := t.Local()</span><br><span class="line">fmt.Println(<span class="string">"'t.Local': "</span>, t_by_local)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间在指定时区的表示</span></span><br><span class="line">t_in := t.In(time.UTC)</span><br><span class="line">fmt.Println(<span class="string">"'t.In': "</span>, t_in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Format</span></span><br><span class="line">fmt.Println(<span class="string">"t.Format"</span>, t.Format(time.RFC3339))</span><br></pre></td></tr></table></figure><ul><li>获取年月日等信息</li></ul><p><code>func (t Time) Date() (year int, month Month, day int) {}</code> // 返回时间的日期信息</p><p> <code>func (t Time) Year() int {}</code> // 返回年</p><p> <code>func (t Time) Month() Month {}</code> // 月</p><p> <code>func (t Time) Day() int {}</code> // 日</p><p> <code>func (t Time) Weekday() Weekday {}</code> // 星期</p><p> <code>func (t Time) ISOWeek() (year, week int) {}</code> // 返回年，星期范围编号</p><p> <code>func (t Time) Clock() (hour, min, sec int) {}</code> // 返回时间的时分秒</p><p> <code>func (t Time) Hour() int {}</code> // 返回小时</p><p> <code>func (t Time) Minute() int {}</code> // 分钟</p><p> <code>func (t Time) Second() int {}</code> // 秒</p><p> <code>func (t Time) Nanosecond() int {}</code> // 纳秒</p><p> <code>func (t Time) YearDay() int {}</code> // 一年中对应的天</p><p> <code>func (t Time) Location() *Location {}</code> // 时间的时区</p><p> <code>func (t Time) Zone() (name string, offset int) {}</code> // 时间所在时区的规范名和想对UTC 时间偏移量</p><p> <code>func (t Time) Unix() int64 {}</code> // 时间转为时间戳</p><p> <code>func (t Time) UnixNano() int64 {}</code> // 时间转为时间戳（纳秒）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回时间的日期信息</span></span><br><span class="line">year, month, day := t.Date()</span><br><span class="line">fmt.Println(<span class="string">"'t.Date': "</span>, year, month, day)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 星期</span></span><br><span class="line">week := t.Weekday()</span><br><span class="line">fmt.Println(<span class="string">"'t.Weekday': "</span>, week)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回年，星期范围编号</span></span><br><span class="line">year, week_int := t.ISOWeek()</span><br><span class="line">fmt.Println(<span class="string">"'t.ISOWeek': "</span>, year, week_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回时间的时分秒</span></span><br><span class="line">hour, min, sec := t.Clock()</span><br><span class="line">fmt.Println(<span class="string">"'t.Clock': "</span>, hour, min, sec)</span><br></pre></td></tr></table></figure><ul><li>时间运算</li></ul><p><code>func (t Time) IsZero() bool {}</code> // 是否是零时时间</p><p> <code>func (t Time) After(u Time) bool {}</code> // 时间在u 之前</p><p> <code>func (t Time) Before(u Time) bool {}</code> // 时间在u 之后</p><p> <code>func (t Time) Equal(u Time) bool {}</code> // 时间与u 相同</p><p> <code>func (t Time) Add(d Duration) Time {}</code> // 返回t +d 的时间点</p><p> <code>func (t Time) Sub(u Time) Duration {}</code> // 返回 t-u</p><p> <code>func (t Time) AddDate(years int, months int, days int) Time {}</code> 返回增加了给出的年份、月份和天数的时间点Time</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 返回增加了给出的年份、月份和天数的时间点Time</span><br><span class="line">t_new := t.AddDate(0, 1, 1)</span><br><span class="line">fmt.Println(&quot;&apos;t.AddDate&apos;: &quot;, t_new)</span><br><span class="line"></span><br><span class="line">// 时间在u 之前</span><br><span class="line">is_after := t.After(t_new)</span><br><span class="line">fmt.Println(&quot;&apos;t.After&apos;: &quot;, is_after)</span><br></pre></td></tr></table></figure><ul><li>time.Duration的类型receiver实现的方法</li></ul><p><code>func (d Duration) String() string</code> // 格式化输出 Duration</p><p> <code>func (d Duration) Nanoseconds() int64</code> // 将时间段表示为纳秒</p><p> <code>func (d Duration) Seconds() float64</code> // 将时间段表示为秒</p><p> <code>func (d Duration) Minutes() float64</code> // 将时间段表示为分钟</p><p> <code>func (d Duration) Hours() float64</code> // 将时间段表示为小时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.Duration 时间段</span></span><br><span class="line">fmt.Println(<span class="string">"time.Duration 时间段"</span>)</span><br><span class="line">d = time.Duration(<span class="number">10000000000000</span>)<span class="comment">//输入参数为int64类型</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"'String: %v', 'Nanoseconds: %v', 'Seconds: %v', 'Minutes: %v', 'Hours: %v'\n"</span>, </span><br><span class="line">d.String(), d.Nanoseconds(), d.Seconds(), d.Minutes(), d.Hours())</span><br><span class="line"><span class="comment">// 'String: 2h46m40s', 'Nanoseconds: 10000000000000', 'Seconds: 10000', 'Minutes: 166.66666666666666', 'Hours: 2.7777777777777777'</span></span><br></pre></td></tr></table></figure><ul><li>time.Location的receiver实现的方法</li></ul><p><code>func (l *Location) String() string</code> // 输出时区名</p><p> <code>func FixedZone(name string, offset int) *Location</code> // FixedZone 使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location</p><p> <code>func LoadLocation(name string) (*Location, error)</code> // LoadLocation 使用给定的名字创建Location</p><p><code>func Sleep(d Duration)</code> // Sleep阻塞当前go程至少d代表的时间段。d&lt;=0时，Sleep会立刻返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d_second := time.Second</span><br><span class="line">time.Sleep(d_second)</span><br></pre></td></tr></table></figure><h3 id="一些常用的技巧与代码示例"><a href="#一些常用的技巧与代码示例" class="headerlink" title="一些常用的技巧与代码示例"></a>一些常用的技巧与代码示例</h3><ul><li><p>string与time.Time互转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">date        = <span class="string">"2006-01-02"</span></span><br><span class="line">datetime    = <span class="string">"2006-01-02 15:04:02"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">timeStamp := time.Now().Format(date) <span class="comment">//将当前时间，即time.Time类型转为string</span></span><br><span class="line"></span><br><span class="line">billTimeStamp, err := time.Parse(date,timeStamp)<span class="comment">//将String类型的时间转为time.Time类型</span></span><br></pre></td></tr></table></figure></li><li><p>unix time与String互转</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endTime := time.Unix(time.Now().Unix(), <span class="number">0</span>)<span class="comment">//此时endTime是time.Time类型</span></span><br><span class="line">endStr := endTime.Format(datetime)<span class="comment">//将unix time 转为了String，再根据上面的例子，可转为time.Time</span></span><br></pre></td></tr></table></figure><h4 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h4><p><a href="https://link.jianshu.com/?t=http://studygolang.com/static/pkgdoc/pkg/time.htm" target="_blank" rel="noopener">pkg/time中文翻译</a></p><p><a href="https://link.jianshu.com/?t=https://golang.org/pkg/time/" target="_blank" rel="noopener">pkg/time英文</a></p>]]></content>
    
    <summary type="html">
    
      golang time包的解析与使用
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>从冒泡排序优化到Go基准测试</title>
    <link href="https://cloudsjhan.github.io/2018/12/15/%E4%BB%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E5%88%B0Go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <id>https://cloudsjhan.github.io/2018/12/15/从冒泡排序优化到Go基准测试/</id>
    <published>2018-12-15T15:12:08.000Z</published>
    <updated>2018-12-15T16:03:47.813Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="Go的测试"><a href="#Go的测试" class="headerlink" title="Go的测试"></a>Go的测试</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li>测试文件命名：文件命名使用 xx_test.go 保存在项目目录里即可，也可以新建个test目录，TestAll；</li><li>测试函数命名：单元测试函数名Test开头，接收一个指针型参数（*testing.T）；</li><li>运行测试程序：go run test -v -run=”函数名”，其中-v意思是输出详细的测试信息；</li></ul><h4 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h4><ul><li>测试文件命名：测试文件命名：文件命名使用 xx_test.go 保存在项目目录里即可，也可以新建个test目录，TestAll；</li><li>测试函数命名：基准测试以Benchmark开头，接收一个指针型参数（*testing.B）；</li><li>运行测试程序：go test -v -bench=”函数名”；</li><li>还有一个参数是 -benchmem, -benchmem 表示分配内存的次数和字节数，-benchtime=”3s” 表示持续3秒</li></ul><h3 id="冒泡排序及其简单优化"><a href="#冒泡排序及其简单优化" class="headerlink" title="冒泡排序及其简单优化"></a>冒泡排序及其简单优化</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>前几天看一个公众号，说是有个人去美团面试，被要求手写冒泡排序算法，这人心想这还不简单的，分分钟写下了下面的代码，可以说是非常标准的冒泡排序了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(array []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i&lt;<span class="built_in">len</span>(array)<span class="number">-1</span>;i++&#123;</span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(array)-i<span class="number">-1</span>;j++&#123;</span><br><span class="line"><span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]&#123;</span><br><span class="line">swap(j, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是随之，面试官说让他优化一下这个算法，问他有没有可优化的地方，这人就懵逼了。其实冒泡排序可优化的地方很多，最简单的一种就是加一个标志位，检查是否已经排序完毕，排序已经完成的话就没有必要再比较下去，浪费时间。上面的代码添加几行，那人就很可能拿到offer了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(array []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i&lt;<span class="built_in">len</span>(array)<span class="number">-1</span>;i++&#123;</span><br><span class="line">exchanged := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j :=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(array)-i<span class="number">-1</span>;j++&#123;</span><br><span class="line"><span class="keyword">if</span> array[j]&gt;array[j+<span class="number">1</span>]&#123;</span><br><span class="line">swap(j, j+<span class="number">1</span>)</span><br><span class="line">exchanged = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> exchanged == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如何更直观的看出，优化过的代码确实有效呢，我们就可以使用go自带的基准测试，测试一下两段代码的性能，优化与否就一目了然。</p><h3 id="基准测试冒泡排序"><a href="#基准测试冒泡排序" class="headerlink" title="基准测试冒泡排序"></a>基准测试冒泡排序</h3><ul><li><p>首先我们创建一个存放测试文件的文件夹</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir testAll</span><br></pre></td></tr></table></figure></li><li><p>然后创建基准测试文件</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch benchmark_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><ul><li>编写基准测试代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sortArray = []int&#123;41, 24, 76, 11, 45, 64, 21, 69, 19, 36&#125;</span><br><span class="line">func BenchmarkBubbleSort(b *testing.B)  &#123;</span><br><span class="line"></span><br><span class="line">for i:=0;i&lt;b.N;i++ &#123;</span><br><span class="line">BubbleSort(sortArray)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试基本冒泡排序"><a href="#测试基本冒泡排序" class="headerlink" title="测试基本冒泡排序"></a>测试基本冒泡排序</h4><ul><li><p>我们首先测试最原始的冒泡排序</p></li><li><p>在testAll文件夹下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -bench=&quot;BubbleSort&quot;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy7v2wibo3j313o0bgta3.jpg" alt=""></p><p>基准测试结果如图所示，解释一下几个关键参数，</p><p>81.2ns/op 表示每次操作耗时81.2纳秒，1.725s表示程序运行的时间。</p><h3 id="测试优化的冒泡排序"><a href="#测试优化的冒泡排序" class="headerlink" title="测试优化的冒泡排序"></a>测试优化的冒泡排序</h3><ul><li>执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -v -bench=&quot;BubbleSort&quot;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy7v8m1tz8j31400bcmyk.jpg" alt=""></p></li></ul><p>  可以看到优化过的代码，执行时间为1.2s,而且每次操作的耗时为23.0纳秒，足足降低了60%多。可见一个很简单的优化就可以使代码提升这么多，在以后的工作中，对于代码的设计与优化还是要重视。</p><hr>]]></content>
    
    <summary type="html">
    
      从冒泡排序看Go的基准测试及其使用
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>postman 接口测试神器</title>
    <link href="https://cloudsjhan.github.io/2018/12/08/postman-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/08/postman-接口测试神器/</id>
    <published>2018-12-08T15:41:16.000Z</published>
    <updated>2018-12-08T15:54:58.525Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><h1 id="Postman-接口测试神器"><a href="#Postman-接口测试神器" class="headerlink" title="Postman 接口测试神器"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e6%8e%a5%e5%8f%a3%e6%b5%8b%e8%af%95%e7%a5%9e%e5%99%a8" target="_blank" rel="noopener">Postman 接口测试神器</a></h1><p>Postman 是一个接口测试和 http 请求的神器，非常好用。</p><p>官方 github 地址: <a href="https://github.com/postmanlabs" target="_blank" rel="noopener">https://github.com/postmanlabs</a></p><p>Postman 的优点：</p><ul><li>支持各种的请求类型: get、post、put、patch、delete 等</li><li>支持在线存储数据，通过账号就可以进行迁移数据</li><li>很方便的支持请求 header 和请求参数的设置</li><li>支持不同的认证机制，包括 Basic Auth，Digest Auth，OAuth 1.0，OAuth 2.0 等</li><li>响应数据是自动按照语法格式高亮的，包括 HTML，JSON 和 XML</li></ul><blockquote><p> 以下内容主要参考： <a href="https://github.com/crifan/api_tool_postman" target="_blank" rel="noopener">Github: api_tool_postman</a>  </p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%ae%89%e8%a3%85" target="_blank" rel="noopener">安装</a></h2><p>Postman 可以单独作为一个应用安装，也可以作为 chrome 的一个插件安装。</p><ul><li>chrome 插件安装, <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="noopener">Postman 插件地址</a>  </li><li><a href="http://files.cnblogs.com/files/mafly/postman-4.1.2.rar" target="_blank" rel="noopener">单独应用安装下载</a>  </li></ul><p>下面主要介绍下载安装独立版本app 软件的 Postman 的过程：</p><p>去主页<a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman 官网</a>找到：<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">Postman | Apps</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/c7j24uyvhy.png?imageView2/2/w/1620" alt="img"></p><p>去下载自己平台的版本：</p><ul><li>Mac</li><li>Windows（x86/x64）</li><li>Linux（x86/x64） 即可。</li></ul><h2 id="快速入门，总体使用方略"><a href="#快速入门，总体使用方略" class="headerlink" title="快速入门，总体使用方略"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e6%80%bb%e4%bd%93%e4%bd%bf%e7%94%a8%e6%96%b9%e7%95%a5" target="_blank" rel="noopener">快速入门，总体使用方略</a></h2><p>安装成功后，打开软件。</p><h3 id="新建接口"><a href="#新建接口" class="headerlink" title="新建接口"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%96%b0%e5%bb%ba%e6%8e%a5%e5%8f%a3" target="_blank" rel="noopener">新建接口</a></h3><p>对应的Request：<code>New -&gt; Request</code></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/a43avzlvvt.png?imageView2/2/w/1620" alt="img"></p><p>或，在右边的 Tab 页面中点击加号+：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/kr7zu3lg54.png?imageView2/2/w/1620" alt="img"></p><p>即可看到新建的 Tab 页：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/7x0f5ohfxq.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置-HTTP-请求的方法"><a href="#设置-HTTP-请求的方法" class="headerlink" title="设置 HTTP 请求的方法"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae-http-%e8%af%b7%e6%b1%82%e7%9a%84%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">设置 HTTP 请求的方法</a></h3><p>设置 HTTP 的 Method 方法和输入 api 的地址</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nvkjcxavj1.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置相关请求头信息"><a href="#设置相关请求头信息" class="headerlink" title="设置相关请求头信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae%e7%9b%b8%e5%85%b3%e8%af%b7%e6%b1%82%e5%a4%b4%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">设置相关请求头信息</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/sde0dugknd.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d4vmkb97c4.png?imageView2/2/w/1620" alt="img"></p><h3 id="设置相关-GET-或-POST-等的参数"><a href="#设置相关-GET-或-POST-等的参数" class="headerlink" title="设置相关 GET 或 POST 等的参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%ae%be%e7%bd%ae%e7%9b%b8%e5%85%b3-get-%e6%88%96-post-%e7%ad%89%e7%9a%84%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">设置相关 GET 或 POST 等的参数</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/qgi9b1hmbs.png?imageView2/2/w/1620" alt="img"></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82" target="_blank" rel="noopener">发送请求</a></h3><p>都填写好之后，点击 Send 去发送请求 Request：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/u4cd93numl.png?imageView2/2/w/1620" alt="img"></p><h3 id="查看响应-Response的信息"><a href="#查看响应-Response的信息" class="headerlink" title="查看响应 Response的信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%9f%a5%e7%9c%8b%e5%93%8d%e5%ba%94-response%e7%9a%84%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">查看响应 Response的信息</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/oo22jbrg8v.png?imageView2/2/w/1620" alt="img"></p><p>然后可以重复上述修改 Request 的参数，点击 Send 去发送请求的过程，以便调试到 API 接口正常工作为止。</p><h3 id="保存接口配置"><a href="#保存接口配置" class="headerlink" title="保存接口配置"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bf%9d%e5%ad%98%e6%8e%a5%e5%8f%a3%e9%85%8d%e7%bd%ae" target="_blank" rel="noopener">保存接口配置</a></h3><p>待整个接口都调试完毕后，记得点击 Save 去保存接口信息：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n2p3eq0ie6.png?imageView2/2/w/1620" alt="img"></p><p>去保存当前 API 接口，然后需要填写相关的接口信息：</p><ul><li>Request Name: 请求的名字 <ul><li>我一般习惯用保存为 接口的最后的字段名，比如<code>http://{{server_address}}/ucows/login/login</code>中的<code>/login/login</code></li></ul></li><li>Request Description: 接口的描述 <ul><li><code>可选</code> 最好写上该接口的要实现的基本功能和相关注意事项</li><li>支持 Markdown 语法</li></ul></li><li>Select a collection or folder to save: 选择要保存到哪个分组（或文件夹） <ul><li>往往保存到某个 API 接口到所属的该项目名的分组</li></ul></li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/zntknyfx6w.png?imageView2/2/w/1620" alt="img"></p><p>填写好内容，选择好分组，再点击保存：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/sb5yb8cwpi.png?imageView2/2/w/1620" alt="img"></p><p>此时，Tab 的右上角的黄色点（表示没有保存）消失了，表示已保存。</p><p>且对应的分组中可以看到对应的接口了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/x3lmlaykbk.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [warning] 默认不保存返回的 Response 数据  </p></blockquote><ul><li>直接点击 Save 去保存，只能保存 API 本身（的 Request 请求），不会保存 Response 的数据</li><li>想要保存 Response 数据，需要用后面要介绍的 <a href="http://book.crifan.com/books/api_tool_postman/website/postman_func_resp/save_multi_example.html" target="_blank" rel="noopener">多个 Example</a></li></ul><h2 id="Request-的多参数操作详解"><a href="#Request-的多参数操作详解" class="headerlink" title="Request 的多参数操作详解"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=request-%e7%9a%84%e5%a4%9a%e5%8f%82%e6%95%b0%e6%93%8d%e4%bd%9c%e8%af%a6%e8%a7%a3" target="_blank" rel="noopener">Request 的多参数操作详解</a></h2><h3 id="自动解析多个参数-Params"><a href="#自动解析多个参数-Params" class="headerlink" title="自动解析多个参数 Params"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e8%87%aa%e5%8a%a8%e8%a7%a3%e6%9e%90%e5%a4%9a%e4%b8%aa%e5%8f%82%e6%95%b0-params" target="_blank" rel="noopener">自动解析多个参数 Params</a></h3><p>比如，对于一个 GET 的请求的 url 是： <code>http://openapi.youdao.com/api?q=纠删码(EC)的学习&amp;from=zh_CHS&amp;to=EN&amp;appKey=152e0e77723a0026&amp;salt=4&amp;sign=6BE15F1868019AD71C442E6399DB1FE4</code></p><p>对应着其实是<code>?key=value</code>形式中包含多个 Http 的 GET 的 query string=query parameters</p><p>Postman 可以自动帮我们解析出对应参数，可以点击 Params：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9kga5uhyuq.png?imageView2/2/w/1620" alt="img"></p><p>看到展开的多个参数：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/2agjjtnusz.png?imageView2/2/w/1620" alt="img"></p><p>如此就可以很方便的修改，增删对应的参数了。</p><h3 id="临时禁用参数"><a href="#临时禁用参数" class="headerlink" title="临时禁用参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%b8%b4%e6%97%b6%e7%a6%81%e7%94%a8%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">临时禁用参数</a></h3><p>且还支持，在不删除某参数的情况下，如果想要暂时不传参数，可以方便的通过不勾选的方式去实现：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/atacmafooc.png?imageView2/2/w/1620" alt="img"></p><h3 id="批量编辑-GET-的多个参数"><a href="#批量编辑-GET-的多个参数" class="headerlink" title="批量编辑 GET 的多个参数"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%89%b9%e9%87%8f%e7%bc%96%e8%be%91-get-%e7%9a%84%e5%a4%9a%e4%b8%aa%e5%8f%82%e6%95%b0" target="_blank" rel="noopener">批量编辑 GET 的多个参数</a></h3><p>当然，如果想要批量的编辑参数，可以点击右上角的Bulk Edit，去实现批量编辑。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/xn3piv6qv8.png?imageView2/2/w/1620" alt="img"></p><h2 id="接口描述与自动生成文档"><a href="#接口描述与自动生成文档" class="headerlink" title="接口描述与自动生成文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%8e%a5%e5%8f%a3%e6%8f%8f%e8%bf%b0%e4%b8%8e%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">接口描述与自动生成文档</a></h2><p>API 的描述中，也支持 Markdown，官方的接口说明文档：<a href="https://www.getpostman.com/docs/postman/api_documentation/intro_to_api_documentation" target="_blank" rel="noopener">Intro to API documentation</a>。</p><p>所以，可以很方便的添加有条理的接口描述，尤其是参数解释了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/428i64obvu.png?imageView2/2/w/1620" alt="img"></p><h3 id="描述支持-markdown-语法"><a href="#描述支持-markdown-语法" class="headerlink" title="描述支持 markdown 语法"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%8f%8f%e8%bf%b0%e6%94%af%e6%8c%81-markdown-%e8%af%ad%e6%b3%95" target="_blank" rel="noopener">描述支持 markdown 语法</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/gae7gd5ldb.png?imageView2/2/w/1620" alt="img"></p><p>而对于要解释的参数，可以通过之前的<code>Param -&gt; Bulk Edit</code>的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/k8h8cccbmy.png?imageView2/2/w/1620" alt="img"></p><p>拷贝过来，再继续去编辑：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/q3ehctbg4b.png?imageView2/2/w/1620" alt="img"></p><p>以及添加更多解释信息：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/cvxks97jg5.png?imageView2/2/w/1620" alt="img"></p><p>点击 Update 后，即可保存。</p><h3 id="发布接口并生成-markdown-的描述文件"><a href="#发布接口并生成-markdown-的描述文件" class="headerlink" title="发布接口并生成 markdown 的描述文件"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e5%b8%83%e6%8e%a5%e5%8f%a3%e5%b9%b6%e7%94%9f%e6%88%90-markdown-%e7%9a%84%e6%8f%8f%e8%bf%b0%e6%96%87%e4%bb%b6" target="_blank" rel="noopener">发布接口并生成 markdown 的描述文件</a></h3><p>去发布后：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6td22h0mcp.png?imageView2/2/w/1620" alt="img"></p><p>对应的效果：<a href="https://documenter.getpostman.com/view/669382/collection/77fd4ek" target="_blank" rel="noopener">有道翻译</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/w9r9f2lhvj.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6w93zr891f.png?imageView2/2/w/1620" alt="img"></p><h2 id="Response-深入"><a href="#Response-深入" class="headerlink" title="Response 深入"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e6%b7%b1%e5%85%a5" target="_blank" rel="noopener">Response 深入</a></h2><h3 id="Response-数据显示模式"><a href="#Response-数据显示模式" class="headerlink" title="Response 数据显示模式"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e6%95%b0%e6%8d%ae%e6%98%be%e7%a4%ba%e6%a8%a1%e5%bc%8f" target="_blank" rel="noopener">Response 数据显示模式</a></h3><p>Postman 对于返回的 Response 数据，支持三种显示模式。</p><ul><li><code>默认</code>格式化后的 Pretty 模式</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/90i3wajcea.png?imageView2/2/w/1620" alt="img"></p><ul><li>Raw 原始模式</li></ul><p>点击Raw，可以查看到返回的没有格式化之前的原始数据：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/2o5e02t9ac.png?imageView2/2/w/1620" alt="img"></p><ul><li>Preview 预览模式</li></ul><p>以及 Preview，是对应 Raw 原始格式的预览模式：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jbnnfhoye4.png?imageView2/2/w/1620" alt="img"></p><p>Preview 这种模式的显示效果，好像是对于返回的是 html 页面这类，才比较有效果。</p><h3 id="Response-的-Cookies"><a href="#Response-的-Cookies" class="headerlink" title="Response 的 Cookies"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e7%9a%84-cookies" target="_blank" rel="noopener">Response 的 Cookies</a></h3><p>很多时候普通的 API 调用，倒是没有 Cookie 的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/1srkh454hi.png?imageView2/2/w/1620" alt="img"></p><h3 id="Response-的-Headers-头信息"><a href="#Response-的-Headers-头信息" class="headerlink" title="Response 的 Headers 头信息"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=response-%e7%9a%84-headers-%e5%a4%b4%e4%bf%a1%e6%81%af" target="_blank" rel="noopener">Response 的 Headers 头信息</a></h3><p>举例，此处返回的是有 Headers 头信息的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4hjkacbfao.png?imageView2/2/w/1620" alt="img"></p><p>可以从中看到服务器是 Nginx 的。</p><h2 id="保存多个-Example"><a href="#保存多个-Example" class="headerlink" title="保存多个 Example"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bf%9d%e5%ad%98%e5%a4%9a%e4%b8%aa-example" target="_blank" rel="noopener">保存多个 Example</a></h2><p>之前想要实现，让导出的 API 文档中能看到接口返回的 Response 数据。后来发现是Example这个功能去实现此效果的。</p><h3 id="如何添加-Example"><a href="#如何添加-Example" class="headerlink" title="如何添加 Example"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a6%82%e4%bd%95%e6%b7%bb%e5%8a%a0-example" target="_blank" rel="noopener">如何添加 Example</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4wjzn3wjr5.png?imageView2/2/w/1620" alt="img"></p><p>继续点击Save Example：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/pyzrhod8jg.png?imageView2/2/w/1620" alt="img"></p><p>保存后，就能看到Example(1)了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/dhmfi3mz78.png?imageView2/2/w/1620" alt="img"></p><h3 id="单个-Example-在导出的-API-文档中的效果"><a href="#单个-Example-在导出的-API-文档中的效果" class="headerlink" title="单个 Example 在导出的 API 文档中的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8d%95%e4%b8%aa-example-%e5%9c%a8%e5%af%bc%e5%87%ba%e7%9a%84-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">单个 Example 在导出的 API 文档中的效果</a></h3><p>然后再去导出文档，导出文档中的确能看到返回数据的例子： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/651td0ljtp.png?imageView2/2/w/1620" alt="img"></p><h3 id="多个-Example-在导出的-API-文档中的效果"><a href="#多个-Example-在导出的-API-文档中的效果" class="headerlink" title="多个 Example 在导出的 API 文档中的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a%e4%b8%aa-example-%e5%9c%a8%e5%af%bc%e5%87%ba%e7%9a%84-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">多个 Example 在导出的 API 文档中的效果</a></h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6bte63z6hq.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6ckvn8fm3x.png?imageView2/2/w/1620" alt="img"></p><h2 id="其他好用的功能及工具"><a href="#其他好用的功能及工具" class="headerlink" title="其他好用的功能及工具"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%85%b6%e4%bb%96%e5%a5%bd%e7%94%a8%e7%9a%84%e5%8a%9f%e8%83%bd%e5%8f%8a%e5%b7%a5%e5%85%b7" target="_blank" rel="noopener">其他好用的功能及工具</a></h2><h3 id="分组-Collection"><a href="#分组-Collection" class="headerlink" title="分组 Collection"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%88%86%e7%bb%84-collection" target="_blank" rel="noopener">分组 Collection</a></h3><p>在刚开始一个项目时，为了后续便于组织和管理，把同属该项目的多个 API，放在一组里</p><p>所以要先去新建一个 Collection: <code>New -&gt; Collection</code></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/lokimruefe.png?imageView2/2/w/1620" alt="img"></p><p>使用了段时间后，建了多个分组的效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ggk7qt7s4f.png?imageView2/2/w/1620" alt="img"></p><p>单个分组展开后的效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/w64q4ziv08.png?imageView2/2/w/1620" alt="img"></p><h3 id="历史记录-History"><a href="#历史记录-History" class="headerlink" title="历史记录 History"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95-history" target="_blank" rel="noopener">历史记录 History</a></h3><p>Postman 支持 history 历史记录，显示出最近使用过的 API： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ui0g94c42i.png?imageView2/2/w/1620" alt="img"></p><h3 id="用环境变量实现多服务器版本"><a href="#用环境变量实现多服务器版本" class="headerlink" title="用环境变量实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">用环境变量实现多服务器版本</a></h3><h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%8e%b0%e5%ad%98%e9%97%ae%e9%a2%98" target="_blank" rel="noopener">现存问题</a></h4><p>在测试 API 期间，往往存在多种环境，对应 IP 地址（或域名也不同）</p><p>比如：</p><ul><li><p>Prod: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://116.62.25.57/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发完成发布到生产环境</li></ul></li><li><p>Dev: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://123.206.191.125/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发期间的线上的 Development 的测试环境</li></ul></li><li><p>LocalTest: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.0.140:80/ucows</span><br></pre></td></tr></table></figure><ul><li>用于开发期间配合后台开发人员的本地局域网内的本地环境，用于联合调试 API 接口</li></ul></li></ul><p>而在测试 API 期间，往往需要手动去修改 API 的地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/l7grallxhf.png?imageView2/2/w/1620" alt="img"></p><p>效率比较低，且地址更换后之前地址就没法保留了。</p><p>另外，且根据不同 IP 地址（或者域名）也不容易识别是哪套环境。</p><h3 id="Postman-支持用-Environment-环境变量去实现多服务器版本"><a href="#Postman-支持用-Environment-环境变量去实现多服务器版本" class="headerlink" title="Postman 支持用 Environment 环境变量去实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e6%94%af%e6%8c%81%e7%94%a8-environment-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%8e%bb%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">Postman 支持用 Environment 环境变量去实现多服务器版本</a></h3><p>后来发现 Postman 中，有 Environment 和 Global Variable，用于解决这个问题，实现不同环境的管理：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/rzkb6ahdi2.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> 很明显，就可以用来实现不用手动修改 url 中的服务器地址，从而动态的实现，支持不同服务器环境:  </p></blockquote><ul><li>Production 生产环境</li><li>Development 开发环境</li><li>Local 本地局域网环境</li></ul><h4 id="如何使用-Enviroment-实现多服务器版本"><a href="#如何使用-Enviroment-实现多服务器版本" class="headerlink" title="如何使用 Enviroment 实现多服务器版本"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-enviroment-%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%89%88%e6%9c%ac" target="_blank" rel="noopener">如何使用 Enviroment 实现多服务器版本</a></h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/pvj87t9bl9.png?imageView2/2/w/1620" alt="img"></p><p>或者：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/4cqehxbdq1.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/t6gzc4ktvw.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> Environments are a group of variables &amp; values, that allow you to quickly switch the context for your requests and collections.  Learn more about environments  You can declare a variable in an environment and give it a starting value, then use it in a request by putting the variable name within curly-braces. Create an environment to get started.  </p></blockquote><p>输入 Key 和 value：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/tdph8jo5u3.png?imageView2/2/w/1620" alt="img"></p><p>点击 Add 后：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nvb1s1ht5r.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [info] 环境变量可以使用的地方  </p></blockquote><ul><li>URL</li><li>URL params</li><li>Header values</li><li>form-data/url-encoded values</li><li>Raw body content</li><li>Helper fields</li><li>写 test 测试脚本中</li><li>通过 postman 的接口，获取或设置环境变量的值。</li></ul><p>此处把之前的在 url 中的 IP 地址（或域名）换成环境变量：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/zfvm8xnp5u.png?imageView2/2/w/1620" alt="img"></p><p>鼠标移动到环境变量上，可以动态显示出具体的值：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/msdxb4rrwj.png?imageView2/2/w/1620" alt="img"></p><p>再去添加另外一个开发环境：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/rs4j9obq5m.png?imageView2/2/w/1620" alt="img"></p><p>则可添加完 2 个环境变量，表示两个服务器地址，两个版本：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/73l36ef55w.png?imageView2/2/w/1620" alt="img"></p><p>然后就可以切换不同服务器环境了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9n52eok8vu.png?imageView2/2/w/1620" alt="img"></p><p>可以看到，同样的变量 server_address，在切换后对应 IP 地址就变成希望的开发环境的 IP 了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/h487ru075j.png?imageView2/2/w/1620" alt="img"></p><h4 id="Postman-导出-API-文档中多个环境变量的效果"><a href="#Postman-导出-API-文档中多个环境变量的效果" class="headerlink" title="Postman 导出 API 文档中多个环境变量的效果"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=postman-%e5%af%bc%e5%87%ba-api-%e6%96%87%e6%a1%a3%e4%b8%ad%e5%a4%9a%e4%b8%aa%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e6%95%88%e6%9e%9c" target="_blank" rel="noopener">Postman 导出 API 文档中多个环境变量的效果</a></h4><p>顺带也去看看，导出为 API 文档后，带了这种 Environment 的变量的接口，文档长什么样子：</p><p>发现是在发布之前，需要选择对应的环境的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/dg394n77xg.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6fqqywrz4h.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jzcgi6c3lg.png?imageView2/2/w/1620" alt="img"></p><p>发布后的文档，可以看到所选环境和对应服务器的 IP 的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/k3tppka6qg.png?imageView2/2/w/1620" alt="img"></p><p>当然发布文档后，也可以实时切换环境：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/fqnjm0392m.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6cz9xt9z7y.png?imageView2/2/w/1620" alt="img"></p><h4 id="环境变量的好处"><a href="#环境变量的好处" class="headerlink" title="环境变量的好处"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%a5%bd%e5%a4%84" target="_blank" rel="noopener">环境变量的好处</a></h4><p>当更换服务器时，直接修改变量的 IP 地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/y6virrs94v.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/udsfrqtqxg.png?imageView2/2/w/1620" alt="img"></p><p>即可实时更新，当鼠标移动到变量上即可看到效果：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6i5l61q5gz.png?imageView2/2/w/1620" alt="img"></p><h3 id="代码生成工具"><a href="#代码生成工具" class="headerlink" title="代码生成工具"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90%e5%b7%a5%e5%85%b7" target="_blank" rel="noopener">代码生成工具</a></h3><h4 id="查看当前请求的-HTTP-原始内容"><a href="#查看当前请求的-HTTP-原始内容" class="headerlink" title="查看当前请求的 HTTP 原始内容"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%9f%a5%e7%9c%8b%e5%bd%93%e5%89%8d%e8%af%b7%e6%b1%82%e7%9a%84-http-%e5%8e%9f%e5%a7%8b%e5%86%85%e5%ae%b9" target="_blank" rel="noopener">查看当前请求的 HTTP 原始内容</a></h4><p>对于当前的请求，还可以通过点击 Code</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/fjqiinpdmd.png?imageView2/2/w/1620" alt="img"></p><p>去查看对应的符合 HTTP 协议的原始的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ems6iaymhz.png?imageView2/2/w/1620" alt="img"></p><h4 id="各种语言的示例代码Code-Generation-Tools"><a href="#各种语言的示例代码Code-Generation-Tools" class="headerlink" title="各种语言的示例代码Code Generation Tools"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%90%84%e7%a7%8d%e8%af%ad%e8%a8%80%e7%9a%84%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81code-generation-tools" target="_blank" rel="noopener">各种语言的示例代码Code Generation Tools</a></h4><p>比如：</p><ul><li>Swift 语言</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n2mpfxcdv3.png?imageView2/2/w/1620" alt="img"></p><ul><li>Java 语言</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/r9dvvipgd1.png?imageView2/2/w/1620" alt="img"></p><ul><li>其他各种语言 还支持其他各种语言：</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/n935sl95gc.png?imageView2/2/w/1620" alt="img"></p><p>目前支持的语言有：</p><ul><li>HTTP</li><li>C (LibCurl)</li><li>cURL</li><li>C#(RestSharp)</li><li>Go</li><li>Java <ul><li>OK HTTP</li><li>Unirest</li></ul></li><li>Javascript</li><li>NodeJS</li><li>Objective-C(NSURL)</li><li>OCaml(Cohttp)</li><li>PHP</li><li>Python</li><li>Ruby(NET::Http)</li><li>Shell</li><li>Swift(NSURL)</li></ul><p>代码生成工具的好处是：在写调用此 API 的代码时，就可以参考对应代码，甚至拷贝粘贴对应代码，即可。</p><h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e6%b5%8b%e8%af%95%e6%8e%a5%e5%8f%a3" target="_blank" rel="noopener">测试接口</a></h3><p>选中某个分组后，点击 Runner</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/p5ijm3jotv.png?imageView2/2/w/1620" alt="img"></p><p>选中某个分组后点击 Run</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d40ouxqffx.png?imageView2/2/w/1620" alt="img"></p><p>即可看到测试结果： </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ynyz14nrsu.png?imageView2/2/w/1620" alt="img"></p><p>关于此功能的介绍可参考<a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman 官网</a>的<a href="https://www.getpostman.com/img/v2/postman/gifs/collection-runner.gif" target="_blank" rel="noopener">git 图</a></p><h3 id="MockServer"><a href="#MockServer" class="headerlink" title="MockServer"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=mockserver" target="_blank" rel="noopener">MockServer</a></h3><p>直接参考官网。</p><h2 id="功能界面"><a href="#功能界面" class="headerlink" title="功能界面"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8a%9f%e8%83%bd%e7%95%8c%e9%9d%a2" target="_blank" rel="noopener">功能界面</a></h2><h3 id="多-Tab-分页"><a href="#多-Tab-分页" class="headerlink" title="多 Tab 分页"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a-tab-%e5%88%86%e9%a1%b5" target="_blank" rel="noopener">多 Tab 分页</a></h3><p>Postman 支持多 tab 页，于此对比之前有些 API 调试工具就不支持多 Tab 页，比如<code>Advanced Rest Client</code></p><p>多 tab 的好处：</p><p>方便在一个 tab 中测试，得到结果后，复制粘贴到另外的 tab 中，继续测试其它接口</p><p>比如此处 tab1 中，测试了获取验证码接口后，拷贝手机号和验证码，粘贴到 tab2 中，继续测试注册的接口</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/9h475eyqnd.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/f26rmodg14.png?imageView2/2/w/1620" alt="img"></p><h3 id="界面查看模式"><a href="#界面查看模式" class="headerlink" title="界面查看模式"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%95%8c%e9%9d%a2%e6%9f%a5%e7%9c%8b%e6%a8%a1%e5%bc%8f" target="_blank" rel="noopener">界面查看模式</a></h3><p>Postman 的默认的 Request 和 Response 是上下布局：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ilcrw9qu2a.png?imageView2/2/w/1620" alt="img"></p><p>此处点击右下角的<code>Two pane view</code>，就变成左右的了：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ij8lqwx97b.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> [info] 左右布局的用途  对于数据量很大，又想要同时看到请求和返回的数据的时候，应该比较有用。  </p></blockquote><h3 id="多颜色主题"><a href="#多颜色主题" class="headerlink" title="多颜色主题"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%a4%9a%e9%a2%9c%e8%89%b2%e4%b8%bb%e9%a2%98" target="_blank" rel="noopener">多颜色主题</a></h3><p>Posman 支持两种主题：</p><ul><li>深色主题</li></ul><p>当前是深色主题，效果很不错：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/jz9xmkcowa.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/u82a7psrgy.png?imageView2/2/w/1620" alt="img"></p><ul><li>浅色主题</li></ul><p>可以切换到 浅色主题：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/qu330s3pfl.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/d17b0zdb4c.png?imageView2/2/w/1620" alt="img"></p><h2 id="API-文档生成"><a href="#API-文档生成" class="headerlink" title="API 文档生成"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=api-%e6%96%87%e6%a1%a3%e7%94%9f%e6%88%90" target="_blank" rel="noopener">API 文档生成</a></h2><p>在服务端后台的开发人员测试好了接口后，打算把接口的各种信息发给使用此 API 的前端的移动端人员时，往往会遇到：</p><p>要么是用复制粘贴 -&gt; 格式不友好 要么是用 Postman 中截图 -&gt; 方便看，但是不方便获得 API 接口和字段等文字内容 要么是用 Postman 中导出为 JSON -&gt; json 文件中信息太繁杂，不利于找到所需要的信息 要么是用文档，比如去编写 Markdown 文档 -&gt; 但后续 API 的变更需要实时同步修改文档，也会很麻烦 这都会导致别人查看和使用 API 时很不方便。</p><p>-&gt; 对此，Postman 提供了发布 API</p><p>预览和发布 API 文档 下面介绍 Postman 中如何预览和发布 API 文档。</p><h3 id="简要概述步骤"><a href="#简要概述步骤" class="headerlink" title="简要概述步骤"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e7%ae%80%e8%a6%81%e6%a6%82%e8%bf%b0%e6%ad%a5%e9%aa%a4" target="_blank" rel="noopener">简要概述步骤</a></h3><ol><li>Collection</li><li>鼠标移动到某个 Collection，点击 三个点</li><li>Publish Docs</li><li>Publish</li><li>得到 Public URL</li><li>别人打开这个 Public URL，即可查看 API 文档</li></ol><h3 id="预览-API-文档"><a href="#预览-API-文档" class="headerlink" title="预览 API 文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e9%a2%84%e8%a7%88-api-%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">预览 API 文档</a></h3><p>点击分组右边的大于号&gt;</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/s7pgyjn13y.png?imageView2/2/w/1620" alt="img"></p><p>如果只是预览，比如后台开发员自己查看 API 文档的话，可以选择：View in web</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/95ekutmlpe.png?imageView2/2/w/1620" alt="img"></p><blockquote><p> 等价于点击Publish Docs去发布：  </p></blockquote><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/ca0mw3r3x7.png?imageView2/2/w/1620" alt="img"></p><p>View in Web 后，有 Publish 的选项（见后面的截图）</p><p>View in Web 后，会打开预览页面：</p><p>比如：</p><p>奶牛云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/collection/view/669382-42273840-6237-dbae-5455-26b16f45e2b9</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/8yfixnbs9s.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/6qtob43od0.png?imageView2/2/w/1620" alt="img"></p><p>而右边的示例代码，也可以从默认的 cURL 换成其他的：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/gy60gkar15.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/hmptft1z7u.png?imageView2/2/w/1620" alt="img"></p><h3 id="发布-API-文档"><a href="#发布-API-文档" class="headerlink" title="发布 API 文档"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%91%e5%b8%83-api-%e6%96%87%e6%a1%a3" target="_blank" rel="noopener">发布 API 文档</a></h3><p>如果想要让其他人能看到这个文档，则点击 Publish：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/nfsjy8thb8.png?imageView2/2/w/1620" alt="img"></p><p>然后会打开类似于这样的地址：</p><p>Postman Documenter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/collection/publish?meta=Y29sbGVjdGlvbl9pZD00MjI3Mzg0MC02MjM3LWRiYWUtNTQ1NS0yNmIxNmY0NWUyYjkmb3duZXI9NjY5MzgyJmNvbGxlY3Rpb25fbmFtZT0lRTUlQTUlQjYlRTclODklOUIlRTQlQkElOTE=</span><br></pre></td></tr></table></figure><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/84pbk6ppzq.png?imageView2/2/w/1620" alt="img"></p><p>点击 Publish 后，可以生成对应的公开的网页地址：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/z3ce5w7dfv.png?imageView2/2/w/1620" alt="img"></p><p>打开 API 接口文档地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/view/669382/collection/77fd4RM</span><br></pre></td></tr></table></figure><p>即可看到（和前面预览一样效果的 API 文档了）：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/84j5ppdtoh.png?imageView2/2/w/1620" alt="img"></p><p>如此，别人即可查看对应的 API 接口文档。</p><h3 id="已发布的-API-文档支持自动更新"><a href="#已发布的-API-文档支持自动更新" class="headerlink" title="已发布的 API 文档支持自动更新"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%b7%b2%e5%8f%91%e5%b8%83%e7%9a%84-api-%e6%96%87%e6%a1%a3%e6%94%af%e6%8c%81%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" target="_blank" rel="noopener">已发布的 API 文档支持自动更新</a></h3><p>后续如果自己的 API 接口修改后：</p><p>比如：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/svcgj7qdll.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/kezpmqdfe8.png?imageView2/2/w/1620" alt="img"></p><p>（后来发现，不用再去进入此预览和发布的流程，去更新文档，而是 Postman 自动支持）</p><p>别人去刷新该文档的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://documenter.getpostman.com/view/669382/collection/77fd4RM</span><br></pre></td></tr></table></figure><p>即可看到更新后的内容：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1171488/1iumgwfs2k.png?imageView2/2/w/1620" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="https://malun666.github.io/aicoder_vip_doc/#/pages/postman?id=%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" target="_blank" rel="noopener">参考资料</a></h2><ul><li>主要参考：Github: api_tool_postman</li><li>Manage environments</li><li>postman-变量/环境/过滤等 - 简书</li><li>Postman 使用手册 3——环境变量 - 简书</li><li>postman 使用之四：切换环境和设置读取变量 - 乔叶叶 - 博客园</li></ul><hr>]]></content>
    
    <summary type="html">
    
      postman接口测试神器使用技巧
    
    </summary>
    
      <category term="工具" scheme="https://cloudsjhan.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="postman" scheme="https://cloudsjhan.github.io/tags/postman/"/>
    
      <category term="工具" scheme="https://cloudsjhan.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之influxDB使用入门</title>
    <link href="https://cloudsjhan.github.io/2018/12/08/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8BinfluxDB%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://cloudsjhan.github.io/2018/12/08/技术周刊之influxDB使用入门/</id>
    <published>2018-12-08T15:25:10.000Z</published>
    <updated>2018-12-08T15:31:29.239Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>InfluxDB是一个用于存储和分析时间序列数据的开源数据库。</p><p>主要特性有：</p><ul><li>内置HTTP接口，使用方便</li><li>数据可以打标记，查让查询可以很灵活</li><li>类SQL的查询语句</li><li>安装管理很简单，并且读写数据很高效</li><li>能够实时查询，数据在写入时被索引后就能够被立即查出</li><li>……</li></ul><p>在最新的<a href="https://db-engines.com/en/ranking/time+series+dbms" target="_blank" rel="noopener">DB-ENGINES</a>给出的时间序列数据库的排名中，InfluxDB高居第一位，可以预见，InfluxDB会越来越得到广泛的使用。</p><ul><li><p>influxDB使用go语言编写，采用了SQL like的语法，非常灵活高效，如果你的数据是与时间相关的，那么使用influxDB做数据可视化是最合适不过的，尤其是influxDB自身就提供数据库CRUD所需要的API，虽然不是RESTFul的，但是也省去了编写后端接口的力气。</p></li><li><p>下面从influxDB的安装、使用CLI的influxdb基本操作、使用API对influxdb操作及golang代码实现、经历的坑，几个方面分享influxDB的入门经历。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>本次安装的环境是：</p><ul><li>CentOS 7</li><li>内核版本：4.4.135-1.el7.elrepo.x86_64</li></ul></li><li><p>直接使用yum安装</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/influxdb.repo # 输入influxDB的repoURL地址等信息</span><br><span class="line">[influxdb]</span><br><span class="line">  name = InfluxDB Repository - RHEL \$releasever</span><br><span class="line">  baseurl = https://repos.influxdata.com/rhel/\$releasever/\$basearch/stable</span><br><span class="line">  enabled = 1</span><br><span class="line">  gpgcheck = 1</span><br><span class="line">  gpgkey = https://repos.influxdata.com/influxdb.key</span><br><span class="line">  EOF</span><br><span class="line"><span class="meta">  #</span><span class="bash">EOF是文本的结束符</span></span><br></pre></td></tr></table></figure></li></ul></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install influxdb</span><br></pre></td></tr></table></figure></li><li><p>influxd config</p><p>安装完成后使用该命令查看influxDB的配置内容，default的config文件路径在：/etc/influxdb/influxdb.conf</p></li><li><p>启动influxDB</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-m1 ~]# influx</span><br><span class="line">Connected to http://localhost:8086 version 1.7.1</span><br><span class="line">InfluxDB shell version: 1.7.1</span><br><span class="line">Enter an InfluxQL query</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>到此完成了influxDB的安装，接下来我们做基本的配置。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>用户管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个管理员用户</span><br><span class="line">CREATE USER "admin" WITH PASSWORD 'xxxx' WITH ALL PRIVILEGES</span><br><span class="line">-- 创建一个普通用户</span><br><span class="line">CREATE USER "user" WITH PASSWORD 'xxxxx'</span><br><span class="line">-- 为用户授权读权限</span><br><span class="line">GRANT READ ON [database] to "user"</span><br><span class="line">-- 为用户授权写权限</span><br><span class="line">GRANT WRITE ON [database] to "user"</span><br><span class="line">--------------------- </span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要修改InfluxDB的配置文件/etc/influxdb/influxdb.conf，设置http下的auth-enabled = <span class="literal">true</span>，重启后，使用influx命令登录数据库就需要用户名和密码了。（Influx命令实际上也是使用API来操作InfluxDB的，InfluxDB只提供了API接口）</span></span><br></pre></td></tr></table></figure><ul><li>查看用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> show users</span></span><br><span class="line">user  admin</span><br><span class="line">----  -----</span><br><span class="line">admin true</span><br><span class="line">sjhan true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>influxDB的配置项目有很多，剩下的可以根据自己的需求继续研究，这里就不展开了。</p><p>在进行数据库基本操作之前我们必须了解一下infuxDB的一些基本概念</p><h4 id="influxDB基本概念"><a href="#influxDB基本概念" class="headerlink" title="influxDB基本概念"></a>influxDB基本概念</h4><ul><li>influxDB里面最基本的概念就是，measurement，tags，fields，points。我们可以类比于MySQL来理解这几个字段：</li><li>measurement类似于SQL中的table；</li><li>tags类似SQL中的被索引的列；</li><li>fields类似于SQL中没有被索引的列；</li><li>points对应SQL的table中的每行数据。</li><li>知道了这几个概念，便可以继续往下进行，如需更加详细的文档，英文版文档<a href="https://docs.influxdata.com/influxdb/v1.7/" target="_blank" rel="noopener">猛戳这里</a>，当然也有中文版，<a href="https://jasper-zhang1.gitbooks.io/influxdb/" target="_blank" rel="noopener">猛戳这里</a>。不知为何中文版我只有番蔷才能访问。</li></ul><h3 id="influxDB基本操作"><a href="#influxDB基本操作" class="headerlink" title="influxDB基本操作"></a>influxDB基本操作</h3><ul><li>首先，跟MySQL一样，我们需要创建一个数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建数据库，默认设置</span><br><span class="line">CREATE DATABASE &quot;first_db&quot;</span><br><span class="line">-- 创建数据库，同时创建一个Retention Policy，数据保留时间描述</span><br><span class="line">-- Retention Policy各部分描述：DURATION为数据存储时长，下面的1d即只存1天的数据；REPLICATION为数据副本，一般在使用集群的时候才会设置为&gt;1；SHARD DURATION为分区间隔，InfluxDB默认对数据分区，填写30m即对数据每隔30分钟做一个新的分区；Name是RP的名字。</span><br><span class="line">CREATE DATABASE &quot;first_db&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 30m NAME &quot;myrp&quot;</span><br></pre></td></tr></table></figure><p>我们创建了一个influxDB的数据库，名字为first_db, 数据存储时间为一天，一个副本，每30分钟做一个新的分区。</p><ul><li><p>influxDB插入数据</p><p>influx -username admin -password</p><p>我们插入一条数据到刚刚创建的数据库中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> product,productName=disk,usageType=pay,creator=zhangsan,appId=<span class="number">105</span> <span class="keyword">cost</span>=<span class="number">3421.6</span></span><br></pre></td></tr></table></figure><p>我们分析一下这条插入语句，其中product字段是influxDB中的measurement,前面讲基本概念的时候已经解释过，类似于MySQL中的table，“productName=disk,usageType=pay,creator=zhangsan,appId=105”，这一坨在influxDB中叫做tag set,可以理解为tag的一个集合，tag的类型只能是字符串的K-V，还有需要注意的是tag set与前面的measurement之间只有一个逗号，<strong>并没有空格！</strong>，一开始不知道这回事，怎么插入都是失败。“cost=3421.6”这个叫做filed set，filed的类型可以是float、boolean、integer。这样插入的一条数据，influxDB中叫做一个point。</p></li></ul><ul><li><p>查询操作</p><p>查询之前要选择你想查询的数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use first_db</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxzdysawf8j31hq0cqwgt.jpg" alt=""></p></li><li><p>可以看到influxDB自动为我们的这个point加了一个timestamp，这个是数据的UNIX时间格式的时间精度，我们在启动数据库时可以定义这个precision，像下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influx --precision rfc3339</span><br></pre></td></tr></table></figure><p>influxDB规定了很多时间精度，具体可以在命令行输出help查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">precision &lt;format&gt;    specifies the format of the timestamp: rfc3339, h, m, s, ms, u or ns</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可指定的时间精度</span></span><br></pre></td></tr></table></figure><ul><li><p>使用influxDB内置CLI执行查询操作</p><p>还是查询我们刚刚插入的那条数据,在命令行中输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode "db=first_db" --data-urlencode "q=SELECT \"cost\" FROM \"product\" WHERE \"productName\"='disk'"</span><br></pre></td></tr></table></figure><p>得到输出为json结构的查询结果<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzegqffyhj31x50u0jvr.jpg" alt=""></p><p>influxDB内置的API很大程度简化了后端的开发，使各种项目可以快速上线。</p></li><li><p>插入操作的API</p></li></ul><p>在命令行中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -XPOST 'http://localhost:8086/write?db=first_db' --data-binary 'weather,location=us-midwes temperature=125'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 插入一条数据，measurement=weather，tag=location，filed=temperature,时间戳为当地服务器时间</span></span><br></pre></td></tr></table></figure><ul><li>我们使用postman测试这个插入接口，以确定该接口的header，body等，为接下来使用go编写请求代码做好准备。通过分析URL，我们可知请求的param是db=first_db，–dat-binary这个参数，意味着你的request body必须是raw,而且header的content-Type=”text”,具体的postman设置参照下图：<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzq4jt9xkj31qa0qcgoc.jpg" alt=""></li><li>点击Send之后，可以在下面看到response的statusCode是204，在http协议中，这个状态码意思是返回体中没有内容。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxzqcl2pvtj31q605yq3l.jpg" alt=""></li><li>我们回到influxDB的terminal中查看一下，可以看到这条数据已经插入成功了。</li></ul><h3 id="GO操作influxDB的API实现插入数据"><a href="#GO操作influxDB的API实现插入数据" class="headerlink" title="GO操作influxDB的API实现插入数据"></a>GO操作influxDB的API实现插入数据</h3><ul><li><p>可以利用这样方便的API，编写代码，实现数据的批量采集、管理、展示，这里我用GO对插入数据的操作简单实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reqBody := <span class="string">"weather,location=us-midwes temperature=521 1475839730100400200"</span></span><br><span class="line">rb := []<span class="keyword">byte</span>(reqBody)</span><br><span class="line">    headers := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Content-type"</span>: <span class="string">"text"</span>,</span><br><span class="line">&#125;</span><br><span class="line">resp, _,err := simpleHttpClient.DoRequest(<span class="string">"POST"</span>,<span class="string">"http://10.18.5.30:8086/write?db=first_db"</span>,headers,rb,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(resp))</span><br></pre></td></tr></table></figure><ul><li><p>使用的DoRequest方法来自<a href="https://github.com/hantmac/simple-httpClient" target="_blank" rel="noopener">这里</a>，这个库对golang的http操作进行简单的封装，而且加入了错误处理，timeout异常检测等。</p></li><li><p>当然也可以使用Go自带的net/http包中的POST方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reqBody := <span class="string">"weather,location=us-midwes temperature=521 1475839730100400200"</span></span><br><span class="line"><span class="comment">//rb := []byte(reqBody)</span></span><br><span class="line">    rb := io.NewReader(reqBody)</span><br><span class="line">resp, err := http.Post(<span class="string">"http://10.18.5.30:8086/write?db=first_db"</span>,<span class="string">"text"</span>,rb)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(resp))</span><br></pre></td></tr></table></figure><ul><li>需要注意的是对request body的类型处理，net/http.post方法要求该参数的类型是io.reader，所以要使用io.NewReader()进行转换。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>以上就是对influxDB的入门介绍，包括基本概念，安装，配置，基本操作（CLI，API）以及使用GO编写操作数据库的代码。但influxDB的奥秘远不止这些，<a href="https://docs.influxdata.com/influxdb/v1.7/" target="_blank" rel="noopener">如需更加深入的研究可参阅官方文档</a>。</li></ul></li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      介绍influxDB的基本概念，基本操作以及如何使用go实现influxDB的操作
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
      <category term="influxDB" scheme="https://cloudsjhan.github.io/tags/influxDB/"/>
    
  </entry>
  
  <entry>
    <title>(转载)golang语言并发与并行——goroutine和channel的详细理解(2)</title>
    <link href="https://cloudsjhan.github.io/2018/12/07/%E8%BD%AC%E8%BD%BD-golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3-2/"/>
    <id>https://cloudsjhan.github.io/2018/12/07/转载-golang语言并发与并行——goroutine和channel的详细理解-2/</id>
    <published>2018-12-07T03:48:11.000Z</published>
    <updated>2018-12-07T03:50:05.116Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://studygolang.com/articles/9533" target="_blank" rel="noopener">本文转载自</a>，版权属于原作者。</p><h1 id="Go语言的并发和并行"><a href="#Go语言的并发和并行" class="headerlink" title="Go语言的并发和并行"></a>Go语言的并发和并行</h1><p>不知道你有没有注意到一个现象，还是这段代码，如果我跑在两个goroutines里面的话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 开两个goroutine跑函数loop, loop函数负责打印10个数</span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察下输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>这是不是有什么问题？?</p><p>以前我们用线程去做类似任务的时候，系统的线程会抢占式地输出， 表现出来的是乱序地输出。而goroutine为什么是这样输出的呢？</p><h2 id="goroutine是在并行吗？"><a href="#goroutine是在并行吗？" class="headerlink" title="goroutine是在并行吗？"></a>goroutine是在并行吗？</h2><p>我们找个例子<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">var quit chan int</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">    time.Sleep(time.Second) // 停顿一秒</span><br><span class="line">    quit &lt;- 0 // 发消息：我执行完啦！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    count := 1000</span><br><span class="line">    quit = make(chan int, count) // 缓冲1000个数据</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123; //开1000个goroutine</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i :=0 ; i &lt; count; i++ &#123; // 等待所有完成消息发送完毕。</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们跑一下这个程序(之所以先编译再运行，是为了让程序跑的尽量快,测试结果更好):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build test.go</span><br><span class="line">time ./test</span><br><span class="line">./test  0.01s user 0.01s system 1% cpu 1.016 total</span><br></pre></td></tr></table></figure><p>我们看到，总计用时接近一秒。 貌似并行了！</p><p>我们需要首先考虑下什么是并发, 什么是并行</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>从概念上讲，并发和并行是不同的, 简单来说看这个图片(原图来自<a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html" target="_blank" rel="noopener">这里</a>)</p><p><img src="http://hit9.qiniudn.com/con_and_par.jpg" alt="img"></p><ul><li>两个队列，一个Coffee机器，那是并发</li><li>两个队列，两个Coffee机器，那是并行</li></ul><p>更多的资料： <a href="http://www.aqee.net/docs/Concurrency-is-not-Parallelism/" target="_blank" rel="noopener">并发不是并行</a>, 当然Google上有更多关于并行和并发的区别。</p><p>那么回到一开始的疑问上，从上面的两个例子执行后的表现来看，多个goroutine跑loop函数会挨个goroutine去进行，而sleep则是一起执行的。</p><p>这是为什么？</p><p>默认地， <a href="http://lib.csdn.net/base/go" target="_blank" rel="noopener">Go</a>所有的goroutines只能在一个线程里跑 。</p><p>也就是说， 以上两个代码都不是并行的，但是都是是并发的。</p><p>如果当前goroutine不发生阻塞，它是不会让出CPU给其他goroutine的, 所以例子一中的输出会是一个一个goroutine进行的，而sleep函数则阻塞掉了 当前goroutine, 当前goroutine主动让其他goroutine执行, 所以形成了逻辑上的并行, 也就是并发。</p><h2 id="真正的并行"><a href="#真正的并行" class="headerlink" title="真正的并行"></a>真正的并行</h2><p>为了达到真正的并行，我们需要告诉Go我们允许同时最多使用多个核。</p><p>回到起初的例子，我们设置最大开2个原生线程, 我们需要用到runtime包(runtime包是goroutine的调度器):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 100; i++ &#123; //为了观察，跑多些</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(2) // 最多使用2个核</span><br><span class="line"></span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下会看到两个goroutine会抢占式地输出数据了。</p><p>我们还可以这样显式地让出CPU时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        runtime.Gosched() // 显式地让出CPU时间给其他goroutine</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    go loop()</span><br><span class="line">    go loop()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察下结果会看到这样有规律的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure><p>其实，这种主动让出CPU时间的方式仍然是在单核里跑。但手工地切换goroutine导致了看上去的“并行”。</p><p>其实作为一个<a href="http://lib.csdn.net/base/python" target="_blank" rel="noopener">Python</a>程序员，goroutine让我更多地想到的是gevent的协程，而不是原生线程。</p><p>关于runtime包对goroutine的调度，在stackoverflow上有一个不错的答案:<a href="http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do" target="_blank" rel="noopener">http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do</a></p><h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p>我在Segmentfault看到了这个问题: <a href="http://segmentfault.com/q/1010000000207474" target="_blank" rel="noopener">http://segmentfault.com/q/1010000000207474</a></p><p>题目说，如下的程序，按照理解应该打印下5次 <code>&quot;world&quot;</code>呀，可是为什么什么也没有打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go say(&quot;world&quot;) //开一个新的Goroutines执行</span><br><span class="line">    for &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>楼下的答案已经很棒了，这里Go仍然在使用单核，for死循环占据了单核CPU所有的资源，而main线和say两个goroutine都在一个线程里面， 所以say没有机会执行。解决方案还是两个：</p><ul><li>允许Go使用多核(<code>runtime.GOMAXPROCS</code>)</li><li>手动显式调动(<code>runtime.Gosched</code>)</li></ul><h2 id="runtime调度器"><a href="#runtime调度器" class="headerlink" title="runtime调度器"></a>runtime调度器</h2><p>runtime调度器是个很神奇的东西，但是我真是但愿它不存在，我希望显式调度能更为自然些，多核处理默认开启。</p><p>关于runtime包几个函数:</p><ul><li><code>Gosched</code> 让出cpu</li><li><code>NumCPU</code> 返回当前系统的CPU核数量</li><li><code>GOMAXPROCS</code> 设置最大的可同时使用的CPU核数</li><li><code>Goexit</code> 退出当前goroutine(但是defer语句会照常执行)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从例子中可以看到，默认的, 所有goroutine会在一个原生线程里跑，也就是只使用了一个CPU核。</p><p>在同一个原生线程里，如果当前goroutine不发生阻塞，它是不会让出CPU时间给其他同线程的goroutines的，这是Go运行时对goroutine的调度，我们也可以使用runtime包来手工调度。</p><p>本文开头的两个例子都是限制在单核CPU里执行的，所有的goroutines跑在一个线程里面，分析如下:</p><ul><li>对于代码例子一（loop函数的那个），每个goroutine没有发生堵塞(直到quit流入数据), 所以在quit之前每个goroutine不会主动让出CPU，也就发生了串行打印</li><li>对于代码例子二（time的那个），每个goroutine在sleep被调用的时候会阻塞，让出CPU, 所以例子二并发执行。</li></ul><p>那么关于我们开启多核的时候呢？Go语言对goroutine的调度行为又是怎么样的？</p><p>我们可以在Golang官方网站的<a href="http://golang.org/doc/faq#goroutines" target="_blank" rel="noopener">这里</a> 找到一句话:</p><blockquote><p>When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won’t be blocked.</p></blockquote><p>也就是说:</p><blockquote><p>当一个goroutine发生阻塞，Go会自动地把与该goroutine处于同一系统线程的其他goroutines转移到另一个系统线程上去，以使这些goroutines不阻塞</p></blockquote><h2 id="开启多核的实验"><a href="#开启多核的实验" class="headerlink" title="开启多核的实验"></a>开启多核的实验</h2><p>仍然需要做一个实验，来测试下多核支持下goroutines的对原生线程的分配, 也验证下我们所得到的结论“goroutine不阻塞不放开CPU”。</p><p>实验代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var quit chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop(id int) &#123; // id: 该goroutine的标号</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123; //打印10次该goroutine的标号</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, id)</span><br><span class="line">    &#125;</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(2) // 最多同时使用2个核</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 3; i++ &#123; //开三个goroutine</span><br><span class="line">        go loop(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多跑几次会看到类似这些输出(不同机器环境不一样):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 1 1 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 1 0 1 2 1 2 1 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 2 0 2 0 2 2 2 2 2 2 2 2</span><br><span class="line">0 0 0 0 0 0 0 1 0 0 1 0 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 2 2</span><br></pre></td></tr></table></figure><p>执行它我们会发现以下现象:</p><ul><li>有时会发生抢占式输出(说明Go开了不止一个原生线程，达到了真正的并行)</li><li>有时会顺序输出, 打印完0再打印1, 再打印2(说明Go开一个原生线程，单线程上的goroutine不阻塞不松开CPU)</li></ul><p>那么，我们还会观察到一个现象，无论是抢占地输出还是顺序的输出，都会有那么两个数字表现出这样的现象:</p><ul><li>一个数字的所有输出都会在另一个数字的所有输出之前</li></ul><p>原因是， 3个goroutine分配到至多2个线程上，就会至少两个goroutine分配到同一个线程里，单线程里的goroutine 不阻塞不放开CPU, 也就发生了顺序输出。</p><hr>]]></content>
    
    <summary type="html">
    
      golang语言并发与并行——goroutine和channel的详细理解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>(转载)golang语言并发与并行——goroutine和channel的详细理解(1)</title>
    <link href="https://cloudsjhan.github.io/2018/12/07/%E8%BD%AC%E8%BD%BD-golang%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E2%80%94%E2%80%94goroutine%E5%92%8Cchannel%E7%9A%84%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3-1/"/>
    <id>https://cloudsjhan.github.io/2018/12/07/转载-golang语言并发与并行——goroutine和channel的详细理解-1/</id>
    <published>2018-12-07T03:38:01.000Z</published>
    <updated>2018-12-07T03:50:54.511Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本篇博文转载自<a href="https://studygolang.com/articles/9532?fr=sidebar" target="_blank" rel="noopener">go语言中文网</a>，版权属原作者所有。</p><p>如果不是我对真正并行的线程的追求，就不会认识到<a href="http://lib.csdn.net/base/go" target="_blank" rel="noopener">Go</a>有多么的迷人。</p><p>Go语言从语言层面上就支持了并发，这与其他语言大不一样，不像以前我们要用Thread库 来新建线程，还要用线程安全的队列库来共享数据。</p><p>以下是我入门的学习笔记。</p><h1 id="Go语言的goroutines、信道和死锁"><a href="#Go语言的goroutines、信道和死锁" class="headerlink" title="Go语言的goroutines、信道和死锁"></a>Go语言的goroutines、信道和死锁</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go语言中有个概念叫做goroutine, 这类似我们熟知的线程，但是更轻。</p><p>以下的程序，我们串行地去执行两次<code>loop</code>函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    loop()</span><br><span class="line">    loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，输出会是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下面我们把一个loop放在一个goroutine里跑，我们可以使用关键字<code>go</code>来定义并启动一个goroutine:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go loop() // 启动一个goroutine</span><br><span class="line">    loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出变成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>可是为什么只输出了一趟呢？明明我们主线跑了一趟，也开了一个goroutine来跑一趟啊。</p><p>原来，在goroutine还没来得及跑loop的时候，主函数已经退出了。</p><p>main函数退出地太快了，我们要想办法阻止它过早地退出，一个办法是让main等待一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go loop()</span><br><span class="line">    loop()</span><br><span class="line">    time.Sleep(time.Second) // 停顿一秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次确实输出了两趟，目的达到了。</p><p>可是采用等待的办法并不好，如果goroutine在结束的时候，告诉下主线说“Hey, 我要跑完了！”就好了， 即所谓阻塞主线的办法，回忆下我们<a href="http://lib.csdn.net/base/python" target="_blank" rel="noopener">Python</a>里面等待所有线程执行完毕的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for thread in threads:</span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure><p>是的，我们也需要一个类似<code>join</code>的东西来阻塞住主线。那就是信道</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是什么？简单说，是goroutine之间互相通讯的东西。类似我们Unix上的管道（可以在进程间传递消息）， 用来goroutine之间发消息和接收消息。其实，就是在做goroutine之间的内存共享。</p><p>使用<code>make</code>来建立一个信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var channel chan int = make(chan int)</span><br><span class="line">// 或</span><br><span class="line">channel := make(chan int)</span><br></pre></td></tr></table></figure><p>那如何向信道存消息和取消息呢？ 一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var messages chan string = make(chan string)</span><br><span class="line">    go func(message string) &#123;</span><br><span class="line">        messages &lt;- message // 存消息</span><br><span class="line">    &#125;(&quot;Ping!&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-messages) // 取消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的，信道的存消息和取消息都是阻塞的 (叫做无缓冲的信道，不过缓冲这个概念稍后了解，先说阻塞的问题)。</p><p>也就是说, 无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好。</p><p>比如以下的main函数和foo函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func foo() &#123;</span><br><span class="line">    ch &lt;- 0  // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把0这个数据拿走</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go foo()</span><br><span class="line">    &lt;- ch // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然信道可以阻塞当前的goroutine, 那么回到上一部分「goroutine」所遇到的问题「如何让goroutine告诉主线我执行完毕了」 的问题来, 使用一个信道来告诉主线即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var complete chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func loop() &#123;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    complete &lt;- 0 // 执行完毕了，发个消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go loop()</span><br><span class="line">    &lt;- complete // 直到线程跑完, 取到消息. main在此阻塞住</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用信道来阻塞主线的话，主线就会过早跑完，loop线都没有机会执行、、、</p><p>其实，无缓冲的信道永远不会存储数据，只负责数据的流通，为什么这么讲呢？</p><ul><li>从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞</li><li>数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞</li></ul><p>所以，你可以<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>下，无论如何，我们测试到的无缓冲信道的大小都是0 (<code>len(channel)</code>)</p><p>如果信道正有数据在流动，我们还要加入数据，或者信道干涩，我们一直向无数据流入的空信道取数据呢？ 就会引起死锁</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一个死锁的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    &lt;- ch // 阻塞main goroutine, 信道c被锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个程序你会看到Go报这样的错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>何谓死锁? <a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>有讲过的，所有的线程或进程都在等待资源的释放。如上的程序中, 只有一个goroutine, 所以当你向里面加数据或者存数据的话，都会锁死信道， 并且阻塞当前 goroutine, 也就是所有的goroutine(其实就main线一个)都在等待信道的开放(没人拿走数据信道是不会开放的)，也就是死锁咯。</p><p>我发现死锁是一个很有意思的话题，这里有几个死锁的例子:</p><ol><li><p>只在单一的goroutine里操作无缓冲信道，一定死锁。比如你只在main函数里操作信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    ch &lt;- 1 // 1流入信道，堵塞当前线, 没人取走数据信道不会打开</span><br><span class="line">    fmt.Println(&quot;This line code wont run&quot;) //在此行执行之前Go就会报死锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如下也是一个死锁的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ch1 chan int = make(chan int)</span><br><span class="line">var ch2 chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    ch1 &lt;- &lt;- ch2 // ch1 等待 ch2流出的数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    go say(&quot;hello&quot;)</span><br><span class="line">    &lt;- ch1  // 堵塞主线</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中主线等ch1中的数据流出，ch1等ch2的数据流出，但是ch2等待数据流入，两个goroutine都在等，也就是死锁。</p></li><li><p>其实，总结来看，为什么会死锁？非缓冲信道上如果发生了流入无流出，或者流出无流入，也就导致了死锁。或者这样理解 Go启动的所有goroutine里的非缓冲信道一定要一个线里存数据，一个线里取数据，要成对才行 。所以下面的示例一定死锁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c, quit := make(chan int), make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">   c &lt;- 1  // c通道的数据没有被其他goroutine读取走，堵塞当前goroutine</span><br><span class="line">   quit &lt;- 0 // quit始终没有办法写入数据</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;- quit // quit 等待数据的写</span><br></pre></td></tr></table></figure><p>仔细分析的话，是由于：主线等待quit信道的数据流出，quit等待数据写入，而func被c通道堵塞，所有goroutine都在等，所以死锁。</p><p>简单来看的话，一共两个线，func线中流入c通道的数据并没有在main线中流出，肯定死锁。</p></li></ol><p>但是，是否果真 所有不成对向信道存取数据的情况都是死锁?</p><p>如下是个反例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    c := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">       c &lt;- 1</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序正常退出了，很简单，并不是我们那个总结不起作用了，还是因为一个让人很囧的原因，main又没等待其它goroutine，自己先跑完了， 所以没有数据流入c信道，一共执行了一个goroutine, 并且没有发生阻塞，所以没有死锁错误。</p><p>那么死锁的解决办法呢？</p><p>最简单的，把没取走的数据取走，没放入的数据放入， 因为无缓冲信道不能承载数据，那么就赶紧拿走！</p><p>具体来讲，就死锁例子3中的情况，可以这么避免死锁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c, quit := make(chan int), make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">    c &lt;- 1</span><br><span class="line">    quit &lt;- 0</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;- c // 取走c的数据！</span><br><span class="line">&lt;-quit</span><br></pre></td></tr></table></figure><p>另一个解决办法是缓冲信道, 即设置c有一个数据的缓冲大小:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int, 1)</span><br></pre></td></tr></table></figure><p>这样的话，c可以缓存一个数据。也就是说，放入一个数据，c并不会挂起当前线, 再放一个才会挂起当前线直到第一个数据被其他goroutine取走, 也就是只阻塞在容量一定的时候，不达容量不阻塞。</p><p>这十分类似我们Python中的队列<code>Queue</code>不是吗？</p><h2 id="无缓冲信道的数据进出顺序"><a href="#无缓冲信道的数据进出顺序" class="headerlink" title="无缓冲信道的数据进出顺序"></a>无缓冲信道的数据进出顺序</h2><p>我们已经知道，无缓冲信道从不存储数据，流入的数据必须要流出才可以。</p><p>观察以下的程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int)</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123; //id: 这个routine的标号</span><br><span class="line">    ch &lt;- id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 开启5个routine</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取出信道中的数据</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Print(&lt;- ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们开了5个goroutine，然后又依次取数据。其实整个的执行过程细分的话，5个线的数据 依次流过信道ch, main打印之, 而宏观上我们看到的即 无缓冲信道的数据是先到先出，但是 无缓冲信道并不存储数据，只负责数据的流通</p><h2 id="缓冲信道"><a href="#缓冲信道" class="headerlink" title="缓冲信道"></a>缓冲信道</h2><p>终于到了这个话题了, 其实缓存信道用英文来讲更为达意: buffered channel.</p><p>缓冲这个词意思是，缓冲信道不仅可以流通数据，还可以缓存数据。它是有容量的，存入一个数据的话 , 可以先放在信道里，不必阻塞当前线而等待该数据取走。</p><p>当缓冲信道达到满的状态的时候，就会表现出阻塞了，因为这时再也不能承载更多的数据了，「你们必须把 数据拿走，才可以流入数据」。</p><p>在声明一个信道的时候，我们给make以第二个参数来指明它的容量(默认为0，即无缓冲):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int = make(chan int, 2) // 写入2个元素都不会阻塞当前goroutine, 存储个数达到2的时候会阻塞</span><br></pre></td></tr></table></figure><p>如下的例子，缓冲信道ch可以无缓冲的流入3个元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你再试图流入一个数据的话，信道ch会阻塞main线, 报死锁。</p><p>也就是说，缓冲信道会在满容量的时候加锁。</p><p>其实，缓冲信道是先进先出的，我们可以把缓冲信道看作为一个线程安全的队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch) // 1</span><br><span class="line">    fmt.Println(&lt;-ch) // 2</span><br><span class="line">    fmt.Println(&lt;-ch) // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信道数据读取和信道关闭"><a href="#信道数据读取和信道关闭" class="headerlink" title="信道数据读取和信道关闭"></a>信道数据读取和信道关闭</h2><p>你也许发现，上面的代码一个一个地去读取信道简直太费事了，Go语言允许我们使用<code>range</code>来读取信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line"></span><br><span class="line">    for v := range ch &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你执行了上面的代码，会报死锁错误的，原因是range不等到信道关闭是不会结束读取的。也就是如果 缓冲信道干涸了，那么range就会阻塞当前goroutine, 所以死锁咯。</p><p>那么，我们试着避免这种情况，比较容易想到的是读到信道为空的时候就结束读取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 3)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">ch &lt;- 2</span><br><span class="line">ch &lt;- 3</span><br><span class="line">for v := range ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    if len(ch) &lt;= 0 &#123; // 如果现有数据量为0，跳出循环</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法是可以正常输出的，但是注意检查信道大小的方法不能在信道存取都在发生的时候用于取出所有数据，这个例子 是因为我们只在ch中存了数据，现在一个一个往外取，信道大小是递减的。</p><p>另一个方式是显式地关闭信道:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 3)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">ch &lt;- 2</span><br><span class="line">ch &lt;- 3</span><br><span class="line"></span><br><span class="line">// 显式地关闭信道</span><br><span class="line">close(ch)</span><br><span class="line"></span><br><span class="line">for v := range ch &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被关闭的信道会禁止数据流入, 是只读的。我们仍然可以从关闭的信道中取出数据，但是不能再写入数据了。</p><h2 id="等待多gorountine的方案"><a href="#等待多gorountine的方案" class="headerlink" title="等待多gorountine的方案"></a>等待多gorountine的方案</h2><p>那好，我们回到最初的一个问题，使用信道堵塞主线，等待开出去的所有goroutine跑完。</p><p>这是一个模型，开出很多小goroutine, 它们各自跑各自的，最后跑完了向主线报告。</p><p>我们讨论如下2个版本的方案:</p><ol><li>只使用单个无缓冲信道阻塞主线</li><li>使用容量为goroutines数量的缓冲信道</li></ol><p>对于方案1, 示例的代码大概会是这个样子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var quit chan int // 只开一个信道</span><br><span class="line"></span><br><span class="line">func foo(id int) &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">    quit &lt;- 0 // ok, finished</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    count := 1000</span><br><span class="line">    quit = make(chan int) // 无缓冲</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">        go foo(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">        &lt;- quit</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方案2, 把信道换成缓冲1000的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit = make(chan int, count) // 容量1000</span><br></pre></td></tr></table></figure><p>其实区别仅仅在于一个是缓冲的，一个是非缓冲的。</p><p>对于这个场景而言，两者都能完成任务, 都是可以的。</p><ul><li>无缓冲的信道是一批数据一个一个的「流进流出」</li><li>缓冲信道则是一个一个存储，然后一起流出去</li></ul><hr>]]></content>
    
    <summary type="html">
    
      golang语言并发与并行——goroutine和channel的详细理解
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>mysql中字段名与保留字冲突</title>
    <link href="https://cloudsjhan.github.io/2018/12/04/mysql%E4%B8%AD%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97%E5%86%B2%E7%AA%81/"/>
    <id>https://cloudsjhan.github.io/2018/12/04/mysql中字段名与保留字冲突/</id>
    <published>2018-12-04T07:24:50.000Z</published>
    <updated>2018-12-04T07:51:27.453Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>在设计数据库的时候不小心将数据库的字段设置成了其内置的保留字，例如下面的这段：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `test_billing` (</span><br><span class="line">`vendor` varchar(255),</span><br><span class="line">`cn` varchar(255),</span><br><span class="line">`current_date` varchar(255),</span><br><span class="line">`cost` varchar(255)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>这样你在执行类似下面的查询时：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cn, cost from test_billing where current_date like&quot;2018-10%&quot;;</span><br></pre></td></tr></table></figure><p>返回值中什么都没有，还带了一个warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>原因就是字段current_date与MySQL内置的保留字冲突了，那么这时候你还急需查看这些数据，比较快的方法就是：在冲突字段上加反引号 <code>current_date</code>,即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cn, cost from test_billing where `current_date` like&quot;2018-10%&quot;;</span><br></pre></td></tr></table></figure><p>就可以解决了。</p><hr>]]></content>
    
    <summary type="html">
    
      不小心将MySQL的字段与保留字冲突的解决方法
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>git常用操作</title>
    <link href="https://cloudsjhan.github.io/2018/12/02/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://cloudsjhan.github.io/2018/12/02/git常用操作/</id>
    <published>2018-12-02T02:38:11.000Z</published>
    <updated>2018-12-02T02:40:20.339Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>首先来一遍从fork到pull request这个过程的基础流程<br>首先，fork 一个repository，实际上是复制了一份 repository 到自己的 GitHub 账户下，然后就可以从 GitHub 将它 clone 到你的电脑上，命令如下：</p><p>git clone <urlfromgithub><br>连接到原始的Repository，因为如果原始的Repository内容有所改变时，我们希望能够pull这些变化，所以新增一个远端链接，并把它命名为’upstream’，命令如下：</urlfromgithub></p><p>git remote add upstream <urlfromupstreamgithub><br>新增branch分支，并选用新增分支。避免与主分支master造成冲突，当我们在新增分支上完成了自己的功能后再合并到主分支，命令如下：</urlfromupstreamgithub></p><p>git branch <branchname><br>git checkout <branchname><br>git checkout -b <branchname> –创建新的分支并切换到新的分支上<br>记录，在我们自己的分支上修改后，需要记录下来。</branchname></branchname></branchname></p><p>git status –查看当前状态<br>git add -A –记录修改文件，加上 -A，會將新增檔案跟刪除檔案的動作一起記錄下來<br>git commit -m “add a file” –提交全部修改<br>git checkout master –第二天开始工作前，切换到master分支<br>git pull origin master –从master的远程分支拉取代码<br>git checkout <branchname> –切换到task所在的本地分支<br>git rebase -i master –将master上的最新的代码合并到当前分支上，这里的-i的作用是将我们 当前分支之前的commit压缩成为一个commit，这样做的好处在于当我们之后创建pull request并进行相应的code review的时候，代码的改动会集中在一个commit，使得code review更直观方便<br>git push –set-upstream origin <my branch="" name=""> –最后，当task的所有编码完成之后，将代码push到远程分支<br>先获取远端，再提交，每次提交代码前，都需要先获取最新代码，防止覆盖他人代码</my></branchname></p><p>git fetch –dry-run –检查远端是否有变动<br>git pull –从远端分支更新最新代码<br>建立Pull Requests，进入你的github项目页，一般情况下 GitHub会检测到你有了新的推送，会主动提示你，点击Create pull request，写上说明，再按Send pull request就完成了，如果 Pull Request 沒有问题的话，很快就會被自动合并 merged 了哦！</p><p>本地合并分支，并删除分支，将分支合并到主分支上，并删除之</p><p>git checkout master –首先切换到主分支中<br>git merge <branchname> –合并另一个分支进来<br>git branch -d <branchname> –删掉刚刚合并的分支<br>git push <remotename> –delete <branchname> –也可以把合并分支从GitHub上的副本repository中刪除<br>其他常用命令<br>git init –将一个文件夹初始化为git仓库<br>git status –检查当前repository中的修改<br>git diff –查看对文件的修改<br>git add <filename> –准备提交对于一个文件的修改<br>git add . –准备提交对所有文件的修改<br>git commit -m “<your commit="" message="">“ –提交你所准备好的修改，并附上简短说明<br>git config –global user.username <username> –配置github账号<br>git remote add <remotename> –新增远端链接<br>git remote set-url <remotename> –对一个远端设定地址<br>git remote add <remotename> <url> –新增带地址的远端链接<br>git remote -v –查看所有远端<br>git pull <remotename> <branchname> –从一个远端收取更新（默认为主分支）<br>git push <remotename> <branchname> –提交代码到指定远端（默认为主分支）<br>git branch -M <newbranchname> –修改当前分支名字<br>git branch –列出所有分支</newbranchname></branchname></remotename></branchname></remotename></url></remotename></remotename></remotename></username></your></filename></branchname></remotename></branchname></branchname></p><hr>]]></content>
    
    <summary type="html">
    
      git常用基本操作
    
    </summary>
    
      <category term="git" scheme="https://cloudsjhan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://cloudsjhan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ionic project-Could not find module @angular-devkit/build-angular from XXX</title>
    <link href="https://cloudsjhan.github.io/2018/11/30/ionic-project-Could-not-find-module-angular-devkit-build-angular-from-XXX/"/>
    <id>https://cloudsjhan.github.io/2018/11/30/ionic-project-Could-not-find-module-angular-devkit-build-angular-from-XXX/</id>
    <published>2018-11-30T14:02:49.000Z</published>
    <updated>2018-11-30T14:45:25.088Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li><p>从GitHub上找了一个ionic的demo，准备运行一下，报错：Could not find module @angular-devkit/build-angular from XXX</p></li><li><p>操作步骤：</p><ul><li><p>git clone <a href="https://github.com/ionic-team/ionic-conference-app.git" target="_blank" rel="noopener">https://github.com/ionic-team/ionic-conference-app.git</a></p></li><li><p>ionic serve</p></li><li><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find module &quot;@angular-devkit/build-angular&quot; from</span><br></pre></td></tr></table></figure><p>解决方案：</p><ul><li>npm install –save @angular-devkit/build-angular</li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      ionic project-Could not find module @angular-devkit/build-angular from XXX
    
    </summary>
    
      <category term="frontEnd" scheme="https://cloudsjhan.github.io/categories/frontEnd/"/>
    
    
      <category term="angular" scheme="https://cloudsjhan.github.io/tags/angular/"/>
    
      <category term="ionic" scheme="https://cloudsjhan.github.io/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>快排之golang实现</title>
    <link href="https://cloudsjhan.github.io/2018/11/18/%E5%BF%AB%E6%8E%92%E4%B9%8Bgolang%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cloudsjhan.github.io/2018/11/18/快排之golang实现/</id>
    <published>2018-11-18T06:36:38.000Z</published>
    <updated>2018-11-19T02:09:59.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li></ul><p>利用分治法可将快速排序的分为三步：</p><ul><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li></ul><p>快速排序平均时间复杂度为<code>O(n log n)</code>,最坏情况为<code>O(n2)</code>，不稳定排序。</p><p>这里实现了两种方式的快排，第一种是单路的，实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(sortArray []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">key := sortArray[right]</span><br><span class="line">i := left - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := left; j &lt; right; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> sortArray[j] &lt;= key &#123;</span><br><span class="line">i++</span><br><span class="line">swap(i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(i+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是双路的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">unc partition2(arr []<span class="keyword">int</span>,left,right <span class="keyword">int</span>)(p <span class="keyword">int</span>)  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i,j,pivot := left,right ,arr[left]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i&lt;j  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; arr[j] &gt;pivot  &#123;</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; j &amp;&amp; arr[i] &lt;= pivot  &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">arr[i] ,arr[j] = arr[j],arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[i],arr[left] = arr[left],arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"fmt"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sortArray = []<span class="keyword">int</span>&#123;<span class="number">41</span>, <span class="number">24</span>, <span class="number">76</span>, <span class="number">11</span>, <span class="number">45</span>, <span class="number">64</span>, <span class="number">21</span>, <span class="number">69</span>, <span class="number">19</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"before sort："</span>)</span><br><span class="line"></span><br><span class="line">quickSort(sortArray, <span class="number">0</span>, MAX<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"after sort:"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(sortArray []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">pos := partition2(sortArray, left, right)<span class="comment">//修改此处测试不同的实现方式</span></span><br><span class="line">quickSort(sortArray, left, pos<span class="number">-1</span>)</span><br><span class="line">quickSort(sortArray, pos+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BUT!</p><p>要表达快排的思想，还是使用Python比较透彻：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quickSort(less) + [pivot] + quickSort(greater)</span><br></pre></td></tr></table></figure><p>是不是将快排的分治思想表达地淋漓尽致，简洁美观。</p><p>​                                        </p><p>​                                    End！</p><hr>]]></content>
    
    <summary type="html">
    
      快速排序的go实现
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://cloudsjhan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="go 数据结构与算法" scheme="https://cloudsjhan.github.io/tags/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git如何找回被删除的分支</title>
    <link href="https://cloudsjhan.github.io/2018/11/15/git%E5%A6%82%E4%BD%95%E6%89%BE%E5%9B%9E%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E5%88%86%E6%94%AF/"/>
    <id>https://cloudsjhan.github.io/2018/11/15/git如何找回被删除的分支/</id>
    <published>2018-11-15T10:37:28.000Z</published>
    <updated>2018-11-15T10:39:44.797Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>在使用git的过程中，因为人为因素造成分支（commit)被删除，可以使用以下步骤进行恢复。</p><p>首先用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复。<br>1.创建分支 abc</p><p>git branch abc<br>1</p><p>2.查看分支列表</p><p>git branch -a<br>  abc</p><ul><li>develop<br>remotes/origin-dev/develop<br>1<br>2<br>3<br>4</li></ul><p>3.切换到abc分支，随便修改一下东西后 commit</p><p>切换分支<br>git checkout abc<br>Switched to branch ‘abc’</p><p>创建一个文件<br>echo ‘abc’ &gt; test.txt</p><p>commit<br>git add .<br>git commit -m ‘add test.txt’<br>[abc 3eac14d] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p><p>4.删除分支abc</p><p>git branch -D abc<br>Deleted branch abc (was 3eac14d).<br>1<br>2</p><p>5.查看分支列表，abc分支已不存在</p><p>git branch -a</p><ul><li>develop<br>remotes/origin-dev/develop<br>1<br>2<br>3</li></ul><p>恢复步骤如下：<br>1.使用git log -g 找回之前提交的commit<br>commit 3eac14d05bc1264cda54a7c21f04c3892f32406a<br>Reflog: HEAD@{1} (fdipzone <a href="mailto:&#102;&#100;&#x69;&#x70;&#122;&#111;&#110;&#x65;&#64;&#x73;&#105;&#x6e;&#x61;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#102;&#100;&#x69;&#x70;&#122;&#111;&#110;&#x65;&#64;&#x73;&#105;&#x6e;&#x61;&#46;&#99;&#x6f;&#x6d;</a>)<br>Reflog message: commit: add test.txt<br>Author: fdipzone <a href="mailto:&#102;&#100;&#x69;&#x70;&#x7a;&#x6f;&#110;&#101;&#x40;&#x73;&#105;&#110;&#97;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#102;&#100;&#x69;&#x70;&#x7a;&#x6f;&#110;&#101;&#x40;&#x73;&#105;&#110;&#97;&#46;&#x63;&#x6f;&#x6d;</a><br>Date:   Sun Jan 31 22:26:33 2016 +0800</p><pre><code>add test.txt</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p><p>2.使用git branch recover_branch[新分支] commit_id命令用这个commit创建一个分支<br>git branch recover_branch_abc 3eac14d05bc1264cda54a7c21f04c3892f32406a</p><p>git branch -a</p><ul><li>develop<br>recover_branch_abc<br>remotes/origin-dev/develop<br>1<br>2<br>3<br>4<br>5<br>6<br>可以见到recover_branch_abc已创建 </li></ul><p>3.切换到recover_branch_abc分支，检查文件是否存在<br>git checkout recover_branch_abc<br>Switched to branch ‘recover_branch_abc’</p><p>ls -lt<br>total 8<br>-rw-r–r–   1 fdipzone  staff     4  1 31 22:38 test.txt<br>1<br>2<br>3<br>4<br>5<br>6</p><h2 id="这样就可以恢复被误删的分支了"><a href="#这样就可以恢复被误删的分支了" class="headerlink" title="这样就可以恢复被误删的分支了"></a>这样就可以恢复被误删的分支了</h2><p>原文：<a href="https://blog.csdn.net/fdipzone/article/details/50616386" target="_blank" rel="noopener">https://blog.csdn.net/fdipzone/article/details/50616386</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><hr>]]></content>
    
    <summary type="html">
    
      git找回被删除的分支
    
    </summary>
    
      <category term="git" scheme="https://cloudsjhan.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://cloudsjhan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>golang读取命令行传来的参数</title>
    <link href="https://cloudsjhan.github.io/2018/11/06/golang%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>https://cloudsjhan.github.io/2018/11/06/golang读取命令行传来的参数/</id>
    <published>2018-11-06T06:59:04.000Z</published>
    <updated>2018-11-06T07:13:58.650Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h1 id="Golang-使用命令行参数"><a href="#Golang-使用命令行参数" class="headerlink" title="Golang-使用命令行参数"></a>Golang-使用命令行参数</h1><p>Golang有两个标准包中都有获得命令行参数的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*]os/Args可以简单地获得一个类似Ｃ语言中的argv结构</span><br><span class="line">[*]flag则提供了一个更为复杂的标志与值的方法</span><br></pre></td></tr></table></figure><p>os.Argsos.Args返回一个字符串数组[] string.</p><p>使用方法很简单：package main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令：go run test.go arg1 arg2</p><p>可见返回了一个三个元素的数组，第０个元素是程序的名字包括路径，os.Args就第一个参数，os.Args就是第二个参数。</p><hr><p>flag包flag包提供的功能非常复杂。</p><p>它将命令行参数分为非标志类参数(nonflag arguments)和Flags，标志参数是这样的-flagname=x，比如说-baudrate=1200。</p><p>非标志类参数为arg1 arg2。</p><p>flag参数处理流程由于标志类参数是参数的一部分，但又特殊，为了将标志类参数区别处理</p><p>flag包有两类方法，一类是flag处理方法，另一类是正常的参数处理方法。</p><p>正常的参数处理方法正常参数处理方法与os.Args差不多，这里是一个方法，flag.Args()，返回也是[]string.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">/*    &quot;os/exec&quot;</span><br><span class="line">    &quot;bytes&quot;*/</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">go run test.go arg1 arg2</span><br></pre></td></tr></table></figure><p>如果有标志类参数呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run test.go arg1 arg2　-baudrate=1200</span><br></pre></td></tr></table></figure><p>这里充分证明了标志类参数也是参数。</p><p>标志类参数Parse前定义如果使用标志类参数，要提前定义,定义之后再调用Parse才能解析出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>标志类参数必须在Parse之定义，否则会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br><span class="line"></span><br><span class="line">flag provided but not defined: -baudrate</span><br><span class="line"></span><br><span class="line">Usage of /tmp/go-build944578075/command-line-arguments/_obj/a.out:</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>flag.Int返回的是地址</p><p>需要注意的是这里flag.Int返回的值为一个地址，你可以随时到这个地址里去取值</p><p>但在Parse之前取值，取到的是默认值，Parse之后去随值，取到的才是真正的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>标志类参数顺序</p><p>标志类参数之间的前后顺序可以改变，但是似乎标志类参数非要放到非标志类参数之前才能正确解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    databits:=flag.Int(&quot;databits&quot;,10,&quot;number of data bits&quot;)</span><br><span class="line">    baudrate:=flag.Int(&quot;baudrate&quot;,1200, &quot;help message for flagname&quot;)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go run test.go -baudrate=9600 -databits=8 arg1 arg2</span><br></pre></td></tr></table></figure><p>上面的命令正确解析了，调换了baudrate和databits的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run test.go arg1 -baudrate=9600 -databits=8  arg2</span><br></pre></td></tr></table></figure><p>上前这里没能正确解析，可以baudrate和databits得到的还是默认值，而非标志类参数获取到了所有的参数。</p><p>–help</p><p>flag.Int的最后一个参数是help信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go run test.go --help</span><br><span class="line"></span><br><span class="line">Usage of /tmp/go-build327358548/command-line-arguments/_obj/a.out:</span><br><span class="line">  -baudrate=1200: help message for flagname</span><br><span class="line">  -databits=10: number of data bits</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>flag.String传入的参数显然不能都是数字，实际go语言提供的类型都支持，与flag.Int类似，所有其他函数都有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.String flag.Uint flag.Float64....</span><br></pre></td></tr></table></figure><p>flag.IntVarflag.Int返回的是指针，用起来可以有点不太好，flag.IntVar可能用起来更好的些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var baudrate int</span><br><span class="line">flag.IntVar(&amp;baudrate,&quot;baudrate&quot;,1200,&quot;baudrate of serial port&quot;)</span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Println(baudrate)</span><br></pre></td></tr></table></figure><p>当前你一样可以用flag.UintVar flag.Float64Var flag.StringVar</p><p>参数个数参数个数也分为标志类参数的非标志类参数，两个方法为NArg和NFlag,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    databits:=flag.Int(<span class="string">"databits"</span>,<span class="number">10</span>,<span class="string">"number of data bits"</span>)</span><br><span class="line">    baudrate:=flag.Int(<span class="string">"baudrate"</span>,<span class="number">1200</span>, <span class="string">"help message for flagname"</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(*baudrate)</span><br><span class="line">    fmt.Println(*databits)</span><br><span class="line">    fmt.Println(flag.Args())</span><br><span class="line">    fmt.Println(flag.NArg())</span><br><span class="line">    fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> run test.<span class="keyword">go</span> -baudrate=<span class="number">9600</span> -databits=<span class="number">8</span> arg1 arg2</span><br></pre></td></tr></table></figure><p>以上代码的执行的过程以及执行结果是：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwycwsdqmrj31ks09iq3t.jpg" alt=""></p><p>从上到下打印出的参数含义分别是：</p><p>1111：指定的标志类参数baudrate，默认值是1200，可随意更改；</p><p>1011： 指定的标志类参数databits，默认值是10，可随意更改；</p><p>[la, la]:非标志类参数为arg1 arg2；</p><p>2：非标志类参数的数量</p><p>2：标志类参数的数量</p><p>​                                                          The End!</p><hr>]]></content>
    
    <summary type="html">
    
      golang使用命令行参数
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL使用group by分组后对每组操作</title>
    <link href="https://cloudsjhan.github.io/2018/11/05/MySQL%E4%BD%BF%E7%94%A8group-by%E5%88%86%E7%BB%84%E5%90%8E%E5%AF%B9%E6%AF%8F%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://cloudsjhan.github.io/2018/11/05/MySQL使用group-by分组后对每组操作/</id>
    <published>2018-11-05T08:54:14.000Z</published>
    <updated>2018-11-06T02:07:42.708Z</updated>
    
    <content type="html"><![CDATA[<p></p><p class="description"></p><br><a id="more"></a><p></p><h2 id="group-by-操作"><a href="#group-by-操作" class="headerlink" title="group by 操作"></a>group by 操作</h2><ul><li><p>分组能够将数据分成几个逻辑组，然后对其进行聚集操作</p></li><li><p>前几天开发的时候遇到这样的一个问题，有一个vender-cost表：</p></li></ul><p>mysql&gt; select * from vendor-cost;<br>+———+————–+————–+———–+————+———-+———-+</p><table><thead><tr><th>vendor</th><th>host</th><th>vendor_id</th><th>start_date</th><th>cost</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>+———+————–+————–+———–+————+———-+———-+<br>| Tencent | ins-m9faipc4 | 100014390 | 2018-10 | 0.015456 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-r76jxurv | 100015923 | 2018-10 | 0.284697 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-ramdkuqz | 100015923 | 2018-10 | 0.021175 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-q7o1dhsa | 100014390 | 2018-10 | 0.113501 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-5xxrgd65 | 100015923 | 2018-10 | 0.058623 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-79g28kn6 | 100015923 | 2018-10 | 0.03808 |<br>| ——- | ———— | ——— | ——- | ——- |<br>|         |              |           |         |         |<br>| Tencent | ins-rw54ka4k | 100015923 | 2018-10 | 0.150595 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>| Tencent | ins-ggxrtm1v | 100015923 | 2018-10 | 0.068281 |<br>| ——- | ———— | ——— | ——- | ——– |<br>|         |              |           |         |          |<br>为了统计出每个vendor_id的cost，就需要使用分组语句，将同一个vendor_id的cost求和：</p><p>select vendor_id, sum(cost) from vendor_cost group by vendor_id;</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwy3y3ulp2j30lk0dejsn.jpg" alt=""></p><p>得出的结果就是每个vendor_id的总cost。</p><ul><li>还有一种group by的用法：<strong>GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里。</strong></li><li>举个栗子：</li></ul><p>现在有表格</p><p>Table: Subject_Selection</p><h2 id="Subject-Semester-Attendee"><a href="#Subject-Semester-Attendee" class="headerlink" title="Subject   Semester   Attendee"></a>Subject   Semester   Attendee</h2><p>ITB001    1          John<br>ITB001    1          Bob<br>ITB001    1          Mickey<br>ITB001    2          Jenny<br>ITB001    2          James<br>MKB114    1          John<br>MKB114    1          Erica</p><ul><li>我们下面再接着要求统计出每门学科每个学期有多少人选择，应用如下SQL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Subject, Semester, <span class="keyword">Count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> Subject_Selection</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Subject, Semester</span><br></pre></td></tr></table></figure><ul><li>得到的结果是：</li></ul><h3 id="得到的结果是："><a href="#得到的结果是：" class="headerlink" title="得到的结果是："></a>得到的结果是：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject    Semester   Count</span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line">ITB001     1          3</span><br><span class="line">ITB001     2          2</span><br><span class="line">MKB114     1          2</span><br></pre></td></tr></table></figure><ul><li>从表中的记录我们可以看出这个分组结果是正确的有3个学生在第一学期选择了ITB001, 2个学生在第二学期选择了ITB001,还有两个学生在第一学期选择了MKB114, 没人在第二学期选择MKB114。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      在MySQL中使用group by对字段进行分组，并对每组进行统计操作
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>golang xorm 操作指南</title>
    <link href="https://cloudsjhan.github.io/2018/10/31/golang-xorm-%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>https://cloudsjhan.github.io/2018/10/31/golang-xorm-操作指南/</id>
    <published>2018-10-31T07:42:15.000Z</published>
    <updated>2018-10-31T07:44:25.132Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><a href="https://www.kancloud.cn/xormplus/xorm/167077" target="_blank" rel="noopener">https://www.kancloud.cn/xormplus/xorm/167077</a></p><hr>]]></content>
    
    <summary type="html">
    
      golang xorm 操作指南 官方版
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之golang中修改struct的slice的值</title>
    <link href="https://cloudsjhan.github.io/2018/10/27/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8Bgolang%E4%B8%AD%E4%BF%AE%E6%94%B9struct%E7%9A%84slice%E7%9A%84%E5%80%BC/"/>
    <id>https://cloudsjhan.github.io/2018/10/27/技术周刊之golang中修改struct的slice的值/</id>
    <published>2018-10-27T02:30:10.000Z</published>
    <updated>2018-10-29T02:01:09.050Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>前段时间写go的时候遇到一个问题，需要修改由struct构成的slice中struct的某个字段值，类似于下面的需求：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Docker <span class="keyword">struct</span> &#123;</span><br><span class="line">Ip  <span class="keyword">string</span></span><br><span class="line">ID <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker1 := Docker&#123;</span><br><span class="line">Ip:  <span class="string">"222"</span>,</span><br><span class="line">ID: <span class="string">"aaa"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker2 := Docker&#123;</span><br><span class="line">Ip:  <span class="string">"111"</span>,</span><br><span class="line">ID: <span class="string">"bbb"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmpDocker []Docker</span><br><span class="line">tmpDocker = <span class="built_in">append</span>(tmpDocker, docker1)</span><br><span class="line">tmpDocker = <span class="built_in">append</span>(tmpDocker, docker2)</span><br><span class="line">现在需要修改tmpDocker中，Ip这个字段的值, 你可以先自己尝试修改一下，然后再往下看</span><br></pre></td></tr></table></figure><p>由这个问题我查阅很多资料，我们先从语言中经典的传值、传引用说起来</p><ul><li>对于一门语言，我们关心传递参数的过程中，是传值还是传引用，其实对于传值和传引用是一个比较古老的问题，在大学入门的时候，你可能就接触过这样的C语言代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下哪个函数能实现交换两个数？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=p;</span><br><span class="line">    p=q;</span><br><span class="line">    q=temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    *temp=*p;</span><br><span class="line">    *p=*q;</span><br><span class="line">    *q=*temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对于C语言来说，并没有传引用的概念，看似传引用的操控，实际上传的是指针的地址，也算是一种传值，先看一下传值，传引用，传指针的概念：</p><ul><li>传值：可能很多人都听说，传值无非就是实参拷贝传递给形参。这句话没有错，但是理解起来还是有点抽象。一句话，传值就是把实参赋值给形参，赋值完毕后实参就和形参没有任何联系，对形参的修改就不会影响到实参。</li><li>传地址：为什么说传地址也是一种传值呢？因为传地址是把实参地址的拷贝传递给形参。还是一句话，传地址就是把实参的地址复制给形参。复制完毕后实参的地址和形参的地址没有任何联系，对实参形参地址的修改不会影响到实参, 但是对形参地址所指向对象的修改却直接反应在实参中，因为形参指向的对象就是形参的对象。</li><li>传引用：传引用本质没有任何实参的拷贝，一句话，就是让另外一个变量也执行该实参。就是两个变量指向同一个对象。这是对形参的修改，必然反映到实参上。</li></ul><p>那么对于go语言来说，是没有引用传递的，go作为云计算时代的C语言，采用的都是值传递，即使是指针，也是将指针的地址即指针的指针，拷贝一份传递，可以参考这篇博文的讲解：Go<a href="http://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html" target="_blank" rel="noopener">语言参数传递是传值还是传引用</a></p><h3 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h3><ul><li><p>了解基本的知识背景之后，让我们回到文章开头的代码，即要修改slice中struct某字段的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type Docker struct &#123;</span><br><span class="line">Ip  string</span><br><span class="line">ID string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker1 := Docker&#123;</span><br><span class="line">Ip:  &quot;222&quot;,</span><br><span class="line">ID: &quot;aaa&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker2 := Docker&#123;</span><br><span class="line">Ip:  &quot;111&quot;,</span><br><span class="line">ID: &quot;bbb&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tmpDocker []Docker</span><br><span class="line">tmpDocker = append(tmpDocker, docker1)</span><br><span class="line">tmpDocker = append(tmpDocker, docker2)</span><br></pre></td></tr></table></figure><p>先将我最初的代码实现贴出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, dockerInfo := <span class="keyword">range</span> tmpDocker &#123;</span><br><span class="line">dockerInfo.Ip = <span class="string">"192.168,.1.1"</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(tmpDocker)</span><br></pre></td></tr></table></figure><p>让我们看一下运行结果：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwmm2z70f6j30d301ja9z.jpg" alt=""></p><p>发现struct中Ip字段的值并没有改变，是为什么呢？</p><p>原因就是：range的过程中产生了一个新的对象，即dockerInfo是temDocker中每个元素的一个副本，所以你改变的只是副本中Ip字段的值，并没有改变真实的。那么如何解决呢?</p><p>这里我提出两种解决的方法，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：赋给一个新的对象</span></span><br><span class="line">newTmpDocker := []Docker&#123;&#125;<span class="comment">//新的对象</span></span><br><span class="line"><span class="keyword">for</span> _, dockerInfo := <span class="keyword">range</span> tmpDocker &#123;</span><br><span class="line">    dockerInfo.Ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">    newTmpDocker = <span class="built_in">append</span>(newTmpDocker, dockerInfo)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(newTmpDocker)</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwmnl32x44j30dj01imx3.jpg" alt=""></p><p>可以看到最终输出的struct的slice中我们想要改变的字段已经修改成功。</p><p>第二种方法是将副本修改后赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">2</span>：修改副本后，将副本赋值给原来的</span><br><span class="line"><span class="keyword">for</span> i, dockerInfo := <span class="keyword">range</span> tmpDocker&#123;</span><br><span class="line">    dockerInfo.Ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">    tmpDocker[i] = dockerInfo</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(tmpDocker)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwmnl32x44j30dj01imx3.jpg" alt=""></p><p>可以看到同样修改成功。</p></li></ul><h3 id="总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。"><a href="#总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。" class="headerlink" title="总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。"></a>总结，在go中，所有传参都是传值，都是一个副本，即一个拷贝，因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</h3><p>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。</p><p>这里也要记住，引用类型和传引用是两个概念。</p><p>再记住，Go里只有传值（值传递）。</p><hr>]]></content>
    
    <summary type="html">
    
      如何优雅地修改go中struct的slice的值
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>golang中string,rune,byte的关系</title>
    <link href="https://cloudsjhan.github.io/2018/10/25/golang%E4%B8%ADstring-rune-byte%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://cloudsjhan.github.io/2018/10/25/golang中string-rune-byte的关系/</id>
    <published>2018-10-25T01:55:40.000Z</published>
    <updated>2018-10-25T02:26:19.271Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ol><li>golang中String的底层是使用byte[]数组存储的，不可改变</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"Golang 测试"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br></pre></td></tr></table></figure><p>这段代码按道理应该输出6+1+2.</p><p>实际运行之后输出却是13， 原因是中文字符在utf-8编码的系统中是3个字节存储的，在Unicode中是2个字节存储的，go的默认编码格式是utf-8，so。。</p><p>这时候，我们使用下标访问字符串中的中文字符是不行的，想要使用下标访问，就需要rune出马。</p><ol start="2"><li>在官方文档中，rune的定义是：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> rune is an alias for int32 and is equivalent to int32 in all ways. It is</span><br><span class="line"> used, by convention, to distinguish character values from integer values.</span><br><span class="line"></span><br><span class="line">int32的别名，几乎在所有方面等同于int32</span><br><span class="line">它用来区分字符值和整数值</span><br><span class="line">type rune int32</span><br></pre></td></tr></table></figure><p>那么我们想要得到预期字符串的长度，就要使用rune切片来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"rune:"</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br></pre></td></tr></table></figure><p>就会输出预期的rune: 9.</p><p>这时我们也可以按照下标去访问str中的字符了。即[7]rune(str) = “测”。</p><p>3.总结</p><p>string的底层是byte，byte与rune的不同之处是：</p><p>byte 等同于int8，常用来处理ascii字符<br>rune 等同于int32,常用来处理unicode或utf-8字符</p><p>或者可以这样说：</p><p>rune 能操作任何字符<br>byte 不支持中文的操作</p><p>​                                           END</p><hr>]]></content>
    
    <summary type="html">
    
      浅析golang中String，rune, byte的关系
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>上海QCon之Go专家David Cheney关于GO最佳实践的演讲</title>
    <link href="https://cloudsjhan.github.io/2018/10/21/%E4%B8%8A%E6%B5%B7QCon%E4%B9%8BGo%E4%B8%93%E5%AE%B6David-Cheney%E5%85%B3%E4%BA%8EGO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%9A%84%E6%BC%94%E8%AE%B2/"/>
    <id>https://cloudsjhan.github.io/2018/10/21/上海QCon之Go专家David-Cheney关于GO最佳实践的演讲/</id>
    <published>2018-10-21T14:07:15.000Z</published>
    <updated>2018-10-21T14:17:36.133Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本周六有幸参加了2018QCon上海的会议，听了David关于GO最佳实践的一些建议，下面贴出的就是David的演讲稿，内容相对来说比较基础，但是又是编程中不可避免的一些问题，希望可以给大家带来一些启发。</p><p>Table of Contents </p><p>Introduction<br> \1. Guiding principles </p><p>1.1. Simplicity 1.2. Readability 1.3. Productivity </p><p>\2. Identiers<br> 2.1. Choose identiers for clarity, not brevity 2.2. Identier length<br> 2.3. Don’t name your variables for their types 2.4. Use a consistent naming style<br> 2.5. Use a consistent declaration style<br> 2.6. Be a team player </p><p>\3. Comments<br> 3.1. Comments on variables and constants should describe their contents not their purpose 3.2. Always document public symbols </p><p>\4. Package Design<br> 4.1. A good package starts with its name<br> 4.2. Avoid package names like base , common , or util 4.3. Return early rather than nesting deeply<br> 4.4. Make the zero value useful<br> 4.5. Avoid package level state </p><p>\5. Project Structure<br> 5.1. Consider fewer, larger packages<br> 5.2. Keep package main small as small as possible </p><p>\6. API Design<br> 6.1. Design APIs that are hard to misuse.<br> 6.2. Design APIs for their default use case<br> 6.3. Let functions dene the behaviour they requires </p><p>\7. Error handling<br> 7.1. Eliminate error handling by eliminating errors 7.2. Only handle an error once </p><p>\8. Concurrency<br> 8.1. Keep yourself busy or do the work yourself<br> 8.2. Leave concurrency to the caller<br> 8.3. Never start a goroutine without when it will stop. </p><p>Introduction </p><p>Hello,<br> My goal over the next two sessions is to give you my advice for best practices writing Go code. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 1/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This is a workshop style presentation, I’m going to dispense with the usual slide deck and we’ll work directly from the document which you can take away with you today. </p><p>TIP </p><p>You can find the latest version of this presentation at <a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>\1. Guiding principles </p><p>If I’m going to talk about best practices in any programming language I need some way to define what I mean by best. If you came to my keynote yesterday you would have seen this quote from the Go team lead, Russ Cox: </p><p>“Software engineering is what happens to programming when you add time and other programmers. </p><p>— Russ Cox </p><p>Russ is making the distinction between software programming and software engineering. The former is a program you write for yourself. The latter is a product that many people will work on over time. Engineers will come and go, teams will grow and shrink over time, requirements will change, features will be added and bugs fixed. This is the nature of software engineering. </p><p>I’m possibly one of the earliest users of Go in this room, but to argue that my seniority gives my views more weight is false. Instead, the advice I’m going to present today is informed by what I believe to be the guiding principles underlying Go itself. They are: </p><p>\1. Simplicity<br> \2. Readability 3. Productivity </p><p>NOTE </p><p>You’ll note that I didn’t say performance, or concurrency. There are languages which are a bit faster than Go, but they’re certainly not as simple as Go. There are languages which make concurrency their highest goal, but they are not as readable, nor as productive. </p><p>Performance and concurrency are important attributes, but not as important as simplicity, readability, and productivity. </p><p>1.1. Simplicity </p><p>Why should we strive for simplicity? Why is important that Go programs be simple? </p><p>We’ve all been in a situation where you say “I can’t understand this code”, yes? We’ve all worked on programs where you’re scared to make a change because you’re worried it’ll break another part of the program; a part you don’t understand and don’t know how to fix. </p><p>This is complexity. Complexity turns reliable software in unreliable software. Complexity is what kills software projects. </p><p>Simplicity is the highest goal of Go. Whatever programs we write, we should be able to agree that they are simple. </p><p>1.2. Readability </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 2/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“Readability is essential for maintainability. — Mark Reinhold </p><p>JVM language summit 2018 </p><p>Why is it important that Go code be readable? Why should we strive for readability? </p><p>“Programs must be written for people to read, and only incidentally for machines to execute. — Hal Abelson and Gerald Sussman </p><p>Structure and Interpretation of Computer Programs </p><p>Readability is important because all software, not just Go programs, is written by humans to be read by other humans. The fact that software is also consumed by machines is secondary. </p><p>Code is read many more times than it is written. A single piece of code will, over its lifetime, be read hundreds, maybe thousands of times. </p><p>“The most important skill for a programmer is the ability to effectively communicate ideas. — Gastón Jorquera [1] </p><p>Readability is key to being able to understand what the program is doing. If you can’t understand what a program is doing, how can you hope to maintain it? If software cannot be maintained, then it will be rewritten; and that could be the last time your company will invest in Go. </p><p>If you’re writing a program for yourself, maybe it only has to run once, or you’re the only person who’ll ever see it, then do what ever works for you. But if this is a piece of software that more than one person will contribute to, or that will be used by people over a long enough time that requirements, features, or the environment it runs in changes, then your goal must be for your program to be maintainable. </p><p>The first step towards writing maintainable code is making sure the code is readable. </p><p>“1.3. Productivity<br> Design is the art of arranging code to work today, and be changeable forever. </p><p>— Sandi Metz </p><p>The last underlying principle I want to highlight is productivity. Developer productivity is a sprawling topic but it boils down to this; how much time do you spend doing useful work verses waiting for your tools or hopelessly lost in a foreign code-base. Go programmers should feel that they can get a lot done with Go. </p><p>The joke goes that Go was designed while waiting for a C++ program to compile. Fast compilation is a key feature of Go and a key recruiting tool to attract new developers. While compilation speed remains a constant battleground, it is fair to say that compilations which take minutes in other languages, take seconds in Go. This helps Go developers feel as productive as their counterparts working in dynamic languages without the reliability issues inherent in those languages. </p><p>More fundamental to the question of developer productivity, Go programmers realise that code is written to be read and so place the act of reading code above the act of writing it. Go goes so far as to enforce, via tooling and custom, that all code be formatted in a specific style. This removes the friction of learning a project specific dialect and helps spot mistakes because they just look incorrect. </p><p>Go programmers don’t spend days debugging inscrutable compile errors. They don’t waste days with complicated build scripts or deploying code to production. And most importantly they don’t spend their time trying to understand what their coworker wrote. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 3/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Productivity is what the Go team talk about when they say the language must scale. 2. Identiers </p><p>The first topic we’re going to discuss is identifiers. An identifier is a fancy word for a name; the name of a variable, the name of a function, the name of a method, the name of a type, the name of a package, and so on. </p><p>“Poor naming is symptomatic of poor design. — Dave Cheney </p><p>Given the limited syntax of Go, the names we choose for things in our programs have an oversized impact on the readability of our programs. Readability is the defining quality of good code thus choosing good names is crucial to the readability of Go code. </p><p>“2.1. Choose identiers for clarity, not brevity<br> Obvious code is important. What you can do in one line you should do in three. </p><p>— Ukiah Smith </p><p>Go is not a language that optimises for clever one liners. Go is not a language which optimises for the least number of lines in a program. We’re not optimising for the size of the source code on disk, nor how long it takes to type. </p><p>“Good naming is like a good joke. If you have to explain it, it’s not funny. — Dave Cheney </p><p>Key to this clarity is the names we choose for identifies in Go programs. Let’s talk about the qualities of a good name: </p><p>A good name is concise. A good name need not be the shortest it can possibly be, but a good name should waste no space on things which are extraneous. Good names have a high signal to noise ratio. </p><p>A good name is descriptive. A good name should describe the application of a variable or constant, not their contents. A good name should describe the result of a function, or behaviour of a method, not their operation. A good name should describe the purpose of a package, not its contents. The more accurately a name describes the thing it identifies, the better the name. </p><p>A good name is should be predictable. You should be able to infer the way a name will be used from its name alone. This is a function of choosing descriptive names, but it also about following tradition. This is what Go programmers talk about when they say idiomatic. </p><p>Let’s talk about each of these properties in depth. </p><p>2.2. Identier length </p><p>Sometimes people criticise the Go style for recommending short variable names. As Rob Pike said, “Go programmers want the right length identifiers”. [1] </p><p>Andrew Gerrand suggests that by using longer identifies for some things we indicate to the reader that they are of higher importance. </p><p>“The greater the distance between a name’s declaration and its uses, the longer the name should be. </p><p>— Andrew Gerrand [2] </p><p>From this we can draw some guidelines: </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 4/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Short variable names work well when the distance between their declaration and last use is short.<br> Long variable names need to justify themselves; the longer they are the more value they need to provide. Lengthy </p><p>bureaucratic names carry a low amount of signal compared to their weight on the page. </p><p>Don’t include the name of your type in the name of your variable. </p><p>Constants should describe the value they hold, not how that value is used. </p><p>Single letter variables for loops and branches, single words for parameters and return values, multiple words for functions and package level declarations </p><p>Single words for methods, interfaces, and packages.<br> Remember that the name of a package is part of the name the caller uses to to refer to it, so make use of that. </p><p>Let’s look at an example to </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br></pre></td></tr></table></figure><p>Age int } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// AverageAge returns the average age of people.</span><br><span class="line">func AverageAge(people []Person) int &#123;</span><br><span class="line">    if len(people) == 0 &#123;</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count, sum int</span><br><span class="line">for _, p := range people &#123;</span><br></pre></td></tr></table></figure><p>sum += p.Age </p><p>count += 1 } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return sum / count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>In this example, the range variable p is declared on line 10 and only referenced on the following line. p lives for a very short time both on the page, and during the execution of the function. A reader who is interested in the effect values of p have on the program need only read two lines. </p><p>By comparison people is declared in the function parameters and lives for seven lines. The same is true for sum , and count , thus they justify their longer names. The reader has to scan a wider number of lines to locate them so they are </p><p>given more distinctive names. </p><p>I could have chosen s for sum and c (or possibly n ) for but this would have reduced all the variables in the program to the same level of importance. I could have chosen                              instead of                              but that would have left the problem of what to call the for … range iteration variable. The singular                              would look odd as the loop iteration variable which lives for little time has a longer name than the slice of values it was derived from. </p><p>count </p><p>TIP </p><p>Use blank lines to break up the flow of a function in the same way you use paragraphs to break up the flow of a document. In AverageAge we have three operations occurring in sequence. The first is the precondition, checking that we don’t divide by zero if people is empty, the second is the accumulation of the sum and count, and the final is the computation of the average. </p><p>2.2.1. Context is key </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 5/45 </p><p>p </p><p>people </p><p>person </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>It’s important to recognise that most advice on naming is contextual. I like to say it is a principle, not a rule. </p><p>What is the difference between two identifiers, i , and index . We cannot say conclusively that one is better than another, for example is </p><p>fundamentally more readable than </p><p>I argue it is not, because it is likely the scope of i , and index for that matter, is limited to the body of the for loop and the extra verbosity of the latter adds little to comprehension of the program. </p><p>However, which of these functions is more readable? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(oid []int, index int) (int, error)</span><br></pre></td></tr></table></figure><p>or </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (s *SNMP) Fetch(o []int, i int) (int, error)</span><br></pre></td></tr></table></figure><p>In this example, oid is an abbreviation for SNMP Object ID, so shortening it to o would mean programmers have to translate from the common notation that they read in documentation to the shorter notation in your code. Similarly, reducing index to i obscures what i stands for as in SNMP messages a sub value of each OID is called an Index. </p><p>TIP Don’t mix and match long and short formal parameters in the same declaration. 2.3. Don’t name your variables for their types </p><p>You shouldn’t name your variables after their types for the same reason you don’t name your pets “dog” and “cat”. You also probably shouldn’t include the name of your type in the name of your variable’s name for the same reason. </p><p>The name of the variable should describe its contents, not the type of the contents. Consider this example: var usersMap map[string]*User </p><p>What’s good about this declaration? We can see that its a map, and it has something to do with the *User type, that’s probably good. But usersMap is a map, and Go being a statically typed language won’t let us accidentally use it where a scalar variable is required, so the Map suffix is redundant. </p><p>Now, consider what happens if we were to declare other variables like: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for index := 0; index &lt; len(s); index++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">    //</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 6/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    companiesMap map[string]*Company</span><br><span class="line">    productsMap map[string]*Products</span><br></pre></td></tr></table></figure><p>) </p><p>Now we have three map type variables in scope, usersMap , companiesMap , and productsMap , all mapping strings to different types. We know they are maps, and we also know that their map declarations prevent us from using one in place of another—the compiler will throw an error if we try to use companiesMap where the code is expecting a </p><p>map[string]*User . In this situation it’s clear that the Map suffix does not improve the clarity of the code, its just extra boilerplate to type. </p><p>My suggestion is to avoid any suffix that resembles the type of the variable.<br> TIP If users isn’t descriptive enough, then usersMap won’t be either. </p><p>This advice also applies to function parameters. For example: </p><p>Naming the <em>Config parameter config is redundant. We know its a </em>Config , it says so right there. In this case consider conf or maybe c will do if the lifetime of the variable is short enough. </p><p>If there is more that one in scope at any one time then calling them conf1 and conf2 is less descriptive than calling them and as the latter are less likely to be mistaken for one another. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line">func WriteConfig(w io.Writer, config *Config)</span><br></pre></td></tr></table></figure><p>*Config </p><p>original </p><p>updated </p><p>Don’t let package names steal good variable names. </p><p>The name of an imported identifier includes its package name. For example the context package will be known as context.Context . This makes it impossible to use </p><p>a variable or type in your package. </p><p>type in the as </p><p>func WriteLog(context context.Context, message string)<br> Will not compile. This is why the local declaration for context.Context types is traditionally ctx . </p><p>eg. </p><p>func WriteLog(ctx context.Context, message string) </p><p>2.4. Use a consistent naming style </p><p>Another property of a good name is it should be predictable. The reader should be able to understand the use of a name when they encounter it for the first time. When they encounter a common name, they should be able to assume it has not changed meanings since the last time they saw it. </p><p>NOTE </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 7/45 </p><p>Context </p><p>context </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>For example, if your code passes around a database handle, make sure each time the parameter appears, it has the same name. Rather than a combination of d <em>sql.DB , dbase </em>sql.DB , DB <em>sql.DB , and database </em>sql.DB , instead consolidate on something like; </p><p>db <em>sql.DB<br> Doing so promotes familiarity; if you see a db , you know it’s a </em>sql.DB and that it has either been declared locally or </p><p>provided for you by the caller. </p><p>Similarly for method receivers; use the same receiver name every method on that type. This makes it easier for the reader to internalise the use of the receiver across the methods in this type. </p><p>The convention for short receiver names in Go is at odds with the advice provided so far. This is just NOTE one of the choices made early on that has become the preferred style, just like the use of CamelCase </p><p>TIP </p><p>rather than snake_case . </p><p>Go style dictates that receivers have a single letter name, or acronyms derived from their type. You may find that the name of your receiver sometimes conflicts with name of a parameter in a method. In this case, consider making the parameter name slightly longer, and don’t forget to use this new parameter name consistently. </p><p>Finally, certain single letter variables have traditionally been associated with loops and counting. For example, i , j , and k are commonly the loop induction variable for simple for loops. n is commonly associated with a counter or accumulator. v is a common shorthand for a value in a generic encoding function, k is commonly used for the key of a map, and s is often used as shorthand for parameters of type string . </p><p>As with the db example above programmers expect                              to be a loop induction variable. If you ensure that is always a loop variable, not used in other contexts outside a                              loop. When readers encounter a variable called , or j , they know that a loop is close by. </p><p>i </p><p>i </p><p>for </p><p>i </p><p>TIP </p><p>If you found yourself with so many nested loops that you exhaust your supply of i , j , and k variables, its probably time to break your function into smaller units. </p><p>2.5. Use a consistent declaration style </p><p>Go has at least six different ways to declare a variable </p><p>varxint=1 varx=1 varxint;x=1 var x = int(1) x:=1 </p><p>I’m sure there are more that I haven’t thought of. This is something that Go’s designers recognise was probably a mistake, but its too late to change it now. With all these different ways of declaring a variable, how do we avoid each Go programmer choosing their own style? </p><p>I want to present a suggestions for how I declare variables in my programs. This is the style I try to use where possible. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 8/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>When declaring, but not initialising, a variable, use var . When declaring a variable that will be explicitly initialised later in the function, use the var keyword. </p><p>The var acts as a clue to say that this variable has been deliberately declared as the zero value of the indicated type. This is also consistent with the requirement to declare variables at the package level using var as opposed to the short declaration syntax—although I’ll argue later that you shouldn’t be using package level variables at all. </p><p>When declaring and initialising, use := . When declaring and initialising the variable at the same time, that is to say we’re not letting the variable be implicitly initialised to its zero value, I recommend using the short variable declaration form. This makes it clear to the reader that the variable on the left hand side of the := is being deliberately initialised. </p><p>To explain why, Let’s look at the previous example, but this time deliberately initialising each variable: </p><p>In the first and third examples, because in Go there are no automatic conversions from one type to another; the type on the left hand side of the assignment operator must be identical to the type on the right hand side. The compiler can infer the type of the variable being declared from the type on the right hand side, to the example can be written more concisely like this: </p><p>This leaves us with explicitly initialising players to 0 which is redundant because 0 is `players’ zero value. So its better to make it clear that we’re going to use the zero value by instead writing </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var players int</span><br></pre></td></tr></table></figure><p>What about the second statement? We cannot elide the type and write </p><p>var things = nil<br> Because nil does not have a type. [2] Instead we have a choice, do we want the zero value for a slice? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var players int    // 0</span><br><span class="line">var things []Thing // an empty slice of Things</span><br><span class="line">var thing Thing    // empty Thing struct</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br><span class="line">var players int = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing *Thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br><span class="line">var players = 0</span><br><span class="line">var things []Thing = nil</span><br><span class="line">var thing = new(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 9/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things []Thing</span><br></pre></td></tr></table></figure><p>or do we want to create a slice with zero elements? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var things = make([]Thing, 0)</span><br></pre></td></tr></table></figure><p>If we wanted the latter then this is not the zero value for a slice so we should make it clear to the reader that we’re making this choice by using the short declaration form: </p><p>things := make([]Thing, 0)<br> Which tells the reader that we have chosen to initialise things explicitly. </p><p>This brings us to the third declaration, </p><p>var thing = new(Thing)<br> Which is both explicitly initialising a variable and introduces the uncommon use of the new keyword which some Go </p><p>programmer dislike. If we apply our short declaration syntax recommendation then the statement becomes </p><p>thing := new(Thing)<br> Which makes it clear that thing is explicitly initialised to the result of new(Thing) –a pointer to a Thing –but still </p><p>leaves us with the unusual use of new . We could address this by using the compact literal struct initialiser form, thing := &amp;Thing{} </p><p>Which does the same as<br> means we’re explicitly initialising </p><p>, hence why some Go programmers are upset by the duplication. However this with a pointer to a Thing{} , which is the zero value for a Thing . </p><p>new(Thing) </p><p>thing </p><p>Instead we should recognise that                              is being declared as its zero value and use the address of operator to pass the address of thing to </p><p>thing </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json.Unmarshall</span><br><span class="line">var thing Thing</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 10/45 </p><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>NOTE </p><p>Of course, with any rule of thumb, there are exceptions. For example, sometimes two variables are closely related so writing </p><p>Would be odd. The declaration may be more readable like this </p><p>min, max := 0, 1000 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var min int</span><br><span class="line">max := 1000</span><br></pre></td></tr></table></figure><p>In summary:<br> When declaring a variable without initialisation, use the var syntax. </p><p>When declaring and explicitly initialising a variable, use := . Make tricky declarations obvious. </p><p>When something is complicated, it should look complicated. var length uint32 = 0x80 </p><p>Here length may be being used with a library which requires a specific numeric type and is more TIP explicit that length is being explicitly chosen to be uint32 than the short declaration form: </p><p>length := uint32(0x80) </p><p>In the first example I’m deliberately breaking my rule of using the var declaration form with an explicit initialiser. This decision to vary from my usual form is a clue to the reader that something unusual is happening. </p><p>2.6. Be a team player </p><p>I talked about a goal of software engineering to produce readable, maintainable, code. Therefore you will likely spend most of your career working on projects of which you are not the sole author. My advice in this situation is to follow the local style. </p><p>Changing styles in the middle of a file is jarring. Uniformity, even if its not your preferred approach, is more valuable for maintenance than your personal preference. My rule of thumb is; if it fits through gofmt then its usually not worth holding up a code review for. </p><p>If you want to do a renaming across a code-base, do not mix this into another change. If someone is TIP using git bisect they don’t want to wade through thousands of lines of renaming to find the code you </p><p>changed as well. </p><p>\3. Comments </p><p>Before we move on to larger items I want to spend a few minutes talking about comments. </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 11/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“Good code has lots of comments, bad code requires lots of comments. — Dave Thomas and Andrew Hunt </p><p>The Pragmatic Programmer </p><p>Comments are very important to the readability of a Go program. A comments should do one of three things: </p><p>\1. The comment should explain what the thing does.<br> \2. The comment should explain how the thing does what it does. 3. The comment should explain why the thing is why it is. </p><p>The first form is ideal for commentary on public symbols: </p><p>The second form is ideal for commentary inside a method: </p><p>The third form, the why , is unique as it does not displace the first two, but at the same time it’s not a replacement for the what, or the how. The why style of commentary exists to explain the external factors that drove the code you read on the page. Frequently those factors rarely make sense taken out of context, the comment exists to provide that context. </p><p>In this example it may not be immediately clear what the effect of setting HealthyPanicThreshold to zero percent will do. The comment is needed to clarify that the value of 0 will disable the panic threshold behaviour. </p><p>3.1. Comments on variables and constants should describe their contents not their purpose </p><p>I talked earlier that the name of a variable, or a constant, should describe its purpose. When you add a comment to a variable or constant, that comment should describe the variables contents, not the variables purpose. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const randomNumber = 6 // determined from an unbiased die</span><br></pre></td></tr></table></figure><p>In this example the comment describes why                              is assigned the value six, and where the six was derived from. The comment does not describe where                              will be used. Here are some more examples: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Open opens the named file for reading.</span><br><span class="line">// If successful, methods on the returned file can be used for reading.</span><br><span class="line">// queue all dependant actions</span><br><span class="line">var results []chan error</span><br><span class="line">for _, dep := range a.Deps &#123;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">results = append(results, execute(seen, dep))</span><br><span class="line">return &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">    // Disable HealthyPanicThreshold</span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">            Value: 0,</span><br></pre></td></tr></table></figure><p>}, } </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>12/45 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">randomNumber</span><br><span class="line">randomNumber</span><br></pre></td></tr></table></figure><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    StatusContinue           = 100 // RFC 7231, 6.2.1</span><br><span class="line">    StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2</span><br><span class="line">    StatusProcessing         = 102 // RFC 2518, 10.1</span><br><span class="line">    StatusOK                 = 200 // RFC 7231, 6.3.1</span><br></pre></td></tr></table></figure><p>In the context of HTTP the number 100 is known as StatusContinue , as defined in RFC 7231, section 6.2.1. For variables without an initial value, the comment should describe who is responsible for </p><p>// sizeCalculationDisabled indicates whether it is safe // to calculate Types’ widths and alignments. See dowidth. var sizeCalculationDisabled bool </p><p>TIP </p><p>initialising this variable. </p><p>Here the comment lets the reader know that the dowidth function is responsible for maintaining the state of sizeCalculationDisabled . </p><p>Hiding in plain sight </p><p>This is a tip from Kate Gregory. [3] Sometimes you’ll find a better name for a variable hiding in a comment. </p><p>The comment was added by the author because registry doesn’t explain enough about its purpose —it’s a registry, but a registry of what? </p><p>By renaming the variable to sqlDrivers its now clear that the purpose of this variable is to hold SQL drivers. </p><p>var sqlDrivers = make(map[string]*sql.Driver) </p><p>Now the comment is redundant and can be removed. </p><p>// registry of SQL drivers<br> var registry = make(map[string]*sql.Driver) </p><p>TIP </p><p>3.2. Always document public symbols </p><p>Because godoc is the documentation for your package, you should always add a comment for every public symbol— variable, constant, function, and method—declared in your package. </p><p>Here are two rules from the Google Style guide </p><p>Any public function that is not both obvious and short must be commented.<br> Any function in a library must be commented regardless of length or complexity </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 13/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package ioutil</span><br><span class="line">// ReadAll reads from r until an error or EOF and returns the data it read.</span><br><span class="line">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><br><span class="line">// defined to read from src until EOF, it does not treat an EOF from Read</span><br><span class="line">// as an error to be reported.</span><br><span class="line">func ReadAll(r io.Reader) ([]byte, error)</span><br></pre></td></tr></table></figure><p>There is one exception to this rule; you don’t need to document methods that implement an interface. Specifically don’t do this: </p><p>This comment says nothing. It doesn’t tell you what the method does, in fact it’s worse, it tells you to go look somewhere else for the documentation. In this situation I suggest removing the comment entirely. </p><p>Here is an example from the io package </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Read implements the io.Reader interface</span><br><span class="line">func (r *FileReader) Read(buf []byte) (int, error)</span><br><span class="line">// LimitReader returns a Reader that reads from r</span><br><span class="line">// but stops with EOF after n bytes.</span><br><span class="line">// The underlying implementation is a *LimitedReader.</span><br><span class="line">func LimitReader(r Reader, n int64) Reader &#123; return &amp;LimitedReader&#123;r, n&#125; &#125;</span><br><span class="line">// A LimitedReader reads from R but limits the amount of</span><br><span class="line">// data returned to just N bytes. Each call to Read</span><br><span class="line">// updates N to reflect the new amount remaining.</span><br><span class="line">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span><br><span class="line">type LimitedReader struct &#123;</span><br><span class="line">    R Reader // underlying reader</span><br><span class="line">    N int64  // max bytes remaining</span><br><span class="line">&#125;</span><br><span class="line">func (l *LimitedReader) Read(p []byte) (n int, err error) &#123;</span><br><span class="line">    if l.N &lt;= 0 &#123;</span><br><span class="line">        return 0, EOF</span><br><span class="line">    &#125;</span><br><span class="line">    if int64(len(p)) &gt; l.N &#123;</span><br><span class="line">        p = p[0:l.N]</span><br><span class="line">    &#125;</span><br><span class="line">    n, err = l.R.Read(p)</span><br><span class="line">    l.N -= int64(n)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure><p>} </p><p>Note that the                              declaration is directly preceded by the function that uses it, and the declaration of follows the declaration of LimitedReader itself. Even though LimitedReader.Read has no </p><p>documentation itself, its clear from that it is an implementation of io.Reader . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LimitedReader</span><br><span class="line">LimitedReader.Read</span><br></pre></td></tr></table></figure><p>TIP </p><p>Before you write the function, write the comment describing the function. If you find it hard to write the comment, then it’s a sign that the code you’re about to write is going to be hard to understand. </p><p>3.2.1. Don’t comment bad code, rewrite it </p><p>“<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 14/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“ Don’t comment bad code — rewrite it — Brian Kernighan </p><p>Comments highlighting the grossness of a particular piece of code are not sufficient. If you encounter one of these comments, you should raise an issue as a reminder to refactor it later. It is okay to live with technical debt, as long as the amount of debt is known. </p><p>The tradition in the standard library is to annotate a TODO style comment with the username of the person who noticed it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// TODO(dfc) this is O(N^2), find a faster way to do this.</span><br></pre></td></tr></table></figure><p>The username is not a promise that that person has committed to fixing the issue, but they may be the best person to ask when the time comes to address it. Other projects annotate TODOs with a date or an issue number. </p><p>“3.2.2. Rather than commenting a block of code, refactor it </p><p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer. </p><p>— Steve McConnell </p><p>Functions should do one thing only. If you find yourself commenting a piece of code because it is unrelated to the rest of the function, consider extracting it into a function of its own. </p><p>In addition to be easier to comprehend, smaller functions are easier to test in isolation, and now you’ve isolated the orthogonal code into its own function, its name may be all the documentation required. </p><p>“4. Package Design<br> Write shy code - modules that don’t reveal anything unnecessary to other modules and that </p><p>don’t rely on other modules’ implementations. </p><p>— Dave Thomas </p><p>Each Go package is in effect it’s own small Go program. Just as the implementation of a function or method is unimportant to the caller, the implementation of the functions and methods and types that make your package’s public API—its behaviour—is unimportant for the caller. </p><p>A good Go package should strive to have a low degree of source level coupling such that, as the project grows, changes to one package do not cascade across the code-base. These stop-the-world refactorings place a hard limit on the rate of change in a code base and thus the productivity of the members working in that code-base. </p><p>In this section we’ll talk about designing a package including the package’s name, naming types, and tips for writing methods and functions. </p><p>4.1. A good package starts with its name </p><p>Writing a good Go package starts with the package’s name. Think of your package’s name as an elevator pitch to describe what it does using just one word. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>15/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Just as I talked about names for variables in the previous section, the name of a package is very important. The rule of thumb I follow is not, “what types should I put in this package?”. Instead the question I ask “what does service does package provide?” Normally the answer to that question is not “this package provides the X type”, but “this package let’s you speak HTTP”. </p><p>TIP Name your package after what is provides, not what it contains. 4.1.1. Good package names should be unique. </p><p>Within your project, each package name should be unique. This advice is pretty easy to follow if the advice that a package’s name should derive from its purpose—if you find you have two packages which need the same name, it is likely either; </p><p>a. The name of the package is too generic. </p><p>b. The package overlaps another package of a similar name. In this case either you should review your design, or consider merging the packages. </p><p>4.2. Avoid package names like base , common , or util </p><p>A common cause of poor package names is what call utility packages. These are packages where common helpers and utility code congeals over time. As these packages contain an assortment of unrelated functions, their utility is hard to describe in terms of what the package provides. This often leads to the package’s name being derived from what the package contains–utilities. </p><p>Package names like utils or helpers are commonly found in larger projects which have developed deep package hierarchies and want to share helper functions without encountering import loops. By extracting utility functions to new package the import loop is broken, but because the package stems from a design problem in the project, its name doesn’t reflect its purpose, only its function of breaking the import cycle. </p><p>My recommendation to improve the name of utils or helpers packages is to analyse where they are called and if possible move the relevant functions into their caller’s package. Even if this involves duplicating some helper code this is better than introducing an import dependency between two packages. </p><p>“[A little] duplication is far cheaper than the wrong abstraction. — Sandy Metz </p><p>In the case where utility functions are used in many places prefer multiple packages, each focused on a single aspect, to a single monolithic package. </p><p>TIP Use plurals for naming utility packages. For example the strings for string handling utilities. </p><p>Packages with names like base or common are often found when functionality common to two or more implementations, or common types for a client and server, has been refactored into a separate package. I believe the solution to this is to reduce the number of packages, to combine the client, server, and common code into a single package named after the function of the package. </p><p>For example, the net/http package does not have client and                              sub packages, instead it has a client.go and server.go file, each holding their respective types, and a                              file for the common message transport code. </p><p>server </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>16/45 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport.go</span><br></pre></td></tr></table></figure><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP </p><p>An identifier’s name includes its package name. </p><p>It’s important to remember that the name of an identifier includes the name of its package. </p><p>The Get function from the net/http package becomes http.Get when referenced by another package. </p><p>The Reader type from the strings package becomes strings.Reader when imported into other packages. </p><p>The Error interface from the net package is clearly related to network errors. 4.3. Return early rather than nesting deeply </p><p>As Go does not use exceptions for control flow there is no requirement to deeply indent your code just to provide a top level structure for the try and catch blocks. Rather than the successful path nesting deeper and deeper to the right, Go code is written in a style where the success path continues down the screen as the function progresses. My friend Mat Ryer calls this practice ‘line of sight’ coding. [4] </p><p>This is achieved by using guard clauses; conditional blocks with assert preconditions upon entering a function. Here is an example from the bytes package, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &lt;= opInvalid &#123;</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">        b.off -= int(b.lastRead)</span><br><span class="line">    &#125;</span><br><span class="line">    b.lastRead = opInvalid</span><br></pre></td></tr></table></figure><p>return nil } </p><p>Upon entering UnreadRune the state of b.lastRead is checked and if the previous operation was not an error is returned immediately. From there the rest of the function proceeds with the assertion that is greater that opInvalid . </p><p>Compare this to the same function written without a guard clause, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (b *Buffer) UnreadRune() error &#123;</span><br><span class="line">    if b.lastRead &gt; opInvalid &#123;</span><br><span class="line">        if b.off &gt;= int(b.lastRead) &#123;</span><br><span class="line">            b.off -= int(b.lastRead)</span><br><span class="line">        &#125;</span><br><span class="line">        b.lastRead = opInvalid</span><br><span class="line">        return nil</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return errors.New(&quot;bytes.Buffer: UnreadRune: previous operation was not a successful</span><br><span class="line">ReadRune&quot;)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>The body of the successful case, the most common, is nested inside the first if condition and the successful exit condition, return nil , has to be discovered by careful matching of closing braces. The final line of the function now returns an error, and the called must trace the execution of the function back to the matching opening brace to know </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 17/45 </p><p>ReadRune </p><p>b.lastRead </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>when control will reach this point. </p><p>This is more error prone for the reader, and the maintenance programmer, hence why Go prefer to use guard clauses and returning early on errors. </p><p>4.4. Make the zero value useful </p><p>Every variable declaration, assuming no explicit initialiser is provided, will be automatically initialised to a value that matches the contents of zeroed memory. This is the values zero value. The type of the value determines its zero value; for numeric types it is zero, for pointer types nil, the same for slices, maps, and channels. </p><p>This property of always setting a value to a known default is important for safety and correctness of your program and can make your Go programs simpler and more compact. This is what Go programmers talk about when they say “give your structs a useful zero value”. </p><p>Consider the sync.Mutex type. sync.Mutex contains two unexported integer fields, representing the mutex’s internal state. Thanks to the zero value those fields will be set to will be set to 0 whenever a sync.Mutex is declared. </p><p>sync.Mutex has been deliberately coded to take advantage of this property, making the type usable without explicit initialisation. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type MyInt struct &#123;</span><br><span class="line">    mu  sync.Mutex</span><br></pre></td></tr></table></figure><p>val int } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var i MyInt</span><br><span class="line">    // i.mu is usable without explicit initialisation.</span><br><span class="line">    i.mu.Lock()</span><br><span class="line">    i.val++</span><br><span class="line">    i.mu.Unlock()</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>Another example of a type with a useful zero value is bytes.Buffer . You can declare a bytes.Buffer and start writing to it without explicit initialisation. </p><p>A useful property of slices is their zero value is nil . This makes sense if we look at the runtime’s definition of a slice header. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    b.WriteString(&quot;Hello, world!\n&quot;)</span><br><span class="line">    io.Copy(os.Stdout, &amp;b)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">        array *[...]T // pointer to the underlying array</span><br><span class="line">        len   int</span><br><span class="line">        cap   int</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 18/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The zero value of this struct would imply len and cap have the value 0 , and array , the pointer to memory holding the contents of the slice’s backing array, would be nil . This means you don’t need to explicitly make a slice, you can just declare it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // s := make([]string, 0)</span><br><span class="line">    // s := []string&#123;&#125;</span><br><span class="line">    var s []string</span><br><span class="line">    s = append(s, &quot;Hello&quot;)</span><br><span class="line">    s = append(s, &quot;world&quot;)</span><br><span class="line">    fmt.Println(strings.Join(s, &quot; &quot;))</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>var s []string is similar to the two commented lines above it, but not identical. It is possible to detect the difference between a slice value that is nil and a slice value that has zero length. The following code will output false. </p><p>NOTE </p><p>A surprising, but useful, property of uninitialised pointer variables—nil pointers—is you can call methods on types that have a nil value. This can be used to provide default values simply. </p><p>func main() {<br> var s1 = []string{}<br> var s2 []string fmt.Println(reflect.DeepEqual(s1, s2)) </p><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    path string</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *Config) Path() string &#123;</span><br><span class="line">    if c == nil &#123;</span><br><span class="line">        return &quot;/usr/home&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return c.path</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var c1 *Config</span><br><span class="line">    var c2 = &amp;Config&#123;</span><br><span class="line">        path: &quot;/export&quot;,</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>4.5. Avoid package level state </p><p>The key to writing maintainable programs is that they should be loosely coupled—a change to one package should have a low probability of affecting another package that does not directly depend on the first. </p><p>There are two excellent ways to achieve loose coupling in Go </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>19/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>\1. Use interfaces to describe the behaviour your functions or methods require. 2. Avoid the use of global state. </p><p>In Go we can declare variables at the function or method scope, and also at the package scope. When the variable is public, given a identifier starting with a capital letter, then its scope is effectively global to the entire program—any package may observe the type and contents of that variable at any time. </p><p>Mutable global state introduces tight coupling between independent parts of your program as global variables become an invisible parameter to every function in your program! Any function that relies on a global variable can be broken if that variable’s type changes. Any function that relies on the state of a global variable can be broken if another part of the program changes that variable. </p><p>If you want to reduce the coupling a global variable creates, </p><p>\1. Move the relevant variables as fields on structs that need them.<br> \2. Use interfaces to reduce the coupling between the behaviour and the implementation of that behaviour. </p><p>\5. Project Structure </p><p>Let’s talk about combining packages together into a project. Commonly this will be a single git repository, but in the future Go developers will use module and project interchangeably. </p><p>Just like a package, each project should have a clear purpose. If your project is a library, it should provide one thing, say XML parsing, or logging. You should avoid combining multiple purposes into a single package, this will help avoid the dreaded common library. </p><p>In my experience, the common repo ends up tightly coupled to its biggest consumer and that makes TIP it hard to back-port fixes without upgrading both common and consumer in lock step, bringing in a </p><p>lot of unrelated changes and API breakage along the way. </p><p>If your project is an application, like your web application, Kubernetes controller, and so on, then you might have one or more                              packages inside your project. For example, the Kubernetes controller I work on has a single </p><p>package which serves as both the server deployed to a Kubernetes cluster, and a client for debugging </p><p>purposes. </p><p>5.1. Consider fewer, larger packages </p><p>One of the things I tend to pick up in code review for programmers who are transitioning from other languages to Go is they tend to overuse packages. </p><p>Go does not provide elaborate ways of establishing visibility; thing Java’s public , protected , private , and implicit default access modifiers. There is no equivalent of C++’s notion of friend classes. </p><p>In Go we have only two access modifiers, public and private, indicated by the capitalisation of the first letter of the identifier. If an identifier is public, it’s name starts with a capital letter, that identifier can be referenced by any other Go package. </p><p>NOTE You may hear people say exported and not exported as synonyms for public and private.<br> Given the limited controls available to control access to a package’s symbols, what practices should Go programmers </p><p>follow to avoid creating over-complicated package hierarchies? </p><p>main </p><p>cmd/contour </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 20/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP Every package, with the exception of cmd/ and internal/ , should contain some source code. </p><p>The advice I find myself repeating is to prefer fewer, larger packages. Your default position should be to not create a new package. That will lead to too many types being made public creating a wide, shallow, API surface for your package.. </p><p>The sections below explores this suggestion in more detail. </p><p>TIP </p><p>Coming from Java? </p><p>If you’re coming from a Java or C# background, consider this rule of thumb. - A Java package is equivalent to a single .go source file. - A Go package is equivalent to a whole Maven module or .NET assembly. </p><p>5.1.1. Arrange code into les by import statements </p><p>If you’re arranging your packages by what they provide to callers, should you do the same for files within a Go package? How do you know when you should break up a .go file into multiple ones? How do you know when you’ve gone to far and should consider consolidating .go file? </p><p>Here are the rules of thumb I use:<br> Start each package with one file. Give that file the same name as the name of the folder. eg. package http </p><p>should be placed in a file called in a directory named http . </p><p>As your package grows you may decide to split apart the various responsibilities into different files. eg,<br> contains the `Request and Response types, client.go contains the Client type, server.go </p><p>contains the type. </p><p>If you find your files have similar import declarations, consider combining them. Alternatively, identify the differences between the import sets and move those </p><p>Different files should be responsible for different areas of the package.                              may be responsible for marshalling of HTTP requests and responses on and off the network,                              may contain the low level network handling logic, client.go and server.go implement the HTTP business logic of request construction or routing, and so on. </p><p>TIP Prefer nouns for source file names. </p><p>The Go compiler compiles each package in parallel. Within a package the compiler compiles each NOTE function (methods are just fancy functions in Go) in parallel. Changing the layout of your code within </p><p>a package does not affect compilation time. </p><p>5.1.2. Prefer internal tests to external tests </p><p>The go tool supports writing your testing package tests in two places. Assuming your package is called http2 , you can write a file and use the declaration. Doing so will compile the code in </p><p>as if it were part of the package. This is known colloquially as an internal test. </p><p>The go tool also supports a special package declaration, ending in test , ie., package http_test . This allows your test files to live alongside your code in the same package, however when those tests are compiled they are not part of your package’s code, they live in their own package. This allows you to write your tests as if you were another package calling into your code. This is known as an _external test. </p><p>.go </p><p>http.go </p><p>messages.go </p><p>Server </p><p>messages.go </p><p>http.go </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure><p>package http2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http2_test.go</span><br></pre></td></tr></table></figure><p>http2 </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 21/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>I recommend using internal tests when writing unit tests for your package. This allows you to test each function or method directly, avoiding the bureaucracy of external testing. </p><p>However, you should place your Example test functions in an external test file. This ensures that when viewed in godoc, the examples have the appropriate package prefix and can be easily copy pasted. </p><p>TIP </p><p>Avoid elaborate package hierarchies, resist the desire to apply taxonomy </p><p>With one exception, which we’ll talk about next, the hierarchy of Go packages has no meaning to the go tool. For example, the net/http package is not a child or sub-package of the net package. </p><p>If you find you have created intermediate directories in your project which contain no .go files, you may have failed to follow this advice. </p><p>5.1.3. Use internal packages to reduce your public API surface </p><p>If your project contains multiple packages you may have some exported functions which are intended to be used by other packages in your project, but are not intended to be part of your project’s public API. If you find yourself in this situation the go tool recognises a special folder name—not package name–, internal/ which can be used to place code which is public to your project, but private to other projects. </p><p>To create such a package, place it in a directory named internal/ or in a sub-directory of a directory named internal/ . When the go command sees an import of a package with                              in its path, it verifies that the </p><p>package doing the import is within the tree rooted at the parent of the                              directory.<br> For example, a package can be imported only by code in the directory tree rooted at … </p><p>/a/b/c . It cannot be imported by code in                              or in any other repository. [5] 5.2. Keep package main small as small as possible </p><p>Your main function, and                              package should do as little as possible. This is because main.main acts as a singleton; there can only be one                              function in a program, including tests. </p><p>Because main.main is a singleton there are a lot of assumptions built into the things that main.main will call that they will only be called during main.main or main.init, and only called once. This makes it hard to write tests for code written in main.main , thus you should aim to move as much of your business logic out of your main function and ideally out of your main package. </p><p>TIP </p><p>main should parse flags, open connections to databases, loggers, and such, then hand off execution to a high level object. </p><p>\6. API Design </p><p>The last piece of design advice I’m going to give today I feel is the most important. </p><p>All of the suggestions I’ve made so far are just that, suggestions. These are the way I try to write my Go, but I’m not going to push them hard in code review. </p><p>However when it comes to reviewing APIs during code review, I am less forgiving. This is because everything I’ve talked about so far can be fixed without breaking backward compatibility; they are, for the most part, implementation details. </p><p>When it comes to the public API of a package, it pays to put considerable thought into the initial design, because changing that design later is going to be disruptive for people who are already using your API. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 22/45 </p><p>internal </p><p>main </p><p>…/a/b/g </p><p>internal </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.../a/b/c/internal/d/e/f</span><br></pre></td></tr></table></figure><p>main </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>“6.1. Design APIs that are hard to misuse.<br> APIs should be easy to use and hard to misuse. </p><p>— Josh Bloch [3] </p><p>If you take anything away from this presentation, it should be this advice from Josh Bloch. If an API is hard to use for simple things, then every invocation of the API will look complicated. When the actual invocation of the API is complicated it will be less obvious and more likely to be overlooked. </p><p>6.1.1. Be wary of functions which take several parameters of the same type </p><p>A good example of a simple looking, but hard to use correctly API is one which takes two or more parameters of the same type. Let’s compare two function signatures: </p><p>What’s the difference between these two functions? Obviously one returns the maximum of two numbers, the other copies a file, but that’s not the important thing. </p><p>Max is commutative; the order of the parameters does not matter. The maximum of eight and ten is ten regardless of if I compare eight to ten or ten two eight. </p><p>However, this property does not hold true for CopyFile . </p><p>Which one of these statements made a backup of your presentation and which one overwrite your presentation with last week’s version? You can’t tell without consulting the documentation. A code reviewer cannot know if you’ve got the order correct without consulting the documentation. </p><p>One possible solution to this is to introduce a helper type which will be responsible for calling CopyFile correctly. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func Max(a, b int) int</span><br><span class="line">func CopyFile(to, from string) error</span><br><span class="line">Max(8, 10) // 10</span><br><span class="line">Max(10, 8) // 10</span><br><span class="line">CopyFile(&quot;/tmp/backup&quot;, &quot;presentation.md&quot;)</span><br><span class="line">CopyFile(&quot;presentation.md&quot;, &quot;/tmp/backup&quot;)</span><br><span class="line">type Source string</span><br><span class="line">func (src Source) CopyTo(dest string) error &#123;</span><br><span class="line">    return CopyFile(dest, string(src))</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var from Source = &quot;presentation.md&quot;</span><br><span class="line">    from.CopyTo(&quot;/tmp/backup&quot;)</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><p>In this way CopyFile is always called correctly—this can be asserted with a unit test—and can possibly be made private, further reducing the likelihood of misuse. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 23/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>TIP APIs with multiple parameters of the same type are hard to use correctly. 6.2. Design APIs for their default use case </p><p>A few years ago I gave a talk [6] about using functional options [7] to make APIs easier to use for their default case. </p><p>The gist of this talk was you should design your APIs for the common use case. Sad another way, your API should not require the caller to provide parameters which they don’t care about. </p><p>6.2.1. Discourage the use of nil as a parameter </p><p>I opened this chapter with the suggestion that you shouldn’t force the caller of your API into providing you parameters when they don’t really care what those parameters mean. This is what I mean when I say design APIs for their default use case. </p><p>Here’s an example from the net/http package </p><p>package http </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ListenAndServe listens on the TCP network address addr and then calls</span><br><span class="line">// Serve with handler to handle requests on incoming connections.</span><br><span class="line">// Accepted connections are configured to enable TCP keep-alives.</span><br><span class="line">//</span><br><span class="line">// The handler is typically nil, in which case the DefaultServeMux is used.</span><br><span class="line">//</span><br><span class="line">// ListenAndServe always returns a non-nil error.</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br></pre></td></tr></table></figure><p>ListenAndServe takes two parameters, a TCP address to listen for incoming connections, and http.Handler to handle the incoming HTTP request. Serve allows the second parameter to be nil , and notes that usually the caller will pass nil indicating that they want to use http.DefaultServeMux as the implicit parameter. </p><p>Now the caller of Serve has two ways to do the same thing. </p><p>Both do exactly the same thing. </p><p>This                              behaviour is viral. The http package also has a http.Serve helper, which you can reasonably imagine that builds upon like this </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>nil </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br><span class="line">func ListenAndServe(addr string, handler Handler) error &#123;</span><br><span class="line">    l, err := net.Listen(&quot;tcp&quot;, addr)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    defer l.Close()</span><br><span class="line">    return Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 24/45 </p><p>http.Serve </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListenAndServe</span><br></pre></td></tr></table></figure><p>nil<br> handler </p><p>DefaultServeMux`” logic. </p><p>http.Serve </p><p>Accepting `nil </p><p>nil </p><p>Serve </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.Serve(nil, nil)</span><br><span class="line">          http.ListenAndServe</span><br><span class="line">DefaultServeMux</span><br></pre></td></tr></table></figure><p>nil </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const root = http.Dir(&quot;/htdocs&quot;)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(&quot;/&quot;, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br></pre></td></tr></table></figure><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ShutdownVMs(ids []string) error</span><br></pre></td></tr></table></figure><p>2018/10/21 </p><p>Practical Go: Real world advice for writing maintainable Go programs </p><p>Because behaviour. In fact, </p><p>permits the caller to pass for the second parameter, also supports this is the one that implements the “if is nil , use </p><p>for one parameter may lead the caller into thinking they can pass for both parameters. However calling like this, </p><p>results in an ugly panic.<br> TIP Don’t mix nil and non nil-able parameters in the same function signature. </p><p>The author of was trying to make the API user’s life easier in the common case, but possibly made the package harder to use safely. </p><p>There is no difference in line count between using explicitly, or implicitly via . </p><p>verses </p><p>and a was this confusion really worth saving one line? </p><p>TIP </p><p>Give serious consideration to how much time helper functions will save the programmer. Clear is better than concise. </p><p>Avoid public APIs with test only parameters </p><p>TIP Avoid exposing APIs with values who only differ in test scope. Instead, use Public wrappers to hide those parameters, use test scoped helpers to set the property in test scope. </p><p>6.2.2. Prefer var args to []T parameters </p><p>It’s very common to write a function or method that takes a slice of values. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> </p><p>25/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This is just an example I made up, but its common to a lot of code I’ve worked on. The problem with signatures like these is they presume that they will be called with more than one entry. However, what I have found is many times these type of functions are called with only one argument, which has to be “boxed” inside a slice just to meet the requirements of the functions signature. </p><p>Additionally, because the ids parameter is a slice, you can pass an empty slice or nil to the function and the compiler will be happy. This adds extra testing load because you should cover these cases in your testing. </p><p>To give an example of this class of API, recently I was refactoring a piece of logic that required me to set some extra fields if at least one of a set of parameters was non zero. The logic looked like this: </p><p>As the if statement was getting very long I wanted to pull the logic of the check out into its own function. This is what I came up with: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if svc.MaxConnections &gt; 0 || svc.MaxPendingRequests &gt; 0 || svc.MaxRequests &gt; 0 ||</span><br><span class="line">svc.MaxRetries &gt; 0 &#123;</span><br><span class="line">    // apply the non zero parameters</span><br><span class="line">&#125;</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(values ...int) bool &#123;</span><br><span class="line">    for _, v := range values &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br></pre></td></tr></table></figure><p>return true } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>This enabled me to make the condition where the inner block will be executed clear to the reader: </p><p>However there is a problem with anyPositive , someone could accidentally invoke it like this if anyPositive() { … } </p><p>In this case anyPositive would return false because it would execute zero iterations and immediately return false . This isn’t the worst thing in the world — that would be if anyPositive returned true when passed no </p><p>arguments. </p><p>Nevertheless it would be be better if we could change the signature of anyPositive to enforce that the caller should pass at least one argument. We can do that by combining normal and vararg parameters like this: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        // apply the non zero parameters</span><br></pre></td></tr></table></figure><p>} </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 26/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now anyPositive cannot be called with less than one argument. 6.3. Let functions dene the behaviour they requires </p><p>Let’s say I’ve been given a task to write a function that persists a Document structure to disk. </p><p>I could specify this function, Save, which takes an *os.File as the destination to write the Document . But this has a few problems </p><p>The signature of Save precludes the option to write the data to a network location. Assuming that network storage is likely to become requirement later, the signature of this function would have to change, impacting all its callers. </p><p>Save is also unpleasant to test, because it operates directly with files on disk. So, to verify its operation, the test would have to read the contents of the file after being written. </p><p>And I would have to ensure that f was written to a temporary location and always removed afterwards. </p><p><em>os.File also defines a lot of methods which are not relevant to , like reading directories and checking to see if a path is a symlink. It would be useful if the signature of the function could describe only the parts of </em>os.File that were relevant. </p><p>What can we do ? </p><p>Using io.ReadWriteCloser we can apply the interface segregation principle to redefine Save to take an interface that describes more general file shaped things. </p><p>With this change, any type that implements the io.ReadWriteCloser interface can be substituted for the previous *os.File . </p><p>This makes Save both broader in its application, and clarifies to the caller of Save which methods of the *os.File type are relevant to its operation. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the file f.</span><br><span class="line">func Save(f *os.File, doc *Document) error</span><br></pre></td></tr></table></figure><p>Save </p><p>Save </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// ReadWriterCloser.</span><br><span class="line">func Save(rwc io.ReadWriteCloser, doc *Document) error</span><br><span class="line">// anyPostive indicates if any value is greater than zero.</span><br><span class="line">func anyPositive(first int, rest ...int) bool &#123;</span><br><span class="line">    if first &gt; 0 &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    for _, v := range rest &#123;</span><br><span class="line">        if v &gt; 0 &#123;</span><br><span class="line">            return true</span><br></pre></td></tr></table></figure><p>} } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 27/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>And as the author of I no longer have the option to call those unrelated methods on as it is hidden behind the interface. </p><p>But we can take the interface segregation principle a bit further. </p><p>Firstly, it is unlikely that if Save follows the single responsibility principle, it will read the file it just wrote to verify its contents—that should be responsibility of another piece of code. </p><p>So we can narrow the specification for the interface we pass to Save to just writing and closing.<br> Secondly, by providing Save with a mechanism to close its stream, which we inherited in this desire to make it still </p><p>look like a file, this raises the question of under what circumstances will wc be closed.<br> Possibly Save will call Close unconditionally, or perhaps Close will be called in the case of success. </p><p>This presents a problem for the caller of Save as it may want to write additional data to the stream after the document is written. </p><p>A better solution would be to redefine Save to take only an io.Writer , stripping it completely of the responsibility to do anything but write data to a stream. </p><p>By applying the interface segregation principle to our Save function, the results has simultaneously been a function which is the most specific in terms of its requirements—it only needs a thing that is writable—and the most general in its function, we can now use Save to save our data to anything which implements io.Writer. </p><p>\7. Error handling </p><p>I’ve given several presentations about error handling [8] and written a lot about error handling on my blog. I also spoke a lot about error handling in yesterday’s session so I won’t repeat what I’ve said. </p><p><a href="https://dave.cheney.net/2014/12/24/inspecting-errors" target="_blank" rel="noopener">https://dave.cheney.net/2014/12/24/inspecting-errors</a> <a href="https://dave.cheney.net/2016/04/07/constant-errors" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/07/constant-errors</a> </p><p>Instead I want to cover two other areas related to error handling. </p><p>7.1. Eliminate error handling by eliminating errors </p><p>If you were in my presentation yesterday I talked about the draft proposals for improving error handling. But do you know what is better than an improved syntax for handling errors? Not needing to handle errors at all. </p><p>Save </p><p>*os.File </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// WriteCloser.</span><br><span class="line">func Save(wc io.WriteCloser, doc *Document) error</span><br><span class="line">// Save writes the contents of doc to the supplied</span><br><span class="line">// Writer.</span><br><span class="line">func Save(w io.Writer, doc *Document) error</span><br></pre></td></tr></table></figure><p>NOTE </p><p>I’m not saying “remove your error handling”. What I am suggesting is, change your code so you do not have errors to handle. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.ReadWriteCloser</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 28/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This section draws inspiration from John Ousterhout’s recently book, A philosophy of Software Design [9]. One of the chapters in that book is called “Define Errors Out of Existence”. We’re going to try to apply this advice to Go. </p><p>7.1.1. Counting lines </p><p>Let’s write a function to count the number of lines in a file. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    var (</span><br><span class="line">        br    = bufio.NewReader(r)</span><br><span class="line">        lines int</span><br><span class="line">        err   error</span><br></pre></td></tr></table></figure><p>) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    _, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">    lines++</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>break } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if err != io.EOF &#123;</span><br><span class="line">    return 0, err</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>Because we’re following our advice from previous sections, CountLines takes an io.Reader, not a *File; its the job of the caller to provide the io.Reader who’s contents we want to count. </p><p>We construct a bufio.Reader , and then sit in a loop calling the ReadString method, incrementing a counter until we reach the end of the file, then we return the number of lines read. </p><p>At least that’s the code we want to write, but instead this function is made more complicated by error handling. For example, there is this strange construction, </p><p>We increment the count of lines before checking the error—that looks odd.<br> The reason we have to write it this way is ReadString will return an error if it encounters and end-of-file before </p><p>hitting a newline character. This can happen if there is no final newline in the file.<br> To try to fix this, we rearrange the logic to increment the line count, then see if we need to exit the loop. </p><p>NOTE this logic still isn’t perfect, can you spot the bug? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">lines++</span><br><span class="line">if err != nil &#123;</span><br></pre></td></tr></table></figure><p>break } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 29/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>But we’re not done checking errors yet. will return when it hits the end of the file. This is expected,                                  needs some way of saying stop, there is nothing more to read. So before we return the error to the caller of                                  , we need to check if the error was not io.EOF , and in that case propagate it up, otherwise we return nil to say that everything worked fine. </p><p>I think this is a good example of Russ Cox’s observation that error handling can obscure the operation of the function. Let’s look at an improved version. </p><p>ReadString </p><p>io.EOF </p><p>ReadString </p><p>CountLine </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">    sc := bufio.NewScanner(r)</span><br><span class="line">    lines := 0</span><br><span class="line">    for sc.Scan() &#123;</span><br><span class="line">        lines++</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>This improved version switches from using bufio.Reader to bufio.Scanner . </p><p>Under the hood bufio.Scanner uses , but it adds a nice layer of abstraction which helps remove the error handling with obscured the operation of                                  . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Reader</span><br></pre></td></tr></table></figure><p>CountLines </p><p>NOTE </p><p>The method, the body of our </p><p>bufio.Scanner can scan for any pattern, but by default it looks for newlines. </p><p>returns true if the scanner has matched a line of text and has not encountered an error. So, loop will be called only when there is a line of text in the scanner’s buffer. This means our revised </p><p>sc.Scan() </p><p>for </p><p>CountLines correctly handles the case where there is no trailing newline, and also handles the case where the file was empty. </p><p>Secondly, as sc.Scan returns false once an error is encountered, our for loop will exit when the end-of-file is reached or an error is encountered. The type memoises the first error it encountered and we can recover that error once we’ve exited the loop using the method. </p><p>Lastly, sc.Err() takes care of handling io.EOF and will convert it to a nil if the end of file was reached without encountering another error. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufio.Scanner</span><br></pre></td></tr></table></figure><p>sc.Err() </p><p>TIP </p><p>When you find yourself faced with overbearing error handling, try to extract some of the operations into a helper type. </p><p>7.1.2. WriteResponse </p><p>My second example is inspired from the Errors are values blog post [10]. </p><p>Earlier in this presentation We’ve seen examples dealing with opening, writing and closing files. The error handling is present, but not overwhelming as the operations can be encapsulated in helpers like ioutil.ReadFile and </p><p>ioutil.WriteFile . However when dealing with low level network protocols it becomes necessary to build the response directly using I/O primitives the error handling can become repetitive. Consider this fragment of a HTTP server which is constructing the HTTP response. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 30/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>First we construct the status line using fmt.Fprintf , and check the error. Then for each header we write the header key and value, checking the error each time. Lastly we terminate the header section with an additional \r\n , check the error, and copy the response body to the client. Finally, although we don’t need to check the error from io.Copy , we need to translate it from the two return value form that io.Copy returns into the single return value that </p><p>WriteResponse returns.<br> That’s a lot of repetitive work. But we can make it easier on ourselves by introducing a small wrapper type, </p><p>errWriter . </p><p>errWriter fulfils the io.Writer contract so it can be used to wrap an existing io.Writer . errWriter passes writes through to its underlying writer until an error is detected. From that point on, it discards any writes and returns the previous error. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Header struct &#123;</span><br><span class="line">    Key, Value string</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status struct &#123;</span><br><span class="line">    Code   int</span><br><span class="line">    Reason string</span><br><span class="line">&#125;</span><br><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, h := range headers &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br><span class="line">    if err != nil &#123;</span><br></pre></td></tr></table></figure><p>return err } </p><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if _, err := fmt.Fprint(w, &quot;\r\n&quot;); err != nil &#123;</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(w, body)</span><br></pre></td></tr></table></figure><p>return err } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 31/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Applying errWriter to WriteResponse dramatically improves the clarity of the code. Each of the operations no longer needs to bracket itself with an error check. Reporting the error is moved to the end of the function by inspecting the ew.err field, avoiding the annoying translation from `io.Copy’s return values. </p><p>7.2. Only handle an error once </p><p>Lastly, I want to mention that you should only handle errors once. Handling an error means inspecting the error value, and making a single decision. </p><p>If you make less than one decision, you’re ignoring the error. As we see here, the error from w.WriteAll is being discarded. </p><p>But making more than one decision in response to a single error is also problematic. The following is code that I come across frequently. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// WriteAll writes the contents of buf to the supplied writer.</span><br><span class="line">func WriteAll(w io.Writer, buf []byte) &#123;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.Write(buf)</span><br><span class="line">type errWriter struct &#123;</span><br><span class="line">    io.Writer</span><br></pre></td></tr></table></figure><p>err error } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (e *errWriter) Write(buf []byte) (int, error) &#123;</span><br><span class="line">    if e.err != nil &#123;</span><br><span class="line">        return 0, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    var n int</span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    return n, nil</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">    for _, h := range headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Fprint(ew, &quot;\r\n&quot;)</span><br><span class="line">io.Copy(ew, body)</span><br><span class="line">return ew.err</span><br></pre></td></tr></table></figure><p>} </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Println(&quot;unable to write:&quot;, err) // annotated error goes to log file</span><br><span class="line">        return err                           // unannotated error returned to caller</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>return nil } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 32/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>In this example if an error occurs during , a line will be written to a log file, noting the file and line that the error occurred, and the error is also returned to the caller, who possibly will log it, and return it, all the way back up to the top of the program. </p><p>The caller is probably doing the same </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br></pre></td></tr></table></figure><p>return err } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">    log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">    return err</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><p>GO </p><p>So you get a stack of duplicate lines in your log file, </p><p>but at the top of the program you get the original error without any context. </p><p>I want to dig into this a little further because I don’t see the problems with logging and returning as just a matter of personal preference. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br><span class="line">err := WriteConfig(f, &amp;conf)</span><br><span class="line">fmt.Println(err) // io.EOF</span><br><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Printf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">        // oops, forgot to return</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        log.Println(&quot;could not write config: %v&quot;, err)</span><br><span class="line">        return err</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><p>GO </p><p>The problem I see a lot is programmers forgetting to return from an error. As we talked about earlier, Go style is to use guard clauses, checking preconditions as the function progresses and returning early. </p><p>In this example the author checked the error, logged it, but forgot to return. This has caused a subtle bug. </p><p>w.Write </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 33/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The contract for error handling in Go says that you cannot make any assumptions about the contents of other return values in the presence of an error. As the JSON marshalling failed, the contents of buf are unknown, maybe it contains nothing, but worse it could contain a 1/2 written JSON fragment. </p><p>Because the programmer forgot to return after checking and logging the error, the corrupt buffer will be passed to WriteAll , which will probably succeed and so the config file will be written incorrectly. However the function will </p><p>return just fine, and the only indication that a problem happened will be a single log line complaining about marshalling JSON, not a failure to write the config. </p><p>7.2.1. Adding context to errors </p><p>The bug occurred because the author was trying to add context to the error message. They were trying to leave themselves a breadcrumb to point them back to the source of the error. </p><p>Let’s look at another way to do the same thing using fmt.Errorf . </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WriteConfig(w io.Writer, conf *Config) error &#123;</span><br><span class="line">    buf, err := json.Marshal(conf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not marshal config: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if err := WriteAll(w, buf); err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;could not write config: %v&quot;, err)</span><br></pre></td></tr></table></figure><p>} </p><p>return nil } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func WriteAll(w io.Writer, buf []byte) error &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;write failed: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>return nil } </p><p>GO </p><p>By combining the annotation of the error with returning onto one line there it is harder to forget to return an error and avoid continuing accidentally. </p><p>If an I/O error occurs writing the file, the error’s `Error() method will report something like this; could not write config: write failed: input/output error </p><p>7.2.2. Wrapping errors with github.com/pkg/errors </p><p>The fmt.Errorf pattern works well for annotating the error message, but it does so at the cost of obscuring the type of the original error. I’ve argued that treating errors as opaque values is important to producing software which is loosely coupled, so the face that the type of the original error should not matter if the only thing you do with an error value is </p><p>\1. Check that it is not nil . 2. Print or log it. </p><p>However there are some cases, I believe they are infrequent, where you do need to recover the original error. In that case you can use something like my errors package to annotate errors like this </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 34/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now the error reported will be the nice K&amp;D [11] style error, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure><p>and the error value retains a reference to the original cause. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;original error: %T %v\n&quot;, errors.Cause(err), errors.Cause(err))</span><br><span class="line">        fmt.Printf(&quot;stack trace:\n%+v\n&quot;, err)</span><br><span class="line">        os.Exit(1)</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>Thus you can recover the original error and print a stack trace; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func ReadFile(path string) ([]byte, error) &#123;</span><br><span class="line">    f, err := os.Open(path)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;open failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    defer f.Close()</span><br><span class="line">    buf, err := ioutil.ReadAll(f)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.Wrap(err, &quot;read failed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return buf, nil</span><br><span class="line">&#125;</span><br><span class="line">func ReadConfig() ([]byte, error) &#123;</span><br><span class="line">    home := os.Getenv(&quot;HOME&quot;)</span><br><span class="line">    config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;))</span><br><span class="line">    return config, errors.WithMessage(err, &quot;could not read config&quot;)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    _, err := ReadConfig()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br></pre></td></tr></table></figure><p>os.Exit(1) } </p><p>} </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 35/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Using the errors package gives you the ability to add context to error values, in a way that is inspectable by both a human and a machine. If you came to my presentation yesterday you’ll know that wrapping is moving into the standard library in an upcoming Go release. </p><p>\8. Concurrency </p><p>Often Go is chosen for a project because of its concurrency features. The Go team have gone to great lengths to make concurrency in Go cheap (in terms of hardware resources) and performant, however it is possible to use Go’s concurrency features to write code which is neither performent or reliable. With the time I have left I want to leave you with some advice for avoid some of the pitfalls that come with Go’s concurrency features. </p><p>Go features first class support for concurrency with channels, and the select and go statements. If you’ve learnt Go formally from a book or training course, you might have noticed that the concurrency section is always one of the last you’ll cover. This workshop is no different, I have chosen to cover concurrency last, as if it is somehow additional to the regular the skills a Go programmer should master. </p><p>There is a dichotomy here; Go’s headline feature is our simple, lightweight concurrency model. As a product, our language almost sells itself on this on feature alone. On the other hand, there is a narrative that concurrency isn’t actually that easy to use, otherwise authors wouldn’t make it the last chapter in their book and we wouldn’t look back on our formative efforts with regret. </p><p>This section discusses some pitfalls of naive usage of Go’s concurrency features. </p><p>8.1. Keep yourself busy or do the work yourself </p><p>What is the problem with this program? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 36/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>The program does what we intended, it serves a simple web server. However it also does something else at the same time, it wastes CPU in an infinite loop. This is because the for{} on the last line of main is going to block the main goroutine because it doesn’t do any IO, wait on a lock, send or receive on a channel, or otherwise communicate with the scheduler. </p><p>As the Go runtime is mostly cooperatively scheduled, this program is going to spin fruitlessly on a single CPU, and may eventually end up live-locked. </p><p>How could we fix this? Here’s one suggestion. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” </p><p>“runtime” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    runtime.Gosched()</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>package main </p><p>GO </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><p>for { </p><p>} } </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 37/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This might look silly, but it’s a common common solution I see in the wild. It’s symptomatic of not understanding the underlying problem. </p><p>Now, if you’re a little more experienced with go, you might instead write something like this. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>}() </p><p>select {} } </p><p>GO </p><p>An empty select statement will block forever. This is a useful property because now we’re not spinning a whole CPU just to call runtime.GoSched() . However, we’re only treating the symptom, not the cause. </p><p>I want to present to you another solution, one which has hopefully already occurred to you. Rather than run<br> in a goroutine, leaving us with the problem of what to do with the main goroutine, simply run </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe</span><br><span class="line">http.ListenAndServe</span><br></pre></td></tr></table></figure><p>TIP </p><p>on the main goroutine itself. </p><p>If the main.main function of a Go program returns then the Go program will unconditionally exit no matter what other goroutines started by the program over time are doing. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;log&quot;</span><br></pre></td></tr></table></figure><p>“net/http” ) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(w, &quot;Hello, GopherCon SG&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;:8080&quot;, nil); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p>So this is my first piece of advice: if your goroutine cannot make progress until it gets the result from another, oftentimes it is simpler to just do the work yourself rather than to delegate it. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 38/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>This often eliminates a lot of state tracking and channel manipulation required to plumb a result back from a goroutine to its initiator. </p><p>TIP </p><p>Many Go programmers overuse goroutines, especially when they are starting out. As with all things in life, moderation is the key the key to success. </p><p>8.2. Leave concurrency to the caller </p><p>What is the difference between these two APIs? </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ListDirectory returns the contents of dir.</span><br><span class="line">func ListDirectory(dir string) ([]string, error)</span><br><span class="line">// ListDirectory returns a channel over which</span><br><span class="line">// directory entries will be published. When the list</span><br><span class="line">// of entries is exhausted, the channel will be closed.</span><br><span class="line">func ListDirectory(dir string) chan string</span><br></pre></td></tr></table></figure><p>Firstly, the obvious differences; the first example reads a directory into a slice then returns the whole slice, or an error if something went wrong. This happens synchronously, the caller of ListDirectory blocks until all directory entries have been read. Depending on how large the directory, this could take a long time, and could potentially allocate a lot of memory building up the slide of directory entry names. </p><p>Lets look at the second example. This is a little more Go like, ListDirectory returns a channel over which directory entries will be passed. When the channel is closed, that is your indication that there are no more directory entries. As the population of the channel happens after ListDirectory returns, ListDirectory is probably starting a goroutine to populate the channel. </p><p>NOTE </p><p>Its not necessary for the second version to actually use a Go routine; it could allocate a channel sufficient to hold all the directory entries without blocking, fill the channel, close it, then return the channel to the caller. But this is unlikely, as this would have the same problems with consuming a large amount of memory to buffer all the results in a channel. </p><p>The channel version of ListDirectory has two further problems: </p><p>By using a closed channel as the signal that there are no more items to process there is no way for ListDirectory to tell the caller that the set of items returned over the channel is incomplete because an error was encountered partway through. There is no way for the caller to tell the difference between an empty directory and an error to read from the directory entirely. Both result in a channel returned from ListDirectory which appears to be closed immediately. </p><p>The caller must continue to read from the channel until it is closed because that is the only way the caller can know that the goroutine which was started to fill the channel has stopped. This is a serious limitation on the use of </p><p>ListDirectory , the caller has to spend time reading from the channel even though it may have received the answer it wanted. It is probably more efficient in terms of memory usage for medium to large directories, but this method is no faster than the original slice based method. </p><p>The solution to the problems of both implementations is to use a callback, a function that is called in the context of each directory entry as it is executed. </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 39/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Not surprisingly this is how the filepath.WalkDir function works. </p><p>If your function starts a goroutine you must provide the caller with a way to explicitly stop that TIP goroutine. It is often easier to leave decision to execute a function asynchronously to the caller of </p><p>that function. </p><p>8.3. Never start a goroutine without when it will stop. </p><p>The previous example showed using a goroutine when one wasn’t really necessary. But one of the driving reasons for using Go is the first class concurrency features the language offers. Indeed there are many instances where you want to exploit the parallelism available in your hardware. To do so, you must use goroutines. </p><p>This simple application serves http traffic on two different ports, port 8080 for application traffic and port 8001 for access to the /debug/pprof endpoint. </p><p>package main </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br></pre></td></tr></table></figure><p>“net/http” </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    _ &quot;net/http/pprof&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    go http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux) // debug</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)                       // app traffic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO </p><p>Although this program isn’t very complicated, it represents the basis of a real application. </p><p>There are a few problems with the application as it stands which will reveal themselves as the application grows, so lets address a few of them now. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ListDirectory(dir string, fn func(string))</span><br></pre></td></tr></table></figure><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 40/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>By breaking the serveApp and serveDebug handlers out into their own functions we’ve decoupled them from main.main . We’ve also followed the advice from above and make sure that serveApp and serveDebug leave their </p><p>concurrency to the caller. </p><p>But there are some operability problems with this program. If serveApp returns then main.main will return causing the program to shutdown and be restarted by whatever process manager you’re using. </p><p>TIP </p><p>Just as functions in Go leave concurrency to the caller, applications should leave the job of monitoring their status and restarting them if they fail to the program that invoked them. Do not make your applications responsible for restarting themselves, this is a procedure best handled from outside the application. </p><p>However, serveDebug is run in a separate goroutine and if it returns just that goroutine will exit while the rest of the program continues on. Your operations staff will not be happy to find that they cannot get the statistics out of your application when they want too because the /debug handler stopped working a long time ago. </p><p>What we want to ensure is that if any of the goroutines responsible for serving this application stop, we shut down the application. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() &#123;</span><br><span class="line">    http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br></pre></td></tr></table></figure><p>serveApp() } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 41/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now serverApp and serveDebug check the error returned from ListenAndServe and call if required. Because both handlers are running in goroutines, we park the main goroutine in a . </p><p>This approach has a number of problems: </p><p>\1. If ListenAndServer returns with a nil error, log.Fatal won’t be called and the HTTP service on that port will shut down without stopping the application. </p><p>\2. log.Fatal calls os.Exit which will unconditionally exit the program; defers won’t be called, other goroutines won’t be notified to shut down, the program will just stop. This makes it difficult to write tests for those functions. </p><p>TIP Only use log.Fatal from main.main or init functions. </p><p>What we’d really like is to pass any error that occurs back to the originator of the goroutine so that it can know why the goroutine stopped, can shut down the process cleanly. </p><p>log.Fatal </p><p>select{} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    if err := http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br></pre></td></tr></table></figure><p>} } </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func serveDebug() &#123;</span><br><span class="line">    if err := http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux); err != nil &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    go serveDebug()</span><br><span class="line">    go serveApp()</span><br></pre></td></tr></table></figure><p>select {} } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 42/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>We can use a channel to collect the return status of the goroutine. The size of the channel is equal to the number of goroutines we want to manage so that sending to the done channel will not block, as this will block the shutdown the of goroutine, causing it to leak. </p><p>As there is no way to safely close the done channel we cannot use the for range idiom to loop of the channel until all goroutines have reported in, instead we loop for as many goroutines we started, which is equal to the capacity of the channel. </p><p>Now we have a way to wait for each goroutine to exit cleanly and log any error they encounter. All that is needed is a way to forward the shutdown signal from the first goroutine that exits to the others. </p><p>It turns out that asking a http.Server to shut down is a little involved, so I’ve spun that logic out into a helper function. The serve helper takes an address and http.Handler , similar to http.ListenAndServe , and also a stop channel which we use to trigger the Shutdown method. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func serveApp() error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return http.ListenAndServe(&quot;0.0.0.0:8080&quot;, mux)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug() error &#123;</span><br><span class="line">    return http.ListenAndServe(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug()</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp()</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 43/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><p>Now, each time we receive a value on the channel, we close the stop channel which causes all the goroutines waiting on that channel to shut down their . This in turn will cause all the remaining ListenAndServe goroutines to return. Once all the goroutines we started have stopped, main.main returns and the process stops cleanly. </p><p>done </p><p>http.Server </p><p>TIP </p><p>Writing this logic yourself is repetitive and subtle. Consider something like this package, <a href="https://github.com/heptio/workgroup" target="_blank" rel="noopener">https://github.com/heptio/workgroup</a> which will do most of the work for you. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func serve(addr string, handler http.Handler, stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    s := http.Server&#123;</span><br></pre></td></tr></table></figure><p>Addr: addr, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Handler: handler,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">    &lt;-stop // wait for stop signal</span><br><span class="line">    s.Shutdown(context.Background())</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    return s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">func serveApp(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(&quot;/&quot;, func(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        fmt.Fprintln(resp, &quot;Hello, QCon!&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return serve(&quot;0.0.0.0:8080&quot;, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line">func serveDebug(stop &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">    return serve(&quot;127.0.0.1:8001&quot;, http.DefaultServeMux, stop)</span><br></pre></td></tr></table></figure><p>} </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    done := make(chan error, 2)</span><br><span class="line">    stop := make(chan struct&#123;&#125;)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveDebug(stop)</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        done &lt;- serveApp(stop)</span><br></pre></td></tr></table></figure><p>}() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stopped bool</span><br><span class="line">for i := 0; i &lt; cap(done); i++ &#123;</span><br><span class="line">    if err := &lt;-done; err != nil &#123;</span><br><span class="line">        fmt.Println(&quot;error: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    if !stopped &#123;</span><br><span class="line">        stopped = true</span><br><span class="line">        close(stop)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>} } </p><p>GO </p><ul><li>下面是David给出的一下关于go的学习参考资料的链接：</li></ul><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a> 44/45 </p><p>2018/10/21 Practical Go: Real world advice for writing maintainable Go programs </p><ol><li><p><a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">https://gaston.life/books/effective-programming/</a></p></li><li><p><a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">https://talks.golang.org/2014/names.slide#4</a></p></li><li><p><a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p></li><li><p><a href="https://www.lysator.liu.se/c/pikestyle.html" target="_blank" rel="noopener">https://www.lysator.liu.se/c/pikestyle.html</a></p></li><li><p><a href="https://speakerdeck.com/campoy/understanding-nil" target="_blank" rel="noopener">https://speakerdeck.com/campoy/understanding-nil</a></p></li><li><p><a href="https://www.youtube.com/watch?v=Ic2y6w8lMPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p></li><li><p><a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p></li><li><p><a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="noopener">https://golang.org/doc/go1.4#internalpackages</a></p></li><li><p><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p></li><li><p><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p></li><li><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p></li><li><p><a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p></li><li><p><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a></p></li><li><p><a href="http://www.gopl.io/" target="_blank" rel="noopener">http://www.gopl.io/</a></p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      博客内容为GO专家David关于Go最佳实践的一些建议
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="GO QCon 技术分享" scheme="https://cloudsjhan.github.io/tags/GO-QCon-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之改善 Python 程序的 91 个建议（转载)</title>
    <link href="https://cloudsjhan.github.io/2018/10/21/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E6%94%B9%E5%96%84-Python-%E7%A8%8B%E5%BA%8F%E7%9A%84-91-%E4%B8%AA%E5%BB%BA%E8%AE%AE%EF%BC%88%E8%BD%AC%E8%BD%BD/"/>
    <id>https://cloudsjhan.github.io/2018/10/21/技术周刊之改善-Python-程序的-91-个建议（转载/</id>
    <published>2018-10-21T13:49:17.000Z</published>
    <updated>2018-10-21T13:54:09.690Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>本篇博客转载自zhuanlan.zhihu.com/p/32817459。</p><p>除了Google的Python代码规范外，从来没有类似的书籍。偶然的机会看到这么一本书，读完之后觉得还不错，所以做个简单的笔记。有想学习类似知识的朋友，又懒得去读完整本书籍，可以参考一下。</p><h3 id="1：引论"><a href="#1：引论" class="headerlink" title="1：引论"></a><strong>1：引论</strong></h3><p>建议1、理解Pythonic概念—-详见Python中的《Python之禅》</p><p>建议2、编写Pythonic代码</p><p>（1）避免不规范代码，比如只用大小写区分变量、使用容易混淆的变量名、害怕过长变量名等。有时候长的变量名会使代码更加具有可读性。</p><p>（2）深入学习Python相关知识，比如语言特性、库特性等，比如Python演变过程等。深入学习一两个业内公认的Pythonic的代码库，比如Flask等。</p><p>建议3：理解Python与C的不同之处，比如缩进与{}，单引号双引号，三元操作符？，Switch-Case语句等。</p><p>建议4：在代码中适当添加注释</p><p>建议5：适当添加空行使代码布局更加合理</p><p>建议6：编写函数的4个原则</p><p>（1）函数设计要尽量短小，嵌套层次不宜过深</p><p>（2）函数声明应该做到合理、简单、易用</p><p>（3）函数参数设计应该考虑向下兼容</p><p>（4）一个函数只做一件事，尽量保证函数粒度的一致性</p><p>建议7：将常量集中在一个文件，且常量名尽量使用全大写字母</p><h3 id="2：编程惯用法"><a href="#2：编程惯用法" class="headerlink" title="2：编程惯用法"></a><strong>2：编程惯用法</strong></h3><p>建议8：利用assert语句来发现问题，但要注意，断言assert会影响效率</p><p>建议9：数据交换值时不推荐使用临时变量，而是直接a, b = b, a</p><p>建议10：充分利用惰性计算（Lazy evaluation）的特性，从而避免不必要的计算</p><p>建议11：理解枚举替代实现的缺陷（最新版Python中已经加入了枚举特性）</p><p>建议12：不推荐使用type来进行类型检查，因为有些时候type的结果并不一定可靠。如果有需求，建议使用isinstance函数来代替</p><p>建议13：尽量将变量转化为浮点类型后再做除法（Python3以后不用考虑）</p><p>建议14：警惕eval()函数的安全漏洞，有点类似于SQL注入</p><p>建议15：使用enumerate()同时获取序列迭代的索引和值</p><p>建议16：分清==和is的适用场景，特别是在比较字符串等不可变类型变量时（详见评论）</p><p>建议17：尽量使用Unicode。在Python2中编码是很让人头痛的一件事，但Python3就不用过多考虑了</p><p>建议18：构建合理的包层次来管理Module</p><h3 id="3：基础用法"><a href="#3：基础用法" class="headerlink" title="3：基础用法"></a><strong>3：基础用法</strong></h3><p>建议19：有节制的使用from…import语句，防止污染命名空间</p><p>建议20：优先使用absolute import来导入模块（Python3中已经移除了relative import）</p><p>建议21：i+=1不等于++i，在Python中，++i前边的加号仅表示正，不表示操作</p><p>建议22：习惯使用with自动关闭资源，特别是在文件读写中</p><p>建议23：使用else子句简化循环（异常处理）</p><p>建议24：遵循异常处理的几点基本原则</p><p>（1）注意异常的粒度，try块中尽量少写代码</p><p>（2）谨慎使用单独的except语句，或except Exception语句，而是定位到具体异常</p><p>（3）注意异常捕获的顺序，在合适的层次处理异常</p><p>（4）使用更加友好的异常信息，遵守异常参数的规范</p><p>建议25：避免finally中可能发生的陷阱</p><p>建议26：深入理解None，正确判断对象是否为空。Python中下列数据会判断为空：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2nJcvp2sZwpqMdESQCm3pUhzcPcBsOyWfj6NJ0vIT3D6AVHMzZLCjmA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>建议27：连接字符串应优先使用join函数，而不是+操作</p><p>建议28：格式化字符串时尽量使用.format函数，而不是%形式</p><p>建议29：区别对待可变对象和不可变对象，特别是作为函数参数时</p><p>建议30：[], {}和()：一致的容器初始化形式。使用列表解析可以使代码更清晰，同时效率更高</p><p>建议31：函数传参数，既不是传值也不是传引用，而是传对象或者说对象的引用</p><p>建议32：警惕默认参数潜在的问题，特别是当默认参数为可变对象时</p><p>建议33：函数中慎用变长参数*args和**kargs</p><p>（1）这种使用太灵活，从而使得函数签名不够清晰，可读性较差</p><p>（2）如果因为函数参数过多而是用变长参数简化函数定义，那么一般该函数可以重构</p><p>建议34：深入理解str()和repr()的区别</p><p>（1）两者之间的目标不同：str主要面向客户，其目的是可读性，返回形式为用户友好性和可读性都比较高的字符串形式；而repr是面向Python解释器或者说Python开发人员，其目的是准确性，其返回值表示Python解释器内部的定义</p><p>（2）在解释器中直接输入变量，默认调用repr函数，而print(var)默认调用str函数</p><p>（3）repr函数的返回值一般可以用eval函数来还原对象</p><p>（4）两者分别调用对象的内建函数<strong>str__()和__repr</strong>()</p><p>建议35：分清静态方法staticmethod和类方法classmethod的使用场景</p><h3 id="4：库"><a href="#4：库" class="headerlink" title="4：库"></a><strong>4：库</strong></h3><p>建议36：掌握字符串的基本用法</p><p>建议37：按需选择sort()和sorted()函数</p><p>》sort()是列表在就地进行排序，所以不能排序元组等不可变类型。</p><p>》sorted()可以排序任意的可迭代类型，同时不改变原变量本身。</p><p>建议38：使用copy模块深拷贝对象，区分浅拷贝（shallow copy）和深拷贝（deep copy）</p><p>建议39：使用Counter进行计数统计，Counter是字典类的子类，在collections模块中</p><p>建议40：深入掌握ConfigParser</p><p>建议41：使用argparse模块处理命令行参数</p><p>建议42：使用pandas处理大型CSV文件</p><p>》Python本身提供一个CSV文件处理模块，并提供reader、writer等函数。</p><p>》Pandas可提供分块、合并处理等，适用于数据量大的情况，且对二维数据操作更方便。</p><p>建议43：使用ElementTree解析XML</p><p>建议44：理解模块pickle的优劣</p><p>》优势：接口简单、各平台通用、支持的数据类型广泛、扩展性强</p><p>》劣势：不保证数据操作的原子性、存在安全问题、不同语言之间不兼容</p><p>建议45：序列化的另一个选择JSON模块：load和dump操作</p><p>建议46：使用traceback获取栈信息</p><p>建议47：使用logging记录日志信息</p><p>建议48：使用threading模块编写多线程程序</p><p>建议49：使用Queue模块使多线程编程更安全</p><h3 id="5：设计模式"><a href="#5：设计模式" class="headerlink" title="5：设计模式"></a><strong>5：设计模式</strong></h3><p>建议50：利用模块实现单例模式</p><p>建议51：用mixin模式让程序更加灵活</p><p>建议52：用发布-订阅模式实现松耦合</p><p>建议53：用状态模式美化代码</p><h3 id="6：内部机制"><a href="#6：内部机制" class="headerlink" title="6：内部机制"></a><strong>6：内部机制</strong></h3><p>建议54：理解build-in对象</p><p>建议55：<strong>init__()不是构造方法，理解__new</strong>()与它之间的区别</p><p>建议56：理解变量的查找机制，即作用域</p><p>》局部作用域</p><p>》全局作用域</p><p>》嵌套作用域</p><p>》内置作用域</p><p>建议57：为什么需要self参数</p><p>建议58：理解MRO（方法解析顺序）与多继承</p><p>建议59：理解描述符机制</p><p>建议60：区别<strong>getattr__()与__getattribute</strong>()方法之间的区别</p><p>建议61：使用更安全的property</p><p>建议62：掌握元类metaclass</p><p>建议63：熟悉Python对象协议</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2mTYUZQBgtMVG5BQzVEnnkMDu5U9MzPJp99DzicxZ6hUjT03ib6wicwalw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>建议64：利用操作符重载实现中缀语法</p><p>建议65：熟悉Python的迭代器协议</p><p>建议66：熟悉Python的生成器</p><p>建议67：基于生成器的协程和greenlet，理解协程、多线程、多进程之间的区别</p><p>建议68：理解GIL的局限性</p><p>建议69：对象的管理和垃圾回收</p><h3 id="7：使用工具辅助项目开发"><a href="#7：使用工具辅助项目开发" class="headerlink" title="7：使用工具辅助项目开发"></a><strong>7：使用工具辅助项目开发</strong></h3><p>建议70：从PyPI安装第三方包</p><p>建议71：使用pip和yolk安装、管理包</p><p>建议72：做paster创建包</p><p>建议73：理解单元测试的概念</p><p>建议74：为包编写单元测试</p><p>建议75：利用测试驱动开发（TDD）提高代码的可测性</p><p>建议76：使用Pylint检查代码风格</p><p>》代码风格审查</p><p>》代码错误检查</p><p>》发现重复以及不合理的代码，方便重构</p><p>》高度的可配置化和可定制化</p><p>》支持各种IDE和编辑器的集成</p><p>》能够基于Python代码生成UML图</p><p>》能够与Jenkins等持续集成工具相结合，支持自动代码审查</p><p>建议77：进行高效的代码审查</p><p>建议78：将包发布到PyPI</p><h3 id="8：性能剖析与优化"><a href="#8：性能剖析与优化" class="headerlink" title="8：性能剖析与优化"></a><strong>8：性能剖析与优化</strong></h3><p>建议79：了解代码优化的基本原则</p><p>建议80：借助性能优化工具</p><p>建议81：利用cProfile定位性能瓶颈</p><p>建议82：使用memory_profiler和objgraph剖析内存使用</p><p>建议83：努力降低算法复杂度</p><p>建议84：掌握循环优化的基本技巧</p><p>》减少循环内部的计算</p><p>》将显式循环改为隐式循环，当然这会牺牲代码的可读性</p><p>》在循环中尽量引用局部变量</p><p>》关注内层嵌套循环</p><p>建议85：使用生成器提高效率</p><p>建议86：使用不同的数据结构优化性能</p><p>建议87：充分利用set的优势</p><p>建议88：使用multiprocessing模块克服GIL缺陷</p><p>建议89：使用线程池提高效率</p><p>建议90：使用C/C++模块扩展提高性能</p><p>建议91：使用Cythonb编写扩展模块</p><hr>]]></content>
    
    <summary type="html">
    
      如何写出规范优雅的Python代码
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
      <category term="编程规范" scheme="https://cloudsjhan.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之基于beego web框架的RESTful API的构建之旅</title>
    <link href="https://cloudsjhan.github.io/2018/10/14/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E5%9F%BA%E4%BA%8Ebeego-web%E6%A1%86%E6%9E%B6%E7%9A%84RESTful-API%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%97%85/"/>
    <id>https://cloudsjhan.github.io/2018/10/14/技术周刊之基于beego-web框架的RESTful-API的构建之旅/</id>
    <published>2018-10-14T07:44:03.000Z</published>
    <updated>2018-10-14T10:10:09.837Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    beego是一个快速开发GO应用的http框架，作者是go语言方向的大牛，astaxie。beego可以用来快速开发API、web、后端服务等应用，是一个RESTFul风格的框架，主要的设计灵感来自于Python web开发框架tornado、flask、sinstra，很好的结合了Go语言本身的一些特性（interface，struct继承等）。</p><p>​    beego是基于八大独立模块来实现的，很好的实现了模块间的解耦，即使用户不使用http的逻辑，也可以很好的使用其中的各个模块。作者自己说，他的这种思想来自于乐高积木，设计beego的时候，这些模块就是积木，而最终搭建好的机器人就是beego。</p><p>​    这篇博文通过使用beego来构建API，讲解实现过程中的细节以及遇到的一些坑，让我们马上开始beego的API构建之旅吧！</p><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><ul><li>进入到你的$GOPATH/src</li><li>安装beego开发包自己快速开发工具bee</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/astaxie/beego</span><br><span class="line"><span class="keyword">go</span> get github.com/astaxie/beego/orm</span><br><span class="line"><span class="keyword">go</span> get github.com/beego/bee</span><br></pre></td></tr></table></figure><ul><li>使用快速开发工具bee，创建我们的API项目</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bee <span class="built_in">new</span> firstAPI</span><br></pre></td></tr></table></figure><p>我们得到的项目结构如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw7uxgc1sqj314q03gwev.jpg" alt=""></p><p>可以看出这是一个典型的MVC架构的应用，beego把我们项目所需要的一些都准备好了，例如配置文件conf，测试文件tests等，我们只需要专注于API代码的编写即可。</p><h3 id="运行项目并获得API自动化文档"><a href="#运行项目并获得API自动化文档" class="headerlink" title="运行项目并获得API自动化文档"></a>运行项目并获得API自动化文档</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bee run -gendoc=<span class="literal">true</span> -downdoc=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>运行上述代码输出如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw7v5dfquwj31kw0skn3a.jpg" alt=""></p><p>我们在浏览器中访问：本机IP：8080/swagger，就会看到swagger的API文档，我们代码更新后，该文档就会自动更新，非常方便。</p><h3 id="models设计"><a href="#models设计" class="headerlink" title="models设计"></a>models设计</h3><ul><li>对 数据库object 操作有四个方法 Read / Insert / Update / Delete</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">user := <span class="built_in">new</span>(User)</span><br><span class="line">user.Name = <span class="string">"slene"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(o.Insert(user))</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">"Your"</span></span><br><span class="line">fmt.Println(o.Update(user))</span><br><span class="line">fmt.Println(o.Read(user))</span><br><span class="line">fmt.Println(o.Delete(user))</span><br></pre></td></tr></table></figure><p>还有其他的方法可以参阅beego<a href="https://beego.me/docs/mvc/model/object.md" target="_blank" rel="noopener">官方文档</a>，里面对orm操作有着详细的介绍。</p><ul><li>创建一个数据库并设计一张数据库表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`Id` int(11),</span><br><span class="line">`Name` varchar(255),</span><br><span class="line">`Birthdate` varchar(255),</span><br><span class="line">`Gender` bool,</span><br><span class="line">`Score` int(11)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>在models文件夹下新建一个文件Student.go,并实现以下代码，代码中关键点都有注释</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在models模块中创建一个struct，目的是使用beego的orm框架，使struct与数据库中的字段产生对应关系</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int</span><span class="string">`orm:"column(Id)"`</span> <span class="comment">//column()括号中的字段就是在定义数据库时的相应字段，这一段必须严格填写，不然在API读写数据时就会出现读不到或者写不进去的问题</span></span><br><span class="line">Name <span class="keyword">string</span>  <span class="string">`orm:"column(Name)"`</span></span><br><span class="line">BirthDate <span class="keyword">string</span> <span class="string">`orm:"column(Birthdate)"`</span></span><br><span class="line">Gender <span class="keyword">bool</span> <span class="string">`orm:"column(Gender)"`</span></span><br><span class="line">Score <span class="keyword">int</span> <span class="string">`orm:"column(Score)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数获得数据库中所有student的信息，返回值是一个结构体数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAllStudents</span><span class="params">()</span> []*<span class="title">Student</span></span> &#123;</span><br><span class="line">o := orm.NewOrm() <span class="comment">//产生一个orm对象</span></span><br><span class="line">o.Using(<span class="string">"default"</span>) <span class="comment">//这句话的意思是使用定义的默认数据库，与main.go中的orm.RegisterDataBase()对应</span></span><br><span class="line"><span class="keyword">var</span> students []*Student <span class="comment">//定义指向结构体数组的指针</span></span><br><span class="line">q := o.QueryTable(<span class="string">"student"</span>)<span class="comment">//获得一个数据库表的请求</span></span><br><span class="line">q.All(&amp;students)<span class="comment">//取到这个表中的所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> students</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数根据student中的Id，返回该学生的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStudentById</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Student</span></span> &#123;</span><br><span class="line">u := Student&#123;Id:id&#125;<span class="comment">//根据所传入的Id得到对应student的对象</span></span><br><span class="line">o := orm.NewOrm()<span class="comment">//new 一个orm对象</span></span><br><span class="line">o.Using(<span class="string">"default"</span>)<span class="comment">//使用最开始定义的default数据库</span></span><br><span class="line">err := o.Read(&amp;u)<span class="comment">//读取Id=id的student的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == orm.ErrNoRows &#123;</span><br><span class="line">fmt.Println(<span class="string">"查询不到"</span>)<span class="comment">//对应操作，不一定是print</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == orm.ErrMissPK &#123;</span><br><span class="line">fmt.Println(<span class="string">"没有主键"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个学生的信息到数据库中，参数是指向student结构题的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddStudent</span><span class="params">(student *Student)</span> <span class="title">Student</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Insert(student)<span class="comment">//插入数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateStudent</span><span class="params">(student *Student)</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Update(student)<span class="comment">//更新该student的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteStudent</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line">o.Using(<span class="string">"default"</span>)</span><br><span class="line">o.Delete(&amp;Student&#123;Id:id&#125;)<span class="comment">//删除对应id的student的信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>  &#123;</span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(Student))<span class="comment">//将数据库注册到orm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>model这一层主要是定义struct，并为上层编写读写数据库。处理数据的代码。</li></ul><h3 id="controller层实现"><a href="#controller层实现" class="headerlink" title="controller层实现"></a>controller层实现</h3><p>基于 beego 的 Controller 设计，只需要匿名组合 <code>beego.Controller</code> 就可以了，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> xxxController <span class="keyword">struct</span> &#123;</span><br><span class="line">    beego.Controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beego.Controller</code> 实现了接口 <code>beego.ControllerInterface</code>，<code>beego.ControllerInterface</code> 定义了如下函数：</p><ul><li><p>Init(ct *context.Context, childName string, app interface{})</p><p>这个函数主要初始化了 Context、相应的 Controller 名称，模板名，初始化模板参数的容器 Data，app 即为当前执行的 Controller 的 reflecttype，这个 app 可以用来执行子类的方法。</p></li><li><p>Prepare()</p><p>这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。</p></li><li><p>Get()</p><p>如果用户请求的 HTTP Method 是 GET，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Get 请求。</p></li><li><p>Post()</p><p>如果用户请求的 HTTP Method 是 POST，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Post 请求。</p></li><li><p>Delete()</p><p>如果用户请求的 HTTP Method 是 DELETE，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Delete 请求。</p></li><li><p>Put()</p><p>如果用户请求的 HTTP Method 是 PUT，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Put 请求.</p></li><li><p>Head()</p><p>如果用户请求的 HTTP Method 是 HEAD，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。</p></li><li><p>Patch()</p><p>如果用户请求的 HTTP Method 是 PATCH，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Patch 请求.</p></li><li><p>Options()</p><p>如果用户请求的HTTP Method是OPTIONS，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Options 请求。</p></li><li><p>Finish()</p><p>这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。</p></li><li><p>Render() error</p><p>这个函数主要用来实现渲染模板，如果 beego.AutoRender 为 true 的情况下才会执行。</p></li></ul><p>所以通过子 struct 的方法重写，用户就可以实现自己的逻辑。</p><h3 id="routers层实现"><a href="#routers层实现" class="headerlink" title="routers层实现"></a>routers层实现</h3><p>什么是路由设置呢？前面介绍的 MVC 结构执行时，介绍过 beego 存在三种方式的路由:固定路由、正则路由、自动路由，与RESTFul API相关的就是固定路由和正则路由。</p><p>下面就是固定路由的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beego.Router(<span class="string">"/"</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin"</span>, &amp;admin.UserController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin/index"</span>, &amp;admin.ArticleController&#123;&#125;)</span><br><span class="line">beego.Router(<span class="string">"/admin/addpkg"</span>, &amp;admin.AddController&#123;&#125;)</span><br></pre></td></tr></table></figure><p>下面是正则路由的例子：</p><ul><li><p>beego.Router(“/api/?:id”, &amp;controllers.RController{})</p><p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/api/:id”, &amp;controllers.RController{})</p><p>默认匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”，但URL”/api/“匹配失败</p></li><li><p>beego.Router(“/api/:id([0-9]+)“, &amp;controllers.RController{})</p><p>自定义正则匹配 //例如对于URL”/api/123”可以匹配成功，此时变量”:id”值为”123”</p></li><li><p>beego.Router(“/user/:username([\w]+)“, &amp;controllers.RController{})</p><p>正则字符串匹配 //例如对于URL”/user/astaxie”可以匹配成功，此时变量”:username”值为”astaxie”</p></li><li><p>beego.Router(“/download/<em>.</em>”, &amp;controllers.RController{})</p><p>*匹配方式 //例如对于URL”/download/file/api.xml”可以匹配成功，此时变量”:path”值为”file/api”， “:ext”值为”xml”</p></li><li><p>beego.Router(“/download/ceshi/*“, &amp;controllers.RController{})</p><p>*全匹配方式 //例如对于URL”/download/ceshi/file/api.json”可以匹配成功，此时变量”:splat”值为”file/api.json”</p></li><li><p>beego.Router(“/:id:int”, &amp;controllers.RController{})</p><p>int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)</p></li><li><p>beego.Router(“/:hi:string”, &amp;controllers.RController{})</p><p>string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)</p></li><li><p>beego.Router(“/cms_:id([0-9]+).html”, &amp;controllers.CmsController{})</p><p>带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123</p></li></ul><p>个人觉得，最方便的还是类似于Python框架flask的注解路由，也是在这个项目中使用的：</p><ul><li><p>在routers/routers.go里面添加你所希望的API</p></li><li><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"firstAPI/controllers"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">ns := beego.NewNamespace(<span class="string">"/v1"</span>,</span><br><span class="line">beego.NSNamespace(<span class="string">"/object"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.ObjectController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">beego.NSNamespace(<span class="string">"/user"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.UserController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">beego.NSNamespace(<span class="string">"/student"</span>,</span><br><span class="line">beego.NSInclude(</span><br><span class="line">&amp;controllers.StudentController&#123;&#125;,</span><br><span class="line">),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">beego.AddNamespace(ns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上代码实现了如下的API：</p><p>/v1/object</p><p>/v1/user</p><p>/v1/student</p><p>非常清晰明了。</p><h3 id="main-go的数据库配置"><a href="#main-go的数据库配置" class="headerlink" title="main.go的数据库配置"></a>main.go的数据库配置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"firstAPI/routers"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DRMySQL)<span class="comment">//注册MySQL的driver</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, <span class="string">"root:test@tcp(127.0.0.1:3306)/restapi_test?charset=utf8"</span>)<span class="comment">//本地数据库的账号。密码等</span></span><br><span class="line">orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> beego.BConfig.RunMode == <span class="string">"dev"</span> &#123;</span><br><span class="line">beego.BConfig.WebConfig.DirectoryIndex = <span class="literal">true</span></span><br><span class="line">beego.BConfig.WebConfig.StaticDir[<span class="string">"/swagger"</span>] = <span class="string">"swagger"</span><span class="comment">//静态文档</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点都在代码中以注释的形式展现。</p><h3 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h3><p>bee run 运行代码后，我们使用postman测试一下我们所构建的API效果如何。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw7w1tcnesj31kw0y90y6.jpg" alt=""></p><p>这里节省篇幅，只测试一个接口。</p><p>到此为止，我们基于beego就实现了简单API接口的构建，是不是既清晰又简单呢？赶快自己动手试试吧！</p><p>本期技术周刊结束，代码已上传到<a href="https://github.com/hantmac/beego_api_demo" target="_blank" rel="noopener">GitHub</a>，可以查阅，我们下期再会！</p><hr>]]></content>
    
    <summary type="html">
    
      本文介绍通过使用golang web开发框架beego搭建RESTFUL风格的API
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang beego" scheme="https://cloudsjhan.github.io/tags/golang-beego/"/>
    
  </entry>
  
  <entry>
    <title>总结版图解http</title>
    <link href="https://cloudsjhan.github.io/2018/10/12/%E6%80%BB%E7%BB%93%E7%89%88%E5%9B%BE%E8%A7%A3http/"/>
    <id>https://cloudsjhan.github.io/2018/10/12/总结版图解http/</id>
    <published>2018-10-12T02:20:37.000Z</published>
    <updated>2018-10-12T02:28:44.744Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p><strong>该博客转载自公众号<a href="https://mp.weixin.qq.com/s/MvMyH1vTCsxBCdHfH7uv1w" target="_blank" rel="noopener">freeCodeCamp</a></strong></p><p>作为一个前端，如果对一个网页从发起请求到返回数据这期间具体发生了什么都不知道的话，那不是一个好前端。最近，读了图解http，以及有关http相关的文章，还有自己也下载了wireshark抓包工具，实际观察了一下这个过程，下面就此做些总结。</p><p><strong>一.从输入一个url到返回数据，中间到底发生了什么？</strong></p><p>假设，我们在浏览器输入<a href="http://www.baidu.com:80/index.html，假设解析出的ip地址是202.43.78.3" target="_blank" rel="noopener">http://www.baidu.com:80/index.html，假设解析出的ip地址是202.43.78.3</a></p><p><strong>1.浏览器解析出主机名</strong></p><p>解析出的主机名是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><strong>2.浏览器查询这个主机名的ip地址（dns）</strong></p><p>dns解析的作用就是把域名解析成ip地址，这样才能在广域网路由器转发报文给目标ip，不然路由器不知道要把报文发给谁。下面就讲下大概的过程，不会涉及太多细节。（以chrome为例子）</p><p>（1）浏览器启动时，首先浏览器会去操作系统获取dns服务器地址，然后把这个地址缓存下来。同时浏览器还会去读取和解析hosts文件，同样放到缓存中。浏览器对解析过的域名和ip地址，都会保存着这两者的映射关系。（存到cache中）</p><p>（2）当解析域名的时候，首先浏览器会去cache中查找有没有缓存好的映射关系，如果没有的话，就去hosts文件中查找，如果也没有的话，浏览器就会发起请求去dns服务器缓存查询了，如果缓存里面也没有，那最后就是dns服务器去查询了。</p><p><strong>3.浏览器获取端口号</strong></p><p><strong>4.浏览器向目标ip地址发起一条到202.43.78.3:80的tcp连接</strong></p><p>为了传输的可靠性，tcp协议要有三次握手过程：</p><p>（1）首先浏览器会向服务器发起一个连接请求</p><p>（2）服务器会对连接请求做出响应，表示同意建立连接</p><p>（3）浏览器收到响应后，再告知对方，它知道服务器同意它建立连接了。</p><p><strong>5.数据包在ip层传输</strong></p><p>数据包在ip层传输，通过多台计算机和网络设备中转，在中转时，利用中转设备的mac地址搜索下一个中转目标（采用ARP协议，根据通信方的ip地址就可以反查出对应的mac地址），直到目标ip地址。</p><p><strong>6.数据链路层处理网络连接的硬件部分</strong></p><p>数据链路层处理网络连接的硬件部分，比如网卡，找到服务器的网卡</p><p><strong>7.浏览器向服务器发送一条http报文</strong></p><p>每一条http报文的组成：</p><p>起始行+首部+主体(可选)</p><p>起始行：http/1.0 200 ok (一般包括http版本，返回状态码，返回码原因)</p><p>首部：content-type:text/plain content-length:19</p><p>主体：name=jane</p><p><strong>8.服务器接受客户端请求，进行一些处理，返回响应报文</strong></p><p>web服务器接收到请求之后，实际上会做些什么呢？</p><p>（1）建立连接，如果接受一个客户端连接，就建立连接，如果不同意，就将其关闭。</p><p>（2）接收请求，读取http请求报文</p><p>（3）访问资源，访问报文中指定的资源</p><p>（4）构建响应，创建带有首部的http响应报文</p><p>（5）发送响应，将响应回送给客户端</p><p><strong>9.浏览器读取http响应报文</strong></p><p><strong>10.浏览器关闭连接</strong></p><p>看了上面的一个简单过程，大家会不会有这样一个问题，难道每次发起一个http请求，都要建立一次tcp连接吗，我们经常写的并发ajax请求，每条请求都是各自独立建立的tcp连接？一条tcp连接建立之后，是什么时候关闭的？带着这些问题，看看下面要讲的http的特性</p><p><strong>二.http的特性</strong></p><p><strong>1.http是不保存状态的协议</strong></p><p>http协议是一种无状态的协议，意思就是说它不会对每次的请求和响应之间的通信状态进行保存。你之前发过的任何请求的信息，没有任何记录。之所以这样设计，也是为了让http变得比较简单，可以处理大量事物。但是无状态的特性，也会导致一些问题，比如说一个用户登录一家网站之后，跳到另一个页面，应该还保持着登录状态，所以后面就出了cookie状态管理技术。相信大家应该都很熟悉了。</p><p><strong>2.请求只能从客户端开始，客户端不可以接收除响应以外的指令</strong></p><p>服务器必须等待客户端的请求，才能给客户端发送响应数据，所以说服务器是不能主动给客户端推送数据的。对于一些实时监控的功能，常常用websocket来代替</p><p><strong>3.没有用户认证，任何人都可以发起请求</strong></p><p>在http协议通信时，是不存在确认通信方的处理步骤的，任何人都可以发起请求。另外，服务器只要收到请求，无论是谁，都会返回一个响应。所以会存在伪装的隐患。后面出现的https就可以解决这个问题。</p><p><strong>4.通信使用的是明文</strong></p><p><strong>5.无法证明报文完整性</strong></p><p><strong>6.可任意选择数据压缩格式，非强制压缩发送</strong></p><p><strong>7.http持久连接和并行连接</strong></p><p>一开始，http请求是串行的，一个http请求，就会建立一条tcp连接，浏览器收到响应之后，就会断开连接。等上一个请求回来了，下一个请求才能继续请求。这样做的缺点是，比较耗时间和内存，后面就出现了下面一系列的优化连接性能的方法。</p><p>（1）并行连接</p><p>原理：通过多条tcp连接发起并发的http请求</p><p>并行连接可以同时发起多个http请求，每次发起一个http请求，就会建立一个tcp连接。每个http请求是独立的，不会相互等待，这样做，很可能会提高页面的加载速度，因为人们会看到页面上面，很多个东西会同时出现，所以感觉页面加载变快了。实际上有时候是真的变快了，因为它是并行工作的。但是有时候不是真的快了。比如说，客户端的网络带宽不足时，（浏览器是通过一个28kbps的modem连接到因特网上去的），如果并行加载多个请求，每个请求就会去竞争这个有限的带宽，每个请求就会以比较慢的速度加载。这样带来的性能提升就很小。</p><p>（2）持久连接</p><p>原理：重用tcp连接，以消除连接及关闭时延</p><p>从http1.1开始，就允许当http响应结束后，tcp连接可以保持在打开状态，以便给未来的http请求重用现在的连接。那么，这个tcp连接什么时候会关闭呢，一般情况下，40s内，如果没有新的请求，就会关闭。</p><p>（3）管道化连接</p><p>原理：通过共享的tcp连接发起并发的http请求</p><p>并行连接可以提高复合页面的传输速度，但是也有许多缺点，比如每次都会建立一次tcp连接，会耗费时间和带宽。持久连接的优势就是降低了时延和tcp的连接数量。但是持久连接可能会导致的一个问题是，可能会累积大量的空闲连接。耗费资源。</p><p>持久连接和并行连接配合使用才是最高效的方式。</p><p>一般浏览器会限制，同个域名下的并行连接的个数是4个，即打开少量的并行连接，其中每个都是持久连接。这也是现在用的最多的方式。</p><hr>]]></content>
    
    <summary type="html">
    
      对于《图解HTTP》一书进行言简意赅的总结
    
    </summary>
    
      <category term="网络" scheme="https://cloudsjhan.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://cloudsjhan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>python apscheduler - skipped: maximum number of running instances reached</title>
    <link href="https://cloudsjhan.github.io/2018/09/28/python-apscheduler-skipped-maximum-number-of-running-instances-reached/"/>
    <id>https://cloudsjhan.github.io/2018/09/28/python-apscheduler-skipped-maximum-number-of-running-instances-reached/</id>
    <published>2018-09-28T08:04:43.000Z</published>
    <updated>2018-09-28T08:14:25.410Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="出现问题的代码"><a href="#出现问题的代码" class="headerlink" title="出现问题的代码"></a>出现问题的代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line">scheduler.add_job(runsync, <span class="string">'interval'</span>, seconds=<span class="number">1</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure><h3 id="问题出现的情况"><a href="#问题出现的情况" class="headerlink" title="问题出现的情况"></a>问题出现的情况</h3><ul><li>运行一段代码，时而报错时而不报错</li><li>报错是：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING:apscheduler.scheduler:Execution of job &quot;runsync (trigger: interval[0:00:01], next run at: 2015-12-01 11:50:42 UTC)&quot; skipped: maximum number of running instances reached (1)</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>apscheduler这个模块，在你的代码运行时间大于interval的时候，就会报错</p><p>也就是说，你的代码运行时间超出了你的定时任务的时间间隔。</p></li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>增大时间间隔即可</li></ul><p>### </p><hr>]]></content>
    
    <summary type="html">
    
      python apscheduler - skipped: maximum number of running instances reached
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 的logging模块实现json格式的日志输出</title>
    <link href="https://cloudsjhan.github.io/2018/09/27/python-%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"/>
    <id>https://cloudsjhan.github.io/2018/09/27/python-的logging模块实现json格式的日志输出/</id>
    <published>2018-09-27T08:28:21.000Z</published>
    <updated>2018-09-29T01:14:39.201Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ul><li>想要让开发过程或者是上线后的bug无处可藏，最好的方式便是在程序运行过程中，不断收集重要的日志，以供分析使用。Python中内置的log收集模块是logging，该模块使用起来比较方便，但是美中不足的地方就是日志的格式转成json比较麻烦。于是我结合logging和另一个模块<a href="https://github.com/madzak/python-json-logger" target="_blank" rel="noopener">python-json-logger</a>(pip install python-json-logger) ，实现json格式的日志输出。</li></ul><h3 id="源码：以下代码可以做成模块，直接导入使用"><a href="#源码：以下代码可以做成模块，直接导入使用" class="headerlink" title="源码：以下代码可以做成模块，直接导入使用"></a>源码：以下代码可以做成模块，直接导入使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging, logging.config, os</span><br><span class="line"><span class="keyword">import</span> structlog</span><br><span class="line"><span class="keyword">from</span> structlog <span class="keyword">import</span> configure, processors, stdlib, threadlocal</span><br><span class="line"><span class="keyword">from</span> pythonjsonlogger <span class="keyword">import</span> jsonlogger</span><br><span class="line">BASE_DIR = BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DEBUG = <span class="keyword">True</span>  <span class="comment"># 标记是否在开发环境</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给过滤器使用的判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequireDebugTrue</span><span class="params">(logging.Filter)</span>:</span></span><br><span class="line">    <span class="comment"># 实现filter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DEBUG</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">()</span>:</span></span><br><span class="line">    LOGGING = &#123;</span><br><span class="line">    <span class="comment"># 基本设置</span></span><br><span class="line">        <span class="string">'version'</span>: <span class="number">1</span>,  <span class="comment"># 日志级别</span></span><br><span class="line">        <span class="string">'disable_existing_loggers'</span>: <span class="keyword">False</span>,  <span class="comment"># 是否禁用现有的记录器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志格式集合</span></span><br><span class="line">        <span class="string">'formatters'</span>: &#123;</span><br><span class="line">        <span class="comment"># 标准输出格式</span></span><br><span class="line">            <span class="string">'json'</span>: &#123;</span><br><span class="line">            <span class="comment"># [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span></span><br><span class="line">                <span class="string">'format'</span>: <span class="string">'[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s'</span>,</span><br><span class="line">                <span class="string">'class'</span>: <span class="string">'pythonjsonlogger.jsonlogger.JsonFormatter'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="string">'filters'</span>: &#123;</span><br><span class="line">            <span class="string">'require_debug_true'</span>: &#123;</span><br><span class="line">                <span class="string">'()'</span>: RequireDebugTrue,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 处理器集合</span></span><br><span class="line">        <span class="string">'handlers'</span>: &#123;</span><br><span class="line">        <span class="comment"># 输出到控制台</span></span><br><span class="line">        <span class="comment"># 输出到文件</span></span><br><span class="line">            <span class="string">'TimeChecklog'</span>: &#123;</span><br><span class="line">                <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">                <span class="string">'class'</span>: <span class="string">'logging.handlers.RotatingFileHandler'</span>,</span><br><span class="line">                <span class="string">'formatter'</span>: <span class="string">'json'</span>,</span><br><span class="line">                <span class="string">'filename'</span>: os.path.join(<span class="string">"./log/"</span>, <span class="string">'TimeoutCheck.log'</span>),  <span class="comment"># 输出位置</span></span><br><span class="line">                <span class="string">'maxBytes'</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>,  <span class="comment"># 文件大小 5M</span></span><br><span class="line">                <span class="string">'backupCount'</span>: <span class="number">5</span>,  <span class="comment"># 备份份数</span></span><br><span class="line">                <span class="string">'encoding'</span>: <span class="string">'utf8'</span>,  <span class="comment"># 文件编码</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="comment"># 日志管理器集合</span></span><br><span class="line">        <span class="string">'loggers'</span>: &#123;</span><br><span class="line">        <span class="comment"># 管理器</span></span><br><span class="line">            <span class="string">'proxyCheck'</span>: &#123;</span><br><span class="line">                <span class="string">'handlers'</span>: [<span class="string">'TimeChecklog'</span>],</span><br><span class="line">                <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">                <span class="string">'propagate'</span>: <span class="keyword">True</span>,  <span class="comment"># 是否传递给父记录器</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configure(</span><br><span class="line">        logger_factory=stdlib.LoggerFactory(),</span><br><span class="line">        processors=[</span><br><span class="line">            stdlib.render_to_log_kwargs]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger = logging.getLogger(<span class="string">"proxyCheck"</span>)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span></span><br><span class="line">logger1 = get_logger()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger1.error(e)  <span class="comment"># 写入错误日志</span></span><br><span class="line">        <span class="comment">#如果需要添加额外的信息，使用extra关键字即可</span></span><br><span class="line">        logger1.error(e, extra=&#123;key1: value1, key2:value2&#125;)</span><br><span class="line">        <span class="comment"># 其他错误处理代码</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="### 测试结果"></a>### 测试结果</h3><ul><li>测试的结果，可以在./log/xxx.log文件中看到输出的日志</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;asctime&quot;: &quot;2018-09-28 09:52:12,622&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 4338656704, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;mylog&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;division by zero&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到日志是json格式，这样你就可以很方便的使用grafna和ES将日志做成看板来展示了。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      使用Python的内置logging实现json格式的日志输出
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 发送各种格式的邮件</title>
    <link href="https://cloudsjhan.github.io/2018/09/17/python-%E5%8F%91%E9%80%81%E5%90%84%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84%E9%82%AE%E4%BB%B6/"/>
    <id>https://cloudsjhan.github.io/2018/09/17/python-发送各种格式的邮件/</id>
    <published>2018-09-17T02:55:56.000Z</published>
    <updated>2018-09-28T02:06:31.935Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line">_user = <span class="string">"sigeken@qq.com"</span></span><br><span class="line">_pwd  = <span class="string">"***"</span></span><br><span class="line">_to   = <span class="string">"402363522@qq.com"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如名字所示Multipart就是分多个部分</span></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">"Subject"</span>] = <span class="string">"don't panic"</span></span><br><span class="line">msg[<span class="string">"From"</span>]    = _user</span><br><span class="line">msg[<span class="string">"To"</span>]      = _to</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---这是文字部分---</span></span><br><span class="line">part = MIMEText(<span class="string">"乔装打扮，不择手段"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---这是附件部分---</span></span><br><span class="line"><span class="comment">#xlsx类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.xlsx'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.xlsx"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#jpg类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.jpg'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.jpg"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#pdf类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.pdf'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.pdf"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#mp3类型附件</span></span><br><span class="line">part = MIMEApplication(open(<span class="string">'foo.mp3'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">part.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">"foo.mp3"</span>)</span><br><span class="line">msg.attach(part)</span><br><span class="line"> </span><br><span class="line">s = smtplib.SMTP(<span class="string">"smtp.qq.com"</span>, timeout=<span class="number">30</span>)<span class="comment">#连接smtp邮件服务器,端口默认是25</span></span><br><span class="line">s.login(_user, _pwd)<span class="comment">#登陆服务器</span></span><br><span class="line">s.sendmail(_user, _to, msg.as_string())<span class="comment">#发送邮件</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      使用Python发送各种格式的邮件
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之当你ping的时候，发生了什么？</title>
    <link href="https://cloudsjhan.github.io/2018/09/16/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E5%BD%93%E4%BD%A0ping%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://cloudsjhan.github.io/2018/09/16/技术周刊之当你ping的时候，发生了什么？/</id>
    <published>2018-09-16T13:40:02.000Z</published>
    <updated>2018-09-16T13:49:36.202Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><p>我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？本周就让我们深入浅出ping的机制。</p><h2 id="ping的作用和原理"><a href="#ping的作用和原理" class="headerlink" title="ping的作用和原理"></a>ping的作用和原理</h2><p>简单来说，「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。</p><p>ping 命令是基于 ICMP 协议来工作的，「 ICMP 」全称为 Internet 控制报文协议（ Internet Control Message Protocol）。ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为ICMP协议会要求目标主机在收到消息之后，必须返回ICMP应答消息给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。</p><p>举一个例子来描述「ping」命令的工作过程：</p><ol><li>假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2</li><li>此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。</li><li>IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包。</li><li>IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去。</li><li>当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A</li><li>在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。</li></ol><p>通过ping的流程可以发现，ICMP协议是这个过程的基础，是非常重要的，因此下面就把ICMP协议再详细解释一下。</p><h2 id="ICMP简介"><a href="#ICMP简介" class="headerlink" title="ICMP简介"></a>ICMP简介</h2><p>我们知道，ping命令是基于ICMP协议来实现的。那么我们再来看下图，就明白了ICMP协议又是通过IP协议来发送的，即ICMP报文是封装在IP包中。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvbpqk4zgbj308b02it8q.jpg" alt=""></p><p>IP协议是一种无连接的，不可靠的数据包协议，它并不能保证数据一定被送达，那么我们要保证数据送到就需要通过其它模块来协助实现，这里就引入的是ICMP协议。</p><p>当传送的IP数据包发送异常的时候，ICMP就会将异常信息封装在包内，然后回传给源主机。</p><p>将上图再细拆一下可见：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvbps2ezmoj30b1028jr6.jpg" alt=""></p><p>将ICMP部分拆开继续分析：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvbptg9n1uj30ci047t8s.jpg" alt=""></p><p>由图可知，ICMP数据包由8bit的类型字段和8bit的代码字段以及16bit的校验字段再加上选项数据组成。</p><p>ICMP协议大致可分为两类：</p><ul><li>查询报文类型</li><li>差错报文类型</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvbpuk9vf2j30bo0bv747.jpg" alt=""></p><ol><li>查询报文类型：</li></ol><p>查询报文主要应用于：ping查询、子网掩码查询、时间戳查询等等。</p><p>上面讲到的ping命令的流程其实就对应ICMP协议查询报文类型的一种使用。在主机A构建ICMP请求数据包的时候，其ICMP的类型字段中使用的是 8 （回送请求），当主机B构建ICMP应答包的时候，其ICMP类型字段就使用的是 0 （回送应答），更多类型值参考上表。</p><p>对 查询报文类型 的理解可参考一下文章最开始讲的ping流程，这里就不做赘述。</p><ol start="2"><li>差错报文类型：</li></ol><p>差错报文主要产生于当数据传送发送错误的时候。</p><p>它包括：目标不可达（网络不可达、主机不可达、协议不可达、端口不可达、禁止分片等）、超时、参数问题、重定向（网络重定向、主机重定向等）等等。</p><p>差错报文通常包含了引起错误的IP数据包的第一个分片的IP首部，加上该分片数据部分的前8个字节。</p><p>当传送IP数据包发生错误的时候（例如 主机不可达），ICMP协议就会把错误信息封包，然后传送回源主机，那么源主机就知道该怎么处理了。</p><p>那是不是只有遇到错误的时候才能使用 差错报文类型 呢？也不一定。</p><p>Traceroute 就是一个例外，Traceroute是用来侦测源主机到目标主机之间所经过路由情况的常用工具。Traceroute 的原理就是利用ICMP的规则，制造一些错误的事件出来，然后根据错误的事件来评估网络路由情况。</p><p>具体做法就是：</p><p>Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL=1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了。</p><p>接着，源主机再给目标主机发一个 TTL=2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了。</p><p>如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。</p><p>但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢？</p><p>Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机。</p><p>traceroot的具体使用方法网上都有很多讲解，可以实际操作一下。</p><hr>]]></content>
    
    <summary type="html">
    
      我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="网络" scheme="https://cloudsjhan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7-安装docker-compose时由于pip10包管理导致的错误</title>
    <link href="https://cloudsjhan.github.io/2018/09/13/CentOS7-%E5%AE%89%E8%A3%85docker-compose%E6%97%B6%E7%94%B1%E4%BA%8Epip10%E5%8C%85%E7%AE%A1%E7%90%86%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://cloudsjhan.github.io/2018/09/13/CentOS7-安装docker-compose时由于pip10包管理导致的错误/</id>
    <published>2018-09-13T02:11:49.000Z</published>
    <updated>2018-09-13T02:15:53.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>今天在CentOS下安装docker-compose，遇到了Cannot uninstall ‘requests’. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.<br>错误的原因是requests默认版本为2.6.0，但是docker-compose要2.9以上才支持，但是无法正常卸载2.9版本，是pip10对包的管理存在变化。</li><li>解决方案：<ul><li>pip install -l requests==2.9</li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      CentOS下安装Docker-compose时出现了 Cannot uninstall &#39;requests&#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.
    
    </summary>
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://cloudsjhan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>技术周刊之解析Python中的赋值、浅拷贝、深拷贝</title>
    <link href="https://cloudsjhan.github.io/2018/09/09/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A%E4%B9%8B%E8%A7%A3%E6%9E%90Python%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://cloudsjhan.github.io/2018/09/09/技术周刊之解析Python中的赋值、浅拷贝、深拷贝/</id>
    <published>2018-09-09T06:39:05.000Z</published>
    <updated>2018-09-09T08:03:48.727Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><ul><li><p>本周我们分享的主题是Python中关于浅拷贝和深拷贝的特性，想要深入研究Python中的浅拷贝和深拷贝的起因在于，我想生成一个json字符串，该字符串未dumps之前是一个Python的数据结构，里面包含字典，以及List，在遍历生成dictionary时候，出现一个bug，就是每次遍历生成的dictionary都是上一次的值，现象可以看以下代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我们定义一个函数get_data()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     appid_dict = &#123;&#125;</span><br><span class="line">   ...:     appid_all_dict = &#123;&#125;</span><br><span class="line">   ...:     <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">   ...:         appid_dict[<span class="string">'a'</span>] = i</span><br><span class="line">   ...:         appid_all_dict[i] = appid_dict</span><br><span class="line"><span class="comment"># 我们的初衷是想要得到</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;'a': 0&#125;, 1: &#123;'a': 1&#125;, 2: &#123;'a': 2&#125;, 3: &#123;'a': 3&#125;&#125;....这样的一个dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在调试过程中，发现得到的结果是这样的：</span></span><br><span class="line"><span class="comment"># (Pdb) appid_all_dict</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;'a': 2&#125;, 1: &#123;'a': 2&#125;, 2: &#123;'a': 2&#125;&#125;</span></span><br><span class="line"><span class="comment"># (Pdb) </span></span><br><span class="line"><span class="comment"># 即，后面的appid_dict都会把前面的覆盖掉，这是什么原因呢？</span></span><br><span class="line"><span class="comment"># 我们这里先把原因说一下：因为Python中对dict的操作默认是浅拷贝，即同样的字典，使用多次的话，每次使用都是指向同一片内存地址(引用)，所以在上面的程序中后面对appid_dict的赋值，都将前面的给覆盖掉了，导致每一个appid_dict指向同一片内存，读取的当然就是最后一次的appid_dict的值，即上面程序的执行结果：</span></span><br><span class="line">&#123;<span class="number">0</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">1</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">2</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">3</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">4</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">5</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">6</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">7</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">8</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;, <span class="number">9</span>: &#123;<span class="string">'a'</span>: <span class="number">9</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>那么如何修改这个bug，让程序输出我们想要得到的结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0: &#123;'a': 0&#125;, 1: &#123;'a': 1&#125;, 2: &#123;'a': 2&#125;, 3: &#123;'a': 3&#125;, 4: &#123;'a': 4&#125;, 5: &#123;'a': 5&#125;, 6: &#123;'a': 6&#125;, 7: &#123;'a': 7&#125;, 8: &#123;'a': 8&#125;, 9: &#123;'a': 9&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>看完下面对于Python赋值、浅拷贝、深拷贝的解析，相信你就可以自己解决这个问题了</p></li></ul><h4 id="Python中的赋值操作"><a href="#Python中的赋值操作" class="headerlink" title="Python中的赋值操作"></a>Python中的赋值操作</h4><ul><li>赋值：就是对象的引用</li><li>举例： a = b: 赋值引用，a和b都指向同一个对象，如图所示<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fv3bo527hfj30y80lwq7i.jpg" alt=""></li></ul><h2 id="Python中浅拷贝"><a href="#Python中浅拷贝" class="headerlink" title="Python中浅拷贝"></a>Python中浅拷贝</h2><ul><li>a = b.copy(): a 是b的浅拷贝，a和b是一个独立的对象，但是它们的子对象还是指向同一片引用。<img src="https://ws4.sinaimg.cn/large/006tNbRwly1fv3btp4y4ij30zs0neq9f.jpg" alt=""></li><li>Python中对字典的默认赋值操作就是浅拷贝，所以导致了文章开头所出现的情况。</li></ul><h2 id="Python中的深拷贝"><a href="#Python中的深拷贝" class="headerlink" title="Python中的深拷贝"></a>Python中的深拷贝</h2><ul><li>首先import copy,导入copy模块（Python中自带），b = copy.deepcopy(a), 我们就说b是a的深拷贝，b拷贝了a所有的资源对象，并新开辟了一块地址空间，两者互不干涉。<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fv3bymsju4j311w0oi100.jpg" alt=""></li></ul><h2 id="实际的例子来进一步说明"><a href="#实际的例子来进一步说明" class="headerlink" title="实际的例子来进一步说明"></a>实际的例子来进一步说明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="function"><span class="keyword">def</span> <span class="title">temp</span><span class="params">()</span>:</span></span><br><span class="line">    ...:     a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">    ...:     b = a <span class="comment"># 赋值操作，直接传所有对象的引用</span></span><br><span class="line">    ...:     c = copy.copy(a) <span class="comment"># 浅拷贝，子对象指向同一引用</span></span><br><span class="line">    ...:     d = copy.deepcopy(a) <span class="comment"># 深拷贝，互不干涉</span></span><br><span class="line">    ...:     a.append(<span class="number">5</span>) <span class="comment"># 修改对象a</span></span><br><span class="line">    ...:     a[<span class="number">4</span>].append(<span class="string">'c'</span>) <span class="comment"># 修改a中的数组</span></span><br><span class="line">    ...:     print( <span class="string">'a = '</span>, a )</span><br><span class="line">    ...:     print( <span class="string">'b = '</span>, b )</span><br><span class="line">    ...:     print( <span class="string">'c = '</span>, c )</span><br><span class="line">    ...:     print( <span class="string">'d = '</span>, d ) </span><br><span class="line">    ...:     </span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: </span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: temp()</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决最初的问题"><a href="#解决最初的问题" class="headerlink" title="解决最初的问题"></a>解决最初的问题</h2><ul><li><p>看到这里，我们再回头看文章最初的那个问题，就可以很easy地解决了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">   ...:     appid_dict = &#123;&#125;</span><br><span class="line">   ...:     appid_all_dict = &#123;&#125;</span><br><span class="line">   ...:     <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        appid_dict = copy.deepcopy(appid_dict)<span class="comment"># 只需要加上这一行，使其成为深拷贝，问题解决！</span></span><br><span class="line">   ...:         appid_dict[<span class="string">'a'</span>] = i</span><br><span class="line">   ...:         appid_all_dict[i] = appid_dict</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要对Python的dictionary进行迭代分析，一定要注意其中的深拷贝问题，出现问题后，也要多往这方面考虑。</p><p>本期技术周刊到此结束。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536489838162&amp;di=52a5d7c56631ad266740914505a80a32&amp;imgtype=0&amp;src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2F57%2FB6%2Fo4YBAFtMadCAL43RAAHzi5GNn9o475.png" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      这周让我们来看一下Python中关于赋值、浅拷贝、深拷贝的特性
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
      <category term="Python" scheme="https://cloudsjhan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>golang 编译针对不同平台的可执行程序</title>
    <link href="https://cloudsjhan.github.io/2018/09/07/golang-%E7%BC%96%E8%AF%91%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://cloudsjhan.github.io/2018/09/07/golang-编译针对不同平台的可执行程序/</id>
    <published>2018-09-07T07:46:32.000Z</published>
    <updated>2018-09-07T07:48:43.584Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Golang 支持在一个平台下生成另一个平台可执行程序的交叉编译功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mac下编译Linux, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Linux下编译Mac, Windows平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.go</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go</span><br><span class="line">Windows下编译Mac, Linux平台的64位可执行程序：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin3</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build test.go</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GOOS：目标可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">GOARCH：目标可执行程序操作系统构架，包括 386，amd64，arm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Golang version 1.5以前版本在首次交叉编译时还需要配置交叉编译环境：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 ./make.bash</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 ./make.bash</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      使用go build 编译同一套代码，在不同的平台运行
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>常用的Python小模块</title>
    <link href="https://cloudsjhan.github.io/2018/09/06/%E5%B8%B8%E7%94%A8%E7%9A%84Python%E5%B0%8F%E6%A8%A1%E5%9D%97/"/>
    <id>https://cloudsjhan.github.io/2018/09/06/常用的Python小模块/</id>
    <published>2018-09-06T08:24:41.000Z</published>
    <updated>2018-09-28T02:06:00.780Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>工作或者生活中总会遇到一些常用的Python模块，为了避免重复的工作，将这些自己写过的Python模块记录下来，方便使用的时候查找。</li></ul><h3 id="Python写CSV文件，并防止中文乱码"><a href="#Python写CSV文件，并防止中文乱码" class="headerlink" title="Python写CSV文件，并防止中文乱码"></a>Python写CSV文件，并防止中文乱码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_csv</span><span class="params">(a_list,b_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'vm_data.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(codecs.BOM_UTF8.decode())</span><br><span class="line">        writer1 = csv.writer(f,  dialect=<span class="string">'excel'</span>)</span><br><span class="line">        <span class="comment">#写CVS的标题</span></span><br><span class="line">        writer1.writerow([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">        <span class="comment">#将数据写入CSV文件</span></span><br><span class="line">        writer1.writerows(zip(a_list, b_list))</span><br></pre></td></tr></table></figure><h3 id="Python将数据结构转为json-并优化json字符串的结构，处理中文乱码"><a href="#Python将数据结构转为json-并优化json字符串的结构，处理中文乱码" class="headerlink" title="Python将数据结构转为json,并优化json字符串的结构，处理中文乱码"></a>Python将数据结构转为json,并优化json字符串的结构，处理中文乱码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"appid.json"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(final, sort_keys=<span class="keyword">True</span>, indent=<span class="number">2</span>, ensure_ascii=<span class="keyword">False</span>))</span><br><span class="line"><span class="comment"># sort_keys = True: 将字典的key按照字母排序</span></span><br><span class="line"><span class="comment"># ident = 2: 优化json字符串结构，看起来更美观</span></span><br><span class="line"><span class="comment"># ensure_ascii=False: 防止json字符串中的中文乱码</span></span><br></pre></td></tr></table></figure><h3 id="使用requests包进行网络请求（以post为例）"><a href="#使用requests包进行网络请求（以post为例）" class="headerlink" title="使用requests包进行网络请求（以post为例）"></a>使用requests包进行网络请求（以post为例）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def  get_data(url):</span><br><span class="line">    final = &#123;&#125;</span><br><span class="line">    url = &quot;http://xxxx.com&quot;</span><br><span class="line">    request_body = &#123;</span><br><span class="line">        &apos;access_token&apos;: access_token,</span><br><span class="line">        &apos;request_body&apos;: &#123;&quot;params1&quot;: param1, &apos;params2&apos;: param2&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    data = requests.post(url, headers=headers, data=json.dumps(request_body))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      常用的Python模块，即查即用
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql无法连接[MySql Host is blocked because of many connection errors]</title>
    <link href="https://cloudsjhan.github.io/2018/09/01/Mysql%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cloudsjhan.github.io/2018/09/01/Mysql无法连接/</id>
    <published>2018-09-01T05:20:54.000Z</published>
    <updated>2018-09-01T05:38:58.657Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li><p>测试环境，发现数据库（MySQL数据库）无法登录，报错如下：</p><p>Host is blocked because of many connection errors; unblock with ‘mysqladmin flush-hosts’</p></li><li><p>解决方案：使用mysqladmin flush-hosts 命令清理一下hosts文件（不知道mysqladmin在哪个目录下可以使用命令查找：whereis mysqladmin）；</p></li><li><p>登录到MySQL数据库中，mysql -uroot -h host -p</p></li><li><p>执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="keyword">flush</span>-<span class="keyword">hosts</span></span><br></pre></td></tr></table></figure><p>问题解决。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      mysql 出现[MySql Host is blocked because of many connection errors]的错误
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql 开启远程连接</title>
    <link href="https://cloudsjhan.github.io/2018/08/29/mysql-%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>https://cloudsjhan.github.io/2018/08/29/mysql-开启远程连接/</id>
    <published>2018-08-29T03:17:20.000Z</published>
    <updated>2018-09-01T05:35:43.913Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li>背景： 建站的时候会出现数据库和网站是不同的ip，就需要开启MySQL的远程连接服务，但是MySQL由于安全原因，默认设置是不允许远程只能本地连接，要开启远程连接就需要修改某些配置文件。</li></ul><h3 id="按照下面的步骤，开启MySQL的远程连接"><a href="#按照下面的步骤，开启MySQL的远程连接" class="headerlink" title="按照下面的步骤，开启MySQL的远程连接"></a>按照下面的步骤，开启MySQL的远程连接</h3><ul><li><p>进入数据库cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -h host -p</span><br><span class="line">Enter password:***</span><br></pre></td></tr></table></figure></li><li><p>连接到默认mysql数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">use mysql;</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grant all privileges on *.* to 'root'@'host' identified by 'password' with grant option;</span><br></pre></td></tr></table></figure><p>host表示你远程连接数据库设备的ip地址（如果你想让所有机器都能远程连接，host改为‘%’，<strong>不推荐这样使用</strong>），password表示MySQL的root用户密码</p></li><li><p>刷新or重启MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure></li><li><p>最后非常重要的一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vim /etc/mysql/my.cnf</span><br><span class="line">屏蔽bing-server 127.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash">bing-server 127.0.0.0</span></span><br></pre></td></tr></table></figure></li><li><p>完成，可以远程连接你的数据库了</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      不管是在测试还是开发中，MySQL经常需要开启远程连接功能
    
    </summary>
    
      <category term="MySQL" scheme="https://cloudsjhan.github.io/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://cloudsjhan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>golang factory design 引发的一系列思考</title>
    <link href="https://cloudsjhan.github.io/2018/08/29/golang-factory-design-%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E6%80%9D%E8%80%83/"/>
    <id>https://cloudsjhan.github.io/2018/08/29/golang-factory-design-引发的一系列思考/</id>
    <published>2018-08-29T02:21:56.000Z</published>
    <updated>2018-09-01T07:18:05.039Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><ul><li>写在前面，突然萌生一个念头，做一个技术周刊系列，将每周工作或者生活当中遇到的比较有趣的问题记录下来，一来时总结一下，二来是为了以后退役了，可以回顾自己的技术生涯。</li><li>没有什么意外的话，我会每周六晚更新。</li><li>最近在整合三家公有云（AWS，ali, ucloud）的接口，考虑到代码复用的问题，于是开始考虑使用一种设计模式，这种场景下，最合适的便是工厂模式，将三家厂商的公有接口放入工厂方法中，然后对每一家new一个实例即可，以后再有新的厂商加入，改动的代码也不会太多。但是设计模式这种东西天然适合于java，对于golang这种比较新的语言来说，实现起来相对没有那么容易，对于刚接触golang的我来说，对一些golang的特性上并不是很熟悉，所以在此期间遇到一些不解的问题，写出来分享一下。</li></ul><h3 id="首先，什么是工厂模式"><a href="#首先，什么是工厂模式" class="headerlink" title="首先，什么是工厂模式"></a>首先，什么是工厂模式</h3><ul><li>简单工厂模式就是通过传递不同的参数，生成不同的实例，工厂方法为每一个product提供一个工程类，通过不同的工厂创建不同的实例。</li></ul><h3 id="典型工厂模式的实现方式（即典型oop实现方式）"><a href="#典型工厂模式的实现方式（即典型oop实现方式）" class="headerlink" title="典型工厂模式的实现方式（即典型oop实现方式）"></a>典型工厂模式的实现方式（即典型oop实现方式）</h3><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProviderModel</span>&#123;</span></span><br><span class="line">    provider <span class="built_in">string</span></span><br><span class="line">        <span class="function">func <span class="title">factory</span><span class="params">(providerName <span class="built_in">string</span>, test <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> providerName == <span class="string">"AWS"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AWS(test)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> providerName == <span class="string">"Ali"</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ali(test)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AWS extends ProviderModel &#123;</span><br><span class="line">    func construct(test <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test</span><br><span class="line">    &#125;</span><br><span class="line">    func doRequest()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">awsmodel := ProviderModel::factory(<span class="string">"AWS"</span>)</span><br><span class="line">awsmodel.doRequest()</span><br><span class="line"></span><br><span class="line">alimodel := ProviderModel ::factory(<span class="string">"Ali"</span>)  </span><br><span class="line">alimodel.doRequest()</span><br></pre></td></tr></table></figure></li></ul><h3 id="golang实现工厂模式存在的问题"><a href="#golang实现工厂模式存在的问题" class="headerlink" title="golang实现工厂模式存在的问题"></a>golang实现工厂模式存在的问题</h3><ul><li><p>golang的特性中并没有像java一样的继承和重载，所以我们要利用golang存在的特性，透过工厂模式的表面透析其本质。</p></li><li><p>我们看一下工厂模式就知道，所谓工厂其实就是定义了一些需要去实现的方法，golang的interface正是可以做到。于是先到Google上搜了一段golang实现的工厂模式的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operater <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operate(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs + lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MultipleOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MultipleOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs * lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperateFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOperateFactory</span><span class="params">()</span> *<span class="title">OperateFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;OperateFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *OperateFactory)</span> <span class="title">CreateOperate</span><span class="params">(operatename <span class="keyword">string</span>)</span> <span class="title">Operater</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> operatename &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;AddOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;MultipleOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"无效运算符号"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Operator := NewOperateFactory().CreateOperate(<span class="string">"+"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"add result is %d\n"</span>, Operator.Operate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来没什么问题，后来又看到一种实现方式，<a href="https://www.jianshu.com/p/9de2cd9bf8f0" target="_blank" rel="noopener">来自这篇博客</a>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> site <span class="keyword">interface</span> &#123;</span><br><span class="line">    fetch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> siteModel <span class="keyword">struct</span> &#123;</span><br><span class="line">    URL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> site1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    siteModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s site1)</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"site1 fetch data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">site</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">"site"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> site1&#123;</span><br><span class="line">            siteModel&#123;URL: <span class="string">"http://www.xxxx.com"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := factory(<span class="string">"site"</span>)</span><br><span class="line">    s.fetch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码初看上去跟第一个实现没什么不一样，但是当我详细阅读代码时，下面的这句代码着实把我弄晕了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">site</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">"site"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> site1&#123;</span><br><span class="line">            siteModel&#123;URL: <span class="string">"http://www.xxxx.com"</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factory函数的返回值定义明明是一个interface, 但是在return的时候，却返回一个struct，查阅很多资料后，<a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">这篇博客</a>帮了我的大忙，其中对interface的解释有这么一句话：<strong>在 Golang 中，interface 是一组 method 的集合，是 duck-type programming 的一种体现。不关心属性（数据），只关心行为（方法）。具体使用中你可以自定义自己的 struct，并提供特定的 interface 里面的 method 就可以把它当成 interface 来使用。</strong>之后又详细看了几遍这篇博文，犹如醍醐灌顶，对golanginterface的理解更深了一层。读完这篇后再去实现工厂模式，或者再去写golang的代码，对interface的使用就会更自如一些。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>本期技术周刊主要由golang工厂模式的讨论引起，之后又涉及到golang interface特性的讨论，对以后使用golang编写更加复杂的代码很有帮助。</p></li><li><p>本期结束，欲知后事如何，且看下周分解。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535796309427&amp;di=a9db53cf71b492f4dd06a57b5ec65229&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D2705270329%2C1518266531%26fm%3D214%26gp%3D0.jpg" alt=""></p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      工作需要，看了一下golang如何实现工厂模式，遇到一些难以理解的知识点，查资料，写demo验证后，记录下来以供参考
    
    </summary>
    
      <category term="技术周刊" scheme="https://cloudsjhan.github.io/categories/%E6%8A%80%E6%9C%AF%E5%91%A8%E5%88%8A/"/>
    
    
      <category term="golang design pattern go-interface" scheme="https://cloudsjhan.github.io/tags/golang-design-pattern-go-interface/"/>
    
  </entry>
  
  <entry>
    <title>golang中的工厂模式</title>
    <link href="https://cloudsjhan.github.io/2018/08/27/golang%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/27/golang中的工厂模式-md/</id>
    <published>2018-08-27T10:53:24.000Z</published>
    <updated>2018-08-27T11:18:09.576Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt="" style="width:100%"></p><a id="more"></a><ul><li>研究go的设计模式，必须了解go的struct和interface，若不熟悉，先阅读以下内容</li><li><a href="http://blog.csdn.net/wangshubo1989/article/details/70040022" target="_blank" rel="noopener">go语言的struct</a></li><li><a href="http://blog.csdn.net/wangshubo1989/article/details/70053086" target="_blank" rel="noopener">go语言的interface</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* 简单工厂模式</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operater <span class="keyword">interface</span> &#123;</span><br><span class="line">    Operate(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs + lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MultipleOperate <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MultipleOperate)</span> <span class="title">Operate</span><span class="params">(rhs <span class="keyword">int</span>, lhs <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs * lhs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperateFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOperateFactory</span><span class="params">()</span> *<span class="title">OperateFactory</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;OperateFactory&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *OperateFactory)</span> <span class="title">CreateOperate</span><span class="params">(operatename <span class="keyword">string</span>)</span> <span class="title">Operater</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> operatename &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;AddOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;MultipleOperate&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"无效运算符号"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Operator := NewOperateFactory().CreateOperate(<span class="string">"+"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"add result is %d\n"</span>, Operator.Operate(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">* 工厂方法</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">float64</span></span><br><span class="line">    b <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OperationI <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetResult() <span class="keyword">float64</span></span><br><span class="line">    SetA(<span class="keyword">float64</span>)</span><br><span class="line">    SetB(<span class="keyword">float64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *Operation)</span> <span class="title">SetA</span><span class="params">(a <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    op.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op *Operation)</span> <span class="title">SetB</span><span class="params">(b <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    op.b = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a + this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a - this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MulOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MulOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a * this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivOperation <span class="keyword">struct</span> &#123;</span><br><span class="line">    Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DivOperation)</span> <span class="title">GetResult</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.a / this.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateOperation() Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *AddFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(AddOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SubFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(SubOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MulFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MulFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(MulOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DivFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *DivFactory)</span> <span class="title">CreateOperation</span><span class="params">()</span> <span class="title">OperationI</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(DivOperation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fac := &amp;(AddFactory&#123;&#125;)</span><br><span class="line">    oper := fac.CreateOperation()</span><br><span class="line">    oper.SetA(<span class="number">1</span>)</span><br><span class="line">    oper.SetB(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(oper.GetResult())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* 抽象工厂方法</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GirlFriend <span class="keyword">struct</span> &#123;</span><br><span class="line">    nationality <span class="keyword">string</span></span><br><span class="line">    eyesColor   <span class="keyword">string</span></span><br><span class="line">    language    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateMyLove() GirlFriend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IndianGirlFriendFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KoreanGirlFriendFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a IndianGirlFriendFactory)</span> <span class="title">CreateMyLove</span><span class="params">()</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;<span class="string">"Indian"</span>, <span class="string">"Black"</span>, <span class="string">"Hindi"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a KoreanGirlFriendFactory)</span> <span class="title">CreateMyLove</span><span class="params">()</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;<span class="string">"Korean"</span>, <span class="string">"Brown"</span>, <span class="string">"Korean"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGirlFriend</span><span class="params">(typeGf <span class="keyword">string</span>)</span> <span class="title">GirlFriend</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gffact AbstractFactory</span><br><span class="line">    <span class="keyword">switch</span> typeGf &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Indian"</span>:</span><br><span class="line">        gffact = IndianGirlFriendFactory&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> gffact.CreateMyLove()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Korean"</span>:</span><br><span class="line">        gffact = KoreanGirlFriendFactory&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> gffact.CreateMyLove()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GirlFriend&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a := getGirlFriend(<span class="string">"Indian"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(a.eyesColor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
      <category term="设计模式" scheme="https://cloudsjhan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac os 环境配置ruby on rails 及其Hello world</title>
    <link href="https://cloudsjhan.github.io/2018/08/26/Mac-os-%E9%85%8D%E7%BD%AE-ruby-on-rails-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/26/Mac-os-配置-ruby-on-rails-md/</id>
    <published>2018-08-26T15:20:33.000Z</published>
    <updated>2018-08-27T15:39:24.975Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><a id="more"></a><p>今天在Mac OS环境中倒腾ruby on rails，遇到一些坑并排坑后总结一个搭建过程，供大家参考。</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul><li><p>本着IT届能用最新的就不用前面的版本的宗旨，在进行之前必须将你的Mac升级到最新的macOS High Sierra</p></li><li><p>安装 XCode Command Line Tools</p></li><li><p>配置Git</p></li><li><p>安装Homebrew</p></li><li><p>安装GPG</p></li><li><p>安装RVM</p></li><li><p>安装ruby</p></li><li><p>升级RubyGems</p></li><li><p>安装rails</p></li><li><p>基本MVC探究之Hello world</p><h3 id="Ruby-On-rails-for-mac-os-High-Sierra"><a href="#Ruby-On-rails-for-mac-os-High-Sierra" class="headerlink" title="Ruby On rails for mac os High Sierra"></a>Ruby On rails for mac os High Sierra</h3><ul><li><p>Mac OS是自带ruby的，但是这些ruby的版本都不是最新的，我们也不要用这些过时的版本</p></li><li><p>首先，升级你的Mac OS到10.13</p></li><li><p>查看是否安装xcode command line tool：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>:xcode-select -p</span><br><span class="line">如果你看到：</span><br><span class="line">xcode-select: error: unable to get active developer directory...</span><br><span class="line">说明你没有安装xcode command line tool,需要按照下面的步骤安装。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你看到：</span><br><span class="line"><span class="meta">$</span>:/Applications/Xcode.app/Contents/Developer 或者/Library/Developer/CommandLineTools</span><br><span class="line">恭喜你，xcode command line tool你已经安装好了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">But，如果你很不幸运地看到了这句话：</span><br><span class="line">$: /Applications/Apple Dev Tools/Xcode.app/Contents/Developer</span><br><span class="line">那么你就要卸掉xcode重新安装了，具体原因看</span><br></pre></td></tr></table></figure><p><a href="http://rvm.io/support/faq#can-i-use-a-path-with-spaces" target="_blank" rel="noopener">这里</a></p></li><li><p>安装xcode</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>一路确认之后，就可以安好xcode，但是如果你的网速不好，等待时间过长，你可以从<a href="https://developer.apple.com/downloads/more" target="_blank" rel="noopener">这里</a>输入你的APPID下载。</p></li><li><p>确认一下是否安好</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xcode-select -p</span><br><span class="line">/Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><ul><li><p>在安装ruby on rails 之前，你应该配置你的Git。Git在Mac OS上使自动安装的软件</p></li><li><p>检查Git版本并确认已经安装让你放心</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git version</span><br><span class="line">git version 2.4.9 (Apple Git-60)</span><br></pre></td></tr></table></figure></li><li><p>配置Git之前，你应该到<a href="https://help.github.com/articles/signing-up-for-a-new-github-account/" target="_blank" rel="noopener">GitHub</a>上注册你的账号并记住密码和邮箱。并使用下面的命令配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config -l --global</span><br><span class="line">fatal: unable to read config file '/Users/.../.gitconfig': No such file or directory</span><br><span class="line"><span class="meta">$</span> git config --global user.name "Your Real Name"</span><br><span class="line"><span class="meta">$</span> git config --global user.email me@example.com</span><br><span class="line"><span class="meta">$</span> git config -l --global</span><br><span class="line">user.name=Your Real Name</span><br><span class="line">user.email=me@example.com</span><br></pre></td></tr></table></figure></li><li><p>Git配置完成，在你想用Git的时候，它就会蹦出来了。</p></li></ul><h3 id="安装Homebrow"><a href="#安装Homebrow" class="headerlink" title="安装Homebrow"></a>安装Homebrow</h3><ul><li><p>检查homebrow是否已经安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew</span><br><span class="line">-bash: brew: command not found</span><br></pre></td></tr></table></figure><p>RVM需要<a href="http://brew.sh/" target="_blank" rel="noopener">Homebrow</a>,其实一个Mac OS额安装包管理工具，用来下载一些软件，类似于Ubuntu的apt-get和centos的yum install.为避免安装RM出现问题，我们必须安装homebrow：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><p>安装过程中可能会出现一些warning并让你输入密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Improper use of the sudo command could lead to data loss...</span><br><span class="line">To proceed, enter your password...</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure><p>尽管输入密码，忽略warning。</p><p>我们这里是使用了Mac OS内置的ruby来安装homebrow。</p></li></ul><h3 id="安装GPG"><a href="#安装GPG" class="headerlink" title="安装GPG"></a>安装GPG</h3><ul><li><p><a href="https://en.wikipedia.org/wiki/GNU_Privacy_Guard" target="_blank" rel="noopener">gpg</a>是一个用来检查RVM下载包的安全性的程序，我们使用homebrew来安装gpg:</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install gpg</span><br></pre></td></tr></table></figure></li><li><p>gpg安装之后，为RVM安装key:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> command curl -sSL https://rvm.io/mpapis.asc | gpg --import -</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装RVM"><a href="#安装RVM" class="headerlink" title="安装RVM"></a>安装RVM</h3><ul><li><p><a href="https://rvm.io/" target="_blank" rel="noopener">RVM</a>，是Ruby version manager的简写，用来安装ruby或者管理rails版本。<a href="https://rvm.io/rvm/install/" target="_blank" rel="noopener">这个网站</a>详细说明了安装ruby的方式，但是我们有一种最简便的方式：</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> \curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>“curl”前面的“\”用来避免ruby版本的冲突，不要漏掉。</p></li><li><p>安装过程中你可能会看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir: /etc/openssl: Permission denied</span><br><span class="line">mkdir -p "/etc/openssl" failed, retrying with sudo</span><br><span class="line">your password required for 'mkdir -p /etc/openssl':</span><br></pre></td></tr></table></figure><p>请输入密码并继续。</p></li><li><p>如果你已经安装过RVM，使用下面的命令update：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm get stable --autolibs=enable</span><br></pre></td></tr></table></figure></li><li><p>重启terminal窗口或者使用：使RVM生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h3><ul><li><p>在安装RVM之后，我们安装最新版本的ruby。ruby 2.5.1是写此博客时当前最新的ruby版本，还请查看ruby<a href="$ source ~/.rvm/scripts/rvm">官网</a>查看最新版本的ruby。必须指定ruby的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm install ruby-2.5.1</span><br></pre></td></tr></table></figure><p>安装后检查是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ruby -v</span><br><span class="line">ruby 2.5.1...</span><br></pre></td></tr></table></figure></li></ul><h3 id="升级rubyGemset"><a href="#升级rubyGemset" class="headerlink" title="升级rubyGemset"></a>升级rubyGemset</h3><ul><li><p><a href="https://rubygems.org/gems/rubygems-update" target="_blank" rel="noopener">RubyGems</a>是一个ruby的包管理工具，用来安装ruby的工具或者额外功能的包。</p></li><li><p>查看gem版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem -v</span><br></pre></td></tr></table></figure><p>将gem升级到最新版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem update --system</span><br></pre></td></tr></table></figure></li><li><p>显示RVM gemsets的最初两个设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm gemset list</span><br><span class="line">gemsets for ruby-2.5.0</span><br><span class="line">=&gt; (default)</span><br><span class="line">   global</span><br></pre></td></tr></table></figure><p>一般使用global：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rvm gemset use global</span><br></pre></td></tr></table></figure></li><li><p>安装bundle,<a href="https://rubygems.org/gems/bundler" target="_blank" rel="noopener">Bundle</a>是一个管理gem的必须的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install Bundler</span><br></pre></td></tr></table></figure></li><li><p>安装Nokogiri，<a href="http://nokogiri.org/" target="_blank" rel="noopener">Nokogiri</a>需要编译成指定的系统，在上面的配置下，号称最难安装的包，也将安装好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install nokogiri</span><br></pre></td></tr></table></figure><p>如果你真的不幸运在安装时遇到问题，Stack <a href="http://stackoverflow.com/questions/tagged/nokogiri" target="_blank" rel="noopener">Overflow</a>能帮到你。</p></li></ul><h3 id="安装rails"><a href="#安装rails" class="headerlink" title="安装rails"></a>安装rails</h3><ul><li><p><a href="http://rubygems.org/gems/rails" target="_blank" rel="noopener">这里</a>是ruby On rail最新的版本，5.1是最新稳定版本，5.2是release版本，我们安装5.1.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install rails --version=5.1</span><br></pre></td></tr></table></figure><p>如果你喜欢尝鲜，可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gem install rails --pre</span><br></pre></td></tr></table></figure><p>安装release版本。</p><p>检查一下rails是否装好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rails -v</span><br><span class="line">Rails 5.2.0</span><br></pre></td></tr></table></figure></li><li><p>到此为止，ruby on rails 以及其环境配置都已妥当，可以开始你的ruby之旅了。</p></li></ul><h3 id="ruby-on-rails-的Hello-world"><a href="#ruby-on-rails-的Hello-world" class="headerlink" title="ruby on rails 的Hello world"></a>ruby on rails 的Hello world</h3><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /</span><br><span class="line"><span class="meta">$</span> mkdir worlspace</span><br><span class="line"><span class="meta">$</span> cd workspace</span><br><span class="line"><span class="meta">$</span> rails _5.1.0_ new hello_app</span><br><span class="line"><span class="meta">$</span> cd hello_app</span><br><span class="line"><span class="meta">$</span> rails server</span><br></pre></td></tr></table></figure><p>将<a href="http://localhost:3000输入浏览器，就能看到ruby" target="_blank" rel="noopener">http://localhost:3000输入浏览器，就能看到ruby</a> on rails的欢迎界面。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ruby" scheme="https://cloudsjhan.github.io/categories/ruby/"/>
    
    
      <category term="ruby on rails" scheme="https://cloudsjhan.github.io/tags/ruby-on-rails/"/>
    
      <category term="web" scheme="https://cloudsjhan.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>go实现UNIX command</title>
    <link href="https://cloudsjhan.github.io/2018/08/22/go-unix-cmd-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/22/go-unix-cmd-md/</id>
    <published>2018-08-22T11:27:41.000Z</published>
    <updated>2018-09-01T05:38:25.962Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">"&gt; "</span>)</span><br><span class="line"><span class="comment">// 读取键盘的输入.</span></span><br><span class="line">input, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行并解析command.</span></span><br><span class="line">err = execInput(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果cd命令没有路径的话，就报下面的错误</span></span><br><span class="line"><span class="keyword">var</span> ErrNoPath = errors.New(<span class="string">"path required"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execInput</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 移除换行符.</span></span><br><span class="line">input = strings.TrimSuffix(input, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入分割成参数.</span></span><br><span class="line">args := strings.Split(input, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对cd命令的情况进行区分.</span></span><br><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cd"</span>:</span><br><span class="line"><span class="comment">// 暂时不支持cd加空格进入home目录.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrNoPath</span><br><span class="line">&#125;</span><br><span class="line">err := os.Chdir(args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Stop further processing.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the command to execute.</span></span><br><span class="line">cmd := exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the correct output device.</span></span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the command and save it's output.</span></span><br><span class="line">err := cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行并测试</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>暂时不支持tab键自动补全命令，只是提供一种简单的思路。</p><hr>]]></content>
    
    <summary type="html">
    
      使用go实现UNIX环境下的命令行工具
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="go" scheme="https://cloudsjhan.github.io/tags/go/"/>
    
      <category term="unix" scheme="https://cloudsjhan.github.io/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>iterm2 突然报很奇怪的错误-Error  No user exists for uid 501</title>
    <link href="https://cloudsjhan.github.io/2018/08/21/iterm2-strange-err-md-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/21/iterm2-strange-err-md-md/</id>
    <published>2018-08-21T15:18:21.000Z</published>
    <updated>2018-08-21T15:33:12.206Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="http://www.qqyou.com/view.php?pic=http://p1.qqyou.com/pic/UploadPic/2014-7/9/2014070910421928610.jpg" alt="" style="width:100%"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No user exists <span class="keyword">for</span> uid <span class="number">501</span></span><br><span class="line">fatal: Could <span class="keyword">not</span> read <span class="keyword">from</span> remote repository.</span><br><span class="line">Please make sure you have the correct access rightsand the repository exists.</span><br></pre></td></tr></table></figure><ul><li>上午还好好的，刚刚连接GitHub报这个错误，排查后了解到是iterm2的神坑。</li><li>重启iterm终端就好 系统有更新的话 需要重启终端 更新。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      iterm2 突然报很奇怪的错误-Error No user exists for uid 501
    
    </summary>
    
      <category term="生活中奇怪的坑" scheme="https://cloudsjhan.github.io/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E5%A5%87%E6%80%AA%E7%9A%84%E5%9D%91/"/>
    
    
      <category term="日常的坑系列" scheme="https://cloudsjhan.github.io/tags/%E6%97%A5%E5%B8%B8%E7%9A%84%E5%9D%91%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>golang中interface的通用设计方法</title>
    <link href="https://cloudsjhan.github.io/2018/08/21/golang%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://cloudsjhan.github.io/2018/08/21/golang通用接口设计方法/</id>
    <published>2018-08-21T14:18:58.000Z</published>
    <updated>2018-08-21T15:10:30.131Z</updated>
    
    <content type="html"><![CDATA[<p class="description">golang中接口设计的通用方法</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 接口定义</span><br><span class="line"><span class="keyword">type</span> XxxManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(args argsType) (*XxxStruct, error)</span><br><span class="line">    Get(args argsType) (**XxxStruct, error)</span><br><span class="line">    Update(args argsType) (*XxxStruct, error)</span><br><span class="line">    Delete(name <span class="keyword">string</span>, options *DeleleOptions) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> 结构体定义 </span><br><span class="line"><span class="keyword">type</span> XxxManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    kubeCli *kubernetes.Clientset</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>，构造函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewXxxManagerImpl</span> <span class="params">(namespace, name <span class="keyword">string</span>, kubeCli *kubernetes.Clientset)</span> <span class="title">XxxManager</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;XxxManagerImpl&#123;</span><br><span class="line">        Name name,</span><br><span class="line">        Namespace namespace,</span><br><span class="line">        kubeCli: kubeCli,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span> 方法具体实现</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XxxManagerImpl)</span> <span class="title">Create</span><span class="params">(args argsType)</span> <span class="params">(*XxxStruct, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//具体的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>golang通用接口设计</strong></p><p>根据以上设计cdosapi封装接口：</p>]]></content>
    
    <summary type="html">
    
      golang中interface的通用设计方法
    
    </summary>
    
      <category term="golang" scheme="https://cloudsjhan.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="https://cloudsjhan.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>python3中遇到&#39;TypeError Unicode-objects must be encoded before hashing&#39;</title>
    <link href="https://cloudsjhan.github.io/2018/08/20/python-md5-err-md/"/>
    <id>https://cloudsjhan.github.io/2018/08/20/python-md5-err-md/</id>
    <published>2018-08-20T14:18:58.000Z</published>
    <updated>2018-09-28T02:06:52.282Z</updated>
    
    <content type="html"><![CDATA[<p class="description">Python3中进行MD5加密，遇到编码问题</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode, quote_plus</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verfy_ac</span><span class="params">(private_key)</span>:</span></span><br><span class="line"></span><br><span class="line">    item = &#123;</span><br><span class="line">     <span class="string">"Action"</span>     :  <span class="string">"CreateUHostInstance"</span>,</span><br><span class="line">     <span class="string">"CPU"</span>        :  <span class="number">2</span>,</span><br><span class="line">     <span class="string">"ChargeType"</span> :  <span class="string">"Month"</span>,</span><br><span class="line">     <span class="string">"DiskSpace"</span>  :  <span class="number">10</span>,</span><br><span class="line">     <span class="string">"ImageId"</span>    :  <span class="string">"f43736e1-65a5-4bea-ad2e-8a46e18883c2"</span>,</span><br><span class="line">     <span class="string">"LoginMode"</span>  :  <span class="string">"Password"</span>,</span><br><span class="line">     <span class="string">"Memory"</span>     :  <span class="number">2048</span>,</span><br><span class="line">     <span class="string">"Name"</span>       :  <span class="string">"Host01"</span>,</span><br><span class="line">     <span class="string">"Password"</span>   :  <span class="string">"VUNsb3VkLmNu"</span>,</span><br><span class="line">     <span class="string">"PublicKey"</span>  :  <span class="string">"ucloudsomeone%40example.com1296235120854146120"</span>,</span><br><span class="line">     <span class="string">"Quantity"</span>   :  <span class="number">1</span>,</span><br><span class="line">     <span class="string">"Region"</span>     :  <span class="string">"cn-bj2"</span>,</span><br><span class="line">     <span class="string">"Zone"</span>       :  <span class="string">"cn-bj2-04"</span></span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment"># 将参数串排序</span></span><br><span class="line"></span><br><span class="line">    params_data = <span class="string">""</span></span><br><span class="line">    <span class="keyword">import</span> pdb;pdb.set_trace()</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> item.items():</span><br><span class="line">        params_data = params_data + str(key) + str(value)</span><br><span class="line">    params_data = params_data + private_key</span><br><span class="line">    params_data_en = quote_plus(params_data)</span><br><span class="line"></span><br><span class="line">    sign = hashlib.sha1()</span><br><span class="line">    sign.update(params_data_en.encode(<span class="string">'utf8'</span>))</span><br><span class="line">    signature = sign.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> signature</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(verfy_ac(<span class="string">"46f09bb9fab4f12dfc160dae12273d5332b5debe"</span>))</span><br></pre></td></tr></table></figure><p>这是<a href="https://docs.ucloud.cn/api/summary/signature" target="_blank" rel="noopener">ucloud官方的API教程</a>，想根据此教程生成签名，教程中的代码是基于Python2.7编写，我将其改成了Python3.但是在执行时报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Unicode-objects must be encoded before hashing</span><br></pre></td></tr></table></figure><hr><p>排错后发现python3中字符对象是unicode对象，不能直接加密，需要编码后才能进行update。</p><p>就是改成如下即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign.update(params_data_en.encode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      Python中进行md5加密时遇到的编码问题
    
    </summary>
    
      <category term="python" scheme="https://cloudsjhan.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://cloudsjhan.github.io/tags/python/"/>
    
      <category term="md5编码" scheme="https://cloudsjhan.github.io/tags/md5%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cloudsjhan.github.io/2018/08/18/hello-world/"/>
    <id>https://cloudsjhan.github.io/2018/08/18/hello-world/</id>
    <published>2018-08-18T14:05:08.383Z</published>
    <updated>2018-08-18T14:05:08.384Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
